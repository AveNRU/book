<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Валидация ссылок посредством сроков жизни - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие подходы программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Примечания</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие устройства</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование устройств для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание образцов устройств</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей устройства</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> правила написания способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Устройство потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Краткий поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими делами с помощью дополнений, ящиков и звеньев</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Дополнения и ящики</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение звеньев для управления областью действия и тайностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве звеньев</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, особенности (свойства) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Особенности (свойства): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html" class="active"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х проверок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать проверки</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением проверок</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Создание проверок</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Дело с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Переработка кода для обеспечения выделения на звенья и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка возможности библиотеки с помощью разработки через проверка</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Полезные  возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего дела с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Обнародование ящика на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью особенности Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью особенности Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный одновременность</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для одновременного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Одновременность с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый одновременность с помощью особенностей Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности предметно-направленного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Свойства предметно-направленных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование особенность-предметов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Выполнение образца предметно-направленного разработки</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Образцы и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться образцы</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли образец не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> правила написания образца</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые особенности</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Конечный дело: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые особенности</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Ржавчина и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Валидация-ссылок-при-помощи-времён-жизни"><a class="header" href="#Валидация-ссылок-при-помощи-времён-жизни">Валидация ссылок при помощи времён жизни<a name="validating-references-with-lifetimes"></a></a></h2>
<p>Сроки (времена) жизни - ещё один вид обобщений, с которыми мы уже встречались. Если раньше мы использовали обобщения, чтобы убедиться, что вид обладает нужным нам поведением, теперь мы будем использовать сроки жизни для того, чтобы быть уверенными, что ссылки действительны как самое меньшее столько времени в этапе исполнения программы, сколько нам требуется.</p>
<p>В разделе <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">"Ссылки и заимствование"</a> главы 4, мы кое о чём умолчали: у каждой ссылки в Ржавчина есть своё <em>время жизни</em> — область кода, на протяжении которого данная ссылка действительна (valid). В большинстве случаев сроки жизни выводятся неявно — так же, как у видов (нам требуется явно объявлять виды лишь в тех случаях, когда при самостоятельном выведении вида возможны исходы). Точно так же мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены сборщиком по-разному. Ржавчина требует от нас объявлять взаимосвязи посредством обобщённых свойств сроков жизни, чтобы убедиться в том, что во время исполнения все действующие ссылки будут правильными.</p>
<p>Определение времени жизни — это подход, отсутствующая в большинстве других языков программирования, так что она может показаться незнакомой. Хотя в этой главе мы не будем рассматривать времена жизни во всех подробностях, тем не менее, мы обсудим основные случаи, в которых вы можете столкнуться с правилами написания времени жизни, что позволит вам получше ознакомиться с этой подходом.</p>
<h3 id="Времена-жизни-предотвращают-появление-повисших-ссылок"><a class="header" href="#Времена-жизни-предотвращают-появление-повисших-ссылок">Времена жизни предотвращают появление "повисших" ссылок</a></h3>
<p>Основное предназначение сроков жизни — предотвращать появление так называемых <em>"повисших ссылок"</em> (<em>dangling references</em>), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться. Рассмотрим программу из приложения 10-16, имеющую внешнюю и внутреннюю области видимости.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
<p><span class="caption">Приложение 10-16: Попытка использования ссылки, значение которой вышло из области видимости</span></p>
<blockquote>
<p>Примечание: примеры в приложениях 10-16, 10-17 и 10-23 объявляют переменные без указания их начального значения, поэтому имя переменной существует во внешней области видимости. На первый взгляд может показаться, что это противоречит отсутствию в Ржавчина нулевых (null) значений. Однако, если мы попытаемся использовать переменную, прежде чем присвоить ей значение, мы получим ошибку сборки, которая показывает, что Ржавчина действительно не разрешает нулевые (null) значения.</p>
</blockquote>
<p>Внешняя область видимости объявляет переменную с именем <code>r</code> без начального значения, а внутренняя область объявляет переменную с именем <code>x</code> с начальным значением <code>5</code>. Во внутренней области мы пытаемся установить значение <code>r</code> как ссылку на <code>x</code>. Затем внутренняя область видимости заканчивается и мы пытаемся напечатать значение из <code>r</code>. Этот код не будет собран, потому что значение на которое ссылается <code>r</code> исчезает из области видимости, прежде чем мы попробуем использовать его. Вот сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Переменная <code>x</code> «не живёт достаточно долго». Причина в том, что <code>x</code> выйдет из области видимости, когда эта внутренняя область закончится в строке 7. Но <code>r</code> все ещё является действительной во внешней области видимости; поскольку её охват больше, мы говорим, что она «живёт дольше». Если бы Ржавчина позволил такому коду работать, то переменная <code>r</code> смогла бы ссылаться на память, которая уже была освобождена (в тот мгновение, когда <code>x</code> вышла из внутренней области видимости), и всё что мы попытались бы сделать с <code>r</code> работало бы неправильно. Как же Ржавчина определяет, что этот код неправилен? Он использует для этого анализатор заимствований (<em>borrow checker</em>).</p>
<h3 id="Анализатор-заимствований"><a class="header" href="#Анализатор-заимствований">Анализатор заимствований</a></h3>
<p>Сборщик Ржавчина имеет в своём составе <em>анализатор заимствований</em>, который сравнивает области видимости для определения, являются ли все заимствования действительными. В приложении 10-17 показан тот же код, что и в приложении 10-16, но с изложениями, показывающими времена жизни переменных.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
<p><span class="caption">Пример 10-17: Изложение времён жизни переменных <code>r</code> и <code>x</code>, с помощью определителей времени жизни <code>'a</code> и <code>'b</code>, соответственно</span></p>
<p>Здесь мы описали время жизни для <code>r</code> с помощью <code>'a</code> и время жизни <code>x</code> с помощью <code>'b</code> . Как видите, время жизни <code>'b</code> внутреннего раздела гораздо меньше, чем время жизни <code>'a</code> внешнего раздела. Во время сборки Ржавчина сравнивает продолжительность двух времён жизни и видит, что <code>r</code> имеет время жизни <code>'a</code>, но ссылается на память со временем жизни <code>'b</code>. Программа отклоняется, потому что <code>'b</code> короче, чем <code>'a</code>: предмет ссылки не живёт так же долго, как сама ссылка.</p>
<p>Приложение 10-18 исправляет код, чтобы в нём не было повисшей ссылки, и собирается без ошибок.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<p><span class="caption">Приложение 10-18: Ссылка правильна, так как данные имеют более продолжительное время жизни, чем ссылка на эти данные</span></p>
<p>Здесь переменная <code>x</code> имеет время жизни <code>'b</code>, которое больше, чем время жизни <code>'a</code>. Это означает, что переменная <code>r</code> может ссылаться на переменную <code>x</code> потому что Ржавчина знает, что ссылка в переменной <code>r</code> будет всегда действительной до тех пор, пока переменная <code>x</code> является валидной.</p>
<p>После того, как мы на примерах рассмотрели времена жизни ссылок и обсудили как Ржавчина их анализирует, давайте поговорим об обобщённых временах жизни входных свойств и возвращаемых значений функций.</p>
<h3 id="Обобщённые-времена-жизни-в-функциях"><a class="header" href="#Обобщённые-времена-жизни-в-функциях">Обобщённые времена жизни в функциях</a></h3>
<p>Напишем функцию, которая возвращает более длинный из двух срезов строки. Эта функция принимает два среза строки и возвращает один срез строки. После того как мы выполнили функцию <code>longest</code>, код в приложении 10-19 должен вывести <code>The longest string is abcd</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
<p><span class="caption">Приложение 10-19: Функция <code>main</code> вызывает функцию <code>longest</code> для поиска наибольшего из двух срезов строки</span></p>
<p>Обратите внимание, что мы хотим чтобы функция принимала строковые срезы, которые являются ссылками, а не строки, потому что мы не хотим, чтобы функция <code>longest</code> забирала во владение свои свойства. Обратитесь к разделу <a href="ch04-03-slices.html#string-slices-as-parameters">"Строковые срезы как свойства"</a><!--  --> Главы 4 для более подробного обсуждения того, почему свойства используемые в приложении 10-19 выбраны именно таким образом.</p>
<p>Если мы попробуем выполнить функцию <code>longest</code> так, как это показано в приложении 10-20, программа не собирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<p><span class="caption">Приложение 10-20: Выполнение функции <code>longest</code>, которая возвращает наибольший срез строки, но пока не собирается</span></p>
<p>Вместо этого мы получим следующую ошибку, говорящую о временах жизни:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Текст ошибки показывает, что возвращаемому виду нужен обобщённый свойство времени жизни, потому что Ржавчина не может определить, относится ли возвращаемая ссылка к <code>x</code> или к <code>y</code>. На самом деле, мы тоже не знаем, потому что раздел<code>if</code> в теле функции возвращает ссылку на <code>x</code>, а раздел<code>else</code> возвращает ссылку на <code>y</code>!</p>
<p>Когда мы определяем эту функцию, мы не знаем определенных значений, которые будут в неё передаваться. Поэтому мы не знаем какая из ветвей оператора <code>if</code> или <code>else</code> будет выполнена. Мы также не знаем определенных времён жизни ссылок, которые будут переданы в функцию, поэтому мы не можем посмотреть на их области видимости, как мы делали в примерах 10-17 и 10-18, чтобы определить, будет ли возвращаемая нами ссылка правильной во всех случаях. Анализатор заимствований также не может этого определить, потому что он не знает как времена жизни переменных <code>x</code> и <code>y</code> соотносятся с временем жизни возвращаемого значения. Чтобы исправить эту ошибку, мы добавим обобщённый свойство времени жизни, который определит отношения между ссылками таким образом, чтобы анализатор заимствований мог провести свой анализ.</p>
<h3 id="правила-написания-изложении-времени-жизни"><a class="header" href="#правила-написания-изложении-времени-жизни">правила написания изложении времени жизни</a></h3>
<p>Изложения времени жизни не меняют срок, как долго живёт та или иная ссылка. Они скорее описывают, как соотносятся между собой времена жизни нескольких ссылок, не влияя на само время жизни. Точно так же, как функции могут принимать любой вид, когда в ярлыке указан свойство обобщённого вида, функции могут принимать ссылки с любым временем жизни, указанным с помощью свойства обобщённого времени жизни.</p>
<p>Изложения времени жизни имеют немного необычный правила написания: имена свойств времени жизни должны начинаться с апострофа (<code>'</code>), пишутся маленькими буквами, и обычно очень короткие, как и имена обобщённых видов. Большинство людей использует имя <code>'a</code> в качестве первой изложении времени жизни. Изложения свойств времени жизни следуют после символа <code>&amp;</code> и отделяются пробелом от названия ссылочного вида.</p>
<p>Приведём несколько примеров: у нас есть ссылка на <code>i32</code> без указания времени жизни, ссылка на <code>i32</code>, с временем жизни имеющим имя <code>'a</code> и изменяемая ссылка на <code>i32</code>, которая также имеет время жизни <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>Одна изложение времени жизни сама по себе не имеет большого значения, поскольку изложении предназначены для того, чтобы уведомить Ржавчина о том, как времена жизни нескольких ссылок соотносятся между собой. Давайте рассмотрим, как изложении времени жизни связаны друг с другом в среде функции <code>longest</code>.</p>
<h3 id="Изложения-времени-жизни-в-ярлыках-функций"><a class="header" href="#Изложения-времени-жизни-в-ярлыках-функций">Изложения времени жизни в ярлыках функций</a></h3>
<p>Чтобы использовать изложении времени жизни в ярлыках функций, нам нужно объявить свойства обобщённого <em>времени жизни</em> внутри угловых скобок между именем функции и списком свойств, как мы это делали с свойствами обобщённого <em>вида</em> .</p>
<p>Мы хотим, чтобы ярлык отражала следующее ограничение: возвращаемая ссылка будет действительна до тех пор, пока валидны оба свойства. Это связь между временами жизни свойств и возвращаемого значения. Мы назовём это время жизни <code>'a</code>, а затем добавим его к каждой ссылке, как показано в приложении 10-21.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Приложение 10-21: В определении функции <code>longest</code> указано, что все ссылки должны иметь одинаковое время жизни, обозначенное как <code>'a</code></span></p>
<p>Этот код должен собираться и давать желаемый итог, когда мы вызовем его в функции <code>main</code> приложения 10-19.</p>
<p>Ярлык функции теперь сообщает Rust, что для некоторого времени жизни <code>'a</code> функция принимает два свойства, оба из которых являются срезами строк, которые живут не меньше, чем время жизни <code>'a</code>. Ярлык функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как самое меньшее столько, сколько длится время жизни <code>'a</code>. В действительностиэто означает, что время жизни ссылки, возвращаемой функцией <code>longest</code>, равно меньшему времени жизни передаваемых в неё ссылок. Мы хотим, чтобы Ржавчина использовал именно такие отношения при анализе этого кода.</p>
<p>Помните, когда мы указываем свойства времени жизни в этой ярлыке функции, мы не меняем время жизни каких-либо переданных или возвращённых значений. Скорее, мы указываем, что анализатор заимствований должен отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что самой функции <code>longest</code> не нужно точно знать, как долго будут жить <code>x</code> и <code>y</code>, достаточно  того, что некоторая область может быть заменена на <code>'a</code>, которая будет удовлетворять этой ярлыке.</p>
<p>При определении времён жизни функций, изложении помещаются в ярлык функции, а не в тело функции. Изложения времени жизни становятся частью договора функции, как и виды в ярлыке. Наличие ярлыков функций, содержащих договор времени жизни, означает, что анализ который выполняет сборщик Rust, может быть проще. Если есть неполадка с тем, как функция определяется или как она вызывается, ошибки сборщика могут указать на часть нашего кода и ограничения более точно. Если бы вместо этого сборщик Ржавчина сделал больше предположений о том, какие отношения времён жизни мы хотели получить, сборщик смог бы указать только на использование нашего кода за много шагов от источника сбоев.</p>
<p>Когда мы передаём определенные ссылки в функцию <code>longest</code>, определенным временем жизни, которое будет заменено на <code>'a</code>, является часть области видимости <code>x</code>, которая пересекается с областью видимости <code>y</code>. Другими словами, обобщённое время жизни <code>'a</code> получит определенное время жизни, равное меньшему из времён жизни <code>x</code> и <code>y</code>. Так как мы определяли возвращаемую ссылку тем же свойствоом времени жизни <code>'a</code>, то возвращённая ссылка также будет действительна на протяжении меньшего из времён жизни <code>x</code> и <code>y</code>.</p>
<p>Давайте посмотрим, как изложении времени жизни ограничивают функцию <code>longest</code> путём передачи в неё ссылок, которые имеют разные определенные времена жизни. Приложение 10-22 является очевидным примером.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-22: Использование функции <code>longest</code> со ссылками на значения вида <code>String</code>, имеющими разное время жизни</span></p>
<p>В этом примере переменная <code>string1</code> действительна до конца внешней области, <code>string2</code> действует до конца внутренней области видимости и <code>result</code> ссылается на что-то, что является действительным до конца внутренней области видимости. Запустите этот код, и вы увидите что анализатор заимствований разрешает такой код; он собирает и напечатает <code>The longest string is long string is long</code>.</p>
<p>Теперь, давайте попробуем пример, который показывает, что время жизни ссылки <code>result</code> должно быть меньшим временем жизни одного из двух переменных. Мы переместим объявление переменной <code>result</code> за пределы внутренней области видимости, но оставим присвоение значения переменной <code>result</code> в области видимости <code>string2</code>. Затем мы переместим <code>println!</code>, который использует <code>result</code> за пределы внутренней области видимости, после того как внутренняя область видимости закончилась. Код в приложении 10-23 не собирается.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 10-23: Попытка использования <code>result</code>, после того как <code>string2</code> вышла из области видимости</span></p>
<p>При попытке собрать этот код, мы получим такую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Эта ошибка говорит о том, что если мы хотим использовать <code>result</code> в указания <code>println!</code>, переменная <code>string2</code> должна бы быть действительной до конца внешней области видимости. Ржавчина знает об этом, потому что мы определяли свойства функции и её возвращаемое значение одинаковым временем жизни <code>'a</code>.</p>
<p>Будучи людьми, мы можем посмотреть на этот код и увидеть, что <code>string1</code> длиннее, чем <code>string2</code> и, следовательно, <code>result</code> будет содержать ссылку на <code>string1</code>. Поскольку <code>string1</code> ещё не вышла из области видимости, ссылка на <code>string1</code> будет все ещё действительной в указания <code>println!</code>. Однако сборщик не видит, что ссылка в этом случае валидна. Мы сказали Rust, что время жизни ссылки, возвращаемой из функции <code>longest</code>, равняется меньшему из времён жизни переданных в неё ссылок. Таким образом, анализатор заимствований запрещает код в приложении 10-23, как возможно имеющий недействительную ссылку.</p>
<p>Попробуйте провести больше экспериментов с различными значениями и временами жизни ссылок, передаваемых в функцию <code>longest</code>, а также с тем, как используется возвращаемое значение  Перед сборкой делайте предположения о том, пройдёт ли ваш код анализ заимствований, а затем проверяйте, насколько вы были правы.</p>
<h3 id="Мышление-в-понятиях-времён-жизни"><a class="header" href="#Мышление-в-понятиях-времён-жизни">Мышление в понятиях времён жизни</a></h3>
<p>В зависимости от того, что делает ваша функция, следует использовать разные способы указания свойств времени жизни. Например, если мы изменим выполнение функции <code>longest</code> таким образом, чтобы она всегда возвращала свой первый переменная вместо самого длинного среза строки, то время жизни для свойства <code>y</code> можно совсем не указывать. Этот код собирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Мы указали свойство времени жизни <code>'a</code> для свойства <code>x</code> и возвращаемого значения, но не для свойства <code>y</code>, поскольку время жизни свойства <code>y</code> никак не соотносится с временем жизни свойства <code>x</code> или возвращаемого значения.</p>
<p>При возврате ссылки из функции, свойство времени жизни для возвращаемого вида должен соответствовать свойству времени жизни одного из переменных. Если возвращаемая ссылка <em>не</em> ссылается на один из свойств, она должна ссылаться на значение, созданное внутри функции. Однако, это приведёт к недействительной ссылке, поскольку значение, на которое она ссылается, выйдет из области видимости в конце функции. Посмотрите на попытку выполнения функции <code>longest</code>, которая не собирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
<p>Здесь, несмотря на то, что мы указали свойство времени жизни <code>'a</code> для возвращаемого вида, выполнение не будет собрана, потому что время жизни возвращаемого значения никак не связано с временем жизни свойств. Получаем сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Неполадказаключается в том, что <code>result</code> выходит за область видимости и очищается в конце функции <code>longest</code>. Мы также пытаемся вернуть ссылку на <code>result</code> из функции. Мы не можем указать свойства времени жизни, которые могли бы изменить недействительную ссылку, а Ржавчина не позволит нам создать недействительную ссылку. В этом случае лучшим решением будет вернуть владеющий вид данных, а не ссылку: в этом случае вызывающая функция будет нести ответственность за очистку полученного ею значения.</p>
<p>В конечном итоге, правила написания времён жизни выполняет связывание времён жизни различных переменных и возвращаемых значений функций. Описывая времена жизни, мы даём Ржавчина достаточно сведений, чтобы разрешить безопасные действия с памятью и запретить действия, которые могли бы создать недействительные ссылки или иным способом нарушить безопасность памяти.</p>
<h3 id="Определение-времён-жизни-при-объявлении-устройств"><a class="header" href="#Определение-времён-жизни-при-объявлении-устройств">Определение времён жизни при объявлении устройств</a></h3>
<p>До сих пор мы объявляли устройства, которые всегда содержали владеющие виды данных. Устройства могут содержать и ссылки, но при этом необходимо добавить изложение времени жизни для каждой ссылки в определении устройства. Приложение 10-24 описывает устройство <code>ImportantExcerpt</code>, содержащую срез строки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<p><span class="caption">Приложение 10-25. Устройства, содержащая ссылку, требует изложении времени жизни</span></p>
<p>У устройства имеется одно поле <code>part</code>, хранящее срез строки, который сам по себе является ссылкой. Как и в случае с обобщёнными видами данных, мы объявляем имя обобщённого свойства времени жизни внутри угловых скобок после имени устройства, чтобы иметь возможность использовать его внутри определения устройства. Данная изложение означает, что образец <code>ImportantExcerpt</code> не может пережить ссылку, которую он содержит в своём поле <code>part</code>.</p>
<p>Функция <code>main</code> здесь создаёт образец устройства <code>ImportantExcerpt</code>, который содержит ссылку на первое предложение вида <code>String</code> принадлежащее переменной <code>novel</code>. Данные в <code>novel</code> существуют до  создания образца <code>ImportantExcerpt</code>. Кроме того, <code>novel</code> не выходит из области видимости до тех пор, пока <code>ImportantExcerpt</code> не выйдет за область видимости, поэтому ссылка в внутри образца <code>ImportantExcerpt</code>  является действительной.</p>
<h3 id="Правила-неявного-выведения-времени-жизни"><a class="header" href="#Правила-неявного-выведения-времени-жизни">Правила неявного выведения времени жизни</a></h3>
<p>Вы изучили, что у каждой ссылки есть время жизни и что нужно указывать свойства времени жизни для функций или устройств, которые используют ссылки. Однако в Главе 4 у нас была функция в приложении 4-9, которая затем снова показана в приложении 10-25, в которой код собрался без наставлений времени жизни.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-25: Функция, которую мы определили в приложении 4-9  собирается без наставлений времени жизни, несмотря на то, что входной и возвращаемый вид свойств являются ссылками</span></p>
<p>Причина, по которой этот код собирается — историческая. В ранних (до-1.0) исполнениях Ржавчина этот код не собрался бы, поскольку каждой ссылке нужно было явно назначать время жизни. В те времена, ярлык функции была бы написана примерно так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>После написания большого количества кода на Ржавчина разработчики языка обнаружили, что в определённых случаейх программисты описывают одни и те же изложении времён жизни снова и снова. Эти случаи были предсказуемы и следовали нескольким определенным образцовым моделям. Объединение Ржавчина решила запрограммировать эти образцы в код сборщика Rust, чтобы анализатор заимствований мог вывести времена жизни в таких случаейх без необходимости явного указания наставлений программистами.</p>
<p>Мы упоминаем этот отрывок истории Rust, потому что возможно, что в будущем появится больше образцов для самостоятельного выведения времён жизни, которые будут добавлены в сборщик. Таким образом, в будущем может понадобится ещё меньшее количество наставлений.</p>
<p>Образцы, запрограммированные в анализаторе ссылок языка Rust, называются <em>правилами неявного выведения времени жизни</em>. Это не правила, которым должны следовать программисты; а набор частных случаев, которые рассмотрит сборщик, и, если ваш код попадает в эти случаи, вам не нужно будет указывать время жизни явно.</p>
<p>Правила выведения не предоставляют полного заключения. Если Ржавчина определенно применяет правила, но некоторая неясность относительно времён жизни ссылок все ещё остаётся, сборщик не будет догадываться, какими должны быть времена жизни оставшихся ссылок. В этом случае, вместо угадывания сборщик выдаст ошибку, которую вы можете устранить, добавив изложении времени жизни.</p>
<p>Времена жизни свойств функции или способа называются <em>временем жизни ввода</em>, а времена жизни возвращаемых значений называются <em>временем жизни вывода</em>.</p>
<p>Сборщик использует три правила, чтобы выяснить времена жизни ссылок при отсутствии явных наставлений. Первое правило относится ко времени жизни ввода, второе и третье правила применяются ко временам жизни вывода. Если сборщик доходит до конца проверки трёх правил и всё ещё есть ссылки, для которых он не может выяснить время жизни, сборщик остановится с ошибкой. Эти правила применяются к объявлениям <code>fn</code>, а также к разделам <code>impl</code>.</p>
<p>Первое правило заключается в том, что каждый свойство являющийся ссылкой, получает свой собственный свойство времени жизни. Другими словами, функция с одним свойствоом получит один свойство времени жизни: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; функция с двумя переменнойми получит два отдельных свойства времени жизни: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, и так далее.</p>
<p>Второе правило говорит, что если есть ровно один входной свойство времени жизни, то его время жизни назначается всем выходным свойствам: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Третье правило о том, что если есть множество входных свойств времени жизни, но один из них является ссылкой <code>&amp;self</code> или <code>&amp;mut self</code>, так как эта функция является способом, то время жизни <code>self</code> назначается временем жизни всем выходным свойствам. Это третье правило делает способы намного приятнее для чтения и записи, потому что требуется меньше символов.</p>
<p>Представим, что мы сборщик и применим эти правила, чтобы вывести времена жизни ссылок в ярлыке функции <code>first_word</code> приложения 10-25. Ярлык этой функции начинается без объявления времён жизни ссылок:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Теперь мы (в качестве сборщика) применим первое правило, утверждающее, что каждый свойство функции получает своё собственное время жизни. Как обычно, назовём его <code>'a</code> и теперь ярлык выглядит так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Далее применяем второе правило, поскольку в функции указан только один входной свойство времени жизни. Второе правило гласит, что время жизни единственного входного свойства назначается выходным свойствам, поэтому ярлык теперь преобразуется таким образом:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Теперь все ссылки в этой функции имеют свойства времени жизни и сборщик может продолжить свой анализ без необходимости просить у программиста указать изложении времён жизни в ярлыке этой функции.</p>
<p>Давайте рассмотрим ещё один пример: на этот раз функцию <code>longest</code>, в которой не было свойств времени жизни, когда мы начали с ней работать в приложении 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Применим первое правило: каждому свойству назначается собственное время жизни. На этот раз у функции есть два свойства, поэтому есть два времени жизни:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Можно заметить, что второе правило здесь не применимо, так как в ярлыке указано больше одного входного свойства времени жизни. Третье правило также не применимо, так как <code>longest</code> — функция, а не способ, следовательно, в ней нет свойства <code>self</code>.  Итак, мы прошли все три правила, но так и не смогли вычислить время жизни выходного свойства. Поэтому мы и получили ошибку при попытке собрать код приложения 10-20: сборщик работал по правилам неявного выведения времён жизни, но не мог выяснить все времена жизни ссылок в ярлыке.</p>
<p>Так как третье правило применяется только к способам, далее мы рассмотрим времена жизни в этом среде, чтобы понять, почему нам часто не требуется определять времена жизни в ярлыках способов.</p>
<h3 id="Изложение-времён-жизни-в-определении-способов"><a class="header" href="#Изложение-времён-жизни-в-определении-способов">Изложение времён жизни в определении способов</a></h3>
<p>Когда мы выполняем способы для устройств с временами жизни, мы используем тот же правила написания, который применялся для наставлений обобщённых видов данных на приложении 10-11. Место, где мы объявляем и используем времена жизни, зависит от того, с чем они связаны — с полями устройства, либо с переменнойми способов и возвращаемыми значениями.</p>
<p>Имена свойств времени жизни для полей устройств всегда описываются после ключевого слова <code>impl</code> и затем используются после имени устройства, поскольку эти времена жизни являются частью вида устройства.</p>
<p>В ярлыках способов внутри раздела <code>impl</code> ссылки могут быть привязаны ко времени жизни ссылок в полях устройства, либо могут быть независимыми. Вдобавок, правила неявного выведения времён жизни часто делают так, что изложении переменных времён жизни являются необязательными в ярлыках способов. Рассмотрим несколько примеров, использующих устройство с названием <code>ImportantExcerpt</code>, которую мы определили в приложении 10-24.</p>
<p>Сначала, воспользуемся способом <code>level</code>, чей  единственный свойство является ссылкой на <code>self</code>, а возвращаемое значение <code>i32</code>, не является ссылкой ни на что:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Объявление свойства времени жизни после <code>impl</code> и его использование после имени вида является обязательным, но нам не нужно определять время жизни ссылки на <code>self</code>, благодаря первому правилу неявного выведения времён жизни.</p>
<p>Вот пример, где применяется третье правило неявного выведения времён жизни:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>В этом способе имеется два входных свойства, поэтому Ржавчина применит первое правило и назначит обоим свойствам <code>&amp;self</code> и <code>announcement</code> собственные времена жизни. Далее, поскольку один из свойств является <code>&amp;self</code>, то возвращаемое значение получает время жизни переменой <code>&amp;self</code> и все времена жизни теперь выведены.</p>
<h3 id="Постоянное-время-жизни"><a class="header" href="#Постоянное-время-жизни">Постоянное время жизни</a></h3>
<p>Одно особенное время жизни, которое мы должны обсудить, называется <code>'static</code>. Оно означает, что данная ссылка  <em>может</em> жить всю продолжительность работы программы. Все строковые записи по умолчанию имеют время жизни <code>'static</code>, но мы можем указать его явным образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>Содержание этой строки сохраняется внутри двоичного файл программы и всегда доступно для использования. Следовательно, время жизни всех строковых записей равно <code>'static</code>.</p>
<p>Сообщения сборщика об ошибках в качестве решения сбоев могут предлагать вам использовать время жизни <code>'static</code>. Но прежде чем указывать <code>'static</code> как время жизни для ссылки, подумайте, на самом ли деле данная ссылка будет доступна во всё время работы программы. В большинстве случаев, сообщения об ошибках, предлагающие использовать время жизни <code>'static</code> появляются при попытках создания недействительных ссылок или несовпадения имеющихся времён жизни. В таких случаях, решение заключается в исправлении таких неполадок. а не в указании постоянного времени жизни <code>'static</code>.</p>
<h2 id="Обобщённые-виды-свойств-ограничения-особенностей-и-времена-жизни-вместе"><a class="header" href="#Обобщённые-виды-свойств-ограничения-особенностей-и-времена-жизни-вместе">Обобщённые виды свойств, ограничения особенностей и времена жизни вместе</a></h2>
<p>Давайте кратко рассмотрим правила написания задания свойств обобщённых видов, ограничений особенности и времён жизни совместно в одной функции:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Today is someone's birthday!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Это функция <code>longest</code>  из приложения 10-21, которая возвращает наибольший из двух срезов строки. Но теперь у неё есть дополнительный свойство с именем <code>ann</code> обобщённого вида <code>T</code>, который может быть представлен любым видом, выполняющим особенность <code>Display</code>, как указано в предложении <code>where</code>. Этот дополнительный свойство будет напечатан с использованием <code>{}</code> , поэтому ограничение особенности <code>Display</code> необходимо. Поскольку время жизни является обобщённым видом, то объявления свойства времени жизни <code>'a</code> и свойства обобщённого вида <code>T</code> помещаются в один список внутри угловых скобок после имени функции.</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>В этой главе мы рассмотрели много всего! Теперь вы знакомы с свойствами обобщённого вида, особенностями и ограничениями особенности, обобщёнными свойствами времени жизни, вы готовы писать код без повторений, который будет работать во множестве различных случаев. Свойства обобщённого вида позволяют использовать код для различных видов данных. Особенности и ограничения особенности помогают убедиться, что, хотя виды и обобщённые, они будут вести себя, как этого требует ваш код. Вы изучили, как использовать изложении времени жизни чтобы убедиться, что этот гибкий код не будет порождать никаких повисших ссылок. И весь этот анализ происходит в мгновение сборки и не влияет на производительность программы во время работы!</p>
<p>Верите или нет, но в рамках этой темы всё есть ещё чему поучиться: в Главе 17 обсуждаются особенности-предметы, которые являются ещё одним способом использования особенностей. Существуют также более сложные сценарии с изложениями времени жизни, которые вам понадобятся только в очень сложных случаях; для этого вам следует прочитать <a href="../reference/index.html">Rust Reference</a>. Далее вы узнаете, как писать проверки на Rust, чтобы убедиться, что ваш код работает так, как задумано.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-02-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-00-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-02-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-00-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
