<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Создание однопоточного веб-сервера - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие подходы программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Примечания</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие устройства</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание образцов структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> правила написания способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Устройство потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Краткий поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью дополнений, ящиков и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Дополнения и ящики</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и тайностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, особенности (свойства) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Особенности (свойства): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х проверок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать проверки</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением проверок</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Создание проверок</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Переработка кода для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через проверка</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация ящика на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью особенности Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью особенности Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный одновременность</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для одновременного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Одновременность с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый одновременность с помощью особенностей Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности предметно-направленного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Свойства предметно-направленных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование особенность-предметов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона предметно-направленного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> правила написания шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Конечный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html" class="active"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые особенности</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Ржавчина и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Создание-однопоточного-веб-сервера"><a class="header" href="#Создание-однопоточного-веб-сервера">Создание однопоточного веб-сервера</a></h2>
<p>Начнём с однопоточного веб-сервера. Перед тем, как начать, давайте сделаем краткий обзор протоколов, задействованных при создании веб-серверов. Детальное описание этих протоколов выходит за рамки этой книги, но краткий обзор даст вам необходимую сведения.</p>
<p>Двумя основными протоколами, используемыми в веб-серверах, являются <em>протокол передачи гипертекста</em> <em>(HTTP - Hypertext Transfer Protocol)</em> и <em>Протокол управления передачей</em> <em>(TCP - Transmission Control Protocol)</em>. Оба протокола являются протоколами вида <em>запрос-ответ</em> (request-response), то есть <em>клиент</em> объявляет запросы, а <em>сервер</em> слушает эти запросы и предоставляет ответ клиенту. Содержимое этих запросов и ответов определяется протоколами.</p>
<p>TCP - это протокол нижнего уровня, который описывает подробности того, как сведения передаётся от одного сервера к другому, но не определяет, что это за сведения. HTTP строится поверх TCP, определяя содержимое запросов и ответов. Технически возможно использовать HTTP с другими протоколами, но в подавляющем большинстве случаев HTTP отправляет свои данные поверх TCP. Мы будем работать с необработанными байтами в TCP и запросами и ответами в HTTP.</p>
<h3 id="Прослушивание-tcp-соединения"><a class="header" href="#Прослушивание-tcp-соединения">Прослушивание TCP соединения</a></h3>
<p>Нашему веб-серверу необходимо прослушивать TCP-соединение, так что это первая часть, над которой мы будем работать. Обычная библиотека предлагает для этого модуль <code>std::net</code>. Сделаем новый проект обычным способом:</p>
<pre><code class="language-console">$ cargo new hello
      Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Дл начала добавьте код из приложения 20-1 в файл <em>src/main.rs</em>. Этот код будет прослушивать входящие TCP потоки по адресу <code>127.0.0.1:7878</code>. Когда сервер примет входящий поток, он напечатает <code>Connection established!</code> ("Соединение установлено!").</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre></pre>
<p><span class="caption">Приложение 20-1: Прослушивание входящих потоков и печать сообщения при получении потока</span></p>
<p>Используя <code>TcpListener</code> мы можем слушать TCP соединения к адресу <code>127.0.0.1:7878</code>. В адресе, в его части перед двоеточием, сначала идёт IP-адрес, относящийся к вашему компьютеру (он одинаковый на каждом компьютере и не представляет определенный компьютер автора), а часть <code>7878</code> является портом. Мы выбрали этот порт по двум причинам: HTTP обычно не используется на этом порту, поэтому маловероятно, что наш сервер будет враждовать с каким-нибудь другим сервером, который может выполняться на вашей машине, и ещё 7878 - это слово <em>rust</em>, набранное на телефоне.</p>
<p>Функция <code>bind</code> в этом сценарии работает так же, как функция <code>new</code>, поскольку она возвращает новый образец <code>TcpListener</code> . Причина, по которой функция называется <code>bind</code> заключается в том, что в сетевой совокупности понятий подключение к порту для прослушивания называется «привязка к порту» (“binding to a port”).</p>
<p>Функция <code>bind</code> возвращает <code>Result&lt;T, E&gt;</code>, а это значит, что привязка может не состояться. Так, например, подключение к порту 80 предполагает наличие привилегий администратора (прочие пользователи могут прослушивать порты только от 1023-го и выше), поэтому если мы попытаемся подключиться к порту 80, не будучи администратором, привязка не сработает. Привязка также не выполнится, например, если мы запустим два образца нашей программы, прослушивающие один и тот же порт. Поскольку мы пишем простейший сервер в учебных целях, мы не будем беспокоиться об обработке подобных ошибок; вместо этого мы используем <code>unwrap</code> для прекращения работы программы в случае возникновения ошибок.</p>
<p>Способ <code>incoming</code> в <code>TcpListener</code> возвращает повторитель, который даёт нам последовательность потоков (определеннее, потоков вида <code>TcpStream</code> ). Один <em>поток</em> представляет собой открытое соединение между клиентом и сервером. <em>Соединением</em> называется полный этап запроса и ответа, в котором клиент подключается к серверу, сервер генерирует ответ, и сервер закрывает соединение. Таким образом, мы будем читать из потока <code>TcpStream</code> то, что отправил клиент, а затем записывать наш ответ в поток, для отправки его обратно клиенту. В целом, цикл <code>for</code> будет обрабатывать каждое соединение по очереди и создавать серию потоков, которые мы будем обрабатывать.</p>
<p>На текущий мгновение наша обработка потока состоит из вызова <code>unwrap</code> для завершения программы, если в потоке возникли ошибки, если же таковых не обнаружится, программа выведет сообщение. В следующем приложении мы добавим больше функциональности для успешного сценария. Причиной того, что мы можем получать ошибки от способа <code>incoming</code>, когда клиент подключается к серверу, является то, что на самом деле мы не перебираем подключения. На самом деле мы перебираем <em>попытки подключения</em>. Подключение может не состояться по ряду причин, многие из которых зависят от операционной системы. Например, многие операционные системы имеют ограничение на количество одновременно открытых соединений, которые они могут поддерживать; при превышении этого предела новые попытки установить соединение будут приводить к ошибке, пока какие-либо из уже открытых соединений не будут закрыты.</p>
<p>Попробуем запустить этот код! Вызовите <code>cargo run</code> в окне вызова, а затем загрузите <em>127.0.0.1:7878</em> в веб-браузере. В браузере должно отображаться сообщение об ошибке, например «Connection reset», поскольку сервер в настоящее время не отправляет обратно никаких данных. Но когда вы посмотрите на свой окно вызова, вы должны увидеть несколько сообщений, которые были напечатаны, когда браузер подключался к серверу!</p>
<pre><code class="language-text">     Running `target/debug/hello`
 Connection established!
 Connection established!
 Connection established!
</code></pre>
<p>Иногда вы видите несколько сообщений, напечатанных для одного запроса браузера; Причина может заключаться в том, что браузер выполняет запрос страницы, а также других ресурсов, таких как значок <em>favicon.ico,</em> который отображается на вкладке браузера.</p>
<p>Также может быть, что браузер пытается подключиться к серверу несколько раз, потому что сервер не отвечает. Когда <code>stream</code> выходит из области видимости и отбрасывается в конце цикла, соединение закрывается как часть реализации <code>drop</code>. Браузеры иногда обрабатывают закрытые соединения, повторяя попытки, потому что неполадка может быть временной. Важным обстоятельством является то, что мы успешно получили дескриптор TCP-соединения!</p>
<p>Не забудьте остановить программу, нажав <span class="keystroke">ctrl-c</span>, когда вы закончите выполнение определённой исполнения кода. Затем перезапустите программу, вызвав приказ <code>cargo run</code>, после того, как вы внесли какой-либо набор изменений, чтобы убедиться, что выполняется самая свежая исполнение кода.</p>
<h3 id="Чтение-запросов"><a class="header" href="#Чтение-запросов">Чтение запросов</a></h3>
<p>Реализуем функционал чтения запроса из браузера! Чтобы разделить части, связанные с получением соединения и последующим действием с ним, мы запустим новую функцию для обработки соединения. В этой новой функции <code>handle_connection</code> мы будем читать данные из потока TCP и распечатывать их, чтобы мы могли видеть данные, отправленные из браузера. Измените код, чтобы он выглядел как в приложении 20-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
<p><span class="caption">Приложение 20-2: Чтение из <code>TcpStream</code> и печать данных</span></p>
<p>Мы добавляем <code>std::io::prelude</code> и <code>std::io::BufReader</code> в область видимости, чтобы получить доступ к типажам и видам, которые позволяют нам читать и писать в поток. В цикле <code>for</code> функции <code>main</code> вместо вывода сообщения о том, что мы установили соединение, мы теперь вызываем новую функцию <code>handle_connection</code> и передаём ей <code>stream</code>.</p>
<p>В функции <code>handle_connection</code> мы создаём новый образец <code>BufReader</code>, который оборачивает изменяемую ссылку на <code>stream</code>. <code>BufReader</code> добавляет буферизацию, управляя вызовами способов типажа <code>std::io::Read</code> за нас.</p>
<p>Мы создаём переменную <code>http_request</code> для сбора строк запроса, который браузер отправляет на наш сервер. Мы указываем, что хотим собрать эти строки в вектор, добавляя изложение вида <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> реализует особенность <code>std::io::BufRead</code>, который реализует способ <code>lines</code>. Способ <code>lines</code> возвращает повторитель<code>Result&lt;String, std::io::Error&gt;</code>, разделяющий поток данных на части всякий раз, когда ему попадается байт новой строки. Чтобы получить все строки <code>String</code>, мы с помощью map вызываем <code>unwrap</code> у каждого <code>Result</code>. Значение <code>Result</code> может быть ошибкой, если данные не соответствуют исполнению UTF-8 или если возникли сбоев с чтением из потока. Опять же, программа в промышленном исполнении должна обрабатывать эти ошибки более изящно, но мы для простоты решили прекращать работу программы в случае ошибки.</p>
<p>Браузер указывает об окончании HTTP-запроса, отправляя два символа перевода строки подряд, поэтому, чтобы получить один запрос из потока, мы забираем строки, пока не получим строку, которая является пустой строкой. После того, как мы собрали строки в вектор, мы распечатываем их, используя красивое отладочное изменение
, чтобы мы могли взглянуть на указания, которые веб-браузер отправляет на наш сервер.</p>
<p>Попробуем этот код! Запустите программу и снова сделайте запрос в веб-браузере. Обратите внимание, что мы по-прежнему будем получать в браузере страницу с ошибкой, но вывод нашей программы в окне вызова теперь будет выглядеть примерно так:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>В зависимости от вашего браузера итог может немного отличаться. Теперь, когда мы печатаем данные запроса, мы можем понять, почему мы получаем несколько подключений из одного запроса браузера, посмотрев на путь после <code>GET</code> в первой строке запроса. Если все повторяющиеся соединения запрашивают <em>/</em> , мы знаем, что браузер пытается получить <em>/</em> повторно, потому что он не получает ответа от нашей программы.</p>
<p>Давайте разберём эти данные запроса, чтобы понять, что браузер запрашивает у нашей программы.</p>
<h3 id="Пристальный-взгляд-на-http-запрос"><a class="header" href="#Пристальный-взгляд-на-http-запрос">Пристальный взгляд на HTTP запрос</a></h3>
<p>HTTP - это текстовый протокол и запрос имеет следующий вид:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка - это <em>строка запроса</em> , содержащая сведения о том, что запрашивает клиент. Первая часть строки запроса указывает используемый <em>способ</em> , например <code>GET</code> или <code>POST</code> , который описывает, как клиент выполняет этот запрос. Наш клиент использовал запрос <code>GET</code>, что означает, что он просит нас предоставить сведения.</p>
<p>Следующая часть строки запроса - это <em>/</em>, которая указывает <em>унифицированный определитель</em> <em>ресурса (URI),</em> который запрашивает клиент: URI почти, но не совсем то же самое, что и <em>унифицированный указатель ресурса</em> <em>(URL)</em>. Разница между URI и URL-адресами не важна для наших целей в этой главе, но спецификация HTTP использует понятие URI, поэтому мы можем просто мысленно заменить URL-адрес здесь.</p>
<p>Последняя часть - это исполнение HTTP, которую использует клиент, а затем строка запроса заканчивается <em>последовательностью CRLF</em> . (CRLF обозначает <em>возврат каретки</em> и <em>перевод строки</em> , что является понятием из дней пишущих машинок!) Последовательность CRLF также может быть записана как <code>\r\n</code> , где <code>\r</code> - возврат каретки, а <code>\n</code> - перевод строки. Последовательность CRLF отделяет строку запроса от остальных данных запроса. Обратите внимание, что при печати CRLF мы видим начало новой строки, а не <code>\r\n</code> .</p>
<p>Глядя на данные строки запроса, которые мы получили от запуска нашей программы, мы видим, что <code>GET</code> - это способ, <em>/</em> - это URI запроса, а <code>HTTP/1.1</code> - это исполнение.</p>
<p>После строки запроса оставшиеся строки, начиная с <code>Host:</code> далее, являются заголовками. <code>GET</code> запросы не имеют тела.</p>
<p>Попробуйте сделать запрос из другого браузера или запросить другой адрес, например <em>127.0.0.1:7878/test</em> , чтобы увидеть, как изменяются данные запроса.</p>
<p>Теперь, когда мы знаем, что запрашивает браузер, давайте отправим обратно в ответ некоторые данные!</p>
<h3 id="Написание-ответа"><a class="header" href="#Написание-ответа">Написание ответа</a></h3>
<p>Теперь реализуем отправку данных в ответ на запрос клиента. Ответы имеют следующий вид:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка - это <em>строка состояния</em>, которая содержит исполнение HTTP, используемую в ответе, числовой код состояния, который суммирует итог запроса, и фразу причины, которая предоставляет текстовое описание кода состояния. После последовательности CRLF идут любые заголовки, другая последовательность CRLF и тело ответа.</p>
<p>Вот пример ответа, который использует HTTP исполнения 1.1, имеет код состояния 200, фразу причины OK, без заголовков и без тела:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Код состояния 200 - это обычный успешный ответ. Текст представляет собой крошечный успешный HTTP-ответ. Давайте запишем это в поток как наш ответ на успешный запрос! Из функции <code>handle_connection</code> удалите <code>println!</code> который печатал данные запроса и заменял их кодом из Приложения 20-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 20-3: Запись крошечного успешного HTTP-ответа в поток</span></p>
<p>Первый перевод строки определяет переменную <code>response</code>, которая содержит данные сообщения об успешном выполнении. Затем мы вызываем <code>as_bytes</code> в нашем <code>response</code>, чтобы преобразовать строковые данные в байты. Способ <code>write_all</code> в <code>stream</code> принимает вид <code>&amp;[u8]</code> и отправляет эти байты непосредственно получателю. Поскольку действие <code>write_all</code> может завершиться с ошибкой, мы, как и ранее, используем <code>unwrap</code> на любом возможно ошибочном итоге. И опять, в существующем приложении здесь вам нужно было бы добавить обработку ошибок.</p>
<p>После этих изменений давайте запустим наш код и сделаем запрос. Мы больше не печатаем никаких данных в окно вызова, поэтому мы не увидим никакого вывода, кроме сообщений от Cargo. Когда вы загрузите <em>127.0.0.1:7878</em> в веб-браузере, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали код получения HTTP-запроса и отправки ответа на него!</p>
<h3 id="Возвращение-существующего-html"><a class="header" href="#Возвращение-существующего-html">Возвращение существующего HTML</a></h3>
<p>Давайте реализуем функционал чего-нибудь большего, чем просто пустой страницы. Создайте новый файл <em>hello.html</em> в корне папки вашего проекта, а не в папке <em>src</em> . Вы можете ввести любой HTML-код, который вам заблагорассудится; В приложении 20-4 показан один из вариантов.</p>
<p><span class="filename">Файл: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Приложение 20-4: Пример HTML-файла для ответа на запрос</span></p>
<p>Это простейший HTML5-документ с заголовком и каким-то текстом. Чтобы сервер возвращал его в ответ на полученный запрос, мы изменим <code>handle_connection</code>, как показано в приложении 20-5, чтобы считать HTML-файл, добавить его в ответ в качестве тела и отправить.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 20-5. Отправка содержимого <em>hello.html</em> в качестве тела ответа</span></p>
<p>Мы добавили элемент <code>fs</code> в указанию <code>use</code>, чтобы включить в область видимости модуль файловой системы встроенной библиотеки. Код для чтения содержимого файла в строку должен выглядеть знакомым для вас; мы использовали его в главе 12, когда читали содержимое файла для нашего проекта ввода-вывода в приложении 12-4.</p>
<p>Далее мы используем <code>format!</code> чтобы добавить содержимое файла в качестве тела ответа об успешном завершении. Чтобы обеспечить действительный HTTP-ответ, мы добавляем заголовок <code>Content-Length</code> который имеет размер тела нашего ответа, в данном случае размер <code>hello.html</code> .</p>
<p>Запустите этот код приказом <code>cargo run</code> и загрузите <em>127.0.0.1:7878</em> в браузере; вы должны увидеть выведенный HTML в браузере!</p>
<p>В настоящее время мы пренебрегаем данные запроса в переменной <code>http_request</code> и в любом случае просто отправляем обратно содержимое HTML-файла. Это означает, что если вы попытаетесь запросить адрес <em>127.0.0.1:7878/something-else</em> в своём браузере, вы все равно получите тот же самый HTML-ответ. Пока что наш сервер очень ограничен, и не умеет делать то, что делает большинство веб-серверов. Мы хотим настроить наши ответы в зависимости от запроса и отправлять обратно HTML-файл только для правильно созданного запроса к пути <em>/</em> .</p>
<h3 id="Проверка-запроса-и-выборочное-возвращение-ответа"><a class="header" href="#Проверка-запроса-и-выборочное-возвращение-ответа">Проверка запроса и выборочное возвращение ответа</a></h3>
<p>Сейчас наш веб-сервер возвращает HTML из файла независимо от того, что определенно запросил клиент. Давайте добавим проверку того, что браузер запрашивает <em>/</em>, прежде чем вернуть HTML-файл, и будем возвращать ошибку, если браузер запрашивает что-то постороннее. Для этого нам нужно модифицировать <code>handle_connection</code>, как показано в приложении 20-6. Новый код проверяет соответствует ли требуемый запросом ресурс с определителем <em>/</em>, и содержит разделы <code>if</code> и <code>else</code>, чтобы иначе обрабатывать другие запросы.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<p><span class="caption">Приложение 20-6: Обрабатываем запросы для корневого ресурса <em>/</em> не так, как запросы для других ресурсов</span></p>
<p>Мы будем рассматривать только первую строку HTTP-запроса, поэтому вместо того, чтобы читать весь запрос в вектор, мы вызываем <code>next</code> , чтобы получить первый элемент из повторителя. Первый вызов <code>unwrap</code> заботится об обработке <code>Option</code> и останавливает программу, если в повторителе нет элементов. Второй <code>unwrap</code> обрабатывает <code>Result</code> и имеет тот же эффект, что и <code>unwrap</code>, который был в <code>map</code>, добавленном в приложении 20-2.</p>
<p>Затем мы проверяем переменную <code>request_line</code>, чтобы увидеть, равна ли она строке запроса, соответствующей запросу GET для пути <em>/</em> . Если это так, раздел<code>if</code> возвращает содержимое нашего HTML-файла.</p>
<p>Если <code>request_line</code> <em>не</em> равна запросу GET для пути <em>/</em>, это означает, что мы получили какой-то другой запрос. Мы скоро добавим код в раздел<code>else</code>, чтобы ответить на все остальные запросы.</p>
<p>Запустите этот код сейчас и запросите <em>127.0.0.1:7878</em> ; вы должны получить HTML в <em>hello.html</em> . Если вы сделаете любой другой запрос, например <em>127.0.0.1:7878/something-else</em> , вы получите ошибку соединения, подобную той, которую вы видели при запуске кода из Приложения 20-1 и Приложения 20-2.</p>
<p>Теперь давайте добавим код из приложения 20-7 в раздел<code>else</code> чтобы вернуть ответ с кодом состояния 404, который указывает о том, что содержание для запроса не найден. Мы также вернём HTML-код для страницы, отображаемой в браузере, с указанием ответа конечному пользователю.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение  20-7: Отвечаем кодом состояния 404 и страницей ошибки, если было запрошено что-то, отличающееся от ресурса <em>/</em></span></p>
<p>Здесь ответ имеет строку состояния с кодом 404 и фразу причины <code>NOT FOUND</code>. Тело ответа будет HTML из файла <em>404.html</em>. Вам нужно создать файл <em>404.html</em> рядом с <em>hello.html</em> для этой страницы ошибки; снова не стесняйтесь использовать любой HTML код или пример HTML кода в приложении 20-8.</p>
<p><span class="filename">Файл: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Приложение 20-8. Пример содержимого страницы для отправки с любым ответом 404</span></p>
<p>С этими изменениями снова запустите сервер. Запрос на <em>127.0.0.1:7878</em> должен возвращать содержимое <em>hello.html</em>, и любой другой запрос, как <em>127.0.0.1:7878/foo</em>, должен возвращать сообщение об ошибке HTML от <em>404.html</em>.</p>
<h3 id="Переработка-кода"><a class="header" href="#Переработка-кода">Переработка кода</a></h3>
<p>На текущий мгновение разделы <code>if</code> и <code>else</code> во многом повторяются: они оба читают файлы и записывают содержимое файлов в поток. Разница лишь в строке состояния и имени файла. Давайте сделаем код более кратким, вынеся эти отличия в отдельные разделы <code>if</code> и <code>else</code>, в которых переменным будут присвоены значения строки состояния и имени файла; далее эти переменные мы сможем использовать в коде для чтения файла и создания ответа. В приложении 20-9 показан код после изменения объёмных разделов <code>if</code> и <code>else</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 20-9: Переработка кода разделов <code>if</code> и <code>else</code>, чтобы они содержали только код, который отличается для каждого из случаев</span></p>
<p>Теперь разделы <code>if</code> и <code>else</code> возвращают только соответствующие значения для строки состояния и имени файла в кортеже. Затем мы используем деструктурирование, чтобы присвоить эти два значения <code>status_line</code> и <code>filename</code> используя шаблон в указания <code>let</code>, как обсуждалось в главе 18.</p>
<p>Ранее повторяющийся код теперь находится вне разделов <code>if</code> и <code>else</code> и использует переменные <code>status_line</code> и <code>filename</code>. Это позволяет легче увидеть разницу между этими двумя случаями и означает, что у нас есть только одно место для обновления кода, если захотим изменить работу чтения файлов и записи ответов. Поведение кода в приложении 20-9 будет таким же, как и в 20-8.</p>
<p>Потрясающие! Теперь у нас есть простой веб-сервер примерно на 40 строках кода Rust, который отвечает на один запрос страницей с содержанием и отвечает на все остальные запросы ответом 404.</p>
<p>В настоящее время наш сервер работает в одном потоке, что означает, что он может обслуживать только один запрос за раз. Давайте разберёмся, почему это может быть неполадкой, сымитировав несколько медленных запросов. Затем мы исправим случай так, чтобы наш сервер мог обрабатывать несколько запросов одновременно.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-final-project-a-web-server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-02-multithreaded.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-final-project-a-web-server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-02-multithreaded.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
