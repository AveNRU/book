<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Макросы - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие подходы программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Примечания</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие устройства</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование устройств для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание образцов устройств</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей устройства</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> правила написания способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Устройство потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Краткий поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими делами с помощью дополнений, ящиков и звеньев</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Дополнения и ящики</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение звеньев для управления областью действия и тайностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве звеньев</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, особенности (свойства) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Особенности (свойства): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х проверок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать проверки</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением проверок</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Создание проверок</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Дело с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Переработка кода для обеспечения выделения на звенья и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка возможности библиотеки с помощью разработки через проверка</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Полезные  возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего дела с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Обнародование ящика на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью особенности Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью особенности Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный одновременность</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для одновременного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Одновременность с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый одновременность с помощью особенностей Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности предметно-направленного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Свойства предметно-направленных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование особенность-предметов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Выполнение образца предметно-направленного разработки</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Образцы и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться образцы</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли образец не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> правила написания образца</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые особенности</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html" class="active"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Конечный дело: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые особенности</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Ржавчина и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Макросы"><a class="header" href="#Макросы">Макросы</a></h2>
<p>Мы использовали макросы, такие как <code>println!</code> на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Понятие <em>макрос</em> относится к семейству возможностей в Rust. Это <em>декларативные</em> (declarative) макросы с помощью <code>macro_rules!</code> и три вида <em>процедурных</em> (procedural) макросов:</p>
<ul>
<li>Пользовательские (выводимые) <code>#[derive]</code> макросы, которые указывают код, добавленный с помощью свойства <code>derive</code>, используемые для устройств и перечислений</li>
<li>Макросы подобные свойствам (attribute-like), которые определяют настраиваемые свойства, используемые для любого элемента языка</li>
<li>Похожие на функции (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream</li>
</ul>
<p>Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.</p>
<h3 id="Разница-между-макросами-и-функциями"><a class="header" href="#Разница-между-макросами-и-функциями">Разница между макросами и функциями</a></h3>
<p>По сути, макросы являются способом написания кода, который записывает другой код, что известно как <em>мета программирование</em>. В Приложении C мы обсуждаем свойство <code>derive</code>, который порождает за вас выполнение различных особенностей. Мы также использовали макросы <code>println!</code> и <code>vec!</code> на протяжении книги. Все эти макросы <em>раскрываются</em> для создания большего количества кода, чем исходный код написанный вами вручную.</p>
<p>Мета программирование полезно для уменьшения объёма кода, который вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.</p>
<p>Ярлык функции должна объявлять некоторое количество и вид этих свойств имеющихся у функции. Макросы, с другой стороны, могут принимать переменное число свойств: мы можем вызвать <code>println!("hello")</code> с одним переменнаяом или <code>println!("hello {}", name)</code> с двумя переменнойми. Также макросы раскрываются до того как сборщик преобразует смысл кода, поэтому макрос может, например, выполнить особенность заданного вида. Функция этого не может, потому что она вызывается во время выполнения и особенность должен быть выполнен во время сборки.</p>
<p>Обратной стороной выполнения макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте Ржавчина код, который записывает другой Ржавчина код. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.</p>
<p>Другое важное различие между макросами и функциями заключается в том, что вы должны объявить макросы или добавить их в область видимости <em>прежде</em> чем можете вызывать их в файле, в отличии от функций, которые вы можете объявить где угодно и вызывать из любого места.</p>
<h3 id="Декларативные-макросы-с-macro_rules-для-общего-мета-программирования"><a class="header" href="#Декларативные-макросы-с-macro_rules-для-общего-мета-программирования">Декларативные макросы с <code>macro_rules!</code> для общего мета программирования</a></h3>
<p>Наиболее широко используемой способом макросов в Ржавчина являются <em>декларативные макросы</em>. Они также иногда упоминаются как "макросы на примере", "<code>macro_rules!</code> макрос" или просто "макросы". По своей сути декларативные макросы позволяют писать нечто похожее на выражение <code>match</code> в  Rust. Как обсуждалось в главе 6, <code>match</code> выражения являются управляющими устройствами, которые принимают некоторое выражение, итог значения выражения сопоставляют с образцами, а затем запускают код для сопоставляемой ветки. Макросы также сравнивают значение с образцами, которые связаны с определенным кодом: в этой случаи значение является записью исходного кода Rust, переданным в макрос. Образцы сравниваются со устройствами этого исходного кода и при совпадении код, связанный с каждым образцом, заменяет код переданный макросу. Все это происходит во время сборки.</p>
<p>Для определения макроса используется устройство <code>macro_rules!</code>. Давайте рассмотрим, как использовать <code>macro_rules!</code> глядя на то, как объявлен макрос <code>vec!</code>. В главе 8 рассказано, как можно использовать макрос <code>vec!</code> для создания нового вектора с определёнными значениями. Например, следующий макрос создаёт новый вектор, содержащий три целых числа:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>Мы также могли использовать макрос <code>vec!</code> для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не смогли бы использовать функцию, чтобы сделать то же самое, потому что мы не знали бы заранее количество или вид значений.</p>
<p>В приложении 19-28 приведено несколько упрощённое определение макроса <code>vec!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<p><span class="caption">Приложение 19-28: Упрощённая исполнение определения макроса <code>vec!</code></span></p>
<blockquote>
<p>Примечание: действительное определение макроса <code>vec!</code> в встроенной библиотеке содержит код для предварительного выделения правильного объёма памяти. Этот код является переработкой, которую мы здесь не используем, чтобы сделать пример проще.</p>
</blockquote>
<p>Изложение <code>#[macro_export]</code> указывает, что данный макрос должен быть доступен всякий раз, когда ящик с объявленным макросом, добавлен в область видимости. Без этой изложении макрос нельзя добавить в область видимости.</p>
<p>Затем мы начинаем объявление макроса с помощью  <code>macro_rules!</code> и имени макроса, который объявляется <em>без</em> восклицательного знака. Название, в данном случае <code>vec</code>, после которого следуют фигурные скобки, указывающие тело определения макроса.</p>
<p>Устройства в теле макроса <code>vec!</code> похожа на устройство <code>match</code> выражения. Здесь у нас есть одна ветвь с образцом <code>( $( $x:expr ),* )</code>, затем следует ветвь <code>=&gt;</code> и раздел кода, связанный с этим образцом. Если образец сопоставлен успешно, то соответствующий раздел кода будет создан. Учитывая, что данный код является единственным образцом в этом макросе, существует только один действительный способ сопоставления, любой другой образец приведёт к ошибке. Более сложные макросы будут иметь более одной ветви.</p>
<p>Допустимый правила написания образца в определениях макросов отличается от правил написания образца рассмотренного в главе 18, потому что образцы макроса сопоставляются со устройствами кода Rust, а не со значениями. Давайте пройдёмся по тому, какие части образца в приложении 19-28 что означают; полный правила написания образцов макроса можно найти в <a href="../reference/macros-by-example.html">Справочнике по Rust</a>.</p>
<p>Во-первых, мы используем набор скобок, чтобы охватить весь образец. Мы используем знак доллара ( <code>$</code>) для объявления переменной в системе макросов, которая будет содержать код на Rust, соответствующий образцу. Знак доллара показывает, что это макропеременная, а не обычная переменная Rust. Далее следует набор скобок, в котором определятся значения, соответствующие образцу в скобках, для использования в коде замены. Внутри <code>$()</code> находится <code>$x:expr</code>, которое соответствует любому выражению Ржавчина и даёт выражению имя <code>$x</code>.</p>
<p>Запятая, следующая за <code>$()</code> указывает на то, что буквенный символ-разделитель запятая может дополнительно появиться после кода, который соответствует коду в <code>$()</code>. Звёздочка <code>*</code> указывает, что образец соответствует ноль или больше раз тому, что предшествует <code>*</code>.</p>
<p>Когда вызывается этот макрос с помощью <code>vec![1, 2, 3];</code> образец <code>$x</code> соответствует три раза всем трём выражениям <code>1</code>, <code>2</code> и <code>3</code>.</p>
<p>Теперь давайте посмотрим на образец в теле кода, связанного с этой ветвью: <code>temp_vec.push()</code> внутри <code>$()*</code> порождается для каждой части, которая соответствует символу <code>$()</code> в образце ноль или более раз в зависимости от того, сколько раз образец сопоставлен. Символ <code>$x</code> заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с <code>vec![1, 2, 3];</code>, созданный код, заменяющий этот вызов макроса будет следующим:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Мы определили макрос, который может принимать любое количество переменных любого вида и может порождать код для создания вектора, содержащего указанные элементы.</p>
<p>Чтобы узнать больше о том, как писать макросы, обратитесь к онлайн-документации или другим ресурсам, таким как <a href="https://veykril.github.io/tlborm/">«Маленькая книга макросов Rust»</a> , начатая Дэниелом Кипом и продолженная Лукасом Виртом.</p>
<h3 id="Процедурные-макросы-для-создания-кода-из-свойств"><a class="header" href="#Процедурные-макросы-для-создания-кода-из-свойств">Процедурные макросы для создания кода из свойств</a></h3>
<p>Вторая разновидность макросов - это <em>процедурные макросы</em> (procedural macros), которые действуют как функции (и являются видом процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают над этим кодом и создают некоторый код в качестве вывода, а не выполняют сопоставления с образцами и замену кода другим кодом, как это делают декларативные макросы. Процедурные макросы могут быть трёх видов: "пользовательского вывода" (custom-derive), "похожие на свойство" (attribute-like) и "похожие на функцию" (function-like), все они работают схожим образом.</p>
<p>При создании процедурных макросов объявления должны находиться в собственном ящике целенаправленного вида. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. В приложении 19-29 показано, как задать процедурный макрос, где <code>some_attribute</code> является заполнителем для использования целенаправленного макроса.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Приложение 19-29: Пример определения процедурного макроса</span></p>
<p>Функция, которая определяет процедурный макрос, принимает <code>TokenStream</code> в качестве входных данных и создаёт <code>TokenStream</code> в качестве вывода. Вид <code>TokenStream</code> объявлен ящиком <code>proc_macro</code>, включённым в Ржавчина и представляет собой последовательность токенов. Это ядро макроса: исходный код над которым работает макрос, является входным <code>TokenStream</code>, а код создаваемый макросом является выходным <code>TokenStream</code>. К функции имеет также прикреплённый свойство, определяющий какой вид процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же ящике.</p>
<p>Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие разновидности отличающимися.</p>
<h3 id="Как-написать-пользовательский-derive-макрос"><a class="header" href="#Как-написать-пользовательский-derive-макрос">Как написать пользовательский <code>derive</code> макрос</a></h3>
<p>Давайте создадим ящик с именем <code>hello_macro</code>, который определяет особенность с именем <code>HelloMacro</code> и имеет одну с ним сопряженную функцию с именем <code>hello_macro</code>. Вместо того, чтобы пользователи нашего ящика самостоятельно выполнили особенность <code>HelloMacro</code> для каждого из своих видов, мы предоставим им процедурный макрос, чтобы они могли определять свой вид с помощью свойства <code>#[derive(HelloMacro)]</code> и получили выполнение по умолчанию для функции <code>hello_macro</code>. Выполнение по умолчанию выведет <code>Hello, Macro! My name is TypeName!</code>, где <code>TypeName</code> - это имя вида, для которого был определён этот особенность. Другими словами, мы напишем ящик, использование которого позволит другому программисту писать код показанный в приложении 19-30.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Приложение 19-30: Код, который сможет писать пользователь нашего ящика при использовании нашего процедурного макроса</span></p>
<p>Этот код напечатает <code>Hello, Macro! My name is Pancakes!</code>, когда мы закончим. Первый шаг - создать новый, библиотечный ящик так:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Далее, мы определим особенность <code>HelloMacro</code> и сопряженную с ним функцию:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<p>У нас есть особенность и его функция. На этом этапе пользователь ящика может выполнить особенность для достижения желаемой возможности, так:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>Тем не менее, ему придётся написать разделвыполнения для каждого вида, который он хотел использовать вместе с <code>hello_macro</code>; а мы хотим избавить их от необходимости делать эту работу.</p>
<p>Кроме того, мы пока не можем предоставить функцию <code>hello_macro</code> с выполнением по умолчанию, которая будет печатать имя вида, для которого выполнен особенность: Ржавчина не имеет возможностей рефлексии (reflection), поэтому он не может выполнить поиск имени вида во время выполнения кода. Нам нужен макрос для создания кода во время сборки.</p>
<p>Следующим шагом является определение процедурного макроса. На мгновение написания этой статьи процедурные макросы должны быть в собственном ящике. Со временем это ограничение может быть отменено. Соглашение о внутреннем выстраивании</p>
<p>ящиков и макросов является следующим: для ящика с именем <code>foo</code>, его пользовательский, ящик с выводимым процедурным макросом называется <code>foo_derive</code>. Давайте начнём с создания нового ящика с именем <code>hello_macro_derive</code> внутри дела <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Наши два ящика тесно связаны, поэтому мы создаём процедурный макрос-ящик в папке ящика <code>hello_macro</code>. Если мы изменим определение особенности в <code>hello_macro</code>, то нам придётся также изменить выполнение процедурного макроса в <code>hello_macro_derive</code>. Два ящика нужно будет обнародовать отдельно и программисты, использующие эти ящики, должны будут добавить их как зависимости, а затем добавить их в область видимости. Мы могли вместо этого сделать так, что ящик <code>hello_macro</code> использует <code>hello_macro_derive</code> как зависимость и реэкспортирует код процедурного макроса. Однако то, как мы внутренне выстраивали</p>
<p>дело, делает возможным программистам использовать <code>hello_macro</code> даже если они не хотят <code>derive</code> возможность.</p>
<p>Нам нужно объявить ящик <code>hello_macro_derive</code> как процедурный макрос-ящик. Также понадобятся возможности из ящиков <code>syn</code> и <code>quote</code>, как вы увидите через мгновение, поэтому нам нужно добавить их как зависимости. Добавьте следующее в файл <em>Cargo.toml</em> для <code>hello_macro_derive</code>:</p>
<p><span class="filename">Файл: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
<p>Чтобы начать определение процедурного макроса, поместите код приложения 19-31 в ваш файл <em>src/lib.rs</em> ящика <code>hello_macro_derive</code>. Обратите внимание, что этот код не собирается пока мы не добавим определение для функции <code>impl_hello_macro</code>.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Ржавчина code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Приложение 19-31: Код, который потребуется в большинстве процедурных макро ящиков для обработки Ржавчина кода</span></p>
<p>Обратите внимание, что мы разделили код на функцию <code>hello_macro_derive</code>, которая отвечает за синтаксический анализ <code>TokenStream</code> и функцию <code>impl_hello_macro</code>, которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса удобнее. Код во внешней функции ( <code>hello_macro_derive</code> в данном случае) будет одинаковым для почти любого процедурного макрос ящика, который вы видите или создаёте. Код, который вы указываете в теле внутренней функции (в данном случае <code>impl_hello_macro</code> ) будет отличаться в зависимости от цели вашего процедурного макроса.</p>
<p>Мы представили три новых ящика: <code>proc_macro</code> <a href="https://crates.io/crates/syn"><code>syn</code></a> и <a href="https://crates.io/crates/quote"><code>quote</code></a>. Макрос <code>proc_macro</code> поставляется с Rust, поэтому нам не нужно было добавлять его в зависимости внутри <em>Cargo.toml</em>. Макрос <code>proc_macro</code> - это API сборщика, который позволяет нам читать и управлять Ржавчина кодом из нашего кода.</p>
<p>Ящик <code>syn</code> разбирает Ржавчина код из строки в устройство данных над которой мы может выполнять действия. Ящик <code>quote</code> превращает устройства данных <code>syn</code> обратно в код Rust. Эти ящики упрощают разбор любого вида Ржавчина кода, который мы хотели бы обрабатывать: написание полного синтаксического анализатора для кода Ржавчина не является простой задачей.</p>
<p>Функция <code>hello_macro_derive</code> будет вызываться, когда пользователь нашей библиотеки указывает своему виду <code>#[derive(HelloMacro)]</code>. Это возможно, потому что мы определяли функцию <code>hello_macro_derive</code> с помощью <code>proc_macro_derive</code> и указали имя <code>HelloMacro</code>, которое соответствует имени нашего особенности; это соглашение, которому следует большинство процедурных макросов.</p>
<p>Функция <code>hello_macro_derive</code> сначала преобразует <code>input</code> из <code>TokenStream</code> в устройство данных, которую мы можем затем преобразовать и над которой выполнять действия. Здесь ящик <code>syn</code> вступает в игру. Функция <code>parse</code> в <code>syn</code> принимает <code>TokenStream</code> и возвращает устройство <code>DeriveInput</code>, представляющую разобранный код Rust. Приложение 19-32 показывает соответствующие части устройства <code>DeriveInput</code>, которые мы получаем при разборе строки <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Приложение 19-32: Образец <code>DeriveInput</code> получаемый, когда разбирается код имеющий свойство макроса из приложения 19-30</span></p>
<p>Поля этой устройства показывают, что код Rust, который мы разобрали, является разделустройства с <code>ident</code> (определителем, означающим имя) <code>Pancakes</code>. В этой устройстве есть больше полей для описания всех видов кода Rust; проверьте <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">документацию <code>syn</code> о устройстве <code>DeriveInput</code></a> для получения дополнительной сведений.</p>
<p>Вскоре мы определим функцию <code>impl_hello_macro</code>, в которой построим новый, дополнительный код Rust. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является <code>TokenStream</code>. Возвращаемый <code>TokenStream</code> добавляется в код, написанный пользователями макроса, поэтому, когда они соберут свой ящик, они получат дополнительную возможность, которую мы предоставляем в изменённом <code>TokenStream</code>.</p>
<p>Возможно, вы заметили, что мы вызываем <code>unwrap</code> чтобы выполнить панику в функции <code>hello_macro_derive</code>, если вызов функции <code>syn::parse</code> потерпит неудачу. Наш процедурный макрос должен паниковать при ошибках, потому что функции <code>proc_macro_derive</code> должны возвращать <code>TokenStream</code>, а не вид <code>Result</code> для соответствия API процедурного макроса. Мы упроисполнения этот пример с помощью <code>unwrap</code>, но в рабочем коде вы должны предоставить более определенные сообщения об ошибках, если что-то пошло не правильно, используя <code>panic!</code> или <code>expect</code>.</p>
<p>Теперь, когда у нас есть код для преобразования определеного Ржавчина кода из <code>TokenStream</code> в образец <code>DeriveInput</code>, давайте создадим код выполняющий особенность <code>HelloMacro</code> у определеного вида, как показано в приложении 19-33.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Ржавчина code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Приложение 19-33: Выполнение особенности <code>HelloMacro</code> с использованием проанализированного кода Rust.</span></p>
<p>Мы получаем образец устройства <code>Ident</code> содержащий имя (определитель) определеного вида с использованием <code>ast.ident</code>. Устройства в приложении 19-32 показывает, что когда мы запускаем функцию <code>impl_hello_macro</code> для кода из приложения 19-30, то получаемый <code>ident</code> будет иметь поле <code>ident</code> со значением <code>"Pancakes"</code>. Таким образом, переменная <code>name</code> в приложении 19-33 будет содержать образец устройства <code>Ident</code>, что при печати выдаст строку <code>"Pancakes"</code>, что является именем устройства в приложении 19-30.</p>
<p>Макрос <code>quote!</code> позволяет определить код Rust, который мы хотим вернуть. Сборщик ожидает что-то отличное от прямого итога выполнения макроса <code>quote!</code>, поэтому нужно преобразовать его в <code>TokenStream</code>. Мы делаем это путём вызова способа <code>into</code>, который использует промежуточное представление и возвращает значение требуемого вида <code>TokenStream</code>.</p>
<p>Макрос <code>quote!</code> также предоставляет очень полезную механику образцов: мы можем ввести <code>#name</code> и <code>quote!</code> заменит его значением из переменной <code>name</code>. Вы можете даже сделать некоторое повторение, подобное тому, как работают обычные макросы. Проверьте <a href="https://docs.rs/quote">документацию ящика <code>quote</code></a> для подробного введения.</p>
<p>Мы хотим, чтобы наш процедурный макрос порождал выполнение нашего особенности <code>HelloMacro</code> для вида, который определял пользователь, который мы можем получить, используя <code>#name</code>. Выполнение особенности имеет одну функцию <code>hello_macro</code>, тело которой содержит возможность, которую мы хотим предоставить: напечатать <code>Hello, Macro! My name is</code> с именем определеного вида.</p>
<p>Макрос <code>stringify!</code> используемый здесь, встроен в Rust. Он принимает Ржавчина выражение, такое как <code>1 + 2</code> и во время сборки сборщик превращает выражение в строковый запись, такой как <code>"1 + 2"</code>. Он отличается от макросов <code>format!</code> или <code>println!</code>, которые вычисляют выражение, а затем превращают итог в виде вида <code>String</code>. Существует возможность того, что введённый <code>#name</code> может оказаться выражением для печати буквально как есть, поэтому здесь мы используем <code>stringify!</code>. Использование <code>stringify!</code> также уменьшает выделение памяти путём преобразования <code>#name</code> в строковый запись во время сборки.</p>
<p>На этом этапе приказ <code>cargo build</code> должна завершиться успешно для обоих <code>hello_macro</code> и <code>hello_macro_derive</code>. Давайте подключим эти ящики к коду в приложении 19-30, чтобы увидеть процедурный макрос в действии! Создайте новый двоичный дело в папке ваших <em>дел</em> с использованием приказы <code>cargo new pancakes</code>. Нам нужно добавить <code>hello_macro</code> и <code>hello_macro_derive</code> в качестве зависимостей для ящика <code>pancakes</code> в файл <em>Cargo.toml</em>. Если вы размещаете свои исполнения <code>hello_macro</code> и <code>hello_macro_derive</code> на сайт <a href="https://crates.io/">crates.io</a>, они будут обычными зависимостями; если нет, вы можете указать их как <code>path</code> зависимости следующим образом:</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Поместите код в приложении 19-30 в <em>src/main.rs</em> и выполните <code>cargo run</code>: он должен вывести <code>Hello, Macro! My name is Pancakes!</code>. Выполнение особенности <code>HelloMacro</code> из процедурного макроса была включена без необходимости его выполнения ящиком <code>pancakes</code>; <code>#[derive(HelloMacro)]</code> добавил выполнение особенности.</p>
<p>Далее давайте рассмотрим, как другие виды процедурных макросов отличаются от пользовательских выводимых макросов.</p>
<h3 id="Макросы-похожие-на-свойство"><a class="header" href="#Макросы-похожие-на-свойство">Макросы, похожие на свойство</a></h3>
<p>Подобные свойствам макросы похожи на пользовательские выводимые макросы, но вместо создания кода для <code>derive</code> свойства, они позволяют создавать новые свойства. Они являются также более гибкими: <code>derive</code> работает только для устройств и перечислений; свойство-подобные могут применяться и к другим элементам, таким как функции. Вот пример использования  имеющего свойство макроса: допустим, у вас есть свойство именованный <code>route</code> который определяет функции при использовании фреймворка для веб-приложений:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>Данный свойство <code>#[route]</code> будет определён платспособом как процедурный макрос. Ярлык функции определения макроса будет выглядеть так:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Здесь есть два свойства вида <code>TokenStream</code>. Первый для содержимого свойства: часть <code>GET, "/"</code> . Второй это тело элемента, к которому прикреплён свойство: в данном случае <code>fn index() {}</code> и остальная часть тела функции.</p>
<p>Кроме того, имеющие свойства макросы работают так же как и пользовательские выводимые макросы: вы создаёте ящик с видом <code>proc-macro</code> и выполняете функцию, которая порождает код, который хотите!</p>
<h3 id="Макросы-похожие-на-функции"><a class="header" href="#Макросы-похожие-на-функции">Макросы, похожие на функции</a></h3>
<p>Макросы, похожие на функции, выглядят подобно вызову функций. Подобно макросам <code>macro_rules!</code> они являются более гибкими, чем функции; например, они могут принимать неизвестное количество переменных. Тем не менее, макросы <code>macro_rules!</code> можно объявлять только с использованием правил написания подобного сопоставлению, который мы обсуждали ранее в разделе <a data-md-type="raw_html" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">"Декларативные макросы <code>macro_rules!</code> для общего мета программирования"</a>. Макросы, похожие на функции, принимают свойство <code>TokenStream</code> и их определение управляет этим <code>TokenStream</code>, используя код Rust, как это делают два других вида процедурных макроса. Примером подобного возможностей макроса является макрос <code>sql!</code>, который можно вызвать так:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Этот макрос будет разбирать SQL указанию внутри него и проверять, что она синтаксически правильная, что является гораздо более сложной обработкой, чем то что может сделать макрос <code>macro_rules!</code>. Макрос <code>sql!</code> мог бы быть определён так:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Это определение похоже на ярлык пользовательского выводимого макроса: мы получаем токены, которые находятся внутри скобок и возвращаем код, который мы хотели создать.</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Фух! Теперь у вас в распоряжении есть некоторые возможности Rust, которые вы не будете часто использовать, но вы будете знать, что они доступны в особых обстоятельствах. Мы представили несколько сложных тем, чтобы при появлении сообщения с предложением исправить ошибку или в коде других людей, вы могли бы распознать эти подходы и правила написания. Используйте эту главу как справочник, который поможет вам найти решение.</p>
<p>Далее мы применим в действительностивсе, что обсуждали на протяжении всей книги, и выполним ещё один дело!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
