<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Язык программирования Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие подходы программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Примечания</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие устройства</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование устройств для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание образцов устройств</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей устройства</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> правила написания способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Устройство потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Краткий поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими делами с помощью дополнений, ящиков и звеньев</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Дополнения и ящики</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение звеньев для управления областью действия и тайностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве звеньев</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, особенности (свойства) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Особенности (свойства): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х проверок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать проверки</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением проверок</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Создание проверок</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Дело с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Переработка кода для обеспечения выделения на звенья и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка возможности библиотеки с помощью разработки через проверка</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Полезные  возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего дела с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Обнародование ящика на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью особенности Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью особенности Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный одновременность</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для одновременного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Одновременность с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый одновременность с помощью особенностей Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности предметно-направленного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Свойства предметно-направленных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование особенность-предметов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Выполнение образца предметно-направленного разработки</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Образцы и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться образцы</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли образец не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> правила написания образца</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые особенности</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Конечный дело: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые особенности</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Ржавчина и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Язык-программирования-rust"><a class="header" href="#Язык-программирования-rust">Язык программирования Rust</a></h1>
<p><em>От Стива Клабника и Кэрол Николс, при поддержке других участников сообщества Rust</em></p>
<p>В этой исполнения учебника предполагается, что вы используете Ржавчина 1.67.1 (выпущен 09.02.2023) или новее. См. <a href="ch01-01-installation.html">раздел «Установка» главы 1</a><!-- ignore --> для установки или обновления Rust.</p>
<p>HTML-исполнение книги доступна онлайн по адресам <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a><sub>(англ.)</sub> и <a href="https://doc.rust-lang.ru/book">https://doc.rust-lang.ru/book</a><sub>(рус.)</sub> и офлайн. При установке Ржавчина с помощью <code>rustup</code>: просто запустите <code>rustup docs --book</code>, чтобы её открыть.</p>
<p>Также доступны несколько <a href="appendix-06-translation.html">переводов</a> от сообщества.</p>
<p>Этот источник доступен в виде <a href="https://nostarch.com/rust-programming-language-2nd-edition">печатной книги в мягкой обложке и в виде электронной книги от No Starch Press</a> .</p>
<blockquote>
<p><strong>🚨 Предпочитаете более увлекательный этап обучения? Попробуйте другую исполнение Ржавчина Book, в которой есть: проверочные вопросы, цветовое выделение, наглядные визуализации и многое другое</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Предисловие"><a class="header" href="#Предисловие">Предисловие</a></h1>
<p>Не всегда было ясно, но язык программирования Ржавчина в основном посвящён <em>расширению возможностей</em>: независимо от того, какой код вы пишете сейчас, Ржавчина позволяет вам достичь большего, чтобы программировать уверенно в более широком ряде областей, чем вы делали раньше.</p>
<p>Возьмём, к примеру, работу «системного уровня», которая касается низкоуровневых подробностей управления памятью, представления данных и многопоточности. Привычно эта область программирования считается загадочной, доступной лишь немногим избранным, посвятившим долгие годы изучению всех её печально известных подводных камней. И даже те, кто опытют это, делают всё с осторожностью, чтобы их код не был уязвим для уязвимостей, сбоев или повреждений.</p>
<p>Rust разрушает эти преграды, устраняя старые подводные камни и предоставляя дружелюбный, отполированный набор средств, который поможет вам на этом пути. Программисты, которым необходимо «погрузиться» в низкоуровневое управление, могут сделать это с помощью Rust, не беря на себя привычный риск сбоев или дыр в безопасности и не изучая тонкости изменчивых наборов средств. Более того, язык предназначен для того, чтобы легко вести вас к надёжному коду, который эффективен с точки зрения скорости и использования памяти.</p>
<p>Программисты, которые уже работают с низкоуровневым кодом, могут использовать Ржавчина для повышения своих чувства собственной значимости. Например, внедрение одновременности в Ржавчина является действием с относительно низким риском: сборщик поймает для вас привычные ошибки. И вы можете заняться более враждебной переработкой в своём коде с уверенностью, что не будете случайно добавлять в код сбои или уязвимости.</p>
<p>Но Ржавчина не ограничивается низкоуровневым системным программированием. Он достаточно выразителен и удобен, чтобы приложения CLI (Command Line Interface – окно выводаные программы), веб-серверы и многие другие виды кода были довольно приятными для написания — позже вы найдёте простые примеры того и другого в книге. Работа с Ржавчина позволяет вырабатывать навыки, которые переносятся из одной предметной области в другую; вы можете изучить Rust, написав веб-приложение, а затем применить те же навыки для Raspberry Pi.</p>
<p>Эта книга полностью раскрывает возможности Ржавчина для расширения возможностей его пользователей. Это дружелюбный и доступный источник, призванный помочь вам повысить уровень не только ваших знаний о Rust, но и ваших возможностей и уверенности как программиста в целом. Так что погружайтесь, готовьтесь учиться и добро пожаловать в сообщество Rust!</p>
<p>— Nicholas Matsakis и Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<blockquote>
<p>Примечание. Это издание книги такое же, как и <a href="https://nostarch.com/rust-programming-language-2nd-edition">Язык программирования Rust</a>, доступное в печатном и электронном виде от <a href="https://nostarch.com/">No Starch Press</a>.</p>
</blockquote>
<p>Добро пожаловать в <em>The Ржавчина Programming Language</em>, вводную книгу о Rust. Язык программирования Ржавчина помогает создавать быстрые, более надёжные приложения. Хорошая удобство и низкоуровневый управление часто являются противоречивыми требованиями для внешнего видаязыков программирования; Ржавчина бросает вызов этому вражде. Благодаря уравновешенности мощных технических возможностей c большим удобством разработки, Ржавчина предоставляет возможности управления низкоуровневыми элементами (например, использование памяти) без трудностей, привычно связанных с таким управлением.</p>
<h2 id="Кому-подходит-rust"><a class="header" href="#Кому-подходит-rust">Кому подходит Rust</a></h2>
<p>Rust наилучше подходит для многих людей по целому ряду причин. Давайте рассмотрим несколько наиболее важных объединений.</p>
<h3 id="Объединения-разработчиков"><a class="header" href="#Объединения-разработчиков">Объединения разработчиков</a></h3>
<p>Rust  показал себя как производительный средство для совместной работы больших приказов разработчиков с разным уровнем знаний в области системного программирования. Низкоуровневый код подвержен различным трудноуловимым ошибкам, которые в большинстве других языков могут быть обнаружены только с помощью тщательного проверки и проверки кода опытными разработчиками. В Ржавчина сборщик играет значение привратника, отказываясь собирать код с этими неуловимыми ошибками, включая ошибки одновременности. Работая вместе с сборщиком, приказ может сосредоточиться на работе над логикой программы, а не над поиском ошибок.</p>
<p>Rust также привносит современные средства разработчика в мир системного программирования:</p>
<ul>
<li>Cargo, входящий в состав управленец зависимостей и средство сборки, делает добавление, сборку и управление зависимостями безболезненным и согласованным в рамках всей внутреннего устройства Rust.</li>
<li>Средство изменения Rustfmt обеспечивает единый исполнение кодирования для всех разработчиков.</li>
<li>Ржавчина Language Server обеспечивает встраивание с встроенной средой разработки (IDE) для автодополнения кода и встроенных сообщений об ошибках.</li>
</ul>
<p>Благодаря применению этих и других средств в внутреннем устройстве Ржавчина разработчики способны производительно работать при написании кода системного уровня.</p>
<h3 id="Студенты"><a class="header" href="#Студенты">Студенты</a></h3>
<p>Rust полезен для студентов и тех, кто увлечен в изучении  системных подходов. Используя Rust, многие люди узнали о таких темах, как разработка операционных систем. Сообщество радушно и с удовольствием ответит на вопросы начинающих. Благодаря усилиям — таким, как эта книга — приказы Ржавчина хотят сделать подходы систем более доступными для большего числа людей, особенно для новичков в программировании.</p>
<h3 id="Предприятия"><a class="header" href="#Предприятия">Предприятия</a></h3>
<p>Сотни больших и малых предприятий используют Ржавчина в промышленных условиях для решения различных задач, включая средства приказной строки, веб-сервисы, средства DevOps, встраиваемые устройства, анализ и транскодирование аудио и видео, криптовалюты, биоинформатику, поисковые системы, приложения Интернета вещей, машинное обучение и даже основные части веб-браузера Firefox.</p>
<h3 id="Разработчики-open-source"><a class="header" href="#Разработчики-open-source">Разработчики Open Source</a></h3>
<p>Rust предназначен для людей, которые хотят развивать язык программирования Rust, сообщество, средства для разработчиков и библиотеки. Мы будем рады, если вы внесёте свой вклад в развитие языка Rust.</p>
<h3 id="Люди-ценящие-скорость-и-безотказность"><a class="header" href="#Люди-ценящие-скорость-и-безотказность">Люди, ценящие скорость и безотказность</a></h3>
<p>Rust предназначен для любителей скорости и безотказности в языке. Под скоростью мы подразумеваем как быстродействие программы на Rust, так и быстроту, с которой Ржавчина позволяет писать программы. Проверки сборщика Ржавчина обеспечивают безотказность за счёт полезных дополнений и переработки кода. Это выгодно отличается от хрупкого унаследованного кода в языках без таких проверок, который разработчики часто боятся изменять. Благодаря обеспечению абстракций с нулевой стоимостью, высокоуровневых возможностей, собираемых в низкоуровневый код такой же быстрый, как и написанный вручную, Ржавчина стремится сделать безопасный код ещё и быстрым.</p>
<p>Язык Ржавчина надеется поддержать и многих других пользователей; перечисленные здесь - лишь самые значимые увлеченные лица. В целом, главная цель Ржавчина - избавиться от соглашений, на которые программисты шли десятилетиями, обеспечив безопасность <em>и</em> производительность, скорость <em>и</em> удобство. Попробуйте Ржавчина и убедитесь, подойдут ли вам его решения.</p>
<h2 id="Для-кого-эта-книга"><a class="header" href="#Для-кого-эта-книга">Для кого эта книга</a></h2>
<p>В этой книге предполагается, что вы писали код на другом языке программирования, но не оговаривается, на каком именно. Мы постарались сделать источник доступным для широкого круга людей с разным уровнем подготовки в области программирования. Мы не будем тратить время на обсуждение <em>сути понятия</em> программирования или как его понимать. Если вы совсем новичок в программировании, советуем прочитать книгу, посвящённую введению в программирование.</p>
<h2 id="Как-использовать-эту-книгу"><a class="header" href="#Как-использовать-эту-книгу">Как использовать эту книгу</a></h2>
<p>В целом, книга предполагает, что вы будете читать последовательно от начала до конца. Более поздние главы опираются на подходы, изложенные в предыдущих главах, а предыдущие главы могут не углубляться в подробности именно темы, так как в последующих главах они будут рассматриваться более подробно.</p>
<p>В этой книге вы найдёте два вида глав: главы о подходах и главы с делом. В главах о подходах вы узнаете о каком-либо особенности Rust. В главах дела мы будем вместе создавать небольшие программы, применяя то, что вы уже узнали. Главы 2, 12 и 20 - это главы дела; остальные - главы о подходах.</p>
<p>Глава 1 объясняет, как установить Rust, как написать программу "Hello, world!" и как использовать Cargo, управленец дополнений и средство сборки Rust. Глава 2 - это опытное введение в написание программы на Rust, в которой вам предлагается создать игру для угадывания чисел. Здесь мы рассмотрим подходы на высоком уровне, а в последующих главах будет предоставлена дополнительная сведения. Если вы хотите сразу же приступить к работе, глава 2 - самое подходящее место для этого. В главе 3 рассматриваются возможности Rust, схожие с возможностями других языков программирования, а в главе 4 вы узнаете о системе владения Rust. Если вы особенно дотошный ученик и предпочитаете изучить каждую подробность, прежде чем переходить к следующей, возможно, вы захотите пропустить главу 2 и сразу перейти к главе 3, вернувшись к главе 2, когда захотите поработать над делом, применяя изученные подробности.</p>
<p>Глава 5 описывает устройства и способы, а глава 6 охватывает перечисления, выражения <code>match</code> и устройства управления потоком <code>if let</code>. Вы будете использовать устройства и перечисления для создания пользовательских видов в Rust.</p>
<p>В главе 7 вы узнаете о системе звеньев Rust, о правилах согласования закрытости вашего кода и его открытом внешней оболочке прикладного программирования (API). В главе 8 обсуждаются некоторые распространённые устройства данных - собрания, которые предоставляет обычная библиотека, такие как векторы, строки и HashMaps. В главе 9 рассматриваются философия и способы обработки ошибок в Rust.</p>
<p>В главе 10 рассматриваются образцовые виды данных, особенности и времена жизни, позволяющие написать код, который может использоваться разными видами. Глава 11 посвящена проверке, которое даже с заверениями безопасности в Ржавчина необходимо для обеспечения правильной логики вашей программы. В главе 12 мы создадим собственную выполнение подмножества возможности средства приказной строки <code>grep</code>, предназначенного для поиска текста в файлах. Для этого мы будем использовать многие подходы, которые обсуждались в предыдущих главах.</p>
<p>В главе 13 рассматриваются замыкания и повторители: особенности Rust, пришедшие из полезных языков программирования. В главе 14 мы более подробно рассмотрим Cargo и поговорим о лучших способах распространения ваших библиотек среди других разработчиков. В главе 15 обсуждаются умные указатели, которые предоставляет обычная библиотека, и особенности, обеспечивающие их возможность.</p>
<p>В главе 16 мы рассмотрим различные подходы одновременного программирования и поговорим о возможности Ржавчина для безбоязненного многопоточно программирования. В главе 17 рассматривается сравнение идиом Ржавчина с принципами предметно-направленного программирования, которые наверняка вам знакомы.</p>
<p>Глава 18 - это справочник по образцам и сопоставлению с образцами, которые являются мощными способами выражения мыслей в программах на Rust. Глава 19 содержит множество важных дополнительных тем, включая небезопасный Rust, макросы и многое другое о времени жизни, особенностях, видах, функциях и замыканиях.</p>
<p>В главе 20 мы завершим дело, в котором выполняем низкоуровневый многопоточный веб-сервер!</p>
<p>Наконец, некоторые приложения содержат полезную сведения о языке в более справочном виде. В приложении A рассматриваются ключевые слова Rust, в приложении B — операторы и символы Rust, в приложении C — производные особенности, предоставляемые встроенной библиотекой, в приложении D — некоторые полезные средства разработки, а в приложении E — издания Rust. В приложении F вы найдёте переводы книги, а в приложении G мы расскажем о том, как создаётся Ржавчина и что такое nightly Rust.</p>
<p>Нет неправильного способа читать эту книгу: если вы хотите пропустить главу - сделайте это! Возможно, вам придётся вернуться к предыдущим главам, если возникнет недопонимание. Делайте все, как вам удобно.</p>
<p><span id="ferris"></span></p>
<p>Важной частью этапа обучения Ржавчина является изучение того, как читать сообщения об ошибках, которые отображает сборщик: они приведут вас к работающему коду. Мы изучим много примеров, которые не собираются и отображают ошибки в сообщениях сборщика в разных случаейх. Знайте, что если вы введёте и запустите случайный пример, он может не собраться! Убедитесь, что вы прочитали окружающий текст, чтобы понять, не предназначен ли пример, который вы пытаетесь запустить, для отображения ошибки. Ferris также поможет вам различить код, который не предназначен для работы:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Пояснения</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"></td><td>Этот код не собирается!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Феррис вскидывает руки"></td><td>Этот код вызывает панику!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Феррис с одним когтем вверх, пожимая плечами"></td><td>Этот код не приводит к желаемому поведению.</td></tr>
</tbody></table>
</div>
<p>В большинстве случаев мы приведём вас к правильной исполнения любого кода, который не собирается.</p>
<h2 id="Исходные-коды"><a class="header" href="#Исходные-коды">Исходные коды</a></h2>
<p>Файлы с исходным кодом, используемым в этой книге, можно найти на <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Начало-работы"><a class="header" href="#Начало-работы">Начало работы</a></h1>
<p>Начнём наше путешествие в Rust! Нужно много всего изучить, но каждое путешествие с чего-то начинается. В этой главе мы обсудим:</p>
<ul>
<li>установку Ржавчина на Linux, macOS и Windows,</li>
<li>написание программы, печатающей <code>Hello, world!</code>,</li>
<li>использование <code>cargo</code>, управленца дополнений и системы сборки в одном лице для Rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Установка"><a class="header" href="#Установка">Установка</a></h2>
<p>Первым шагом является установка Rust. Мы загрузим Rust, используя средство приказной строки <code>rustup</code>, предназначенный для управлениями исполнениями Ржавчина и другими связанными с ним средствами. Вам понадобится интернет-соединение для его загрузки.</p>
<blockquote>
<p>Примечание: если вы по каким-то причинам предпочитаете не использовать rustup, пожалуйста, посетите <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">страницу «Другие способы установки Rust»</a> для получения дополнительных возможностей.</p>
</blockquote>
<p>Следующие шаги устанавливают последнюю безотказную исполнение сборщика Rust. Благодаря заверениям безотказности Ржавчина все примеры в книге, которые собираются, будут собираться и в новых исполнениях Rust. Вывод может немного отличаться в разных исполнениях, поскольку Ржавчина часто улучшает сообщения об ошибках и предупреждения. Другими словами, любая новая, безотказная исполнение Rust, которую вы установите с помощью этих шагов, должна работать с содержимым этой книги так, как ожидается.</p>
<blockquote>
<h3 id="Условные-обозначения-приказной-строки"><a class="header" href="#Условные-обозначения-приказной-строки">Условные обозначения приказной строки</a></h3>
<p>В этой главе и во всей книге мы будем выполнять некоторые приказы, используемые в окне вызова. Строки, которые вы должны вводить в окне вызова, начинаются с <code>$</code>. Вам не нужно вводить символ <code>$</code>; это подсказка приказной строки, отображаемая для обозначения начала каждой приказы. Строки, которые не начинаются с <code>$</code>, обычно показывают вывод предыдущей приказы. Кроме того, в примерах, своеобразных для PowerShell, будет использоваться <code>&gt;</code>, а не <code>$</code>.</p>
</blockquote>
<h3 id="Установка-rustup-на-linux-или-macos"><a class="header" href="#Установка-rustup-на-linux-или-macos">Установка <code>rustup</code> на Linux или macOS</a></h3>
<p>Если вы используете Linux или macOS, пожалуйста, выполните следующую приказ:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Приказ загружает сценарий и запускает установку средства <code>rustup</code>, который устанавливает последнюю безотказную исполнение Rust. Вам может быть предложено ввести пазначение. Если установка прошла успешно, появится следующая строка:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Вам также понадобится <em>составитель (linker)</em> — программа, которую Ржавчина использует для объединения своих собранных выходных данных в один файл. Скорее всего, он у вас уже есть. При возникновении ошибок объединения, вам следует установить сборщик C, который обычно будет включать в себя и составитель. Сборщик C также полезен, потому что некоторые распространённые дополнения Ржавчина зависят от кода C и нуждаются в сборщике C.</p>
<p>На macOS вы можете получить сборщик C, выполнив приказ:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Пользователи Linux, как правило, должны устанавливать GCC или Clang в соответствии с документацией их установочного набора. Например, при использовании Ubuntu можно установить дополнение <code>build-essential</code>.</p>
<h3 id="Установка-rustup-на-windows"><a class="header" href="#Установка-rustup-на-windows">Установка <code>rustup</code> на Windows</a></h3>
<p>На Windows перейдите по адресу <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> и следуйте указаниям по установке Rust. На определённом этапе установки вы получите сообщение, предупреждающее, что вам также понадобятся средства сборки MSVC для Visual Studio 2013 или более поздней исполнения.</p>
<p>Чтобы получить средства сборки, вам потребуется установить <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a>. На вопрос о том, какие составляющие необходимо установить, выберите:</p>
<ul>
<li>“Desktop Development with C++”</li>
<li>The Windows 10 or 11 SDK</li>
<li>Английский языковой дополнение вместе с любым другим языковым дополнением по вашему выбору.</li>
</ul>
<p>В остальной части этой книги используются приказы, которые работают как в <em>cmd.exe</em>, так и в PowerShell. При наличии отличительных различий мы объясним, что необходимо сделать в таких случаях.</p>
<h3 id="Устранение-возможных-ошибок"><a class="header" href="#Устранение-возможных-ошибок">Устранение возможных ошибок</a></h3>
<p>Чтобы проверить, правильно ли у вас установлен Rust, откройте оболочку и введите эту строку:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Вы должны увидеть номер исполнения, хэш определения и дату определения для последней безотказной исполнения, которая была выпущена, в следующем виде:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Если вы видите эту сведения, вы успешно установили Rust! Если вы не видите эту сведения, убедитесь, что Ржавчина находится в вашей системной переменной <code>%PATH%</code> следующим образом:</p>
<p>В Windows CMD:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>В PowerShell:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>В Linux и macOS:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Если все было сделано правильно, но Ржавчина все ещё не работает, есть несколько мест, где вам могут помочь. Узнайте, как связаться с другими Rustaceans (так мы себя называем) на <a href="https://www.rust-lang.org/community">странице сообщества</a>.</p>
<h3 id="Обновление-и-удаление"><a class="header" href="#Обновление-и-удаление">Обновление и удаление</a></h3>
<p>После установки Ржавчина с помощью <code>rustup</code> обновление до новой исполнения не составит труда. В приказной оболочке запустите следующий скрипт обновления:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Чтобы удалить Ржавчина и <code>rustup</code>, выполните следующую приказ:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="Местная-документация"><a class="header" href="#Местная-документация">Местная документация</a></h3>
<p>Установка Ржавчина также включает местную повтор документации, чтобы вы могли читать её в без доступа к мировой сети режиме. Выполните <code>rustup doc</code>, чтобы открыть местную документацию в браузере.</p>
<p>Если обычная библиотека предоставляет вид или функцию, а вы не знаете, что она делает или как её использовать, воспользуйтесь документацией внешней оболочки прикладного программирования (API), чтобы это узнать!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Привет-мир"><a class="header" href="#Привет-мир">Привет, мир!</a></h2>
<p>Теперь, когда вы установили Rust, пришло время написать свою первую программу на Rust. Привычно при изучении нового языка принято писать небольшую программу, которая печатает на экране текст <code>Привет, мир!</code>, поэтому мы сделаем то же самое!</p>
<blockquote>
<p>Примечание: Эта книга предполагает наличие достаточного навыка работы с приказной строкой. Ржавчина не предъявляет особых требований к тому, каким набором средств вы пользуетесь для изменения или хранения вашего кода, поэтому если вы предпочитаете использовать встроенную среду разработки (IDE) вместо приказной строки, смело используйте вашу любимую IDE. Многие IDE сейчас в той или иной степени поддерживают Rust; подробности можно узнать из документации к IDE. Объединение Ржавчина сосредоточилась на обеспечении отличной поддержки IDE с помощью <code>rust-analyzer</code>. Более подробную сведения смотрите в <a href="appendix-04-useful-development-tools.html">Приложении D</a><!-- ignore -->.</p>
</blockquote>
<h3 id="Создание-папки-дела"><a class="header" href="#Создание-папки-дела">Создание папки дела</a></h3>
<p>Прежде всего начнём с создания папки, в которой будем сохранять наш код на языке Rust. На самом деле не важно, где сохранять наш код. Однако, для упражнений и дел, обсуждаемых в данной книге, мы советуем создать папку <em>projects</em> в вашем домашнем папке, там же и хранить в будущем код программ из книги.</p>
<p>Откройте окно вызова и введите следующие приказы для того, чтобы создать папку <em>projects</em> для хранения кода разных дел, и, внутри неё, папку <em>hello_world</em> для дела “Привет, мир!”.</p>
<p>Для Linux, macOS и PowerShell на Windows, введите:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Для Windows в CMD, введите:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="Написание-и-запуск-первой-Ржавчина-программы"><a class="header" href="#Написание-и-запуск-первой-Ржавчина-программы">Написание и запуск первой Ржавчина программы</a></h3>
<p>Затем создайте новый исходный файл и назовите его <em>main.rs</em>. Файлы Ржавчина всегда заканчиваются расширением <em>.rs</em>. Если вы используете более одного слова в имени файла, принято разделять их символом подчёркивания. Например, используйте <em>hello_world.rs</em> вместо <em>helloworld.rs</em>.</p>
<p>Теперь откроем файл <em>main.rs</em> для изменения и введём следующие строки кода:</p>
<p><span class="filename">Название файла: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Привет, мир!");
}</code></pre></pre>
<p><span class="caption">Приложение 1-1: Программа, которая печатает <code>Привет, мир!</code></span></p>
<p>Сохраните файл и вернитесь в окно окна вызова в папка <em>~/projects/hello_world</em>. В Linux или macOS введите следующие приказы для сборки и запуска файла:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Привет, мир!
</code></pre>
<p>В Windows, введите приказ <code>.\main.exe</code> вместо <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Привет, мир!
</code></pre>
<p>Независимо от вашей операционной системы, строка <code>Привет, мир!</code> должна быть выведена на окно вызова. Если вы не видите такого вывода, обратитесь к разделу <a href="ch01-01-installation.html#troubleshooting">"Устранение неполадок "</a><!-- ignore -->, чтобы узнать, как получить помощь.</p>
<p>Если напечаталось <code>Привет, мир!</code>, то примите наши поздравления! Вы написали программу на Rust, что делает вас Ржавчина программистом — добро пожаловать!</p>
<h3 id="Анатомия-программы-на-rust"><a class="header" href="#Анатомия-программы-на-rust">Анатомия программы на Rust</a></h3>
<p>Давайте рассмотрим «Привет, мир!» программу в подробностях. Вот первая часть головоломки:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>Эти строки определяют функцию с именем <code>main</code>. Функция <code>main</code> особенная: это всегда первый код, который запускается в каждой исполняемой программе Rust. Первая строка объявляет функцию с именем <code>main</code>, которая не имеет свойств и ничего не возвращает. Если бы были свойства, они бы заключались в круглые скобки <code>()</code>.</p>
<p>Тело функции заключено в <code>{}</code>. Ржавчина требует фигурных скобок вокруг всех тел функций. Хороший исполнение — поместить открывающую фигурную скобку на ту же строку, что и объявление функции, добавив между ними один пробел.</p>
<blockquote>
<p>Примечание: Если хотите придерживаться принятого исполнения во всех делах Rust, вы можете использовать средство самостоятельного изменения под названием <code>rustfmt</code> для изменения кода в определённом исполнении (подробнее о <code>rustfmt</code> в <a href="appendix-04-useful-development-tools.html">Приложении D</a><!-- ignore -->. Объединение Ржавчина включила этот средство в обычный установочный набор Rust, как <code>rustc</code>, поэтому он уже должен быть установлен на вашем компьютере!</p>
</blockquote>
<p>Тело функции <code>main</code> содержит следующий код:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!("Привет, мир!");
<span class="boring">}</span></code></pre></pre>
<p>Эта строка делает всю работу в этой маленькой программе: печатает текст на экран. Можно заметить четыре важных подробности.</p>
<p>Во-первых, исполнение Ржавчина предполагает отступ в четыре пробела, а не табуляцию.</p>
<p>Во-вторых, <code>println!</code> вызывается макрос Rust. Если бы вместо него была вызвана функция, она была бы набрана как <code>println</code> (без <code>!</code>). Более подробно мы обсудим макросы Ржавчина в главе 19. Пока достаточно знать, что использование <code>!</code> подразумевает вызов макроса вместо обычной функции, и что макросы не всегда подчиняются тем же правилам как функции.</p>
<p>В-третьих, вы видите строку <code>"Привет, мир!"</code>. Мы передаём её в качестве переменной макросу <code>println!</code>, и она выводится на экран.</p>
<p>В-четвёртых, мы завершаем строку точкой с запятой (<code>;</code>), которая указывает на окончание этого выражения и возможность начала следующего. Большинство строк кода Ржавчина заканчиваются точкой с запятой.</p>
<h3 id="Сборка-и-запуск---это-отдельные-шаги"><a class="header" href="#Сборка-и-запуск---это-отдельные-шаги">Сборка и запуск - это отдельные шаги</a></h3>
<p>Вы только что запустили впервые созданную программу, поэтому давайте рассмотрим каждый шаг этого этапа.</p>
<p>Перед запуском программы на Ржавчина вы должны собрать её с помощью сборщика Rust, введя приказ <code>rustc</code> и передав ей имя вашего исходного файла, например:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Если у вас есть опыт работы с C или C++, вы заметите, что это похоже на <code>gcc</code> или <code>clang</code>. После успешной сборки Ржавчина выводит двоичный исполняемый файл.</p>
<p>В Linux, macOS и PowerShell в Windows вы можете увидеть исполняемый файл, введя приказ <code>ls</code> в оболочке:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>В Linux и macOS вы увидите два файла. При использовании PowerShell в Windows вы увидите такие же три файла, как и при использовании CMD. Используя CMD в Windows, введите следующее:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Это показывает исходный код файла с расширением <em>.rs</em>, исполняемый файл (<em>main.exe</em> на Windows, но <em>main</em> на всех других площадках) и, при использовании Windows, файл, содержащий отладочную сведения с расширением <em>.pdb</em>. Отсюда вы запускаете файлы <em>main</em> или <em>main.exe</em>, например:</p>
<pre><code class="language-console">$ ./main # для Linux
&gt; .\main.exe # для Windows
</code></pre>
<p>Если ваш <em>main.rs</em> — это ваша программа «Привет, мир!», эта строка выведет в окно вызова <code>Привет, мир!</code>.</p>
<p>Если вы лучше знакомы с изменяемыми языками, такими как Ruby, Python или JavaScript, возможно, вы не привыкли собирать и запускать программу как отдельные шаги. Ржавчина — это предварительно <em>собранный</em> язык, то есть вы можете собрать программу и передать исполняемый файл кому-то другому, и он сможет запустить его даже без установленного Rust. Если вы даёте кому-то файл <em>.rb</em> , <em>.py</em> или <em>.js</em>, у него должна быть установлена выполнение Ruby, Python или JavaScript (соответственно). Но в этих языках вам нужна только одна приказ для сборки и запуска вашей программы. В внешнем виде языков программирования всё — соглашение.</p>
<p>Сборка с помощью <code>rustc</code> подходит для простых программ, но по мере роста вашего дела вы захотите управлять всеми свойствами и упростить передачу кода. Далее мы познакомим вас с средством Cargo, который поможет вам писать программы из существующего мира на Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Привет-cargo"><a class="header" href="#Привет-cargo">Привет, Cargo!</a></h2>
<p>Cargo - это система сборки и управленец дополнений Rust. Большая часть разработчиков используют данный средство для управления делами, потому что Cargo выполняет за вас множество задач, таких как сборка кода, загрузка библиотек, от которых зависит ваш код, и создание этих библиотек. (Мы называем библиотеки, которые нужны вашему коду, <em>зависимостями</em>.)</p>
<p>Самые простые программы на Rust, подобные той, которую мы написали, не имеют никаких зависимостей. Если бы мы сделали дело «Hello, world!» с Cargo, он бы использовал только ту часть Cargo, которая отвечает за сборку вашего кода. По мере написания более сложных программ на Ржавчина вы будете добавлять зависимости, а если вы начнёте дело с использованием Cargo, добавлять зависимости станет намного проще.</p>
<p>Поскольку значительное число дел Ржавчина используют Cargo, оставшаяся часть книги подразумевает, что вы тоже используете Cargo. Cargo входит в состав поставки Rust, если вы использовали напрямую от разрабочиков программы установки, рассмотренные в разделе <a href="ch01-01-installation.html#installation">"Установка"</a><!-- ignore -->. Если вы установили Ржавчина другим способом, проверьте, установлен ли Cargo, введя в окне вызова следующее:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Если приказ выдал номер исполнения, то значит Cargo установлен. Если вы видите ошибку, вроде <code>command not found</code> ("приказ не найдена"), загляните в документацию для использованного вами способа установки, чтобы выполнить установку Cargo отдельно.</p>
<h3 id="Создание-дела-с-помощью-cargo"><a class="header" href="#Создание-дела-с-помощью-cargo">Создание дела с помощью Cargo</a></h3>
<p>Давайте создадим новый дело с помощью Cargo и посмотрим, как он отличается от нашего начального дела "Hello, world!". Перейдите обратно в папку <em>projects</em> (или любую другую, где вы решили сохранять код). Затем, в любой операционной системе, запустите приказ:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Первая приказ создаёт новый папка и дело с именем <em>hello_cargo</em>. Мы назвали наш дело <em>hello_cargo</em>, и Cargo создаёт свои файлы в папке с тем же именем.</p>
<p>Перейдём в папка <em>hello_cargo</em> и посмотрим файлы. Увидим, что Cargo создал два файла и одну папку: файл  <em>Cargo.toml</em> и папка <em>src</em> с файлом <em>main.rs</em> внутри.</p>
<p>Кроме того, cargo объявлял новый хранилище Git вместе с файлом <em>.gitignore</em>. Файлы Git не будут созданы, если вы запустите <code>cargo new</code> в существующем хранилища Git; вы можете изменить это поведение, используя <code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Примечание. Git — это распространённая система управления исполнений. Вы можете изменить <code>cargo new</code>, чтобы использовать другую систему управления исполнений или не использовать систему управления исполнений, используя флаг <code>--vcs</code>. Запустите <code>cargo new --help</code>, чтобы увидеть доступные свойства.</p>
</blockquote>
<p>Откройте файл <em>Cargo.toml</em> в любом текстовом редакторе. Он должен выглядеть как код в приложении 1-2.</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Приложение 1-2: Содержимое файла <em>Cargo.toml</em>, созданное приказом <code>cargo new</code></span></p>
<p>Это файл в виде<a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!--  --> (<em>Tom’s Obvious, Minimal Language</em>), который является видом настроек Cargo.</p>
<p>Первая строка, <code>[package]</code>, является заголовочной разделом, которая указывает что следующие указания настраивают дополнение. По мере добавления больше сведений в данный файл, будет добавляться больше разделов и указаний (строк).</p>
<p>Следующие три строки задают сведения о настройке, необходимую Cargo для сборки вашей программы: имя, исполнение и издание Rust, который будет использоваться. Мы поговорим о ключе <code>edition</code> в <a href="appendix-05-editions.html">Приложении E</a><!-- ignore -->.</p>
<p>Последняя строка, <code>[dependencies]</code> является началом разделы для списка любых зависимостей вашего дела. В Rust, это внешние дополнения кода, на которые ссылаются ключевым словом <em>crate</em>. Нам не нужны никакие зависимости в данном деле, но мы будем использовать их в первом деле главы 2, так что нам пригодится данная раздел зависимостей потом.</p>
<p>Откройте файл <em>src/main.rs</em> и загляните в него:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo создал для вас программу "Hello, world!", подобную той, которую мы написали в Приложении 1-1! Пока что различия между нашим предыдущим делом и делом, созданным при помощи Cargo, заключаются в том, что Cargo поместил исходный код в папка <em>src</em>, и у нас есть настроечный файл <em>Cargo.toml</em> в верхнем папке дела.</p>
<p>Cargo ожидает, что ваши исходные файлы находятся внутри папки <em>src</em>. Папка верхнего уровня дела предназначен только для файлов README, сведений о лицензии, файлы настройке и чего то ещё не относящего к вашему коду. Использование Cargo помогает создавать дело. Есть место для всего и все находится на своём месте.</p>
<p>Если вы начали дело без использования Cargo, как мы делали для "Hello, world!" дела, то можно преобразовывать его в дело с использованием Cargo. Переместите код в подпапка <em>src</em> и создайте соответствующий файл <em>Cargo.toml</em> в папке.</p>
<h3 id="Сборка-и-запуск-cargo-дела"><a class="header" href="#Сборка-и-запуск-cargo-дела">Сборка и запуск Cargo дела</a></h3>
<p>Посмотрим, в чем разница при сборке и запуске программы "Hello, world!" с помощью Cargo. В папке <em>hello_cargo</em> соберите дело следующей приказом:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Этот приказ создаёт исполняемый файл в <em>target/debug/hello_cargo</em> (или <em>target\debug\hello_cargo.exe</em> в Windows), а не в вашем текущем папке. Поскольку обычная сборка является отладочной, Cargo помещает двоичный файл в папка с именем <em>debug</em>. Вы можете запустить исполняемый файл с помощью этой приказы:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>Если все хорошо, то <code>Hello, world!</code> печатается в окне вызова. Запуск приказы <code>cargo build</code> в первый раз также приводит к созданию нового файла <em>Cargo.lock</em> в папке верхнего уровня. Данный файл хранит точные исполнения зависимостей вашего дела. Так как у нас нет зависимостей, то файл пустой. Вы никогда не должны менять этот файл вручную: Cargo сам управляет его содержимым для вас.</p>
<p>Только что мы собрали дело приказом <code>cargo build</code> и запустили его из <code>./target/debug/hello_cargo</code>. Но мы также можем при помощи приказы <code>cargo run</code> сразу и собрать код, и затем запустить полученный исполняемый файл всего лишь одной приказом:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Использование <code>cargo run</code> более удобно, чем необходимость помнить и запускать <code>cargo build</code>, а затем использовать весь путь к двоичному файлу, поэтому большинство разработчиков используют <code>cargo run</code>.</p>
<p>Обратите внимание, что на этот раз мы не видели вывода, указывающего на то, что Cargo собирает <code>hello_cargo</code>. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать, а просто запустил двоичный файл. Если бы вы изменили свой исходный код, Cargo пересобрал бы дело перед его запуском, и вы бы увидели этот вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo также предоставляет приказ, называемую <code>cargo check</code>. Этот приказ быстро проверяет ваш код, чтобы убедиться, что он собирается, но не создаёт исполняемый файл:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Почему вам не нужен исполняемый файл? Часто <code>cargo check</code> выполняется намного быстрее, чем <code>cargo build</code>, поскольку пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу во время написания кода, использование <code>cargo check</code> ускорит этап уведомления вас о том, что ваш дело всё ещё собирается! Таким образом, многие Rustacean периодически запускают <code>cargo check</code>, когда пишут свои программы, чтобы убедиться, что она собирается. Затем они запускают <code>cargo build</code>, когда готовы использовать исполняемый файл.</p>
<p>Давайте подытожим, что мы уже узнали о Cargo:</p>
<ul>
<li>Мы можем создать дело с помощью <code>cargo new</code>.</li>
<li>можно собирать дело, используя приказ <code>cargo build</code>,</li>
<li>можно одновременно собирать и запускать дело одной приказом <code>cargo run</code>,</li>
<li>можно собрать дело для проверки ошибок с помощью <code>cargo check</code>, не тратя время на кодосоздание исполняемого файла,</li>
<li>cargo сохраняет итоги сборки не в папку с исходным кодом, а в отдельный папка <em>target/debug</em>.</li>
</ul>
<p>Дополнительным преимуществом использования Cargo является то, что его приказы одинаковы для разных операционных систем. С этой точки зрения, мы больше не будем предоставлять отдельные указания для Linux, macOS или Windows.</p>
<h3 id="Сборка-конечной-исполнения-release"><a class="header" href="#Сборка-конечной-исполнения-release">Сборка конечной исполнения (Release)</a></h3>
<p>Когда дело, наконец, готов к исполнению, можно использовать приказ <code>cargo build --release</code> для его сборки с переработкой. Данная приказ создаёт исполняемый файл в папке <em>target/release</em> в отличии от папки <em>target/debug</em>. Переработки делают так, что Ржавчина код работает быстрее, но их включение увеличивает время сборки. По этой причине есть два отдельных профиля: один для разработки, когда нужно осуществлять сборку быстро и часто, и другой, для сборки конечной программы, которую будете отдавать пользователям, которая готова к работе и будет выполняться сверх быстро. Если вы замеряете время выполнения вашего кода, убедитесь, что собрали дело с переработкой <code>cargo build --release</code> и проверяете исполняемый файл из папки <em>target/release</em>.</p>
<h3 id="cargo-как-Условие"><a class="header" href="#cargo-как-Условие">Cargo как Условие</a></h3>
<p>В простых делах Cargo не даёт больших преимуществ по сравнению с использованием <code>rustc</code>, но он проявит себя, когда ваши программы станут более сложными. Когда программы вырастают до нескольких файлов или нуждаются в зависимостях, гораздо проще позволить Cargo согласовывать сборку.</p>
<p>Не смотря на то, что дело <code>hello_cargo</code> простой, теперь он  использует большую часть существующего набора средств, который вы будете повседневно использовать в вашей развитии, связанной с Rust. Когда потребуется работать над делами размещёнными в сети, вы сможете просто использовать следующую последовательность приказов для получения кода с помощью Git, перехода в папка дела, сборку дела:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Для получения дополнительной сведений о Cargo ознакомьтесь с <a href="https://doc.rust-lang.org/cargo/">его документацией</a> .</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Теперь вы готовы начать своё Ржавчина путешествие! В данной главе вы изучили как:</p>
<ul>
<li>установить последнюю безотказную исполнение Rust, используя <code>rustup</code>,</li>
<li>обновить Ржавчина до последней исполнения,</li>
<li>открыть местно установленную документацию,</li>
<li>написать и запустить программу вида "Hello, world!", используя напрямую сборщик <code>rustc</code>,</li>
<li>создать и запустить новый дело, используя соглашения и приказы Cargo.</li>
</ul>
<p>Это отличное время для создания более существенной программы, чтобы привыкнуть читать и писать код на языке Rust. Итак, в главе 2 мы построим программу для игры в угадай число. Если вы предпочитаете начать с изучения того, как работают общие подходы программирования в Rust, обратитесь к главе 3, а затем вернитесь к главе 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Программируем-игру-в-загадки"><a class="header" href="#Программируем-игру-в-загадки">Программируем игру в загадки</a></h1>
<p>Давайте окунёмся в Rust, вместе поработав над опытным делом! В этой главе вы познакомитесь с несколькими общими подходами Rust, показав, как использовать их в существующей программе. Вы узнаете о <code>let</code> , <code>match</code>, способах, сопряженных функциях, внешних дополнениях и многом другом! В следующих главах мы рассмотрим эти мысли более подробно. В этой главе вы просто примените в основах.</p>
<p>Мы выполняем привычную для начинающих программистов задачу — игру в загадки. Вот как это работает: программа порождает случайное целое число в ряде от 1 до 100. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра напечатает поздравительное сообщение и завершится.</p>
<h2 id="Настройка-нового-дела"><a class="header" href="#Настройка-нового-дела">Настройка нового дела</a></h2>
<p>Для настройки нового дела перейдите в папка <em>projects</em>, который вы создали в главе 1, и создайте новый дело с использованием Cargo, как показано ниже:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Первая приказ, <code>cargo new</code>, принимает в качестве первого переменной имя дела (<code>guessing_game</code>). Вторая приказ изменяет папка на новый папка дела.</p>
<p>Загляните в созданный файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Как вы уже видели в главе 1, <code>cargo new</code> создаёт программу «Hello, world!». Посмотрите файл <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Теперь давайте соберем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью приказы <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Приказ <code>run</code> пригодится, когда необходимо ускоренно выполнить повторение дела. Именно так мы собираемся делать в этом деле, быстро проверяя каждую повторение, прежде чем перейти к следующей.</p>
<p>Снова откройте файл <em>src/main.rs</em>. Весь код вы будете писать в нем.</p>
<h2 id="Обработка-догадки"><a class="header" href="#Обработка-догадки">Обработка догадки</a></h2>
<p>Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой виде. Начнём с того, что позволим игроку ввести догадку. Вставьте код из приложения 2-1 в <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}</code></pre>
<p><span class="caption">Приложение 2-1: код, который получает догадку от пользователя и выводит её на экран</span></p>
<p>Этот код содержит много сведений, поэтому давайте рассмотрим его построчно. Чтобы получить пользовательский ввод и затем вывести итог, нам нужно включить в область видимости библиотеку ввода/вывода <code>io</code>. Библиотека <code>io</code> является частью встроенной библиотеки, известной как <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>По умолчанию в Ржавчина есть набор элементов, определённых в встроенной библиотеке, которые он добавляет в область видимости каждой программы. Этот набор называется <em>прелюдией</em>, и вы можете изучить его содержание <a href="../std/prelude/index.html">в документации встроенной библиотеки</a>.</p>
<p>Если вид, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора <code>use</code>. Использование библиотеки <code>std::io</code> предоставляет ряд полезных полезных возможностей, включая способность принимать пользовательский ввод.</p>
<p>Как уже отмечалось в главе 1, функция <code>main</code> является точкой входа в программу:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Ключевое слово <code>fn</code> объявляет новую функцию, круглые скобки <code>()</code> показывают, что у функции нет входных свойств, фигурная скобка <code>{</code> - обозначение начала тела функции.</p>
<p>Также в главе 1 упоминалось, что <code>println!</code> — это макрос, который выводит строку на экран:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Этот код показывает сведения о ходе игры и запрашивает пользовательский ввод.</p>
<h3 id="Хранение-значений-с-помощью-переменных"><a class="header" href="#Хранение-значений-с-помощью-переменных">Хранение значений с помощью переменных</a></h3>
<p>Далее мы создаём <em>переменную</em> для хранения пользовательского ввода, как показано ниже:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Вот теперь программа становится важнее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем оператор <code>let</code>. Вот ещё один пример:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Эта строка создаёт новую переменную с именем <code>apples</code> и привязывает её к значению 5. В Ржавчина переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту подход в разделе <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">"Переменные и изменчивость".</a><!-- ignore --> в главе 3. Чтобы сделать переменную изменяемой, мы добавляем <code>mut</code> перед её именем:</p>
<pre><code class="language-rust ignore">let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая</code></pre>
<blockquote>
<p>Примечание: сочетание знаков <code>//</code> начинает примечание, который продолжается до конца строки. Ржавчина пренебрегает всё, что находится в примечаниях. Мы обсудим примечания более подробно в <a href="ch03-04-comments.html">Главе 3</a><!-- ignore -->.</p>
</blockquote>
<p>Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что <code>let mut guess</code> предоставит изменяемую переменную с именем <code>guess</code>. Знак равенства (<code>=</code>) сообщает Rust, что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с <code>guess</code>, которое является итогом вызова функции <code>String::new</code>, возвращающей новый образец <code>String</code>. <a data-md-type="raw_html" href="../std/string/struct.String.html"><code>String</code></a> — это вид строки, предоставляемый встроенной библиотекой, который является расширяемым отрывком текста в кодировке UTF-8.</p>
<p>правила написания <code>::</code> в строке <code>::new</code> указывает, что <code>new</code> является сопряженной функцией вида <code>String</code>. <em>Сопряженная функция</em> — это функция, выполненная для вида, в данном случае <code>String</code>. Функция <code>new</code> создаёт новую пустую строку. Функцию <code>new</code> можно встретить во многих видах, это привычное название для функции, которая создаёт новое значение какого-либо вида.</p>
<p>В конечном итоге строка <code>let mut guess = String::new();</code> создала изменяемую переменную, которая связывается с новым пустым образцом <code>String</code>. Фух!</p>
<h3 id="Получение-пользовательского-ввода"><a class="header" href="#Получение-пользовательского-ввода">Получение пользовательского ввода</a></h3>
<p>Напомним: мы подключили возможность ввода/вывода из встроенной библиотеки с помощью <code>use std::io;</code> в первой строке программы. Теперь мы вызовем функцию <code>stdin</code> из звена <code>io</code>, которая позволит нам обрабатывать пользовательский ввод:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Если бы мы не подключили библиотеку <code>io</code> с помощью <code>use std::io</code> в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как <code>std::io::stdin</code>. Функция <code>stdin</code> возвращает образец <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>, который является видом, представляющим указатель принятого ввода для вашего окна вызова.</p>
<p>Далее строка <code>.read_line(&amp;mut guess)</code> вызывает способ <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> на указателе принятого ввода для получения ввода от пользователя. Мы также передаём <code>&amp;mut guess</code> в качестве переменной <code>read_line</code>, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача <code>read_line</code> — принять все, что пользователь вводит в обычный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве переменной. Строковый переменная должен быть изменяемым, чтобы способ мог изменить содержимое строки.</p>
<p>Символ <code>&amp;</code> указывает, что этот переменная является <em>ссылкой</em>, которая предоставляет возможность нескольким частям вашего кода получить доступ к одному отрывку данных без необходимости воспроизводить эти данные в память несколько раз. Ссылки — это сложная полезная возможность, а одним из главных преимуществ Ржавчина является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>. (В главе 4 ссылки будут описаны более подробно).</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Обработка-возможного-сбоя-с-помощью-вида-result"><a class="header" href="#Обработка-возможного-сбоя-с-помощью-вида-result">Обработка возможного сбоя с помощью вида <code>Result</code></a></h3>
<p>Мы всё ещё работаем над этой строкой кода. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной логической строки. Следующая часть — способ:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Мы могли бы написать этот код так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове способа с помощью правил написания <code>.method_name()</code> часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.</p>
<p>Как упоминалось ранее, <code>read_line</code> помещает всё, что вводит пользователь, в строку, которую мы ему передаём, но также возвращает значение <code>Result</code>. <a data-md-type="raw_html" href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> — это <a href="ch06-00-enums.html"><em>перечисление</em></a><!-- ignore -->, часто называемое <em>enum</em>, то есть вид, который может находиться в одном из нескольких возможных состояний. Мы называем каждое такое состояние <em>исходом</em>.</p>
<p>В <a href="ch06-00-enums.html">Главе 6</a> рассмотрим перечисления более подробно. Задачей видов <code>Result</code> является кодирование сведений для обработки ошибок.</p>
<p>Исходами <code>Result</code> являются <code>Ok</code> и <code>Err</code>. Исход <code>Ok</code> указывает, что действие завершилась успешно, а внутри <code>Ok</code> находится успешно созданное значение. Исход <code>Err</code> означает, что действие не удалась, а <code>Err</code> содержит сведения о причинах неудачи.</p>
<p>Значения вида <code>Result</code>, как и значения любого вида, имеют определённые для них способы. У образца <code>Result</code> есть <a href="../std/result/enum.Result.html#method.expect">способ <code>expect</code></a><!-- ignore -->, который можно вызвать. Если этот образец <code>Result</code> является значением <code>Err</code>, <code>expect</code> вызовет сбой программы и отобразит сообщение, которое вы передали в качестве переменной. Если способ <code>read_line</code> возвращает <code>Err</code>, то это, скорее всего, итог ошибки основной операционной системы. Если образец <code>Result</code> является значением <code>Ok</code>, <code>expect</code> возьмёт возвращаемое значение, которое удерживает <code>Ok</code>, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.</p>
<p>Если не вызвать <code>expect</code>, программа собирается, но будет получено предупреждение:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust предупреждает о неиспользованном значении <code>Result</code>, возвращаемого из <code>read_line</code>, показывая, что программа не учла возможность возникновения ошибки.</p>
<p>Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим со сбоем завершить программу при возникновении сбоев, поэтому используем <code>expect</code>. О способах восстановления после ошибок вы узнаете в <a href="ch09-02-recoverable-errors-with-result.html">главе 9</a>.</p>
<h3 id="Вывод-значений-с-помощью-заполнителей-println"><a class="header" href="#Вывод-значений-с-помощью-заполнителей-println">Вывод значений с помощью заполнителей <code>println!</code></a></h3>
<p>Кроме закрывающей фигурной скобки, в коде на данный мгновение есть ещё только одно место для обсуждения:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {}", guess);
<span class="boring">}</span></code></pre>
<p>Этот код выводит строку, которая теперь содержит ввод пользователя. Набор фигурных скобок <code>{}</code> является заполнителем: думайте о <code>{}</code> как о маленьких клешнях краба, которые удерживают значение на месте. При печати значения переменной имя переменной может заключаться в фигурные скобки. При печати итога вычисления выражения поместите пустые фигурные скобки в строку вида, затем после строки вида укажите список выражений, разделённых запятыми, которые будут напечатаны в каждом заполнителе пустой фигурной скобки в том же порядке. Печать переменной и итога выражения одним вызовом <code>println!</code> будет выглядеть так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Этот код выведет <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="Проверка-первой-части"><a class="header" href="#Проверка-первой-части">Проверка первой части</a></h3>
<p>Давайте проверим первую часть игры. Запустите её используя <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.</p>
<h2 id="Создание-тайного-числа"><a class="header" href="#Создание-тайного-числа">Создание тайного числа</a></h2>
<p>Далее нам нужно создать тайное число, которое пользователь попытается угадать. Тайное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в ряде от 1 до 100, чтобы игра не была слишком сложной. Ржавчина пока не включает возможность случайных чисел в свою обычную библиотеку. Однако приказ Ржавчина предоставляет [ящик <code>rand</code>] с подобной возможностью.</p>
<h3 id="Использование-ящика-для-получения-дополнительного-возможностей"><a class="header" href="#Использование-ящика-для-получения-дополнительного-возможностей">Использование ящика для получения дополнительного возможностей</a></h3>
<p>Помните, что дополнение (crate) - это собрание файлов исходного кода Rust. Дело, создаваемый нами, представляет собой <br> <em>двоичный дополнение (binary crate)</em>, который является исполняемым файлом. Дополнение <code>rand</code> - это <em>библиотечный дополнение (library crate)</em>, содержащий код, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.</p>
<p>Согласование работы внешних дополнений является тем местом, где Cargo на самом деле блистает. Чтобы начать писать код, использующий <code>rand</code>, необходимо изменить файл <em>Cargo.toml</em>, включив в него в качестве зависимости дополнение <code>rand</code>. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком разделы <code>[dependencies]</code>, созданным для вас Cargo. Обязательно укажите <code>rand</code> в точности так же, как здесь, с таким же номером исполнения, иначе примеры кода из этого урока могут не заработать.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Имя файла: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>В файле <em>Cargo.toml</em> всё, что следует за заголовком, является частью этой разделы, которая продолжается до тех пор, пока не начнётся следующая. В <code>[dependencies]</code> вы сообщаете Cargo, от каких внешних ящиков зависит ваш дело и какие исполнения этих ящиков вам нужны. В этом случае мы указываем ящик <code>rand</code> со определетелем смысловой исполнения <code>0.8.5</code>. Cargo понимает <a href="http://semver.org">смысловое управление исполнениями</a> (иногда называемое <em>SemVer</em>), которое является исполнением для описания исполнений. Число <code>0.8.5</code> на самом деле является сокращением от <code>^0.8.5</code>, что означает любую исполнение не ниже <code>0.8.5</code>, но ниже <code>0.9.0</code>.</p>
<p>Cargo рассчитывает, что эти исполнения имеют общедоступное API, совместимое с исполнением <code>0.8.5</code>, и вы получите последние исполнения исправлений, которые по-прежнему будут собираться с кодом из этой главы. Не обеспечивается, что исполнение <code>0.9.0</code> или выше будет иметь тот же API, что и в следующих примерах.</p>
<p>Теперь, не меняя ничего в коде, давайте соберём дело, как показано в приложении 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Приложение 2-2: итог выполнения <code>cargo build</code> после добавления ящика rand в качестве зависимости</span></p>
<p>Вы можете увидеть другие номера исполнений (но все они будут совместимы с кодом благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.</p>
<p>Когда мы включаем внешнюю зависимость, Cargo берет последние исполнения всего, что нужно этой зависимости, из <em>реестра (registry)</em>, который является повтором данных с <a href="https://crates.io/">Crates.io</a>. Crates.io — это место, где участники внутреннего устройства Ржавчина размещают свои дела с открытым исходным кодом для использования другими.</p>
<p>После обновления реестра Cargo проверяет раздел <code>[dependencies]</code> и загружает все указанные в списке дополнения, которые ещё не были загружены. В нашем случае, хотя мы указали только <code>rand</code> в качестве зависимости, Cargo также захватил другие дополнения, от которых зависит работа <code>rand</code>. После загрузки дополнений Ржавчина собирает их, а затем собирает дело с имеющимися зависимостями.</p>
<p>Если сразу же запустить <code>cargo build</code> снова, не внося никаких изменений, то кроме строки <code>Finished</code> вы не получите никакого вывода. Cargo знает, что он уже загрузил и собрал зависимости, и вы не вносили никаких изменений в файл <em>Cargo.toml</em>. Cargo также знает, что вы ничего не изменили в своём коде, поэтому он не пересоберет и его. Если делать нечего, он просто завершает работу.</p>
<p>Если вы откроете файл <em>src/main.rs</em>, внесёте обыкновенное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле <em>src/main.rs</em>. Ваши зависимости не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и собрано для них.</p>
<h4 id="Обеспечение-воспроизводимых-сборок-с-помощью-файла-cargolock"><a class="header" href="#Обеспечение-воспроизводимых-сборок-с-помощью-файла-cargolock">Обеспечение воспроизводимых сборок с помощью файла <em>Cargo.lock</em></a></h4>
<p>В Cargo есть рычаг, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает ваш код. Пока вы не укажете обратное, Cargo будет использовать только те исполнения зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит исполнение 0.8.6 дополнения <code>rand</code> , и она содержит важное исправление ошибки, но также отступление, которая может сломать ваш код. Чтобы справиться с этим, Ржавчина создаёт файл <em>Cargo.lock</em> при первом запуске <code>cargo build</code>, поэтому теперь он есть в папке <em>guessing_game</em>.</p>
<p>Когда вы создаёте дело в первый раз, Cargo определяет все исполнения зависимостей, которые соответствуют условиям, а затем записывает их в файл <em>Cargo.lock</em>. Когда вы будете собирать свой дело в будущем, Cargo увидит, что файл <em>Cargo.lock</em> существует, и будет использовать указанные там исполнения, а не выполнять всю работу по выяснению исполнений заново. Это позволяет самостоятельно создавать воспроизводимую сборку. Другими словами, ваш дело останется на <code>0.8.5</code> до тех пор, пока вы явно не обновите его благодаря файлу <em>Cargo.lock</em>. Поскольку файл <em>Cargo.lock</em> важен для воспроизводимых сборок, он часто хранится в системе управления исполнениями вместе с остальным кодом дела.</p>
<h4 id="Обновление-дополнения-для-получения-новой-исполнения"><a class="header" href="#Обновление-дополнения-для-получения-новой-исполнения">Обновление дополнения для получения новой исполнения</a></h4>
<p>Если вы <em>захотите</em> обновить дополнение, Cargo предоставляет приказ <code>update</code>, которая пренебрегает файл <em>Cargo.lock</em> и определяет последние исполнения, соответствующие вашим согласно принятых требованийм из файла <em>Cargo.toml</em>. После этого Cargo запишет эти исполнения в файл <em>Cargo.lock</em>. Иначе по умолчанию Cargo будет искать только исполнения больше 0.8.5, но при этом меньше 0.9.0. Если дополнение <code>rand</code> имеет две новые исполнения — 0.8.6 и 0.9.0 — то при запуске <code>cargo update</code> вы увидите следующее:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo пренебрегает исполнение 0.9.0. В этот мгновение также появится изменение в файле <em>Cargo.lock</em>, указывающее на то, что исполнение <code>rand</code>, которая теперь используется, равна 0.8.6. Чтобы использовать <code>rand</code> исполнения 0.9.0 или любой другой исполнения из серии 0.9.<em>x</em>, необходимо обновить файл <em>Cargo.toml</em> следующим образом:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>В следующий раз, при запуске <code>cargo build</code>, Cargo обновит реестр доступных дополнений и пересмотрит ваши требования к <code>rand</code> в соответствии с новой исполнением, которую вы указали.</p>
<p>Можно много рассказать про <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> и <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">его внутреннее устройство</a><!-- ignore --> которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Ржавчина разработчики имеют возможность писать меньшие дела, которые составлены из многих дополнений.</p>
<h3 id="Создание-случайного-числа"><a class="header" href="#Создание-случайного-числа">Создание случайного числа</a></h3>
<p>Давайте начнём использовать <code>rand</code>, чтобы создать число для угадывания. Следующим шагом будет обновление <em>src/main.rs</em>, как показано в приложении 2-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<p><span class="caption">Приложение 2-3: Добавление кода который порождает случайное число</span></p>
<p>Сначала мы добавляем строку <code>use rand::Rng</code>. Особенность <code>Rng</code> определяет способы, выполняющие породители случайных чисел, и этот особенность должен быть в области видимости, чтобы эти способы можно было использовать. В главе 10 мы рассмотрим особенности подробно.</p>
<p>Затем мы добавляем две строки посередине. В первой строке мы вызываем функцию <code>rand::thread_rng</code>, дающую нам породитель случайных чисел, который мы собираемся использовать: тот самый, который является местным для текущего потока выполнения и запускается операционной системой. Затем мы вызываем его способ <code>gen_range</code>. Этот способ определяется <code>Rng</code>, который мы включили в область видимости с помощью оператора <code>use rand::Rng</code>. Способ <code>gen_range</code> принимает в качестве переменной выражение ряда и порождает случайное число в этом ряде. Вид используемого выражения ряда принимает разновидность <code>start..=end</code> и включает нижнюю и верхнюю границы, поэтому, чтобы запросить число от 1 до 100, нам нужно указать <code>1..=100</code>.</p>
<blockquote>
<p>Примечание: непросто сразу разобраться, какие особенности использовать, какие способы и функции вызывать из дополнения, поэтому каждый дополнение имеет документацию с указаниями по его использованию. Ещё одной замечательной особенностью Cargo является выполнение приказы <code>cargo doc --open</code>, которая местно собирает документацию, предоставляемую всеми вашими зависимостями, и открывает её в браузере. К примеру, если важна другая возможность из дополнения <code>rand</code>, запустите <code>cargo doc --open</code> и нажмите <code>rand</code> в боковой панели слева.</p>
</blockquote>
<p>Во второй новой строке мы увидим загаданное число. Во время разработки программы полезно иметь возможность её проверять, но в конечной исполнения мы это удалим. Конечно, ведь это совсем не похоже на игру, если программа печатает ответ сразу после запуска!</p>
<p>Попробуйте запустить программу несколько раз:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Вы должны получить разные случайные числа, и все они должны быть числами в ряде от 1 до 100. Отличная работа!</p>
<h2 id="Сравнение-догадки-с-тайным-числом"><a class="header" href="#Сравнение-догадки-с-тайным-числом">Сравнение догадки с тайным числом</a></h2>
<p>Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем сравнить их. Этот шаг показан в приложении 2-4. Учтите, что этот код ещё не собирается, подробнее мы объясним дальше.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<p><span class="caption">Приложение 2-4: Обработка возможных возвращаемых значений при сравнении двух чисел</span></p>
<p>Сначала добавим ещё один оператор <code>use</code>, который вводит вид с именем <code>std::cmp::Ordering</code> в область видимости из встроенной библиотеки. Вид <code>Ordering</code> является ещё одним перечислением и имеет исходы <code>Less</code>, <code>Greater</code> и <code>Equal</code>. Это три возможных исхода при сравнении двух величин.</p>
<p>После чего ниже добавляем пять новых строк, использующих вид <code>Ordering</code>. Способ <code>cmp</code> сравнивает два значения и может вызываться для всего, что можно сравнить. Он принимает ссылку на все, что требуется сравнить: здесь сравнивается <code>guess</code> с <code>secret_number</code>. В итоге возвращается исход перечисления <code>Ordering</code>, которое мы ввели в область видимости с помощью оператора <code>use</code>. Для принятия решения о том, что делать дальше, мы используем выражение <a href="ch06-02-match.html"><code>match</code></a>, определяющее, какой исход <code>Ordering</code> был возвращён из вызова <code>cmp</code> со значениями <code>guess</code> и <code>secret_number</code>.</p>
<p>Выражение <code>match</code> состоит из <em>веток (arms)</em>. Ветка состоит из <em>образца</em> для сопоставления и кода, который будет запущен, если значение, переданное в <code>match</code>, соответствует образцу этой ветки. Ржавчина принимает значение, заданное <code>match</code>, и по очереди просматривает образец каждой ветки. Образцы и устройство <code>match</code> — это мощные возможности Rust, позволяющие выразить множество случаев, с которыми может столкнуться ваш код, и обеспечить их обработку. Эти возможности будут подробно раскрыты в главе 6 и главе 18 соответственно.</p>
<p>Давайте рассмотрим пример с выражением <code>match</code>, которое мы здесь используем. Скажем, пользователь угадал 50, а случайно созданное тайное число на этот раз — 38.</p>
<p>Когда код сравнивает 50 с 38, способ <code>cmp</code> вернёт <code>Ordering::Greater</code>, поскольку 50 больше, чем 38. Выражение <code>match</code> получит значение <code>Ordering::Greater</code> и начнёт проверять образец в каждой ветке. Он просмотрит образец первой ветки, <code>Ordering::Less</code>, и увидит, что значение <code>Ordering::Greater</code> не соответствует <code>Ordering::Less</code>, поэтому пренебрегает код этой ветки и перейдёт к следующей. Образец следующей ветки — <code>Ordering::Greater</code>, который <em>соответствует</em> <code>Ordering::Greater</code>! Код этой ветки будет выполнен и напечатает <code>Too big!</code> на экран. Выражение <code>match</code> заканчивается после первого успешного совпадения, поэтому в этом сценарии оно не будет рассматривать последнюю ветку.</p>
<p>Однако код в приложении 2-4 всё ещё не собирается. Давайте попробуем:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs:840:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>Суть ошибки заключается в наличии <em>несовпадающих видов</em>. У Ржавчина строгая постоянная система видов. Однако в нем также есть рычаг вывода видов. Когда мы написали <code>let mut guess = String::new()</code>, Ржавчина смог сделать вывод, что <code>guess</code> должна быть <code>String</code> и не заставил указывать вид. С другой стороны, <code>secret_number</code> — это числовой вид. Несколько видов чисел в Ржавчина могут иметь значение от 1 до 100: <code>i32</code>, 32-битное число; <code>u32</code>, беззнаковое 32-битное число; <code>i64</code>, 64-битное число, и так далее. Если не указано иное, Ржавчина по умолчанию использует <code>i32</code>, который будет видом <code>secret_number</code>, если вы не добавите сведения о виде где-то ещё, чтобы заставить Ржавчина вывести другой числовой вид. Причина ошибки заключается в том, что Ржавчина не может сравнить строку и числовой вид.</p>
<p>В конечном итоге необходимо преобразовать <code>String</code>, считываемую программой в качестве входных данных, в существующий числовой вид, чтобы иметь возможность числового сравнения с загаданным числом. Для этого добавьте в тело функции <code>main</code> следующую строку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p>Вот эта строка:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>Мы создаём переменную с именем <code>guess</code>. Но подождите, разве в программе уже нет переменной с этим именем <code>guess</code>? Так и есть, но Ржавчина позволяет нам затенять предыдущее значение <code>guess</code> новым. <em>Затенение</em> позволяет нам повторно использовать имя переменной <code>guess</code>, чтобы избежать создания двух единственных переменных, таких как <code>guess_str</code> и <code>guess</code>, например. Мы рассмотрим это более подробно в главе 3, а пока знайте, что эта функция часто используется, когда необходимо преобразовать значение из одного вида в другой.</p>
<p>Мы связываем эту новую переменную с выражением <code>guess.trim().parse()</code>. Переменная <code>guess</code> в этом выражении относится к исходной переменной <code>guess</code>, которая содержала входные данные в виде строки. Способ <code>trim</code> на образце <code>String</code> удалит любые пробельные символы в начале и конце строки для того, чтобы мы могли сопоставить строку с <code>u32</code>, который содержит только числовые данные. Пользователь должен нажать <span class="keystroke">enter</span>, чтобы выполнить <code>read_line</code> и ввести свою догадку, при этом в строку добавится символ новой строки. Например, если пользователь набирает <span class="keystroke">5</span> и нажимает <span class="keystroke">enter</span>, <code>guess</code> будет выглядеть так: <code>5\n</code>. Символ <code>\n</code> означает "новая строка". (В Windows нажатие <span class="keystroke">enter</span> сопровождается возвратом каретки и новой строкой, <code>\r\n</code>). Способ <code>trim</code> убирает <code>\n</code> или <code>\r\n</code>, оставляя только <code>5</code>.</p>
<p>Способ <a href="../std/primitive.str.html#method.parse"><code>parse</code> строк</a><!-- ignore --> преобразует строку в другой вид. Здесь мы используем его для преобразования строки в число. Нам нужно сообщить Ржавчина точный числовой вид, который мы хотим получить, используя <code>let guess: u32</code>. Двоеточие ( <code>:</code> ) после <code>guess</code> говорит Rust, что мы определяем вид переменной. В Ржавчина есть несколько встроенных числовых видов; <code>u32</code>, показанный здесь, представляет собой 32-битное целое число без знака. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других видах чисел в главе 3.</p>
<p>Кроме того, изложение <code>u32</code> в этом примере программы и сравнение с <code>secret_number</code> означает, что Ржавчина сделает вывод, что <code>secret_number</code> должен быть <code>u32</code>. Итак, теперь сравнение будет между двумя значениями одного типа!</p>
<p>Способ <code>parse</code> будет работать только с символами, которые логически могут быть преобразованы в числа, и поэтому легко может вызвать ошибки. Если, например, строка содержит <code>A👍%</code>, преобразовать её в число невозможно. Так как способ <code>parse</code> может потерпеть неудачу, он возвращает вид <code>Result</code> — так же как и способ <code>read_line</code> (обсуждалось ранее в разделе <a data-md-type="raw_html" href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">«Обработка возможной ошибки с помощью вида <code>Result</code>»</a>). Мы будем точно так же обрабатывать данный <code>Result</code>, вновь используя способ <code>expect</code>. Если <code>parse</code> вернёт исход <code>Result</code> <code>Err</code>, так как не смог создать число из строки, вызов <code>expect</code> со сбоем завершит игру и отобразит переданное ему сообщение. Если <code>parse</code> сможет успешно преобразовать строку в число, он вернёт исход <code>Result</code> <code>Ok</code>, а <code>expect</code> вернёт число, полученное из значения <code>Ok</code>.</p>
<p>Давайте запустим программу теперь:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Хорошо! Несмотря на то, что были добавлены пробелы в строке ввода, программа всё равно поняла, что пользователь имел в виду число 76. Запустите программу несколько раз, чтобы проверить разное поведение при различных видах ввода: задайте число правильно, задайте слишком большое число и задайте слишком маленькое число.</p>
<p>Сейчас у нас работает большая часть игры, но пользователь может сделать только одну догадку. Давайте изменим это, добавив цикл!</p>
<h2 id="Возможность-нескольких-догадок-с-помощью-циклов"><a class="header" href="#Возможность-нескольких-догадок-с-помощью-циклов">Возможность нескольких догадок с помощью циклов</a></h2>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Мы добавляем цикл, чтобы дать пользователям больше шансов угадать число:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p>Как видите, мы перемеисполнения всё, начиная с подсказки ввода догадки, в цикл. Не забудьте добавить ещё по четыре пробела на отступы строк внутри цикла и запустите программу снова. Теперь программа будет бесконечно запрашивать ещё одну догадку, что в действительности создаёт новую неполадку. Похоже, пользователь не сможет выйти из игры!</p>
<p>Пользователь может прервать выполнение программы с помощью сочетания клавиш <span class="keystroke">ctrl+c</span>. Но есть и другой способ спастись от этого ненасытного монстра, о котором говорилось при обсуждении <code>parse</code> в <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">«Сравнение догадки с тайным числом»</a>: если пользователь введёт нечисловой ответ, программа завершится со сбоем. Мы можем воспользоваться этим, чтобы позволить пользователю выйти из игры, как показано здесь:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ввод <code>quit</code> приведёт к выходу из игры, но, как вы заметите, так же будет и при любом другом нечисловом вводе. Однако это, мягко говоря, не разумно. Мы хотим, чтобы игра самостоятельно остановилась, когда будет угадано правильное число.</p>
<h3 id="Выход-после-правильной-догадки"><a class="header" href="#Выход-после-правильной-догадки">Выход после правильной догадки</a></h3>
<p>Давайте запрограммируем игру на выход при выигрыше пользователя, добавив оператор <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p>Добавление строки <code>break</code> после <code>You win!</code> заставляет программу выйти из цикла, когда пользователь правильно угадает тайное число. Выход из цикла также означает выход из программы, так как цикл является последней частью <code>main</code>.</p>
<h3 id="Обработка-недопустимого-ввода"><a class="header" href="#Обработка-недопустимого-ввода">Обработка недопустимого ввода</a></h3>
<p>Чтобы улучшить поведение игры, вместо со сбоемго завершения программы, когда пользователь вводит не число, давайте заставим игру пренебрегать этотобстоятельство, позволяя пользователю продолжить угадывание. Для этого необходимо изменить строку, в которой <code>guess</code> преобразуется из <code>String</code> в <code>u32</code>, как показано в приложении 2-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 2-5. Пренебрежение нечисловой догадки и запрос другой догадки вместо завершения программы</span></p>
<p>Мы заменяем вызов <code>expect</code> на выражение <code>match</code>, чтобы перейти от со сбоемго завершения при ошибке к обработке ошибки. Помните, что <code>parse</code> возвращает вид <code>Result</code>, а <code>Result</code> — это перечисление, которое имеет исходы <code>Ok</code> и <code>Err</code>. Здесь мы используем выражение <code>match</code>, как и в случае с итогом <code>Ordering</code> способа <code>cmp</code>.</p>
<p>Если <code>parse</code> успешно преобразует строку в число, он вернёт значение <code>Ok</code>, содержащее полученное число. Это значение <code>Ok</code> будет соответствовать образцу первой ветки, а выражение <code>match</code> просто вернёт значение <code>num</code>, которое <code>parse</code> произвёл и поместил внутрь значения <code>Ok</code>. Это число окажется в нужной нам переменной <code>guess</code>, которую мы создали.</p>
<p>Если способ <code>parse</code> <em>не способен</em> превратить строку в число, он вернёт значение <code>Err</code>, которое содержит более подробную сведения об ошибке. Значение <code>Err</code> не совпадает с образцом <code>Ok(num)</code> в первой ветке <code>match</code>, но совпадает с образцом <code>Err(_)</code> второй ветки. Подчёркивание <code>_</code> является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений <code>Err</code>, независимо от того, какая сведения находится внутри. Поэтому программа выполнит код второй ветки, <code>continue</code>, который сообщает программе перейти к следующей повторения <code>loop</code> и запросить ещё одну догадку. В этом случае программа эффективно пренебрегает все ошибки, с которыми <code>parse</code> может столкнуться!</p>
<p>Всё в программе теперь должно работать как положено. Давайте попробуем:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Потрясающе! С помощью одной маленькой последней правки мы закончим игру в угадывание. Напомним, что программа все ещё печатает тайное число. Это хорошо подходило для проверки, но это портит игру. Давайте удалим <code>println!</code>, который выводит тайное число. В Приложении 2-6 показан окончательный исход кода.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Приложение 2-6: полный код игры</span></p>
<p>На данный мгновение вы успешно создали игру в загадки. Поздравляем!</p>
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Этот дело — опытный способ познакомить вас со многими новыми подходами Rust: <code>let</code>, <code>match</code>, функции, использование внешних ящиков и многое другое. В следующих нескольких главах вы изучите эти подходы более подробно. Глава 3 охватывает понятия, которые есть в большинстве языков программирования, такие как переменные, виды данных и функции, и показывает, как использовать их в Rust. В главе 4 рассматривается владение — особенность, которая отличает Ржавчина от других языков. В главе 5 обсуждаются устройства и правила написания способов, а в главе 6 объясняется, как работают перечисления.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Общие-подходы-программирования"><a class="header" href="#Общие-подходы-программирования">Общие подходы программирования</a></h1>
<p>В этой главе рассматриваются подходы, присутствующие почти в каждом языке программирования, и то, как они работают в Rust. В основе большинства языков программирования есть много общего. Все подходы, представленные в этой главе, не являются единственными для Rust, но мы обсудим их в среде Ржавчина и разъясним правила использования этих подходов.</p>
<p>В частности вы изучите переменные, основные виды, функции, примечания и поток управления. Эти фундаментальные понятия будут присутствовать в каждой программе на Rust, и их изучение на ранней стадии даст вам прочную основу для начала работы.</p>
<blockquote>
<p><b>Ключевые слова </b></p>
<p>В языке Ржавчина как и в других языках есть набор <em>ключевых слов</em>, зарезервированных только для использования в языке. Помните, что нельзя использовать эти слова в качестве имён переменных или функций. Большинство этих ключевых слов имеют особые назначения, и вы будете использовать их для выполнения различных задач в своих программах на Rust. Некоторые из них сейчас не имеют функционального назначения, но зарезервированы для возможности, которая может быть добавлена в Ржавчина в будущем. Список ключевых слов вы можете найти в <a href="appendix-01-keywords.html" data-md-type="link">Приложении А</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Переменные-и-изменяемость"><a class="header" href="#Переменные-и-изменяемость">Переменные и изменяемость</a></h2>
<p>Как упоминалось в разделе <a href="ch02-00-guessing-game-tutorial.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85">"Хранение значений с помощью переменных"</a>, по умолчанию переменные неизменяемы. Это один из многих стимулов Rust, позволяющий писать код с использованием преимущества безопасности и удобной состязательности (concurrency), предоставляемых Rust. Тем не менее, существует возможность сделать переменные изменяемыми. Давайте рассмотрим, как и почему Ржавчина побуждает предпочесть неизменяемость и почему иногда можно отказаться от этого.</p>
<p>Если переменная является неизменяемой, то после привязки значения к имени изменить его будет нельзя. Чтобы показать это, создайте новый дело под названием <em>variables</em> в папке <em>projects</em> с помощью приказы <code>cargo new variables</code>.</p>
<p>Далее, в новом папке <em>variables</em> откройте <em>src/main.rs</em> и замените в нем код на ниже приведённый, который пока не будет собираться:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
let x = 5;
println!("The value of x is: {}", x);
x = 6;
println!("The value of x is: {}", x);
}</code></pre>
<p>Сохраните и запустите программу, используя <code>cargo run</code>. Будет получено сообщение об ошибке относительно неизменяемости, как показано в этом выводе:</p>
<pre><code class="language-console">error[E0384]: cannot assign twice to immutable variable `x`  --&gt; src/main.rs:4:5   | 2 |     let x = 5;   |         - first assignment to `x` 3 |     println!("The value of x is: {}", x); 4 |     x = 6;   |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>В этом примере показано, как сборщик помогает находить ошибки в ваших программах. Ошибки сборщика могут расстраивать, но в действительности они означают, что программа пока не делает правильно то, что вы ожидаете; это <em>не значит</em>, что вы плохой программист! Даже опытные Rustaceans иногда сталкиваются с ошибками сборщика.</p>
<p>Вы получили сообщение об ошибке <code>cannot assign twice to immutable variable </code>x``, потому что попытались присвоить новое значение неизменяемой переменной <code>x</code>.</p>
<p>Важно, чтобы при попытке изменить значение, объявленное неизменяемым, выдавались ошибки времени сборки, так как подобная случаей может привести к сбоям. Если одна часть нашего кода исполняется исходя из уверенности в неизменяемости значения, а другая часть изменяет это значение, то велика вероятность , что первая часть не выполнит своего предназначения. Причину такой ошибки бывает трудно отследить, особенно если вторая часть кода изменяет значение лишь <em>изредка</em>. Сборщик Ржавчина предоставляет заверение, что если объявить значение неизменяемым, то оно действительно не изменится, а значит, не нужно следить за этим самим. Таким образом, ваш код становится проще для понимания.</p>
<p>Однако изменяемость может быть очень полезной и может сделать код более удобным для написания. Хотя переменные по умолчанию неизменяемы, их можно сделать изменяемыми, добавив <code>mut</code> перед именем переменной, как это было сделано в <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">Главе 2</a>. Добавление <code>mut</code> также передаёт будущим читателям кода намерение, обозначая, что другие части кода будут изменять значение этой переменной.</p>
<p>Например, изменим <em>src/main.rs</em> на следующий код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>Запустив программу, мы получим итог:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Нам разрешено изменить значение, связанное с x, с 5 на 6 при помощи mut. В конечном счёте, решение об использовании изменяемости остаётся за вами и зависит от вашего мнения о наилучшем исходе в данной именно случаи.</p>
<h3 id="Постоянного-значения"><a class="header" href="#Постоянного-значения">Постоянного значения</a></h3>
<p>Подобно неизменяемым переменным, <em>постоянные значения</em> — это значения, которые связаны с именем и не могут изменяться, но между постоянными значениями и переменными есть несколько различий.</p>
<p>Во-первых, нельзя использовать <code>mut</code> с постоянными значениями. Постоянного значения не просто неизменяемы по умолчанию — они неизменяемы всегда. Для объявления постоянных значенийиспользуется ключевое слово <code>const</code> вместо <code>let</code>, а также вид значения <em>должен быть</em> указан в изложении. Мы рассмотрим виды и изложении видов в следующем разделе <a href="ch03-02-data-types.html#data-types">«Виды данных».</a><!-- ignore -->, так что не беспокойтесь о подробностях прямо сейчас. Просто знайте, что вы всегда должны определять вид.</p>
<p>Постоянного значения можно объявлять в любой области видимости, включая вездесущую, благодаря этому они полезны для значений, которые нужны во многих частях кода.</p>
<p>Последнее отличие в том, что постоянные значения могут быть заданы только постоянным выражением, но не итогом вычисленного во время выполнения значения.</p>
<p>Вот пример объявления постоянные значения:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Имя постоянные значения - <code>THREE_HOURS_IN_SECONDS</code>, а её значение устанавливается как итог умножения 60 (количество секунд в минуте) на 60 (количество минут в часе) на 3 (количество часов, которые нужно посчитать в этой программе). Соглашение Ржавчина для именования постоянных значенийтребует использования всех заглавных букв с подчёркиванием между словами. Сборщик может вычислять ограниченный набор действий во время сборки, позволяющий записать это значение более понятным и простым для проверки способом, чем установка этой постоянные значения в значение 10 800. Дополнительную сведения о том, какие действия можно использовать при объявлении постоянных значений, см. в разделе <a href="../reference/const_eval.html">Раздел справки Ржавчина по вычислениям постоянных значений</a>.</p>
<p>Постоянного значения существуют в течение всего времени работы программы в пределах области, в которой они были объявлены. Это свойство делает постоянные значения полезными для значений в домене вашего приложения, о которых могут знать несколько частей программы, например, наибольшее количество очков, которое может заработать любой игрок в игре, или скорость света.</p>
<p>Обозначение жёстко закодированных значений, используемых в программе, как постоянные значения полезно для передачи смысла этого значения будущим сопровождающим кода. Это также позволяет иметь единственное место в коде, которое нужно будет изменить, если в будущем потребуется обновить значение.</p>
<h3 id="Затенение-переменных"><a class="header" href="#Затенение-переменных">Затенение (переменных)</a></h3>
<p>Как было показано в уроке по игре в Угадайка в <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">главе 2</a>, можно объявить новую переменную с тем же именем, как и у существующей переменной. Rustaceans говорят, что первая переменная <em>затеняется</em> второй, то есть вторая переменная - это то, что увидит сборщик, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не станет тенью, либо не закончится область видимости. Мы можем затенять переменную, используя то же имя переменной и повторяя использование ключевого слова <code>let</code> следующим образом:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>Эта программа сначала привязывает <code>x</code> к значению <code>5</code>. Затем она создаёт новую переменную <code>x</code>, повторяя <code>let x =</code>, беря исходное значение и добавляя <code>1</code>, чтобы значение <code>x</code> стало равным <code>6</code>. Затем во внутренней области видимости, созданной с помощью фигурных скобок, третий оператор <code>let</code> также затеняет <code>x</code> и создаёт новую переменную, умножая предыдущее значение на <code>2</code>, чтобы дать <code>x</code> значение <code>12</code>. Когда эта область заканчивается, внутреннее затенение заканчивается, и <code>x</code> возвращается к значению <code>6</code>. Запустив эту программу, она выведет следующее:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>Затенение отличается от объявления переменной с помощью <code>mut</code>, так как мы получим ошибку сборки, если случайно попробуем переназначить значение без использования ключевого слова <code>let</code>. Используя <code>let</code>, можно выполнить несколько превращений над значением, при этом оставляя переменную неизменяемой, после того как все эти превращения завершены.</p>
<p>Другой разницей между <code>mut</code> и затенением является то, что мы создаём совершенно новую переменную, когда снова используем слово <code>let</code> (ещё одну). Мы можем даже изменить вид значения, но снова использовать прежнее имя. К примеру, наша программа спрашивает пользователя, сколько пробелов он хочет разместить между некоторым текстом, запрашивая символы пробела, но мы на самом деле хотим сохранить данный ввод как число:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>Первая переменная <code>spaces</code> — является строковым видом, а вторая переменная <code>spaces</code> — числовым видом. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как <code>spaces_str</code> и <code>spaces_num</code>. Вместо этого мы можем повторно использовать более простое имя <code>spaces</code>. Однако, если мы попытаемся использовать для этого <code>mut</code>, как показано далее, то получим ошибку времени сборки:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>Ошибка говорит, что не разрешается менять вид переменной:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Теперь, когда мы изучили, как работают переменные, давайте рассмотрим различные виды данных, которые они могут иметь.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Виды-Данных"><a class="header" href="#Виды-Данных">Виды Данных</a></h2>
<p>Каждое значение в Ржавчина относится к определённому <em>виду данных</em>, который указывает на вид данных, что позволяет Ржавчина знать, как работать с этими данными. Мы рассмотрим два подмножества видов данных: одиночные и составные.</p>
<p>Не забывайте, что Ржавчина является <em>постоянно строго определенным</em> (statically typed) языком. Это означает, что он должен знать виды всех переменных во время сборки. Обычно сборщик может предположить, какой вид используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько видов, необходимо добавлять изложение вида вручную. Например, когда мы преобразовали <code>String</code> в число с помощью вызова <code>parse</code> в разделе <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">«Сравнение предположения с загаданным номером»</a> главы 2, мы должны добавить такую изложение:<!-- ignore --></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre></pre>
<p>Если мы не добавим изложение вида <code>: u32</code>, показанную в предыдущем коде, Ржавчина отобразит следующую ошибку, которая означает, что сборщику нужно от нас больше сведений, чтобы узнать, какой вид мы хотим использовать:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>В будущем вы увидите различные изложении для разных видов данных.</p>
<h3 id="Одиночные-виды-данных"><a class="header" href="#Одиночные-виды-данных">Одиночные виды данных</a></h3>
<p><em>Одиночный</em> вид представляет собой единичное значение. В Ржавчина есть четыре основных одиночных вида: целочисленный, числа с плавающей точкой, логический и символы. Вы наверняка знакомы с этими видами по другим языкам программирования. Давайте разберёмся, как они работают в Rust.</p>
<h4 id="Целочисленные-виды"><a class="header" href="#Целочисленные-виды">Целочисленные виды</a></h4>
<p>Целочисленный вид (<em>integer</em>) — это число без дробной части. В главе 2 мы использовали один целочисленный вид — вид <code>u32</code>. Такое объявление вида указывает, что значение, с которым оно связано, должно быть целым числом без знака (виды целых чисел со знаком начинаются с <code>i</code> вместо <code>u</code>), которое занимает 32 бита памяти. В Таблице 3-1 показаны встроенные целочисленные виды в Rust. Мы можем использовать любой из этих исходов для объявления вида целочисленного значения.</p>
<p><span class="caption">Таблица 3-1: целочисленные виды в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Длина</th><th>Со знаком</th><th>Без знака</th></tr></thead><tbody>
<tr><td>8 бит</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 бит</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 бита</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 бита</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 бит</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>архитектурно-зависимая</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Каждый исход может быть как со знаком, так и без знака и имеет явный размер. Такая свойство вида как <em>знаковый</em> и <em>беззнаковый</em> определяет возможность числа быть отрицательным. Другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, число отображается со знаком плюс или со знаком -; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся с использованием <a href="https://en.wikipedia.org/wiki/Two%27s_complement">дополнительного кода</a>.</p>
<p>Каждый исход со знаком может хранить числа от -(2 <sup>n - 1</sup> ) до 2 <sup>n - 1</sup> - 1 включительно, где <em>n</em> — количество битов, которые использует этот исход. Таким образом, <code>i8</code> может хранить числа от -(2 <sup>7</sup> ) до 2 <sup>7</sup> - 1, что равно значениям от -128 до 127. Исходы без знака могут хранить числа от 0 до 2 <sup>n</sup> - 1, поэтому <code>u8</code> может хранить числа от 0 до 2 <sup>8</sup> - 1, что равно значениям от 0 до 255.</p>
<p>Кроме того, виды <code>isize</code> и <code>usize</code> зависят от архитектуры компьютера, на котором выполняется программа, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.</p>
<p>Вы можете записывать целочисленные записи в любой из разновидностей, показанных в таблице 3-2. Заметьте, что числовые записи, имеющие несколько числовых видов, допускают использование вставки вида, например <code>57u8</code>, для обозначения вида. Числовые записи также могут использовать <code>_</code> в качестве визуального разделителя для облегчения чтения числа, например <code>1_000</code>, который будет иметь такое же значение, как если бы было задано <code>1000</code>.</p>
<p><span class="caption">Таблица 3-2: Целочисленные записи в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Числовой запись</th><th>Пример</th></tr></thead><tbody>
<tr><td>Десятичный</td><td><code>98_222</code></td></tr>
<tr><td>Шестнадцатеричный</td><td><code>0xff</code></td></tr>
<tr><td>восьмеричный</td><td><code>0o77</code></td></tr>
<tr><td>Двоичный</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Байт (только <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Как же узнать, какой вид целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные виды по умолчанию <code>i32</code>. Основной случай, в котором вы должны использовать <code>isize</code> или <code>usize</code>, — это упорядочевание какой-либо собрания.</p>
<blockquote>
<p><h>Целочисленное переполнение</h> Допустим, имеется переменная вида <code>u8</code>, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого ряда, например, 256, произойдёт <em>целочисленное переполнение</em>, что может привести к одному из двух исходов поведения. Если выполняется сборка в режиме отладки, Ржавчина включает проверку на целочисленное переполнение, приводящую вашу программу к <em>панике</em> во время выполнения, когда возникает такое поведение. Ржавчина использует понятие <em>паника(panicking)</em>, когда программа завершается с ошибкой. Мы обсудим панику более подробно в разделе <a href="ch09-01-unrecoverable-errors-with-panic.html">"Неустранимые ошибки с <code>panic!</code>"</a> в главе 9. . При сборки в режиме release с флагом <code>--release</code>, Ржавчина <em>не</em> включает проверки на целочисленное переполнение, которое вызывает панику. Вместо этого, в случае переполнения, Ржавчина выполняет <em>обёртывание второго дополнения</em>. Проще говоря, значения, превышающие наибольшее значение, которое может хранить вид, "оборачиваются" к наименьшему из значений, которые может хранить вид. В случае <code>u8</code> значение 256 становится 0, значение 257 становится 1, и так далее. Программа не запаникует, но переменная будет иметь значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Полагаться на поведение обёртывания целочисленного переполнения считается ошибкой. Для явной обработки возможности переполнения существует семейство способов, предоставляемых встроенной библиотекой для простых числовых видов:</p>
<ul>
<li>Обёртывание во всех режимах с помощью способов <code>wrapping_*</code>, таких как <code>wrapping_add</code>.</li>
<li>Возврат значения <code>None</code> при переполнении с помощью способов <code>checked_*</code>.</li>
<li>Возврат значения и логический индикатор, указывающий, произошло ли переполнение при использовании способов <code>overflowing_*</code>.</li>
<li>Насыщение наименьшим или наибольшим значением с помощью способов <code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="Числа-с-плавающей-запятой"><a class="header" href="#Числа-с-плавающей-запятой">Числа с плавающей запятой</a></h4>
<p>Также в Ржавчина есть два простых вида для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Виды с плавающей точкой в Ржавчина - это f32 и f64, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется вид f64, поскольку на современных процессорах он работает примерно с той же скоростью, как и f32, но обладает большей точностью. Все виды с плавающей запятой являются знаковыми.</p>
<p>Вот пример, отображающий числа с плавающей запятой в действии:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Числа с плавающей запятой представлены в соответствии со исполнением IEEE-754. Вид <code>f32</code> является плавающей запятой одинарной точности, а <code>f64</code> - двойной точности.</p>
<h4 id="Числовые-действия"><a class="header" href="#Числовые-действия">Числовые действия</a></h4>
<p>Rust поддерживает основные математические действия, привычные для всех видов чисел: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующий код показывает, как можно использовать каждую числовую действие в указания <code>let</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Каждое выражение в этих указаниях использует математический оператор и вычисляется в одно значение, которое связывается с переменной. <a href="appendix-02-operators.html">Приложении B</a> содержит список всех операторов, которые предоставляет Rust.</p>
<h4 id="Логический-вид-данных"><a class="header" href="#Логический-вид-данных">Логический вид данных</a></h4>
<p>Как и в большинстве других языков программирования, логический вид в Ржавчина имеет два возможных значения: <code>true</code> и <code>false</code>. Значения логических видов имеют размер в один байт. Логический вид в Ржавчина задаётся с помощью <code>bool</code>. Например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>Основной способ использования логических значений - это использование условий, таких как выражение <code>if</code>. Мы рассмотрим, как выражения <code>if</code> работают в Ржавчина в разделе <a href="ch03-05-control-flow.html#control-flow">"Поток управления"</a>.</p>
<h4 id="Символьный-вид-данных"><a class="header" href="#Символьный-вид-данных">Символьный вид данных</a></h4>
<p>Вид <code>char</code> в Ржавчина является самым простым алфавитным видом языка. Вот несколько примеров объявления значений <code>char</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Заметьте, мы указываем записи <code>char</code> с одинарными кавычками, в отличие от строковых записей, для которых используются двойные кавычки. Вид <code>char</code> в Ржавчина имеет размер четыре байта и представляет собой одиночное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины - все это допустимые значения вида <code>char</code> в Rust. Одиночные значения Unicode находятся в ряде от <code>U+0000</code> до <code>U+D7FF</code> и от <code>U+E000</code> до <code>U+10FFFF</code> включительно. Однако "символ" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "символ", может не совпадать с тем, что такое <code>char</code> в Rust. Мы подробно обсудим эту тему в главе 8 "Хранение текста в кодировке UTF-8 с помощью строк".</p>
<h3 id="Составные-виды-данных"><a class="header" href="#Составные-виды-данных">Составные виды данных</a></h3>
<p><em>Составные виды</em> могут объединять различные значения в один вид. В Ржавчина есть два простых составных вида: упорядоченные ряды и массивы.</p>
<h4 id="Упорядоченные-ряды"><a class="header" href="#Упорядоченные-ряды">Упорядоченные ряды</a></h4>
<p><em>Упорядоченный ряд</em>- это гибкий способ объединения нескольких значений с различными видами в один составной вид. Упорядоченные ряды имеют конечную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.</p>
<p>Мы создаём упорядоченный ряд, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждая позиция в упорядоченном ряде имеет вид, причём виды различных значений в упорядоченном ряде не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные изложении видов:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>Переменная <code>tup</code> связана со всем упорядоченным рядом, поскольку упорядоченный ряд является одним составным элементом. Чтобы получить отдельные значения из упорядоченного ряда, можно использовать сопоставление с образцом для разъединения значения упорядоченного ряда, например, так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>Эта программа сначала создаёт упорядоченный ряд и связывает его с переменной <code>tup</code>. Затем с помощью образца <code>let</code> берётся <code>tup</code> и превращается в три отдельные переменные, <code>x</code>, <code>y</code> и <code>z</code>. Это называется <em>разъединением</em>, поскольку разбивает единый упорядоченный ряд на три части. Наконец, программа печатает значение <code>y</code>, которое равно <code>6.4</code>.</p>
<p>Мы также можем получить доступ к элементу упорядоченного ряда напрямую, используя точку (<code>.</code>), за которой следует порядковый указательзначения, требуемого для доступа. Например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Эта программа создаёт упорядоченный ряд <code>x</code>, а затем обращается к каждому элементу упорядоченного ряда, используя соответствующие порядковые указатели. Как и в большинстве языков программирования, первый порядковый указательв упорядоченном ряде равен 0.</p>
<p>Упорядоченный ряд, не имеющий значений, имеет особое имя  <em>единичный вид (unit)</em>. Это значение и соответствующий ему вид записываются как <code>()</code> и представляет собой пустое значение или пустой возвращаемый вид. Выражения неявно возвращают значение единичного вида, если не возвращают никакого другого значения.</p>
<h4 id="Массивы"><a class="header" href="#Массивы">Массивы</a></h4>
<p>Другим способом создания собрания из нескольких значений является массив <em>array</em>. В отличие от упорядоченного ряда, каждый элемент массива должен иметь один и тот же вид. В отличие от массивов в некоторых других языках, массивы в Ржавчина имеют конечную длину.</p>
<p>Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Массивы удобно использовать, если данные необходимо разместить в обойме, а не в куче (мы подробнее обсудим обойма и кучу в <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">Главе 4</a>) или если требуется, чтобы количество элементов всегда было конечным. Однако массив не так гибок, как вектор. <em>Вектор</em> - это подобный вид собрания, предоставляемый встроенной библиотекой, который <em>может</em> увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор. Более подробно векторы рассматриваются в <a href="ch08-01-vectors.html">Главе 8</a>.</p>
<p>Однако массивы более полезны, когда вы знаете, что количество элементов не нужно будет изменять. Например, если бы вы использовали названия месяцев в программе, вы, вероятно, использовали бы массив, а не вектор, потому что вы знаете, что он всегда будет содержать 12 элементов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p>Вид массива записывается следующим образом: в квадратных скобках обозначается вид элементов массива, а затем, через точку с запятой, количество элементов. Например:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Здесь <code>i32</code> является видом каждого элемента массива. После точки с запятой указано число <code>5</code>, показывающее, что массив содержит 5 элементов.</p>
<p>Вы также можете объявить массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо вида. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>Массив в переменной <code>a</code> будет включать <code>5</code> элементов, значение которых будет равно <code>3</code>. Данная запись подобна коду <code>let a = [3, 3, 3, 3, 3];</code>, но является более краткой.</p>
<h5 id="Доступ-к-элементам-массива"><a class="header" href="#Доступ-к-элементам-массива">Доступ к элементам массива</a></h5>
<p>Массив — это единый отрывок памяти известного конечного размера, который может быть размещён в обойме. Вы можете получить доступ к элементам массива с помощью упорядочевания, например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>В этом примере переменная с именем first получит значение 1, потому что это значение находится по порядковому указателю [0] в массиве. Переменная с именем second получит значение 2 по порядковому указателю [1] в массиве.</p>
<h5 id="Неправильный-доступ-к-элементу-массива"><a class="header" href="#Неправильный-доступ-к-элементу-массива">Неправильный доступ к элементу массива</a></h5>
<p>Давайте посмотрим, что произойдёт, если попытаться получить доступ к элементу массива, находящемуся за его пределами. Допустим, вы запускаете данный код, похожий на игру в угадывание из Главы 2, чтобы получить от пользователя порядковый указательмассива:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}</code></pre>
<p>Этот код успешно собирается. Если запустить этот код с помощью <code>cargo run</code> и ввести <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> или <code>4</code>, программа напечатает соответствующее значение по данному порядковому указателю в массиве. Если вместо этого ввести число за пределами массива, например, <code>10</code>, то программа выведет следующее:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Программа столкнулась с ошибкой во <em>времени выполнения</em> на этапе применения недопустимого значения в действия упорядочевания. Программа завершилась с сообщением об ошибке и не выполнила конечную указанию <code>println!</code>. При попытке доступа к элементу с помощью упорядочевания Ржавчина проверяет, что указанный порядковый указательменьше длины массива. Если порядковый указательбольше или равен длине, Ржавчина паникует. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что сборщик не может знать, какое значение введёт пользователь при последующем выполнении кода.</p>
<p>Это пример принципов безопасности памяти Ржавчина в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный порядковый указатель, доступ к памяти может быть неправильным. Ржавчина защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу. В главе 9 подробнее обсуждается обработка ошибок в Ржавчина и то, как вы можете написать читаемый, безопасный код, который не вызывает панику и не разрешает неправильный доступ к памяти.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Функции"><a class="header" href="#Функции">Функции</a></h2>
<p>Функции широко распространены в коде Rust. Вы уже познакомились с одной из самых важных функций в языке: функцией <code>main</code>, которая является точкой входа большинства программ. Вы также видели ключевое слово <code>fn</code>, позволяющее объявлять новые функции.</p>
<p>Код Ржавчина использует <em>змеиный регистр (snake case)</em> как основной исполнение для имён функций и переменных, в котором все буквы строчные, а символ подчёркивания разделяет слова. Вот программа, содержащая пример определения функции:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}</code></pre></pre>
<p>Для определения функции в Ржавчина необходимо указать <code>fn</code>, за которым следует имя функции и набор круглых скобок. Фигурные скобки указывают сборщику, где начинается и заканчивается тело функции.</p>
<p>Мы можем вызвать любую функцию, которую мы определили ранее, введя её имя и набор скобок следом. Поскольку в программе определена <code>another_function</code>, её можно вызвать из функции <code>main</code>. Обратите внимание, что <code>another_function</code> определена <em>после</em> функции <code>main</code> в исходном коде; мы могли бы определить её и раньше. Ржавчина не важно, где вы определяете свои функции, главное, чтобы они были определены где-то в той области видимости, которую может видеть вызывающий их код.</p>
<p>Создадим новый двоичный дело с названием <em>functions</em> для дальнейшего изучения функций. Поместите пример <code>another_function</code> в файл <em>src/main.rs</em> и запустите его. Вы должны увидеть следующий вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Строки выполняются в том порядке, в котором они расположены в функции <code>main</code>. Сначала печатается сообщение "Hello, world!", а затем вызывается <code>another_function</code>, которая также печатает сообщение.</p>
<h3 id="Свойства-функции"><a class="header" href="#Свойства-функции">Свойства функции</a></h3>
<p>Мы можем определить функции, имеющие <em>свойства</em>, которые представляют собой особые переменные, являющиеся частью ярлыки функции. Когда у функции есть свойства, необходимо предоставить ей определенные значения этих свойств. Технически определенные значения называются <em>переменные</em>, но в повседневном общении люди обычно используют слова <em>свойство</em> и <em>переменная</em> как взаимозаменяемые либо для переменных в определении функции, либо для определенных значений, передаваемых при вызове функции.</p>
<p>В этой исполнения <code>another_function</code> мы добавляем свойство:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>Попробуйте запустить эту программу. Должны получить следующий итог:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Объявление <code>another_function</code> содержит один свойство с именем <code>x</code>. Вид <code>x</code> задан как <code>i32</code>. Когда мы передаём <code>5</code> в <code>another_function</code>, макрос <code>println!</code> помещает <code>5</code> на место пары фигурных скобок, содержащих <code>x</code> в строке вида.</p>
<p>В ярлыках функций вы <em>обязаны</em> указывать вид каждого свойства. Это намеренное решение в внешнем виде Rust: требование наставлений видов в определениях функций позволяет сборщику в дальнейшем избежать необходимости использовать их в других местах кода, чтобы определить, какой вид вы имеете в виду. Сборщик также может выдавать более полезные сообщения об ошибках, если он знает, какие виды ожидает функция.</p>
<p>При определении нескольких свойств, разделяйте объявления свойств запятыми, как показано ниже:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}</code></pre></pre>
<p>Этот пример создаёт функцию под именем <code>print_labeled_measurement</code> с двумя свойствами. Первый свойство называется <code>value</code> с видом <code>i32</code>. Второй называется <code>unit_label</code> и имеет вид <code>char</code>. Затем функция печатает текст, содержащий <code>value</code> и <code>unit_label</code>.</p>
<p>Попробуем запустить этот код. Замените текущую программу дела <em>functions</em> в файле <em>src/main.rs</em> на предыдущий пример и запустите его с помощью <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Поскольку мы вызвали функцию с <code>5</code> в качестве значения для <code>value</code> и <code>'h'</code> в качестве значения для <code>unit_label</code>, вывод программы содержит эти значения.</p>
<h3 id="Указания-и-выражения"><a class="header" href="#Указания-и-выражения">Указания и выражения</a></h3>
<p>Тела функций состоят из ряда указаний, необязательно заканчивающихся выражением. До сих пор функции, которые мы рассматривали, не включали завершающее выражение, но вы видели выражение как часть указания. Поскольку Ржавчина является языком, основанным на выражениях, это важное различие необходимо понимать. В других языках таких различий нет, поэтому давайте рассмотрим, что такое указания и выражения, и как их различия влияют на тела функций.</p>
<ul>
<li><strong>Указания</strong> выполняют какое-либо действие и не возвращают значения.</li>
<li><strong>Выражения</strong> вычисляются до результирующего значения. Давайте рассмотрим несколько примеров.</li>
</ul>
<p>На самом деле мы уже использовали указания и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова <code>let</code> является оператором. В Приложении 3-1, <code>let y = 6;</code> — это указание.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Приложение 3-1: Объявление функции <code>main</code>, содержащей одну указанию</span></p>
<p>Определения функций также являются указанием. Весь предыдущий пример сам по себе является указанием.</p>
<p>Указания не возвращают значения. Следовательно вы не можете присвоить <code>let</code> указанию другой переменной, как это пытается сделать следующий код. Вы получите ошибку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>Если вы запустите эту программу, то ошибка будет выглядеть так:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>Указание <code>let y = 6</code> не возвращает значение, поэтому не с чем связать переменную <code>x</code>. Это отличается от поведения в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В таких языках можно писать код <code>x = y = 6</code> и обе переменные <code>x</code> и <code>y</code> будут иметь значение <code>6</code>. Но в Ржавчина не так.</p>
<p>Выражения вычисляют значение и составляют большую часть остального кода, который вы напишете на Rust. Рассмотрим математическую действие, к примеру <code>5 + 6</code>, которая является выражением, вычисляющим значение <code>11</code>. Выражения могут быть частью указаний: в приложении 3-1 <code>6</code> в указания <code>let y = 6;</code> является выражением, которое вычисляется в значение <code>6</code>. Вызов функции — это выражение. Вызов макроса — это выражение. Новый разделобласти видимости, созданный с помощью фигурных скобок, представляет собой выражение, например:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>Это выражение:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>это блок, который в данном случае вычисляется в значение <code>4</code>. Это значение связывается с <code>y</code> как часть указания <code>let</code>. Обратите внимание, что строка <code>x + 1</code> не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения не содержат завершающих точек с запятой. Если вы добавите точку с запятой в конец выражения, вы превратите его в указанию, и тогда она не будет возвращать значение. Помните об этом, когда будете изучать возвращаемые значения функций и выражения.</p>
<h3 id="Функции-с-возвращаемыми-значениями"><a class="header" href="#Функции-с-возвращаемыми-значениями">Функции с возвращаемыми значениями</a></h3>
<p>Функции могут возвращать значения коду, который их вызывает. Мы не называем возвращаемые значения, но мы должны объявить их вид после стрелки ( <code>-&gt;</code> ). В Ржавчина возвращаемое значение функции является родственным значения конечного выражения в разделе тела функции. Вы можете раньше выйти из функции и вернуть значение, используя ключевое слово <code>return</code> и указав значение, но большинство функций неявно возвращают последнее выражение. Вот пример такой функции:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>В коде функции <code>five</code> нет вызовов функций, макросов или даже указаний  <code>let</code> — есть только одно число <code>5</code>. Это является абсолютно правильной функцией в Rust. Заметьте, что возвращаемый вид у данной функции определён как <code>-&gt; i32</code>. Попробуйте запустить этот код. Вывод будет таким:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Значение <code>5</code> в <code>five</code> является возвращаемым функцией значением, поэтому возвращаемый вид - <code>i32</code>. Рассмотрим пример более подробно. Здесь есть два важных особенности: во-первых, строка <code>let x = five();</code> показывает использование возвращаемого функцией значения для объявления переменной. Так как функция <code>five</code> возвращает <code>5</code>, то эта строка эквивалентна следующей:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Во-вторых, у функции <code>five</code> нет свойств и определён вид возвращаемого значения, но тело функции представляет собой одинокую <code>5</code> без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.</p>
<p>Рассмотрим другой пример:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>Запуск кода напечатает <code>The value of x is: 6</code>. Но если поставить точку с запятой в конце строки, содержащей <code>x + 1</code>, превратив её из выражения в указанию, мы получим ошибку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>Сборка данного кода вызывает следующую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>Основное сообщение об ошибке, <code>несовпадение видов</code>, раскрывает ключевую неполадку этого кода. Определение функции <code>plus_one</code> сообщает, что будет возвращено <code>i32</code>, но указания не вычисляются в значение, что и выражается единичным видом <code>()</code>. Следовательно, ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Ржавчина выдаёт сообщение, которое, возможно, поможет исправить эту неполадку: он предлагает удалить точку с запятой для устранения ошибки.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Примечания"><a class="header" href="#Примечания">Примечания</a></h2>
<p>Все программисты стремятся сделать свой код простым для понимания, но иногда требуется дополнительное объяснение. В таких случаях программисты оставляют в исходном коде <em>примечания</em>, которые сборщик пренебрегает, но люди, читающие исходный код, вероятно, сочтут их полезными.</p>
<p>Пример простого примечания:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hello, world.
<span class="boring">}</span></code></pre></pre>
<p>В Ржавчина принят идиоматический исполнение примечаниев, который начинает примечание с двух косых черт, и примечание продолжается до конца строки. Для примечаниев, выходящих за пределы одной строки, необходимо включить <code>//</code> в каждую строку, как показано ниже:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Итак, мы делаем что-то сложное, настолько длинное, что нам нужно
// несколько строк примечаниев, чтобы сделать это! Ух! Надеюсь, этот примечание
// объясняет, что происходит.
<span class="boring">}</span></code></pre></pre>
<p>Примечания также можно размещать в конце строк, содержащих код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}</code></pre></pre>
<p>Но чаще всего они используются в таком виде: примечание располагается на отдельной строке над кодом, который он определяет:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}</code></pre></pre>
<p>В Ржавчина есть ещё один вид примечаниев - документационные примечания, которые мы обсудим в разделе <a href="ch14-02-publishing-to-crates-io.html">"Обнародование дополнения на Crates.io"</a> главы 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Управляющие-устройства"><a class="header" href="#Управляющие-устройства">Управляющие устройства</a></h2>
<p>Возможности запуска некоторого кода в зависимости от некоторого условия, и замкнутого выполнения некоторого кода, являются основными элементами в большинстве языков программирования. Наиболее распространёнными устройствоми, позволяющими управлять потоком выполнения кода Rust, являются выражения <code>if</code> и циклы.</p>
<h3 id="Выражения-if"><a class="header" href="#Выражения-if">Выражения <code>if</code></a></h3>
<p>Выражение <code>if</code> позволяет выполнять части кода в зависимости от условий. Вы задаёте условие, а затем указываете: "Если это условие выполняется, выполните этот разделкода. Если условие не выполняется, не выполняйте этот разделкода".</p>
<p>Для изучения выражения <code>if</code> создайте новый дело под названием <em>branches</em> в папке <em>projects</em>. В файл <em>src/main.rs</em> поместите следующий код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}</code></pre></pre>
<p>Условие начинается с ключевого слова <code>if</code>, за которым следует условное выражение. В данном случае условное выражение проверяет, имеет ли переменная <code>number</code> значение меньше 5. Сразу после условного выражения внутри фигурных скобок мы помещаем разделкода, который будет выполняться, если итог равен <code>true</code>. Блоки кода, связанные с условными выражениями, иногда называют <em>ветками</em>, как и ветки в выражениях <code>match</code>, которые мы обсуждали в разделе <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">"Сравнение догадки с тайным числом"</a> главы 2.</p>
<p>Это необязательно, но мы также можем использовать ключевое слово <code>else</code>, которое мы используем в данном примере, чтобы предоставить программе иной разделвыполнения кода, выполняющийся если итог вычисления будет ложным. Если не указать выражение <code>else</code> и условие будет ложным, программа просто пропустит раздел<code>if</code> и перейдёт к следующему отрывку кода.</p>
<p>Попробуйте запустить этот код. Появится следующий итог:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Попробуйте изменить значение <code>number</code> на значение, которое делает условие <code>false</code> и посмотрите, что произойдёт:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("condition was true");
</span><span class="boring">    } else {
</span><span class="boring">        println!("condition was false");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Запустите программу снова и посмотрите на вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>Также стоит отметить, что условие в этом коде <em>должно</em> быть логического вида <code>bool</code>. Если условие не является <code>bool</code>, возникнет ошибка. Например, попробуйте запустить следующий код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}</code></pre>
<p>На этот раз условие <code>if</code> вычисляется в значение <code>3</code>, и Ржавчина бросает ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>Ошибка говорит, что Ржавчина ожидал вид <code>bool</code>, но получил значение целочисленного вида. В отличии от других языков вроде Ruby и JavaScript, Ржавчина не будет пытаться самостоятельно преобразовывать <em>нелогические</em> виды в логические. Необходимо явно и всегда использовать <code>if</code> с логическим видом в качестве условия. Если нужно, чтобы разделкода <code>if</code> запускался только, когда число не равно <code>0</code>, то, например, мы можем изменить выражение <code>if</code> на следующее:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}</code></pre></pre>
<p>Будет напечатана следующая строка <code>number was something other than zero</code>.</p>
<h4 id="Обработка-нескольких-условий-с-помощью-else-if"><a class="header" href="#Обработка-нескольких-условий-с-помощью-else-if">Обработка нескольких условий с помощью <code>else if</code></a></h4>
<p>Можно использовать несколько условий, сочетая <code>if</code> и <code>else</code> в выражении <code>else if</code>. Например:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}</code></pre></pre>
<p>У этой программы есть четыре возможных пути выполнения. После её запуска вы должны увидеть следующий итог:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Во время выполнения этой программы по очереди проверяется каждое выражение <code>if</code> и выполняется первый блок, для которого условие <code>true</code>. Заметьте, что хотя 6 делится на 2, мы не видим ни вывода <code>number is divisible by 2</code>, ни текста <code>number is not divisible by 4, 3, or 2</code> из раздела <code>else</code>. Так происходит потому, что Ржавчина выполняет разделтолько для первого истинного условия, а обнаружив его, даже не проверяет остальные.</p>
<p>Использование множества выражений <code>else if</code> приводит к загромождению кода, поэтому при наличии более чем одного выражения, возможно, стоит провести переработка кода кода. В главе 6 описана мощная устройство ветвления Ржавчина для таких случаев, называемая <code>match</code>.</p>
<h4 id="Использование-if-в-указания-let"><a class="header" href="#Использование-if-в-указания-let">Использование <code>if</code> в указания <code>let</code></a></h4>
<p>Поскольку <code>if</code> является выражением, его можно использовать в правой части указания <code>let</code> для присвоения итога переменной, как в приложении 3-2.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}</code></pre></pre>
<p><span class="caption">Приложение 3-2: Присвоение итога выражения <code>if</code> переменной</span></p>
<p>Переменная <code>number</code> будет привязана к значению, которое является итогом выражения <code>if</code>. Запустим код и посмотрим, что происходит:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Вспомните, что разделы кода вычисляются последним выражением в них, а числа сами по себе также являются выражениями. В данном случае, значение всего выражения <code>if</code> зависит от того, какой разделвыполняется. При этом значения, которые могут быть итогами каждого из ветвей <code>if</code>, должны быть одного вида. В Приложении 3-2, итогами обеих ветвей <code>if</code> и <code>else</code> являются целочисленный вид <code>i32</code>. Если виды не совпадают, как в следующем примере, мы получим ошибку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}</code></pre>
<p>При попытке сборки этого кода, мы получим ошибку. Ветви <code>if</code> и <code>else</code> представляют несовместимые виды значений, и Ржавчина точно указывает, где искать неполадку в программе:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>Выражение в разделе <code>if</code> вычисляется как целочисленное, а выражение в разделе <code>else</code> вычисляется как строка. Это не сработает, потому что переменные должны иметь один вид, а Ржавчина должен знать во время сборки, какого вида переменная <code>number</code>. Зная вид <code>number</code>, сборщик может убедиться, что вид действителен везде, где мы используем <code>number</code>. Ржавчина не смог бы этого сделать, если бы вид <code>number</code> определялся только во время выполнения. Сборщик усложнился бы и давал бы меньше заверений в отношении кода, если бы ему приходилось отслеживать несколько гипотетических видов для любой переменной.</p>
<h3 id="Повторное-выполнение-кода-с-помощью-циклов"><a class="header" href="#Повторное-выполнение-кода-с-помощью-циклов">Повторное выполнение кода с помощью циклов</a></h3>
<p>Часто бывает полезно выполнить раздел кода более одного раза. Для этой задачи Ржавчина предоставляет несколько устройств цикла, которые позволяют выполнить разделкода  до конца, а затем сразу же вернуться в начало. Для экспериментов с циклами давайте создадим новый дело под названием <em>loops</em>.</p>
<p>В Ржавчина есть три вида циклов: <code>loop</code>, <code>while</code> и <code>for</code>. Давайте попробуем каждый из них.</p>
<h4 id="Повторение-выполнения-кода-с-помощью-loop"><a class="header" href="#Повторение-выполнения-кода-с-помощью-loop">Повторение выполнения кода с помощью <code>loop</code></a></h4>
<p>Ключевое слово <code>loop</code> говорит Ржавчина выполнять разделкода снова и снова до бесконечности или пока не будет явно приказано остановиться.</p>
<p>В качестве примера, измените код файла <em>src/main.rs</em> в папке дела <em>loops</em> на код ниже:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("again!");
    }
}</code></pre>
<p>Когда запустим эту программу, увидим, как <code>again!</code> печатается снова и снова, пока не остановить программу вручную. Большинство окно вызоваов поддерживают сочетание клавиш <span class="keystroke">ctrl-c</span> для прерывания программы, которая застряла в непрерывном цикле. Попробуйте:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>Символ <code>^C</code> обозначает место, где было нажато <span class="keystroke">ctrl-c </span>. В зависимости от того, где находился код в цикле в мгновение получения звонка отпрерывания, вы можете увидеть или не увидеть слово <code>again!</code>, напечатанное после <code>^C</code>.</p>
<p>К счастью, Ржавчина также предоставляет способ выйти из цикла с помощью кода. Ключевое слово <code>break</code> нужно поместить в цикл, чтобы указать программе, когда следует прекратить выполнение цикла. Напоминаем, мы делали так в игре "Угадайка" в разделе <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">"Выход после правильной догадки"</a><!-- ignore --> Главы 2, чтобы выйти из программы, когда пользователь выиграл игру, угадав правильное число.</p>
<p>Мы также использовали <code>continue</code> в игре "Угадайка", которое указывает программе в цикле пропустить весь оставшийся код в данной повторения цикла и перейти к следующей повторения.</p>
<h4 id="Возвращение-значений-из-циклов"><a class="header" href="#Возвращение-значений-из-циклов">Возвращение значений из циклов</a></h4>
<p>Одно из применений <code>loop</code> - это повторение действия, которая может закончиться неудачей, например, проверка успешности выполнения потоком своего задания. Также может понадобиться передать из цикла итог этой действия в остальную часть кода. Для этого можно добавить возвращаемое значение после выражения <code>break</code>, которое используется для остановки цикла. Это значение будет возвращено из цикла, и его можно будет использовать, как показано здесь:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}</code></pre></pre>
<p>Перед циклом мы объявляем переменную с именем <code>counter</code> и объявим её значением <code>0</code>. Затем мы объявляем переменную с именем <code>result</code> для хранения значения, возвращаемого из цикла. На каждой повторения цикла мы добавляем <code>1</code> к переменной <code>counter</code>, а затем проверяем, равняется ли <code>10</code> переменная <code>counter</code>. Когда это происходит, мы используем ключевое слово <code>break</code> со значением <code>counter * 2</code>. После цикла мы ставим точку с запятой для завершения указания, присваивающей значение <code>result</code>. Наконец, мы выводим значение в <code>result</code>, равное в данном случае 20.</p>
<h4 id="Метки-циклов-для-устранения-неоднозначности-между-несколькими-циклами"><a class="header" href="#Метки-циклов-для-устранения-неоднозначности-между-несколькими-циклами">Метки циклов для устранения неоднозначности между несколькими циклами</a></h4>
<p>Если у вас есть циклы внутри циклов, <code>break</code> и <code>continue</code> применяются к самому внутреннему циклу в этой цепочке. При желании вы можете создать <em>метку цикла</em>, которую вы затем сможете использовать с <code>break</code> или <code>continue</code> для указания, что эти ключевые слова применяются к помеченному циклу, а не к самому внутреннему циклу. Метки цикла должны начинаться с одинарной кавычки. Вот пример с двумя вложенными циклами:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}</code></pre></pre>
<p>Внешний цикл имеет метку <code>'counting_up</code>, и он будет считать от 0 до 2. Внутренний цикл без метки ведёт обратный отсчёт от 10 до 9. Первый <code>break</code>, который не содержит метку, выйдет только из внутреннего цикла. Указание <code>break 'counting_up;</code> завершит внешний цикл. Этот код напечатает:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="Циклы-с-условием-while"><a class="header" href="#Циклы-с-условием-while">Циклы с условием <code>while</code></a></h4>
<p>В программе часто требуется проверить состояние условия в цикле. Пока условие истинно, цикл выполняется. Когда условие перестаёт быть истинным, программа вызывает <code>break</code>, останавливая цикл. Такое поведение можно выполнить с помощью сочетания <code>loop</code>, <code>if</code>, <code>else</code> и <code>break</code>. При желании попробуйте сделать это в программе. Это настолько распространённый образец, что в Ржавчина выполнена встроенная языковая устройство для него, называемая цикл <code>while</code>. В приложении 3-3 мы используем <code>while</code>, чтобы выполнить три цикла программы, производя каждый раз обратный отсчёт, а затем, после завершения цикла, печатаем сообщение и выходим.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}</code></pre></pre>
<p><span class="caption">Приложение 3-3: Использование цикла <code>while</code> для выполнения кода, пока условие истинно</span></p>
<p>Эта устройство устраняет множество вложений, которые потребовались бы при использовании <code>loop</code>, <code>if</code>, <code>else</code> и <code>break</code>, и она более понятна. Пока условие вычисляется в <code>true</code>, код выполняется; в противном случае происходит выход из цикла.</p>
<h4 id="Цикл-по-элементам-собрания-с-помощью-for"><a class="header" href="#Цикл-по-элементам-собрания-с-помощью-for">Цикл по элементам собрания с помощью <code>for</code><a id="looping-through-a-collection-with-for"></a></a></h4>
<p>Для перебора элементов собрания, например, массива, можно использовать устройство <code>while</code>. Например, цикл в приложении 3-4 печатает каждый элемент массива <code>a</code>.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Приложение 3-4: Перебор каждого элемента собрания с помощью цикла <code>while</code></span></p>
<p>Этот код выполняет перебор элементов массива. Он начинается с порядкового указателя <code>0</code>, а затем замкнуто выполняется, пока не достигнет последнего порядкового указателя в массиве (то есть, когда <code>index &lt; 5</code> уже не является истиной). Выполнение этого кода напечатает каждый элемент массива:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Все пять значений массива появляются в окне вызова, как и ожидалось. Поскольку <code>index</code> в какой-то мгновение достигнет значения <code>5</code>, цикл прекратит выполнение перед попыткой извлечь шестое значение из массива.</p>
<p>Однако такой подход чреват ошибками; мы можем вызвать панику в программе, если значение порядкового указателя или условие проверки неверны. Например, если изменить определение массива <code>a</code> на четыре элемента, но забыть обновить условие на <code>while index &lt; 4</code>, код вызовет панику. Также это медленно, поскольку сборщик добавляет код времени выполнения для обеспечения проверки нахождения порядкового указателя в границах массива на каждой повторения цикла.</p>
<p>В качестве более краткой иного решения можно использовать цикл <code>for</code> и выполнять некоторый код для каждого элемента собрания. Цикл <code>for</code> может выглядеть как код в приложении 3-5.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}</code></pre></pre>
<p><span class="caption">Приложение 3-5: Перебор каждого элемента собрания с помощью цикла <code>for</code></span></p>
<p>При выполнении этого кода мы увидим тот же итог, что и в приложении 3-4. Что важнее, теперь мы повысили безопасность кода и устранили вероятность ошибок, которые могут возникнуть в итоге выхода за пределы массива или недостаточно далёкого перехода и пропуска некоторых элементов.</p>
<p>При использовании цикла <code>for</code> не нужно помнить о внесении изменений в другой код, в случае изменения количества значений в массиве, как это было бы с способом, использованным в приложении 3-4.</p>
<p>Безопасность и краткость циклов <code>for</code> делают их наиболее часто используемой устройством цикла в Rust. Даже в случаейх необходимости выполнения некоторого кода определённое количество раз, как в примере обратного отсчёта, в котором использовался цикл <code>while</code> из Приложения 3-3, большинство Rustaceans использовали бы цикл <code>for</code>. Для этого можно использовать <code>Range</code>, предоставляемый встроенной библиотекой, который порождает последовательность всех чисел, начиная с первого числа и заканчивая вторым числом, но не включая его (т.е. <code>(1..4)</code> эквивалентно <code>[1, 2, 3]</code> или в общем случае <code>(start..end)</code> эквивалентно <code>[start, start+1, start+2, ... , end-2, end-1]</code> - прим.переводчика).</p>
<p>Вот как будет выглядеть обратный отсчёт с использованием цикла <code>for</code> и другого способа, о котором мы ещё не говорили, <code>rev</code>, для разворота ряда:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}</code></pre></pre>
<p>Данный код выглядит лучше, не так ли?</p>
<h2 id="Итоги-1"><a class="header" href="#Итоги-1">Итоги</a></h2>
<p>Вы справились! Это была объёмная глава: вы узнали о переменных, одиночных и составных видах данных, функциях, примечаниях, выражениях <code>if</code> и циклах! Для опытов работы с подходами, обсуждаемыми в этой главе, попробуйте создать программы для выполнения следующих действий:</p>
<ul>
<li>Преобразование температур между значениями по Фаренгейту к Цельсию.</li>
<li>Порождение n-го числа Фибоначчи.</li>
<li>Распечатайте текст рождественской песни "Двенадцать дней Рождества", воспользовавшись повторами в песне.</li>
</ul>
<p>Когда вы будете готовы двигаться дальше, мы поговорим о подходы в Rust, которая <em>не существует</em> обычно в других языках программирования: владение.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Понимание-Владения"><a class="header" href="#Понимание-Владения">Понимание Владения</a></h1>
<p>Владение - это самая не имеет себе подобных особенность Rust, которая имеет глубокие последствия для всего языка. Это позволяет Ржавчина обеспечивать безопасность памяти без использования сборщика мусора, поэтому важно понимать, как работает владение. В этой главе мы поговорим о владении, а также о нескольких связанных с ним возможностях: заимствовании, срезах и о том, как Ржавчина раскладывает данные в памяти.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Что-такое-владение"><a class="header" href="#Что-такое-владение">Что такое владение?</a></h2>
<p><em>Владение</em> — это набор правил, определяющих, как программа на языке Ржавчина управляет памятью. Все программы так или иначе должны управлять тем, как они используют память компьютера во время работы. Некоторые языки имеют сборщик мусора, постоянно отслеживающий неиспользуемую память во время работы программы; в других языках программист должен явно выделять и освобождать память. В Ржавчина используется третий подход: память управляется через систему владения с набором правил, которые проверяются сборщиком. При нарушении любого из правил программа не будет собрана. Ни одна из особенностей системы владения не замедлит работу вашей программы.</p>
<p>Поскольку владение является новой подходом для многих программистов, требуется некоторое время, чтобы привыкнуть к ней. Хорошая новость заключается в том, что чем больше у вас будет опыта с Ржавчина и с правилами системы владения, тем легче вам будет естественным образом разрабатывать безопасный и эффективный код. Держитесь! Не сдавайтесь!</p>
<p>Понимание подходы владения даст вам основу для понимания всех остальных особенностей, делающих Ржавчина единственным. В этой главе вы изучите владение на примерах, которые сосредоточены на наиболее часто используемой устройстве данных: строках.</p>
<blockquote>
<h3 id="Обойма-и-куча"><a class="header" href="#Обойма-и-куча">Обойма и куча</a></h3>
<p>Многие языки программирования не требуют, чтобы вы слишком часто думали о обойме и куче. Но в языках системного программирования, одним из которых является Rust, то, какое значение находится в обойме или в куче, влияет на поведение языка и на принятие вами определённых решений. Владение будет описано через призму обоймы и кучи позже в этой главе, а пока — краткое пояснение.</p>
<p>И обойма, и куча — это части памяти, доступные вашему коду для использования во время выполнения. Однако они внутренне выстроенны</p>
</blockquote>
<p>по-разному. Обойма хранит значения в порядке их получения, а удаляет — в обратном. Это называется <em>«последним пришёл — первым ушёл»</em>. Подумайте о стопке тарелок: когда вы добавляете тарелки, вы кладёте их сверху стопки — когда вам нужна тарелка, вы берёте одну так же сверху. Добавление или удаление тарелок посередине или снизу не сработает! Добавление данных называется <em>помещением в обойма</em>, а удаление — извлечением <em>из обоймы</em>. Все данные, хранящиеся в обойме, должны иметь известный определенный размер. Данные, размер которых во время сборки неизвестен или может измениться, должны храниться в куче.</p>
<blockquote>
<p>Куча устроена менее согласованно: когда вы кладёте данные в кучу, вы запрашиваете определённый объём пространства. Операционная система находит в куче свободный участок памяти достаточного размера, помечает его как используемый и возвращает <em>указатель</em>, являющийся адресом этого участка памяти. Этот этап называется <em>выделением памяти в куче</em> и иногда сокращается до <em>выделения памяти</em> (помещение значений в обойма не считается выделением). Поскольку указатель на участок памяти в куче имеет определённый определенный размер, его можно расположить в обойме, однако когда вам понадобятся актуальные данные, вам придётся проследовать по указателю. Представьте, что вы сидите в ресторане. Когда вы входите, вы называете количество человек в вашей объединении, и человек находит свободный стол, которого хватит на всех, и ведёт вас туда. Если кто-то из вашей объединение опоздает, он может спросить, куда вас посадили, чтобы найти вас.</p>
<p>Помещение в обойма происходит более быстро, чем выделение памяти в куче, потому что операционная система не должна искать место для размещения сведений — это место всегда на верхушке обоймы. Для сравнения, выделение памяти в куче требует больше работы, потому что операционная система сначала должна найти участок памяти достаточного размера, а затем произвести некоторые действия для подготовки к следующему выделению памяти.</p>
<p>Доступ к данным в куче медленнее, чем доступ к данным в обойме, потому что вам нужно следовать по адресу указателя, чтобы добраться туда. Современные процессоры работают быстрее, если они меньше прыгают по памяти. Продолжая подобие, рассмотрим официанта в ресторане, принимающего заказы со многих столов. Наиболее эффективно будет получить все заказы за одним столом, прежде чем переходить к следующему столу. Получение заказа со стола А, затем со стола В, затем снова одного с А, а затем снова одного с В было бы гораздо более медленным делом. Точно так же процессор может выполнять свою работу лучше, если он работает с данными, которые находятся близко к другим данным (как в обойме), а не далеко (как это может быть в куче).</p>
<p>Когда ваш код вызывает функцию, значения, переданные в неё (возможно включающие указатели на данные в куче), и местные переменные помещаются в обойма. Когда функция завершается, эти значения извлекаются из обоймы.</p>
<p>Отслеживание того, какие части кода используют какие данные, уменьшение количества повторяющихся данных и очистка неиспользуемых данных в куче, чтобы не исчерпать пространство, — все эти сбоев решает владение. Как только вы поймёте, что такое владение, вам не нужно будет слишком часто думать о обойме и куче. Однако знание того, что основная цель владения — управление данными кучи, может помочь объяснить, почему оно работает именно так.</p>
</blockquote>
<h3 id="Правила-владения"><a class="header" href="#Правила-владения">Правила владения</a></h3>
<p>Во-первых, давайте взглянем на правила владения. Помните об этих правилах, пока мы работаем с примерами, которые их отображают:</p>
<ul>
<li>У каждого значения в Ржавчина есть <em>владелец</em>,</li>
<li>У значения может быть только один владелец в один мгновение времени,</li>
<li>Когда владелец покидает область видимости, значение удаляется.</li>
</ul>
<h3 id="Область-видимости-переменной"><a class="header" href="#Область-видимости-переменной">Область видимости переменной</a></h3>
<p>Теперь, когда мы прошли основной правила написания Rust, мы не будем включать весь код <code>fn main() {</code> в примеры. Поэтому, если вы будете следовать этому курсу, убедитесь, что следующие примеры помещены в функцию <code>main</code> вручную. В итоге наши примеры будут более краткими, что позволит нам сосредоточиться на существующих подробностях, а не на образцовом коде.</p>
<p>В качестве первого примера владения мы рассмотрим <em>область видимости</em> некоторых переменных. Область видимости — это рядвнутри программы, для которого допустим элемент. Возьмём следующую переменную:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>Переменная <code>s</code> относится к строковому записи, где значение строки жёстко прописано в тексте нашей программы. Переменная действительна с особенности её объявления до конца текущей <em>области видимости</em>. В приложении 4-1 показана программа с примечаниями, указывающими, где допустима переменная <code>s</code> .</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-1: переменная и область действия, в которой она допустима</span></p>
<p>Другими словами, здесь есть два важных особенности:</p>
<ul>
<li>Когда переменная <code>s</code> <em>появляется</em> в области видимости, она считается действительной,</li>
<li>Она остаётся действительной до особенности <em>выхода</em> за границы этой области.</li>
</ul>
<p>На этом этапе объяснения взаимосвязь между областями видимости и допустимостью переменных подобна той, что существует в других языках программирования. Теперь мы будем опираться на это понимание, введя вид <code>String</code>.</p>
<h3 id="Вид-данных-string"><a class="header" href="#Вид-данных-string">Вид данных <code>String</code></a></h3>
<p>Для отображения правил владения нам требуется более сложный вид данных чем те, что мы обсуждали в части <a href="ch03-02-data-types.html#data-types">"Виды данных"</a> Главы 3. Виды, рассмотренные ранее, имеют определённый размер, а значит могут быть размещены на обойме и извлечены из него, когда их область видимости закончится, и могут быть быстро и обыкновенно воспроизведены для создания новой, независимой повторы, если другой части кода нужно использовать то же самое значение в другой области видимости. Но мы хотим посмотреть на данные, хранящиеся в куче, и выяснить, как Ржавчина узнаёт, когда нужно очистить эти данные, поэтому вид <code>String</code> — отличный пример.</p>
<p>Мы сосредоточимся на тех частях <code>String</code>, которые связаны с владением. Эти особенности также применимы к другим сложным видам данных, независимо от того, предоставлены они встроенной библиотекой или созданы вами. Более подробно мы обсудим <code>String</code> в <a href="ch08-02-strings.html">главе 8</a><!-- ignore -->.</p>
<p>Мы уже видели строковые записи, где строковое значение жёстко прописано в нашей программе. Строковые записи удобны, но они подходят не для каждой случаи, где мы можем хотеть использовать текст. Одна из причин заключается в том, что они неизменны. Кроме того, не каждое строковое значение может быть известно во время написания кода: что, если мы захотим принять и сохранить пользовательский ввод? Для таких случаев в Ржавчина есть ещё один строковый вид — <code>String</code>. Этот вид управляет данными, выделенными в куче, и поэтому может хранить объём текста, который во время сборки неизвестен. Также вы можете создать <code>String</code> из строкового записи, используя функцию <code>from</code>, например:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>Оператор "Двойное двоеточие" <code>::</code> позволяет использовать пространство имён данной именно функции <code>from</code> с видом <code>String</code>, а не какое-то иное имя, такое как <code>string_from</code>. Мы обсудим этот правила написания более подробно в разделе <a href="ch05-03-method-syntax.html#method-syntax">«Синтаксис способа»</a>. раздел <!-- ignore --> Главы 5, и в ходе обсуждения пространств имён с звенами в <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"> «Пути для обращения к элементу в дереве звеньев»</a><!-- ignore --> в главе 7.</p>
<p>Строка такого вида <em>может</em> быть изменяема:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // This will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>В чем же тут разница? Почему строку <code>String</code> можно изменить, а записи — нельзя? Разница заключается в том, как эти два вида работают с памятью.</p>
<h3 id="Память-и-способы-её-выделения"><a class="header" href="#Память-и-способы-её-выделения">Память и способы её выделения</a></h3>
<p>В случае строкового записи мы знаем его содержимое во время сборки, и оно жёстко прописано в итоговом исполняемом файле. Причина того, что строковые записи более быстрые и эффективные, в их неизменяемости. К сожалению, нельзя поместить неопределённый кусок памяти в выполняемый файл для текста, размер которого неизвестен при сборки и может меняться во время выполнения программы.</p>
<p>Чтобы поддерживать изменяемый, увеличивающийся текст вида <code>String</code>, необходимо выделять память в куче для всего содержимого, размер которого неизвестен во время сборки. Это означает, что:</p>
<ul>
<li>Память должна запрашиваться у операционной системы во время выполнения программы,</li>
<li>Необходим способ возврата этой памяти операционной системе, когда мы закончили в программе работу со <code>String</code>.</li>
</ul>
<p>Первая часть выполняется нами: когда мы вызываем <code>String::from</code>, его выполнение запрашивает необходимую память. Это работает довольно похоже во всех языках программирования.</p>
<p>Однако вторая часть отличается. В языках со <em>сборщиком мусора (GC)</em>, память, которая больше не используется, отслеживается и очищается с его помощью — нам не нужно об этом думать. В большинстве языков без сборщика мусора мы обязаны сами определять, когда память больше не используется, и вызывать код для явного её освобождения, точно так же, как мы делали это для её запроса. Правильное выполнение этого этапа исторически было сложной неполадкой программирования. Если мы забудем освободить память, она будет потеряна. Если мы сделаем это слишком рано, у нас будет недопустимая переменная. Сделать это дважды — тоже будет ошибкой. Нам нужно соединить ровно один <code>allocate</code> ровно с одним <code>free</code>.</p>
<p>Rust выбирает другой путь: память самостоятельно возвращается, как только владеющая памятью переменная выходит из области видимости. Вот исполнение примера с областью видимости из приложения 4-1, в котором используется вид <code>String</code> вместо строкового записи:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}</span></code></pre></pre>
<p>Существует естественный мгновение, когда мы можем вернуть память, необходимую нашему <code>String</code>, обратно распределителю — когда <code>s</code> выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Ржавчина вызывает для нас особую функцию. Эта функция называется <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, и именно здесь автор <code>String</code> может поместить код для возврата памяти. Ржавчина самостоятельно вызывает <code>drop</code> после закрывающей фигурной скобки.</p>
<blockquote>
<p>Примечание: в C++ этот образец освобождения ресурсов в конце времени жизни элемента иногда называется <em>«Получение ресурса есть объявление» (англ. Resource Acquisition Is Initialization (RAII))</em>. Функция <code>drop</code> в Ржавчина покажется вам знакомой, если вы использовали образцы RAII.</p>
</blockquote>
<p>Этот образец оказывает глубокое влияние на способ написания кода в Rust. Сейчас это может казаться простым, но в более сложных случаейх поведение кода может быть неожиданным, например когда хочется иметь несколько переменных, использующих данные, выделенные в куче. Изучим несколько таких случаев.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-перемещения"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-перемещения">Взаимодействие переменных и данных с помощью перемещения</a></h4>
<p>Несколько переменных могут по-разному взаимодействовать с одними и теми же данными в Rust. Давайте рассмотрим пример использования целого числа в приложении 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-2. Присвоение целочисленного значения переменной <code>x</code> переменной <code>y</code></span></p>
<p>Мы можем догадаться, что делает этот код: «привязать значение <code>5</code> к <code>x</code>; затем сделать повтор значения в <code>x</code> и привязать его к <code>y</code>». Теперь у нас есть две переменные: <code>x</code> и <code>y</code>, и обе равны <code>5</code>. Это то, что происходит на самом деле, потому что целые числа — это простые значения с известным конечным размером, и эти два значения <code>5</code> помещаются в обойма.</p>
<p>Теперь рассмотрим исполнение с видом <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Это выглядит очень похоже, поэтому мы можем предположить, что происходит то же самое: вторая строка сделает повтор значения в <code>s1</code> и привяжет его к <code>s2</code>. Но это не совсем так.</p>
<p>Взгляните на рисунок 4-1, чтобы увидеть, что происходит со <code>String</code> под капотом. <code>String</code> состоит из трёх частей, показанных слева: указатель на память, в которой хранится содержимое строки, длина и ёмкость. Эта объединение данных хранится в обойме. Справа — память в куче, которая содержит содержимое.</p>
<img alt="Two tables: the first table contains the representation of s1 on the&lt;br&gt;stack, consisting of its length (5), capacity (5), and a pointer to the first&lt;br&gt;value in the second table. The second table contains the representation of the&lt;br&gt;string data on the heap, byte by byte." src="https://github.com/rust-lang-ru/book/blob/master/rustbook-ru/src/img/trpl04-01.svg?raw=true" class="">
<p><span class="caption">Рисунок 4-1: представление в памяти <code>String</code>, содержащей значение <code>"hello"</code>, привязанное к <code>s1</code></span></p>
<p>Длина — это объём памяти в байтах, который в настоящее время использует содержимое <code>String</code>. Ёмкость — это общий объём памяти в байтах, который <code>String</code> получил от распределителя. Разница между длиной и ёмкостью имеет значение, но не в этом среде, поэтому на данный мгновение можно пренебрегать ёмкость.</p>
<p>Когда мы присваиваем <code>s1</code> значению <code>s2</code>, данные <code>String</code> повторяются, то есть мы повторяем указатель, длину и ёмкость, которые находятся в обойме. Мы не повторяем данные в куче, на которые указывает указатель. Другими словами, представление данных в памяти выглядит так, как показано на рис. 4-2.</p>
<img alt="Three tables: tables s1 and s2 representing those strings on the&lt;br&gt;stack, respectively, and both pointing to the same string data on the heap." src="https://github.com/rust-lang-ru/book/blob/master/rustbook-ru/src/img/trpl04-02.svg?raw=true" class="">
<p><span class="caption">Рисунок 4-2: представление в памяти переменной <code>s2</code>, имеющей повтор указателя, длины и ёмкости <code>s1</code></span></p>
<p>Представление <em>не</em> похоже на рисунок 4-3, как выглядела бы память, если бы вместо этого Ржавчина также воспроизвел данные кучи. Если бы Ржавчина сделал это, действие <code>s2 = s1</code> могла бы быть очень дорогой с точки зрения производительности во время выполнения, если бы данные в куче были большими.</p>
<img alt="Two tables: the first table contains the representation of s1 on the&lt;br&gt;stack, consisting of its length (5), capacity (5), and a pointer to the first&lt;br&gt;value in the second table. The second table contains the representation of the&lt;br&gt;string data on the heap, byte by byte." src="https://github.com/rust-lang-ru/book/blob/master/rustbook-ru/src/img/trpl04-01.svg?raw=true" class="">
<p><span class="caption">Рисунок 4-3: другой исход того, что может сделать <code>s2 = s1</code>, если Ржавчина также воспроизведет данные кучи</span></p>
<p>Ранее мы сказали, что когда переменная выходит за пределы области видимости, Ржавчина самостоятельно вызывает функцию <code>drop</code> и очищает память в куче для данной переменной. Но на рис. 4.2 оба указателя данных указывают на одно и то же место. Это неполадка: когда переменные <code>s2</code> и <code>s1</code> выходят из области видимости, они обе будут пытаться освободить одну и ту же память в куче. Это известно как <em>ошибка двойного освобождения (double free)</em> и является одной из ошибок безопасности памяти, упоминаемых ранее. Освобождение памяти дважды может привести к повреждению памяти, что возможно может привести к уязвимостям безопасности.</p>
<p>Чтобы обеспечить безопасность памяти, после строки <code>let s2 = s1;</code> , Ржавчина считает <code>s1</code> более недействительным. Следовательно, Ржавчина не нужно ничего освобождать, когда <code>s1</code> выходит за пределы области видимости. Посмотрите, что происходит, когда вы пытаетесь использовать <code>s1</code> после создания <code>s2</code> ; это не сработает:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>Вы получите похожую ошибку, потому что Ржавчина не позволяет вам использовать недействительную ссылку:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Если вы слышали понятия <em>поверхностное повторение</em> и <em>глубокое повторение</em> при работе с другими языками, подход повторения указателя, длины и ёмкости без повторения данных, вероятно, звучит как создание поверхностной повторы. Но поскольку Ржавчина также аннулирует первую переменную, вместо того, чтобы называть это поверхностным повторением, это называется <em>перемещением</em>. В этом примере мы бы сказали, что <code>s1</code> был <em>перемещён</em> в <code>s2</code>. Итак, что на самом деле происходит, показано на рисунке 4-4.</p>
<img alt="Три таблицы: таблицы s1 и s2, представляющие эти строки в обойме соответственно, и обе указывающие на одни и те же строковые данные в куче. Таблица s1 выделена серым цветом, потому что s1 больше недействительна; только s2 можно использовать для доступа к данным кучи." src="img/trpl04-04.svg" class="center" style="width: 50%;">
<p><span class="caption">Рисунок 4-4: представление в памяти после того, как <code>s1</code> был признан недействительным</span></p>
<p>Это решает нашу неполадку! Действительной остаётся только переменная <code>s2</code>. Когда она выходит из области видимости, то она одна будет освобождать память в куче.</p>
<p>Такой выбор внешнего вида языка даёт дополнительное преимущество: Ржавчина никогда не будет самостоятельно создавать «глубокие» повторы ваших данных. Следовательно любое такое <em>самостоятельное</em> повторение можно считать недорогим с точки зрения производительности во время выполнения.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-клонирования"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-клонирования">Взаимодействие переменных и данных с помощью клонирования</a></h4>
<p>Если мы <em>хотим</em> глубоко воспроизвести данные кучи <code>String</code>, а не только данные обоймы, мы можем использовать общий способ, называемый <code>clone</code>. Мы обсудим правила написания способов в главе 5, но поскольку способы являются общей чертой многих языков программирования, вы, вероятно, уже встречались с ними.</p>
<p>Вот пример работы способа <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>Это отлично работает и очевидно приводит к поведению, представленному на рисунке 4-3, где данные кучи <em>были</em> воспроизведены.</p>
<p>Когда вы видите вызов <code>clone</code>, вы знаете о выполнении некоторого кода, который может быть дорогим. В то же время использование <code>clone</code> является визуальным индикатором того, что тут происходит что-то необычное.</p>
<h4 id="Из-обоймы-данные-повторение"><a class="header" href="#Из-обоймы-данные-повторение">Из обоймы данные: повторение</a></h4>
<p>Это ещё одна особенность о которой мы ранее не говорили. Этот код, часть которого была показа ранее в приложении 4-2, использует целые числа. Он работает без ошибок:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>Но этот код, кажется, противоречит тому, что мы только что узнали: у нас нет вызова <code>clone</code>, но <code>x</code> всё ещё действителен и не был перемещён в <code>y</code>.</p>
<p>Причина в том, что такие виды, как целые числа, размер которых известен во время сборки, полностью хранятся в обойме, поэтому повторы действительных значений создаются быстро. Это означает, что нет причин, по которым мы хотели бы предотвратить доступность <code>x</code> после того, как создадим переменную <code>y</code>. Другими словами, здесь нет разницы между глубоким и поверхностным повторением, поэтому вызов <code>clone</code> ничем не отличается от обычного поверхностного повторения, и мы можем его опустить.</p>
<p>В Ржавчина есть особая изложение, называемая особенностью <code>Copy</code>, которую мы можем размещать на видах, хранящихся в обойме, как и целые числа (подробнее о видах мы поговорим в <a href="ch10-02-traits.html">главе 10</a><!-- ignore -->). Если вид выполняет особенность <code>Copy</code>, переменные, которые его используют, не перемещаются, а обыкновенно повторяются, что делает их действительными после присвоения другой переменной.</p>
<p>Rust не позволит нам определять вид с помощью <code>Copy</code>, если вид или любая из его частей выполняет <code>Drop</code>. Если для вида нужно, чтобы произошло что-то особенное, когда значение выходит за пределы области видимости, и мы добавляем изложение <code>Copy</code> к этому виду, мы получим ошибку времени сборки. Чтобы узнать, как добавить изложение <code>Copy</code> к вашему виду для выполнения особенности, смотрите <a href="appendix-03-derivable-traits.html">раздел «Производные особенности»</a><!-- ignore --> в приложении С.</p>
<p>Но какие же виды выполняют особенность <code>Copy</code>? Можно проверить документацию любого вида для уверенности, но как правило любая объединение простых одиночных значений может быть выполнить <code>Copy</code>, и никакие виды, которые требуют выделения памяти в куче или являются некоторой способом ресурсов, не выполняют особенности <code>Copy</code>. Вот некоторые виды, которые выполняют <code>Copy</code>:</p>
<ul>
<li>Все целочисленные виды, такие как <code>u32</code>,</li>
<li>Логический вид данных <code>bool</code>, возможные значения которого <code>true</code> и <code>false</code>,</li>
<li>Все виды с плавающей запятой, такие как <code>f64</code>.</li>
<li>Символьный вид <code>char</code>,</li>
<li>Упорядоченные ряды, но только если они содержат виды, которые также выполняют <code>Copy</code>. Например, <code>(i32, i32)</code> будет с <code>Copy</code>, но упорядоченный ряд <code>(i32, String)</code> уже нет.</li>
</ul>
<h3 id="Владение-и-функции"><a class="header" href="#Владение-и-функции">Владение и функции</a></h3>
<p>Механика передачи значения функции подобна тому, что происходит при присвоении значения переменной. Передача переменной в функцию приведёт к перемещению или воспроизведению, как и присваивание. В приложении 4-3 есть пример с некоторыми изложениями, показывающими, где переменные входят в область видимости и выходят из неё.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{some_string}");
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{some_integer}");
} // Here, some_integer goes out of scope. Nothing special happens.</code></pre></pre>
<p><span class="caption">Приложение 4-3. Функции с определенными владельцами и областью действия</span></p>
<p>Если попытаться использовать <code>s</code> после вызова <code>takes_ownership</code>, Ржавчина выдаст ошибку времени сборки. Такие постоянные проверки защищают от ошибок. Попробуйте добавить код в <code>main</code>, который использует переменную <code>s</code> и <code>x</code>, чтобы увидеть где их можно использовать и где правила владения предотвращают их использование.</p>
<h3 id="Возвращение-значений-и-область-видимости"><a class="header" href="#Возвращение-значений-и-область-видимости">Возвращение значений и область видимости</a></h3>
<p>Возвращаемые значения также могут передавать право владения. В приложении 4-4 показан пример функции, возвращающей некоторое значение, с такими же изложениями, как в приложении 4-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}</code></pre></pre>
<p><span class="caption">Приложение 4-4: передача права владения на возвращаемые значения</span></p>
<p>Владение переменной каждый раз следует одному и тому же образцу: присваивание значения другой переменной перемещает его. Когда переменная, содержащая данные в куче, выходит из области видимости, содержимое в куче будет очищено функцией <code>drop</code>, если только данные не были перемещены во владение другой переменной.</p>
<p>Хотя это работает, получение права владения, а затем возвращение владения каждой функцией немного утомительно. Что, если мы хотим, чтобы функция использовала значение, но не становилась владельцем? Очень раздражает, что всё, что мы передаём, также должно быть передано обратно, если мы хотим использовать это снова, в дополнение к любым данным, полученным из тела функции, которые мы также можем захотеть вернуть.</p>
<p>Rust позволяет нам возвращать несколько значений с помощью упорядоченного ряда, как показано в приложении 4-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre></pre>
<p><span class="caption">Приложение 4-5: возврат права владения на свойства</span></p>
<p>Но это слишком высокопарно и многословно для подходы, которая должна быть общей. К счастью для нас, в Ржавчина есть возможность использовать значение без передачи права владения, называемая <em>ссылками</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Ссылки-и-заимствование"><a class="header" href="#Ссылки-и-заимствование">Ссылки и заимствование</a></h2>
<p>Неполадкас кодом упорядоченного ряда в приложении 4-5 заключается в том, что мы должны вернуть <code>String</code> из вызванной функции, чтобы использовать <code>String</code> после вызова <code>calculate_length</code>, потому что <code>String</code> была перемещена в <code>calculate_length</code>. Вместо этого мы можем предоставить ссылку на значение <code>String</code>. <em>Ссылка</em> похожа на указатель в том смысле, что это адрес, по которому мы можем проследовать, чтобы получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка обязательно указывает на допустимое значение определённого вида в течение всего срока существования этой ссылки.</p>
<p>Вот как вы могли бы определить и использовать функцию <code>calculate_length</code>, имеющую ссылку на предмет в качестве свойства, вместо того, чтобы брать на себя ответственность за значение:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>Во-первых, обратите внимание, что весь код упорядоченного ряда в объявлении переменной и возвращаемое значение функции исчезли. Во-вторых, обратите внимание, что мы передаём <code>&amp;s1</code> в <code>calculate_length</code> и в его определении используем <code>&amp;String</code>, а не <code>String</code>. Эти знаки представляют собой <em>ссылки</em>, и они позволяют вам ссылаться на некоторое значение, не принимая владение над ним. Рисунок 4-5 изображает эту подход.</p>
<img alt="&amp;String s pointing at String s1" src="img/trpl04-05.svg" class="">
<p><span class="caption">Рисунок 4-5: диаграмма для <code>&amp;String s</code>, указывающей на <code>String s1</code></span></p>
<blockquote>
<p>Примечание: противоположностью ссылки с использованием <code>&amp;</code> является <em>разыменование</em>, выполняемое с помощью оператора разыменования <code>*</code>. Мы увидим некоторые исходы использования оператора разыменования в главе 8 и обсудим подробности разыменования в главе 15.</p>
</blockquote>
<p>Давайте подробнее рассмотрим рычаг вызова функции:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("The length of '{s1}' is {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> позволяет нам создать ссылку, которая <em>ссылается</em> на значение <code>s1</code>, но не владеет им. Поскольку она не владеет им, значение, на которое она указывает, не будет удалено, когда ссылка перестанет использоваться.</p>
<p>Ярлык функции использует <code>&amp;</code> для индикации того, что вид свойства <code>s</code> является ссылкой. Добавим объясняющие примечания:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("The length of '{s1}' is {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.</code></pre></pre>
<p>Область действия <code>s</code> такая же, как и область действия любого свойства функции, но значение, на которое указывает ссылка, не удаляется, когда <code>s</code> перестаёт использоваться, потому что <code>s</code> не является его владельцем. Когда функции имеют ссылки в качестве свойств вместо действительных значений, нам не нужно возвращать значения, чтобы вернуть право владения, потому что мы никогда не владели ими.</p>
<p>Мы называем этап создания ссылки <em>заимствованием</em>. Как и в существующей жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть это законному владельцу.</p>
<p>А что произойдёт, если попытаться изменить то, что было позаимствовано? Попробуйте код приложения 4-6 Спойлер: этот код не сработает!</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
<p><span class="caption">Приложение 4-6: попытка изменения заимствованной переменной</span></p>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Как переменные неизменяемы по умолчанию, так и ссылки. Нам не разрешено изменять то, на что у нас есть ссылка.</p>
<h3 id="Изменяемые-ссылки"><a class="header" href="#Изменяемые-ссылки">Изменяемые ссылки</a></h3>
<p>Мы можем исправить код из приложения 4-6, чтобы позволить себе изменять заимствованное значение, с помощью нескольких небольших настроек, которые используют <em>изменяемую ссылку</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
<p>Сначала мы меняем <code>s</code> на <code>mut</code>. Затем мы создаём изменяемую ссылку с помощью <code>&amp;mut s</code>, у которой вызываем <code>change</code> и обновляем ярлык функции, чтобы принять изменяемую ссылку с помощью <code>some_string: &amp;mut String</code>. Это даёт понять, что <code>change</code> изменит значение, которое заимствует.</p>
<p>Изменяемые ссылки имеют одно большое ограничение: если у вас есть изменяемая ссылка на значение, у вас не может быть других ссылок на это же значение. Код, который пытается создать две изменяемые ссылки на <code>s</code>, завершится ошибкой:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
<span class="boring">}</span></code></pre>
<p>Описание ошибки:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Эта ошибка говорит о том, что код недействителен, потому что мы не можем заимствовать <code>s</code> как изменяемые более одного раза в один мгновение. Первое изменяемое заимствование находится в <code>r1</code> и должно длиться до тех пор, пока оно не будет использовано в <code>println!</code>, но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку в <code>r2</code>, которая заимствует те же данные, что и <code>r1</code>.</p>
<p>Ограничение, предотвращающее одновременное использование нескольких изменяемых ссылок на одни и те же данные, допускает изменение, но очень управляющим образом. Это то, с чем борются новые Rustaceans, потому что большинство языков позволяют изменять значение в любой мгновение. Преимущество этого ограничения заключается в том, что Ржавчина может предотвратить гонку данных во время сборки. <em>Гонка данных</em> похожа на состояние гонки и происходит, когда возникают следующие три сценария:</p>
<ul>
<li>Два или больше указателей используют одни и те же данные в одно и то же время,</li>
<li>Самое наименьшее один указатель используется для записи данных,</li>
<li>Отсутствуют рычаги для согласования доступа к данным.</li>
</ul>
<p>Гонки данных вызывают неопределённое поведение, и их может быть сложно диагностировать и исправить, когда вы пытаетесь отследить их во время выполнения. Ржавчина предотвращает такую неполадку, отказываясь собирать код с гонками данных!</p>
<p>Как всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не <em>одновременно</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust применяет подобное правило для соединения изменяемых и неизменяемых ссылок. Этот код приводит к ошибке:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>Ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Вау! У нас <em>также</em> не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение.</p>
<p>Пользователи неизменяемой ссылки не ожидают, что значение внезапно изменится из-под них! Однако разрешены множественные неизменяемые ссылки, потому что никто, кто просто читает данные, не может повлиять на чтение данных кем-либо ещё.</p>
<p>Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, этот код будет собираться, потому что последнее использование неизменяемых ссылок <code>println!</code>, происходит до того, как вводится изменяемая ссылка:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!("{r1} and {r2}");
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>Области неизменяемых ссылок <code>r1</code> и <code>r2</code> заканчиваются после <code>println!</code> где они использовались в последний раз, то есть до создания изменяемой ссылки <code>r3</code>. Эти области не перекрываются, поэтому этот код разрешён: сборщик может сказать, что ссылка больше не используется в точке перед концом области.</p>
<p>Несмотря на то, что ошибки заимствования могут иногда вызывать разочарование, помните, что сборщик Ржавчина заранее указывает на вероятную ошибку (во время сборки, а не во время выполнения) и точно показывает, в чем неполадка. Тогда вам не придётся выяснять, почему ваши данные оказались не такими, как вы ожидали.</p>
<h3 id="Висячие-ссылки"><a class="header" href="#Висячие-ссылки">Висячие ссылки</a></h3>
<p>В языках с указателями весьма легко ошибочно создать недействительную (висячую) <em>(dangling)</em> ссылку. Ссылку указывающую на участок памяти, который мог быть передан кому-то другому, путём освобождения некоторой памяти при сохранении указателя на эту память. Ржавчина сборщик заверяет, что ссылки никогда не станут недействительными: если у вас есть ссылка на какие-то данные, сборщик обеспечит что эти данные не выйдут из области видимости прежде, чем из области видимости исчезнет ссылка.</p>
<p>Давайте попробуем создать висячую ссылку, чтобы увидеть, как Ржавчина предотвращает их появление с помощью ошибки во время сборки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
<p>Здесь ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
</code></pre>
<p>Это сообщение об ошибке относится к особенности языка, которую мы ещё не рассмотрели: времени жизни. Мы подробно обсудим времена жизни в главе 10. Но если вы не обращаете внимания на части, касающиеся времени жизни, сообщение будет содержать ключ к тому, почему этот код является неполадкой:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Давайте подробнее рассмотрим, что именно происходит на каждом этапе нашего кода <code>dangle</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!</code></pre>
<p>Поскольку <code>s</code> создаётся внутри <code>dangle</code>, когда код <code>dangle</code> будет завершён, <code>s</code> будет освобождена. Но мы попытались вернуть ссылку на неё. Это означает, что эта ссылка будет указывать на недопустимую <code>String</code>. Это нехорошо! Ржавчина не позволит нам сделать это.</p>
<p>Решением будет вернуть непосредственно <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>Это работает без неполадок. Владение перемещено, и ничего не освобождено.</p>
<h3 id="Правила-работы-с-ссылками"><a class="header" href="#Правила-работы-с-ссылками">Правила работы с ссылками</a></h3>
<p>Давайте повторим  все, что мы обсудили про ссылки:</p>
<ul>
<li>В любой мгновение времени у вас может быть <em>одна</em> (но не обе) изменяемая ссылка или любое количество неизменяемых ссылок.</li>
<li>Все ссылки должны быть действительными.</li>
</ul>
<p>В следующей главе мы рассмотрим другой вид ссылок — срезы.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Вид-срезы"><a class="header" href="#Вид-срезы">Вид срезы</a></h2>
<p><em>Срезы</em> позволяют ссылаться на непрерывную последовательность элементов в собрания, а не на всю собрание. Срез является своего рода ссылкой, поэтому он не имеет права владения.</p>
<p>Вот небольшая неполадка программирования: напишите функцию, которая принимает строку слов, разделённых пробелами, и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробела в строке, вся строка должна состоять из одного слова, поэтому должна быть возвращена вся строка.</p>
<p>Давайте рассмотрим, как бы мы написали ярлык этой функции без использования срезов, чтобы понять неполадку, которую решат срезы:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>Функция <code>first_word</code> имеет <code>&amp;String</code> в качестве свойства. Мы не хотим владения, так что всё в порядке. Но что мы должны вернуть? На самом деле у нас нет способа говорить о <em>части</em> строки. Однако мы могли бы вернуть порядковый указательконца слова, обозначенного пробелом. Давайте попробуем, как показано в Приложении 4-7.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 4-7. Функция <code>first_word</code>, возвращающая значение порядкового указателя байта в свойство <code>String</code></span></p>
<p>Поскольку нам нужно просмотреть <code>String</code> поэлементно и проверить, является ли значение пробелом, мы преобразуем нашу <code>String</code> в массив байтов с помощью способа <code>as_bytes</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Далее, мы создаём <em>повторитель </em> по массиву байт используя способ <code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Мы обсудим повторители более подробно в <a href="ch13-02-iterators.html">Главе 13</a><!-- ignore -->. На данный мгновение знайте, что <code>iter</code> — это способ, который возвращает каждый элемент в собрания, а <code>enumerate</code> оборачивает итог <code>iter</code> и вместо этого возвращает каждый элемент как часть упорядоченного ряда. Первый элемент упорядоченного ряда, возвращаемый из <code>enumerate</code>, является порядковым указателем, а второй элемент — ссылкой на элемент. Это немного удобнее, чем вычислять порядковый указательсамостоятельно.</p>
<p>Поскольку способ <code>enumerate</code> возвращает упорядоченный ряд, мы можем использовать образцы для разъединения этого упорядоченного ряда. Мы подробнее обсудим образцы в <a href="ch06-02-match.html#patterns-that-bind-to-values">Главе 6.</a><!-- ignore -->. В цикле <code>for</code> мы указываем образец, имеющий <code>i</code> для порядкового указателя в упорядоченном ряде и <code>&amp;item</code> для одного байта в упорядоченном ряде. Поскольку мы получаем ссылку на элемент из <code>.iter().enumerate()</code>, мы используем <code>&amp;</code> в образце.</p>
<p>Внутри цикла <code>for</code> мы ищем байт, представляющий пробел, используя правила написания байтового записи. Если мы находим пробел, мы возвращаем положение. В противном случае мы возвращаем длину строки с помощью <code>s.len()</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Теперь у нас есть способ узнать порядковый указательбайта указывающего на конец первого слова в строке, но есть неполадка. Мы возвращаем сам <code>usize</code>, но это число имеет значение только в среде <code>&amp;String</code>. Другими словами, поскольку это значение отдельное от <code>String</code>, то нет заверения, что оно все ещё будет действительным в будущем. Рассмотрим программу из приложения 4-8, которая использует функцию <code>first_word</code> приложения 4-7.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}</code></pre></pre>
<p><span class="caption">Приложение 4-8. Сохранение итога вызова функции <code>first_word</code> и последующего изменения содержимого <code>String</code></span></p>
<p>Данная программа собирается без ошибок и будет успешно работать, даже после того как мы воспользуемся переменной <code>word</code> после вызова <code>s.clear()</code>. Так как значение <code>word</code> совсем не связано с состоянием переменной <code>s</code>, то <code>word</code> сохраняет своё значение <code>5</code> без изменений. Мы бы могли воспользоваться значением <code>5</code> чтобы получить первое слово из переменной <code>s</code>, но это приведёт к ошибке, потому что содержимое <code>s</code> изменилось после того как мы сохранили <code>5</code> в переменной <code>word</code> (стало пустой строкой в вызове <code>s.clear()</code>).</p>
<p>Необходимость беспокоиться о том, что порядковый указательв переменной <code>word</code> не согласуется с данными в переменной  <code>s</code> является утомительной и подверженной ошибкам! Управление этими порядковыми указателями становится ещё более хрупким, если мы напишем функцию <code>second_word</code>. Её ярлык могла бы выглядеть так:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Теперь мы отслеживаем начальный <em>и</em> конечный порядковый указатель, и у нас есть ещё больше значений, которые были рассчитаны на основе данных в определённом состоянии, но вообще не привязаны к этому состоянию. У нас есть три несвязанные переменные, которые необходимо согласовать.</p>
<p>К счастью в Ржавчина есть решение данной сбоев: строковые срезы.</p>
<h3 id="Строковые-срезы"><a class="header" href="#Строковые-срезы">Строковые срезы</a></h3>
<p>Строковый срез - это ссылка на часть строки <code>String</code> и он выглядит следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>Вместо ссылки на всю <code>String</code> <code>hello</code> является ссылкой на часть <code>String</code>, указанную в дополнительном куске кода <code>[0..5]</code>. Мы создаём срезы, используя рядв квадратных скобках, указав <code>[starting_index..ending_index]</code>, где <code>starting_index</code> — это первая позиция, а<code>ending_index</code> конечный_порядковый указатель— это на единицу больше, чем последняя позиция в срезе. Внутри устройства данных среза хранит начальную положение и длину среза, что соответствует <code>ending_index</code> - <code>starting_index</code>. Итак, в случае <code>let world = &amp;s[6..11];</code>, <code>world</code> будет срезом, содержащим указатель на байт с порядковым указателем 6 <code>s</code> со значением длины <code>5</code>.</p>
<p>Рисунок 4-6 отображает это на диаграмме.</p>
 <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="">
<p><span class="caption">Рисунок 4-6: Строковый срез ссылается на часть <code>String</code></span></p>
<p>С правилами написания Ржавчина <code>..</code>, если вы хотите начать с порядкового указателя 0, вы можете отбросить значение перед двумя точками. Другими словами, они равны:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>Таким же образом, если ваш срез включает последний байт <code>String</code>, вы можете отбросить конечный номер. Это означает, что они равны:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>Вы также можете отбросить оба значения, чтобы получить часть всей строки. Итак, они равны:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Примечание. Порядковые указатели ряда срезов строк должны располагаться на допустимых границах символов UTF-8. Если вы попытаетесь создать отрывок строки нарушая границы символа в котором больше одного байта, ваша программа завершится с ошибкой. В целях введения срезов строк мы предполагаем, что в этом разделе используется только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">«Сохранение закодированного текста UTF-8 со строками»</a>.<!-- ignore --> раздел главы 8.</p>
</blockquote>
<p>Давайте используем полученную сведения и перепишем способ <code>first_word</code> так, чтобы он возвращал срез. Для обозначения вида "срез строки" существует запись <code>&amp;str</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Мы получаем порядковый указательконца слова так же, как в приложении 4.7, ища первое вхождение пробела. Когда мы находим пробел, мы возвращаем отрывок строки, используя начало строки и порядковый указательпробела в качестве начального и конечного порядковых указателей.</p>
<p>Теперь, когда мы вызываем <code>first_word</code>, мы возвращаем одно значение, привязанное к основным данным. Значение состоит из ссылки на начальную точку среза и количества элементов в срезе.</p>
<p>Подобным образом можно переписать и второй способ <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Теперь у нас есть простой API, который гораздо сложнее испортить, потому что сборщик заверяет, что ссылки в <code>String</code> останутся действительными. Помните ошибку в программе в приложении 4-8, когда мы получили порядковый указательдо конца первого слова, но затем очиисполнения строку, так что наш порядковый указательстал недействительным? Этот код был логически неправильным, но не показывал немедленных ошибок. Неполадки проявятся позже, если мы попытаемся использовать порядковый указательпервого слова с пустой строкой. Срезы делают эту ошибку невозможной и сообщают нам о неполадке с нашим кодом гораздо раньше. Так, использование исполнения способа <code>first_word</code> со срезом вернёт ошибку сборки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!("the first word is: {word}");
}</code></pre>
<p>Ошибка сборки:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на что-то, мы не можем также взять изменяемую ссылку. Поскольку для <code>clear</code> необходимо обрезать <code>String</code>, необходимо получить изменяемую ссылку. <code>println!</code> после вызова <code>clear</code> использует ссылку в <code>word</code>, поэтому неизменяемая ссылка в этот мгновение всё ещё должна быть активной. Ржавчина запрещает одновременное существование изменяемой ссылки в виде<code>clear</code> и неизменяемой ссылки в <code>word</code>, и сборка завершается ошибкой. Ржавчина не только упростил использование нашего API, но и устранил целый класс ошибок во время сборки!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="Строковые-записи---это-срезы"><a class="header" href="#Строковые-записи---это-срезы">Строковые записи - это срезы</a></h4>
<p>Напомним, что мы говорили о строковых записях, хранящихся внутри двоичного файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые записи:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>Вид <code>s</code> здесь <code>&amp;str</code>: это срез, указывающий на эту определенную точку двоичного файла. Вот почему строковые записи неизменяемы; <code>&amp;str</code> — неизменяемая ссылка.</p>
<h4 id="Строковые-срезы-как-свойства"><a class="header" href="#Строковые-срезы-как-свойства">Строковые срезы как свойства</a></h4>
<p>Знание того, что вы можете брать срезы записей и <code>String</code> значений, приводит нас к ещё одному улучшению <code>first_word</code>, и это его ярлык:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Более опытный пользователь Rustacean вместо этого написал бы ярлык, показанную в приложении 4.9, потому что это позволяет нам использовать одну и ту же функцию как для значений <code>&amp;String</code>, так и для значений <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 4-9: Улучшение функции <code>first_word</code> используя вид строкового среза для свойства <code>s</code></span></p>
<p>Если у нас есть отрывок строки, мы можем передать его напрямую. Если у нас есть <code>String</code>, мы можем передать часть <code>String</code> или ссылку на <code>String</code>. Эта гибкость использует преимущества <em>приведения deref</em>, функции, которую мы рассмотрим в <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">разделе «Неявное приведение Deref с функциями и способами».</a><!-- ignore --> раздел главы 15.</p>
<p>Определение функции для получения отрывка строки вместо ссылки на <code>String</code> делает наш API более общим и полезным без потери какой-либо возможности:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
<h3 id="Другие-срезы"><a class="header" href="#Другие-срезы">Другие срезы</a></h3>
<p>Срезы строк, как вы можете себе представить, отличительны для строк. Но есть и более общий вид среза. Рассмотрим этот массив:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Точно так же, как мы можем захотеть сослаться на часть строки, мы можем захотеть сослаться на часть массива. Мы бы сделали так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Этот срез имеет вид <code>&amp;[i32]</code>. Он работает так же, как и срезы строк, сохраняя ссылку на первый элемент и его длину. Вы будете использовать этот вид отрывка для всех видов других собраний. Мы подробно обсудим эти собрания, когда будем говорить о векторах в главе 8.</p>
<h2 id="Итоги-2"><a class="header" href="#Итоги-2">Итоги</a></h2>
<p>Подходы владения, заимствования и срезов обеспечивают безопасность памяти в программах на Ржавчина во время сборки. Язык Ржавчина даёт вам управление над использованием памяти так же, как и другие языки системного программирования, но то, что владелец данных самостоятельно очищает эти данные, когда владелец выходит за рамки, означает, что вам не нужно писать и отлаживать дополнительный код, чтобы получить этот управление.</p>
<p>Владение влияет на множество других частей и подходов языка Rust. Мы будем говорить об этих подходах на протяжении оставшихся частей книги. Давайте перейдём к Главе 5 и рассмотрим объединение частей данных в устройства <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Использование-устройств-для-внутреннего-выстраивания"><a class="header" href="#Использование-устройств-для-внутреннего-выстраивания">Использование устройств для внутреннего выстраивания</a></h1>
<p>связанных данных</p>
<p><em>Устройства (struct)</em> — это пользовательский вид данных, позволяющий назвать и упаковать вместе несколько связанных значений, составляющих значимую логическую объединение. Если вы знакомы с предметно-направленными языками, <em>устройства</em> похожа на свойства данных предмета. В этой главе мы сравним и сопоставим упорядоченные ряды со устройствами, чтобы опираться на то, что вы уже знаете, и отобразим, когда устройства являются лучшим способом объединения данных.</p>
<p>Мы отобразим, как определять устройства и создавать их образцы. Мы обсудим, как определить сопряженные функции, особенно сопряженные функции, называемые <em>способами</em>, для указания поведения, сопряженного с видом устройства. Устройства и перечисления (обсуждаемые в главе 6) являются строительными разделами для создания новых видов в предметной области вашей программы. Они дают возможность в полной мере воспользоваться преимуществами проверки видов во время сборки Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Определение-и-объявление-устройств"><a class="header" href="#Определение-и-объявление-устройств">Определение и объявление устройств</a></h2>
<p>Устройства похожи на упорядоченные ряды, рассмотренные в разделе <a href="ch03-02-data-types.html#the-tuple-type">"Упорядоченные ряды"</a><!-- ignore -->, так как оба хранят несколько связанных значений. Как и упорядоченные ряды, части устройств могут быть разных видов. В отличие от упорядоченных рядов, в устройстве необходимо именовать каждую часть данных для понимания смысла значений. Добавление этих имён обеспечивает большую гибкость устройств по сравнению с упорядоченнымм рядами: не нужно полагаться на порядок данных для указания значений образца или доступа к ним.</p>
<p>Для определения устройства указывается ключевое слово <code>struct</code> и её название. Название должно описывать значение частей данных, объединенных вместе. Далее, в фигурных скобках для каждой новой части данных поочерёдно определяются имя части данных и её вид. Каждая пара <code>имя: тип</code> называется <em>полем</em>. Приложение 5-1 описывает устройство для хранения сведений об учётной записи пользователя:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 5-1: Определение устройства <code>User</code></span></p>
<p>После определения устройства можно создавать её <em>образец</em>, назначая определённое значение каждому полю с соответствующим видом данных. Чтобы создать образец, мы указываем имя устройства, затем добавляем фигурные скобки и включаем в них пары <code>ключ: значение</code> (key: value), где ключами являются имена полей, а значениями являются данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления полей в описании устройства (но всё-таки желательно для удобства чтения). Другими словами, объявление устройства - это как образец нашего вида, в то время как образец устройства использует этот образец, заполняя его определёнными данными, для создания значений нашего вида. Например, можно объявить пользователя как в приложении 5-2:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<p><span class="caption">Приложение 5-2: Создание образца устройства <code>User</code></span></p>
<p>Чтобы получить определенное значение из устройства, мы используем запись через точку. Например, чтобы получить доступ к адресу электронной почты этого пользователя, мы используем <code>user1.email</code>. Если образец является изменяемым, мы можем поменять значение, используя точечную наставление и присвоение к определенному полю. В Приложении 5-3 показано, как изменить значение в поле <code>email</code> изменяемого образца <code>User</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
<p><span class="caption">Приложение 5-3: Изменение значения в поле <code>email</code> образца <code>User</code></span></p>
<p>Стоит отметить, что весь образец устройства должен быть изменяемым; Ржавчина не позволяет помечать изменяемыми отдельные поля. Как и для любого другого выражения, мы можем использовать выражение создания устройства в качестве последнего выражения тела функции для неявного возврата нового образца.</p>
<p>На приложении 5-4 функция <code>build_user</code> возвращает образец <code>User</code> с указанным адресом и именем. Поле <code>active</code> получает значение <code>true</code>, а поле <code>sign_in_count</code> получает значение <code>1</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-4: Функция <code>build_user</code>, которая принимает email и имя пользователя и возвращает образец <code>User</code></span></p>
<p>Имеет смысл называть свойства функции теми же именами, что и поля устройства, но необходимость повторять <code>email</code> и <code>username</code> для названий полей и переменных несколько утомительна. Если устройства имеет много полей,  повторение каждого имени станет ещё более раздражающим. К счастью, есть удобное сокращение!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="Использование-сокращённой-объявления-поля"><a class="header" href="#Использование-сокращённой-объявления-поля">Использование сокращённой объявления поля</a></h3>
<p>Так как имена входных свойств функции и полей устройства являются полностью равноценными в приложении 5-4, возможно использовать правила написания <em>сокращённой объявления поля</em>, чтобы переписать <code>build_user</code> так, чтобы он работал точно также, но не содержал повторений для <code>username</code> и <code>email</code>, как в приложении 5-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-5: функция <code>build_user</code> использует сокращённую объявление полей, потому что её входные свойства <code>username</code> и <code>email</code> имеют имена подобные именам полей устройства</span></p>
<p>Здесь происходит создание нового образца устройства <code>User</code>, которая имеет поле с именем <code>email</code>. Мы хотим установить поле устройства <code>email</code> значением входного свойства <code>email</code> функции <code>build_user</code>. Так как поле <code>email</code> и входной свойство функции <code>email</code> имеют одинаковое название, можно писать просто <code>email</code> вместо кода <code>email: email</code>.</p>
<h3 id="Создание-образца-устройства-из-образца-другой-устройства-с-помощью-правил-написания-обновления-устройства"><a class="header" href="#Создание-образца-устройства-из-образца-другой-устройства-с-помощью-правил-написания-обновления-устройства">Создание образца устройства из образца другой устройства с помощью правил написания обновления устройства</a></h3>
<p>Часто бывает полезно создать новый образец устройства, который включает большинство значений из другого образца, но некоторые из них изменяет. Это можно сделать с помощью <em>правил написания обновления устройства</em>.</p>
<p>Сначала в приложении 5-6 показано, как обычно создаётся новый образец <code>User</code> в <code>user2</code> без правил написания обновления. Мы задаём новое значение для <code>email</code>, но в остальном используем те же значения из <code>user1</code>, которые были заданы в приложении 5-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<p><span class="caption">Приложение 5-6: Создание нового образца <code>User</code> с использованием некоторых значений из образца <code>user1</code></span></p>
<p>Используя правила написания обновления устройства, можно получить тот же эффект, используя меньше кода как показано в приложении 5-7. правила написания <code>..</code> указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного образца.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
<p><span class="caption">Приложение 5-7: Использование правил написания обновления устройства для установки нового значения <code>email</code> для образца <code>User</code>, но использование остальных значений из образца <code>user1</code></span></p>
<p>Код в приложении 5-7 также создаёт образец в <code>user2</code>, который имеет другое значение для <code>email</code>, но с тем же значением для полей <code>username</code>, <code>active</code> и <code>sign_in_count</code> из <code>user1</code>. Оператор <code>..user1</code> должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в <code>user1</code>, но можно указать значения для любого количества полей в любом порядке, независимо от порядка полей в определении устройства.</p>
<p>Стоит отметить, что правила написания обновления устройства использует <code>=</code> как присваивание. Это связано с перемещением данных, как мы видели в разделе <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">«Взаимодействие переменных и данных с помощью перемещения»</a><!-- ignore -->. В этом примере мы больше не можем использовать <code>user1</code> после создания <code>user2</code>, потому что <code>String</code> в поле <code>username</code> из <code>user1</code> было перемещено в <code>user2</code>. Если бы мы задали <code>user2</code> новые значения <code>String</code> для <code>email</code> и <code>username</code>, и таким образом, использовали только значения <code>active</code> и <code>sign_in_count</code> из <code>user1</code>, то <code>user1</code> всё ещё был бы действительным после создания <code>user2</code>. Оба вида <code>active</code> и <code>sign_in_count</code> выполняют особенность <code>Copy</code>, поэтому они ведут себя так, как мы обсуждали в разделе <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">«Из обоймы данные: повторение»</a><!-- ignore -->.</p>
<h3 id="Упорядоченные-в-ряд-устройства-устройства-без-именованных-полей-для-создания-разных-видов"><a class="header" href="#Упорядоченные-в-ряд-устройства-устройства-без-именованных-полей-для-создания-разных-видов">Упорядоченные в ряд устройства: устройства без именованных полей для создания разных видов</a></h3>
<p>Rust также поддерживает устройства, похожие на упорядоченные ряды, которые называются <em>упорядоченные в ряд устройства</em>. Упорядоченные в ряд устройства обладают дополнительным смыслом, который даёт имя устройства, но при этом не имеют имён, связанных с их полями. Скорее, они просто хранят виды полей. Упорядоченные в ряд устройства полезны, когда вы хотите дать имя всему упорядоченному ряду и сделать упорядоченный ряд отличным от других упорядоченных рядов, и когда именование каждого поля, как в обычной устройстве, было бы многословным или избыточным.</p>
<p>Чтобы определить упорядоченную в ряд устройство, начните с ключевого слова <code>struct</code> и имени устройства, за которым следуют виды в упорядоченном ряде. Например, здесь мы определяем и используем две упорядоченные в ряд устройства с именами <code>Color</code> и <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Обратите внимание, что значения <code>black</code> и <code>origin</code> — это разные виды, потому что они являются образцами разных упорядоченных в ряд устройств. Каждая определяемая вами устройства имеет собственный вид, даже если поля внутри устройства могут иметь одинаковые виды. Например, функция, принимающая свойство вида <code>Color</code>, не может принимать <code>Point</code> в качестве переменной, даже если оба вида состоят из трёх значений <code>i32</code>. В остальном образцы упорядоченных в ряд устройств похожи на упорядоченные ряды в том смысле, что вы можете разъединять их на отдельные части и использовать <code>.</code>, за которой следует порядковый указательдля доступа к отдельному значению.</p>
<h3 id="Единично-подобные-устройства-устройства-без-полей"><a class="header" href="#Единично-подобные-устройства-устройства-без-полей">Единично-подобные устройства: устройства без полей</a></h3>
<p>Также можно определять устройства, не имеющие полей! Они называются <em>единично-подобными устройствами</em>, поскольку ведут себя подобно <code>()</code>, единичному виду, о котором мы говорили в разделе <a href="ch03-02-data-types.html#the-tuple-type">"Упорядоченные ряды"</a><!-- ignore -->. Единично-подобные устройства могут быть полезны, когда требуется выполнить особенность для некоторого вида, но у вас нет данных, которые нужно хранить в самом виде. Мы обсудим особенности в главе 10. Вот пример объявления и создание образца единичной устройства с именем <code>AlwaysEqual</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>Чтобы определить <code>AlwaysEqual</code>, мы используем ключевое слово <code>struct</code>, желаемое имя, а затем точку с запятой. Нет необходимости в фигурных или круглых скобках! Затем мы можем получить образец <code>AlwaysEqual</code> в переменной <code>subject</code> подобным образом: используя имя, которое мы определили, без фигурных и круглых скобок. Представим, что в дальнейшем мы выполняем поведение для этого вида таким образом, что каждый образец <code>AlwaysEqual</code> всегда будет равен каждому образцу любого другого вида, возможно, с целью получения ожидаемого итога для проверки. Для выполнения такого поведения нам не нужны никакие данные! В главе 10 вы увидите, как определять черты и выполнить их для любого вида, включая единично-подобные устройства.</p>
<blockquote>
<h3 id="Владение-данными-устройства"><a class="header" href="#Владение-данными-устройства">Владение данными устройства</a></h3>
<p>В определении устройства <code>User</code> в приложении 5-1 мы использовали владеющий вид <code>String</code> вместо вида строковый срез <code>&amp;str</code>. Это осознанный выбор, поскольку мы хотим, чтобы каждый образец этой устройства владел всеми своими данными и чтобы эти данные были действительны до тех пор, пока действительна вся устройства.</p>
<p>Устройства также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого необходимо использовать возможность Ржавчина <em>время жизни</em>, которую мы обсудим в главе 10. Время жизни заверяет, что данные, на которые ссылается устройства, будут действительны до тех пор, пока существует устройства. Допустим, если попытаться сохранить ссылку в устройстве без указания времени жизни, как в следующем примере; это не сработает:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
<p>Сборщик будет жаловаться на необходимость определения времени жизни ссылок:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>В главе 10 мы обсудим, как исправить эти ошибки, чтобы иметь возможность хранить ссылки в устройствах, а пока мы исправим подобные ошибки, используя владеющие виды вроде <code>String</code> вместо ссылок <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="Пример-использования-устройств"><a class="header" href="#Пример-использования-устройств">Пример использования устройств</a></h2>
<p>Чтобы понять, когда нам может понадобиться использование устройств, давайте напишем программу, которая вычисляет площадь прямоугольника. Мы начнём с использования одиночных переменных, а затем будем улучшать программу до использования устройств.</p>
<p>Давайте создадим новый дело программы при помощи Cargo и назовём его <em>rectangles</em>. Наша программа будет получать на вход длину и ширину прямоугольника в пикселях и затем рассчитывать площадь прямоугольника. Приложение 5-8 показывает один из коротких исходов кода, который позволит нам сделать именно то, что надо, в файле дела <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<p><span class="caption">Приложение 5-8: вычисление площади прямоугольника, заданного отдельными переменными ширины и высоты</span></p>
<p>Теперь запустим программу, используя <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Этот код успешно вычисляет площадь прямоугольника, вызывая функцию <code>area</code> с каждым измерением, но мы можем улучшить его ясность и читабельность.</p>
<p>Неполадкаданного способа очевидна из ярлыки <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "The area of the rectangle is {} square pixels.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>Функция <code>area</code> должна вычислять площадь одного прямоугольника, но функция, которую мы написали, имеет два свойства, и нигде в нашей программе не ясно, что эти свойства взаимосвязаны. Было бы более читабельным и управляемым собъединять ширину и высоту вместе. В разделе <a href="ch03-02-data-types.html#the-tuple-type">«Упорядоченные ряды»</a><!-- ignore --> главы 3 мы уже обсуждали один из способов сделать это — использовать упорядоченные ряды.</p>
<h3 id="Переработка-кода-при-помощи-упорядоченных-рядов"><a class="header" href="#Переработка-кода-при-помощи-упорядоченных-рядов">Переработка кода при помощи упорядоченных рядов</a></h3>
<p>Приложение 5-9 — это другая исполнение программы, использующая упорядоченные ряды.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<p><span class="caption">Приложение 5-9: определение ширины и высоты прямоугольника с помощью упорядоченного ряда</span></p>
<p>С одной стороны, эта программа лучше. Упорядоченные ряды позволяют добавить немного устройства, и теперь мы передаём только один переменная. Но с другой стороны, эта исполнение менее понятна: упорядоченные ряды не называют свои элементы, поэтому нам приходится упорядочивать части упорядоченного ряда, что делает наше вычисление менее очевидным.</p>
<p>Если мы перепутаем местами ширину с высотой при расчёте площади, то это не имеет значения. Но если мы хотим нарисовать прямоугольник на экране, то это уже будет важно! Мы должны помнить, что ширина  <code>width</code> находится в упорядоченном ряде с порядковым указателем <code>0</code>, а высота <code>height</code> — с порядковым указателем <code>1</code>. Если кто-то другой поработал бы с кодом, ему бы пришлось разобраться в этом и также помнить про порядок. Легко забыть и перепутать эти значения — и это вызовет ошибки, потому что данный код не передаёт наши намерения.</p>
<h3 id="Переработка-кода-при-помощи-устройств-добавим-больше-смысла"><a class="header" href="#Переработка-кода-при-помощи-устройств-добавим-больше-смысла">Переработка кода при помощи устройств: добавим больше смысла</a></h3>
<p>Мы используем устройства, чтобы добавить смысл данным при помощи назначения им осмысленных имён . Мы можем переделать используемый упорядоченный ряд в устройство с единым именем для сущности и частными названиями её частей, как показано в приложении 5-10.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<p><span class="caption">Приложение 5-10: определение устройства <code>Rectangle</code></span></p>
<p>Здесь мы определили устройство и дали ей имя <code>Rectangle</code>. Внутри фигурных скобок определили поля как <code>width</code> и <code>height</code>, оба — вида <code>u32</code>. Затем в <code>main</code> создали определенный образец <code>Rectangle</code> с шириной в <code>30</code> и высотой в <code>50</code> единиц.</p>
<p>Наша функция <code>area</code> теперь определена с одним свойствоом, названным <code>rectangle</code>, чей вид является неизменяемым заимствованием устройства <code>Rectangle</code>. Как упоминалось в главе 4, необходимо заимствовать устройство, а не передавать её во владение. Таким образом функция <code>main</code> сохраняет <code>rect1</code> в собственности и может использовать её дальше. По этой причине мы и используем <code>&amp;</code> в ярлыке и в месте вызова функции.</p>
<p>Функция <code>area</code> получает доступ к полям <code>width</code> и <code>height</code> образца <code>Rectangle</code> (обратите внимание, что доступ к полям заимствованного образца устройства не приводит к перемещению значений полей, поэтому вы часто видите заимствования устройств). Наша ярлык функции для <code>area</code> теперь говорит именно то, что мы имеем в виду: вычислить площадь <code>Rectangle</code>, используя его поля <code>width</code> и <code>height</code>. Это означает, что ширина и высота связаны друг с другом, и даёт описательные имена значениям, а не использует значения порядкового указателя упорядоченного ряда <code>0</code> и <code>1</code>. Это торжество ясности.</p>
<h3 id="Добавление-полезной-возможности-при-помощи-выводимых-особенностей"><a class="header" href="#Добавление-полезной-возможности-при-помощи-выводимых-особенностей">Добавление полезной возможности при помощи выводимых особенностей</a></h3>
<p>Было бы полезно иметь возможность печатать образец <code>Rectangle</code> во время отладки программы и видеть значения всех полей. Приложение 5-11 использует макрос <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a><!-- ignore -->, который мы уже использовали в предыдущих главах. Тем не менее, это не работает.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}</code></pre>
<p><span class="caption">Приложение 5-11: Попытка вывести значения образца <code>Rectangle</code></span></p>
<p>При сборки этого кода мы получаем ошибку с сообщением:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Макрос <code>println!</code> умеет выполнять множество видов изменения, и по умолчанию фигурные скобки в <code>println!</code> означают использование изменение
, известное как особенность <code>Display</code>. Его вывод предназначен для непосредственного использования конечным пользователем. Простые виды, изученные ранее, по умолчанию выполняют особенность <code>Display</code>, потому что есть только один способ отобразить число <code>1</code> или любой другой простой вид. Но для устройств изменение
<code>println!</code> менее очевидно, потому что есть гораздо больше способов отображения: Вы хотите запятые или нет? Вы хотите печатать фигурные скобки? Должны ли отображаться все поля? Из-за этой неоднозначности Ржавчина не пытается  угадать, что нам нужно, а устройства не имеют встроенной выполнения <code>Display</code> для использования в <code>println!</code> с заполнителем <code>{}</code>.</p>
<p>Продолжив чтение текста ошибки, мы найдём полезное замечание:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Давайте попробуем! Вызов макроса <code>println!</code> теперь будет выглядеть так <code>println!("rect1 is {:?}", rect1);</code>. Ввод определетеля <code>:?</code> внутри фигурных скобок говорит макросу <code>println!</code>, что мы хотим использовать другой вид вывода, известный как <code>Debug</code>. Особенность <code>Debug</code> позволяет печатать устройство способом, удобным для разработчиков, чтобы видеть значение во время отладки кода.</p>
<p>Соберем код с этими изменениями. Упс! Мы всё ещё получаем ошибку:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Снова сборщик даёт нам полезное замечание:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>выполняет</em> возможность для печати отладочной сведений, но <em>не включает (не выводит) её по умолчанию</em>. Мы должны явно включить эту возможность для нашей устройства. Чтобы это сделать, добавляем внешний свойство <code>#[derive(Debug)]</code> сразу перед определением устройства, как показано в приложении 5-12.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}</code></pre></pre>
<p><span class="caption">Приложение 5-12: добавление свойства для вывода особенности <code>Debug</code> и печати образца <code>Rectangle</code> с отладочным изменением
</span></p>
<p>Теперь при запуске программы мы не получим ошибок и увидим следующий вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Отлично! Это не самый красивый вывод, но он показывает значения всех полей образца, которые определённо помогут при отладке. Когда у нас более крупные устройства, то полезно иметь более простой для чтения вывод; в таких случаях можно использовать код <code>{:#?}</code> вместо <code>{:?}</code> в строке макроса <code>println!</code>. В этом примере использование исполнения <code>{:#?}</code> приведёт к такому выводу:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Другой способ распечатать значение в виде<code>Debug</code> — использовать макрос <a href="../std/macro.dbg.html"><code>dbg!</code></a><!-- ignore -->, который становится владельцем выражения (в отличие от <code>println!</code>, принимающего ссылку), печатает номер файла и строки, где происходит вызов макроса <code>dbg!</code>, вместе с результирующим значением этого выражения и возвращает владение на значение.</p>
<blockquote>
<p>Примечание: при вызове макроса <code>dbg!</code> выполняется печать в обычный поток ошибок (<code>stderr</code>), в отличие от <code>println!</code>, который использует обычный поток вывода в окно вывода (<code>stdout</code>). Подробнее о <code>stderr</code> и <code>stdout</code> мы поговорим в разделе <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">«Запись сообщений об ошибках в обычный вывод ошибок вместо принятого вывода» главы 12</a><!-- ignore -->.</p>
</blockquote>
<p>Вот пример, когда нас важно значение, которое присваивается полю <code>width</code>, а также значение всей устройства в <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>Можем написать макрос <code>dbg!</code> вокруг выражения <code>30 * scale</code>, потому что <code>dbg!</code> возвращает владение значения выражения. Поле <code>width</code> получит то же значение, как если бы у нас не было вызова <code>dbg!</code>. Мы не хотим, чтобы макрос <code>dbg!</code> становился владельцем <code>rect1</code>, поэтому используем ссылку на <code>rect1</code> в следующем вызове. Вот как выглядит вывод этого примера:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Мы можем увидеть, что первый отладочный вывод поступил из строки 10 <em>src/main.rs</em>, там, где мы отлаживаем выражение <code>30 * scale</code>, и его результирующее значение равно 60 (<code>Debug</code> изменение
, выполненное для целых чисел, заключается в печати только их значения). Вызов <code>dbg!</code> в строке 14 <em>src/main.rs</em> выводит значение <code>&amp;rect1</code>, которое является устройством <code>Rectangle</code>. В этом выводе используется красивое изменение
<code>Debug</code> вида <code>Rectangle</code>. Макрос <code>dbg!</code> может быть очень полезен, когда вы пытаетесь понять, что делает ваш код!</p>
<p>В дополнение к <code>Debug</code>, Ржавчина предоставил нам ряд особенностей, которые мы можем использовать с свойством <code>derive</code> для добавления полезного поведения к нашим пользовательским видам. Эти особенности и их поведение перечислены в <a href="appendix-03-derivable-traits.html">приложении C</a><!-- ignore -->. Мы расскажем, как выполнить эти особенности с пользовательским поведением, а также как создать свои собственные особенности в главе 10. Кроме того, есть много других свойств помимо <code>derive</code>; для получения дополнительной сведений смотрите <a href="https://doc.rust-lang.org/reference/attributes.html">раздел “Свойства” справочника Rust</a>.</p>
<p>Функция <code>area</code> является довольно отличительной: она считает только площадь прямоугольников. Было бы полезно привязать данное поведение как можно ближе к устройстве <code>Rectangle</code>, потому что наш отличительный код не будет работать с любым другим видом. Давайте рассмотрим, как можно улучшить наш код превращая функцию <code>area</code> в <em>способ</em> <code>area</code>, определённый для вида <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="правила-написания-способа"><a class="header" href="#правила-написания-способа">правила написания способа</a></h2>
<p><em>Способы</em> похожи на функции: мы объявляем их с помощью ключевого слова <code>fn</code> и имени, они могут иметь свойства и возвращаемое значение, и они содержат код, запускающийся в случае вызова способа. В отличие от функций, способы определяются в среде устройства (или предмета перечисления или особенности, которые мы рассмотрим в <a href="ch06-00-enums.html">главе 6)</a><!-- ignore --> и <a href="ch17-02-trait-objects.html">главе 17</a><!-- ignore --> соответственно), а их первым свойствоом всегда является <code>self</code>, представляющий собой образец устройства, с которой вызывается этот способ.</p>
<h3 id="Определение-способов"><a class="header" href="#Определение-способов">Определение способов</a></h3>
<p>Давайте изменим функцию <code>area</code> так, чтобы она имела образец <code>Rectangle</code> в качестве входного свойства и сделаем её способом <code>area</code>, определённым для устройства <code>Rectangle</code>, как показано в приложении 5-13:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}</code></pre></pre>
<p><span class="caption">Приложение 5-13: Определение способа <code>area</code> для устройства <code>Rectangle</code></span></p>
<p>Чтобы определить функцию в среде <code>Rectangle</code>, мы создаём раздел<code>impl</code> (implementation - выполнение) для <code>Rectangle</code>. Всё в <code>impl</code> будет связано с видом <code>Rectangle</code>. Затем мы перемещаем функцию <code>area</code> внутрь фигурных скобок <code>impl</code> и меняем первый (и в данном случае единственный) свойство на <code>self</code> в ярлыке и в теле. В <code>main</code>, где мы вызвали функцию <code>area</code> и передали <code>rect1</code> в качестве переменной, теперь мы можем использовать <em>правила написания способа</em> для вызова способа <code>area</code> нашего образца <code>Rectangle</code>. правила написания способа идёт после образца: мы добавляем точку, за которой следует имя способа, круглые скобки и любые переменные.</p>
<p>В ярлыке <code>area</code> мы используем <code>&amp;self</code> вместо <code>rectangle: &amp;Rectangle</code>. <code>&amp;self</code> на самом деле является сокращением от <code>self: &amp;Self</code>. Внутри раздела <code>impl</code> вид <code>Self</code> является псевдонимом вида, для которого выполнен раздел<code>impl</code>. Способы обязаны иметь свойство с именем <code>self</code> вида <code>Self</code>, поэтому Ржавчина позволяет вам сокращать его, используя только имя <code>self</code> на месте первого свойства. Обратите внимание, что нам по-прежнему нужно использовать <code>&amp;</code> перед сокращением <code>self</code>, чтобы указать на то, что этот способ заимствует образец <code>Self</code>, точно так же, как мы делали это в <code>rectangle: &amp;Rectangle</code>. Как и любой другой свойство, способы могут брать во владение <code>self</code>, заимствовать неизменяемый <code>self</code>, как мы поступили в данном случае, или заимствовать изменяемый <code>self</code>.</p>
<p>Мы выбрали <code>&amp;self</code> здесь по той же причине, по которой использовали <code>&amp;Rectangle</code> в исполнения кода с функцией: мы не хотим брать устройство во владение, мы просто хотим прочитать данные в устройстве, а не писать в неё. Если бы мы хотели изменить образец, на котором мы вызывали способ силами самого способа, то мы бы использовали <code>&amp;mut self</code> в качестве первого свойства. Наличие способа, который берёт образец во владение, используя только <code>self</code> в качестве первого свойства, является редким; эта техника обычно используется, когда способ превращает <code>self</code> во что-то ещё, и вы хотите запретить вызывающей стороне использовать исходный образец после превращения.</p>
<p>Основная причина использования способов вместо функций, помимо правил написания способа, где нет необходимости повторять вид <code>self</code> в ярлыке каждого способа, заключается в согласования кода. Мы помеисполнения все, что мы можем сделать с образцом вида, в один <code>impl</code> вместо того, чтобы заставлять будущих пользователей нашего кода искать доступный возможности <code>Rectangle</code> в разных местах предоставляемой нами библиотеки.</p>
<p>Обратите внимание, что мы можем дать способу то же имя, что и одному из полей устройства. Например, для <code>Rectangle</code> мы можем определить способ, также названный <code>width</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}</code></pre></pre>
<p>Здесь мы определили, чтобы способ <code>width</code> возвращал значение <code>true</code>, если значение в поле <code>width</code> образца больше <code>0</code>, и значение <code>false</code>, если значение равно <code>0</code>, но мы можем использовать поле в способе с тем же именем для любых целей. В <code>main</code>, когда мы ставим после <code>rect1.width</code> круглые скобки, Ржавчина знает, что мы имеем в виду способ <code>width</code>. Когда мы не используем круглые скобки, Ржавчина понимает, что мы имеем в виду поле <code>width</code>.</p>
<p>Часто, но не всегда, когда мы создаём способы с тем же именем, что и у поля, мы хотим, чтобы он только возвращал значение одноимённого поля и больше ничего не делал. Подобные способы называются <em>геттерами</em>, и Ржавчина не выполняет их самостоятельно для полей устройства, как это делают некоторые другие языки. Геттеры полезны, поскольку вы можете сделать поле закрытым, а способ открытым и, таким образом, включить доступ только для чтения к этому полю как часть общедоступного API вида. Мы обсудим, что такое открытость и закрытость, и как обозначить поле или способ в качестве открытого или закрытого в <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">главе 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="Где-используется-оператор--"><a class="header" href="#Где-используется-оператор--">Где используется оператор <code>-&gt;</code>?</a></h3>
<p>В языках C и C++, используются два различных оператора для вызова способов: используется <code>.</code>, если вызывается способ непосредственно у образца устройства и используется <code>-&gt;</code>, если вызывается способ для указателя на предмет. Другими словами, если <code>object</code> является указателем, то вызовы способа <code>object-&gt;something()</code> и <code> (*object).something()</code> являются подобными.</p>
<p>Ржавчина не имеет эквивалента оператора <code>-&gt;</code>, наоборот, в Ржавчина есть возможность называемая <em>самостоятельное обращение по ссылке и разыменование</em> (automatic referencing and dereferencing). Вызов способов является одним из немногих мест в Rust, в котором есть такое поведение.</p>
<p>Вот как это работает: когда вы вызываете способ <code>object.something()</code>, Ржавчина самостоятельно добавляет <code>&amp;</code>, <code>&amp;mut</code> или  <code>*</code>, таким образом, чтобы <code>object</code> соответствовал ярлыке способа. Другими словами, это то же самое:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>Первый пример выглядит намного понятнее. Самостоятельный вывод ссылки работает потому, что способы имеют понятного получателя - вид <code>self</code>. Учитывая получателя и имя способа, Ржавчина может точно определить, что в данном случае делает код: читает ли способ (<code>&amp;self</code>), делает ли изменение (<code>&amp;mut self</code>) или поглощает (<code>self</code>). Тотобстоятельство, что Ржавчина делает заимствование неявным для принимающего способа, в значительной степени способствует тому, чтобы сделать владение удобным на опыте.</p>
</blockquote>
<h3 id="Способы-с-несколькими-свойствами"><a class="header" href="#Способы-с-несколькими-свойствами">Способы с несколькими свойствами</a></h3>
<p>Давайте применим в использовании способов, выполнив второй способ в устройстве <code>Rectangle</code>. На этот раз мы хотим, чтобы образец <code>Rectangle</code> брал другой образец <code>Rectangle</code> и возвращал <code>true</code>, если второй <code>Rectangle</code> может полностью поместиться внутри <code>self</code> (первый <code>Rectangle</code>); в противном случае он должен вернуть <code>false</code>. То есть, как только мы определим способ <code>can_hold</code>, мы хотим иметь возможность написать программу, показанную в Приложении 5-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
<p><span class="caption">Приложение 5-14: Использование ещё не написанного способа <code>can_hold</code></span></p>
<p>Ожидаемый итог будет выглядеть следующим образом, т.к. оба размера в образце <code>rect2</code> меньше, чем размеры в образце <code>rect1</code>, а <code>rect3</code> шире, чем <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Мы знаем, что хотим определить способ, поэтому он будет находится в <code>impl Rectangle</code> разделе. Имя способа будет <code>can_hold</code>, и оно будет принимать неизменяемое заимствование на другой <code>Rectangle</code> в качестве свойства. Мы можем сказать, какой это будет вид свойства, посмотрев на код вызывающего способа: способ <code>rect1.can_hold(&amp;rect2)</code> передаёт в него  <code>&amp;rect2</code> , который является неизменяемым заимствованием образца <code>rect2</code> вида <code>Rectangle</code>. В этом есть смысл, потому что нам нужно только читать <code>rect2</code> (а не писать, что означало бы, что нужно изменяемое заимствование), и мы хотим, чтобы <code>main</code> сохранил право собственности на образец <code>rect2</code>, чтобы мы могли использовать его снова после вызов способа <code>can_hold</code>. Возвращаемое значение <code>can_hold</code> имеет булевый вид, а выполнение проверяет, являются ли ширина и высота <code>self</code> больше, чем ширина и высота другого <code>Rectangle</code> соответственно. Давайте добавим новый способ <code>can_hold</code> в <code>impl</code> разделиз приложения 5-13, как показано в приложении 5-15.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-15: Выполнение способа <code>can_hold</code> для <code>Rectangle</code>, принимающего другой образец <code>Rectangle</code> в качестве свойства</span></p>
<p>Когда мы запустим код с функцией <code>main</code> приложения 5-14, мы получим желаемый вывод. Способы могут принимать несколько свойств, которые мы добавляем в ярлык после первого  свойства <code>self</code>, и эти свойства работают так же, как свойства в функциях.</p>
<h3 id="Сопряженные-функции"><a class="header" href="#Сопряженные-функции">Сопряженные функции</a></h3>
<p>Все функции, определённые в разделе <code>impl</code>, называются <em>сопряженными функциями</em>, потому что они сопряжены с видом, указанным после ключевого слова <code>impl</code>. Мы можем определить сопряженные функции, которые не имеют <code>self</code> в качестве первого свойства (и, следовательно, не являются способами), потому что им не нужен образец вида для работы. Мы уже использовали одну подобную функцию: функцию <code>String::from</code>, определённую для вида <code>String</code>.</p>
<p>Сопряженные функции, не являющиеся способами, часто используются для строителей, возвращающих новый образец устройства. Их часто называют <code>new</code>, но <code>new</code> не является особым именем и не встроена в язык. Например, мы можем предоставить сопряженную функцию с именем <code>square</code>, которая будет иметь один свойство размера и использовать его как ширину и высоту, что упростит создание квадратного <code>Rectangle</code>, вместо того, чтобы указывать одно и то же значение дважды:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>Ключевые слова <code>Self</code> в возвращаемом виде и в теле функции являются псевдонимами для вида, указанного после ключевого слова <code>impl</code>, которым в данном случае является <code>Rectangle</code>.</p>
<p>Чтобы вызвать эту связанную функцию, используется правила написания <code>::</code> с именем устройства; например <code>let sq = Rectangle::square(3);</code>. Эта функция находится в пространстве имён устройства. правила написания <code>::</code> используется как для связанных функций, так и для пространств имён, созданных звенами. Мы обсудим звенья в <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">главе 7</a><!-- ignore -->.</p>
<h3 id="Несколько-разделов-impl"><a class="header" href="#Несколько-разделов-impl">Несколько разделов <code>impl</code></a></h3>
<p>Каждая устройства может иметь несколько <code>impl</code>. Например, Приложение 5-15 эквивалентен коду, показанному в приложении 5-16, в котором каждый способ находится в своём собственном разделе <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-16: Переписанный Приложения 5-15 с использованием нескольких <code>impl</code></span></p>
<p>Здесь нет причин разделять способы на несколько <code>impl</code>, но это допустимый правила написания. Мы увидим случай, когда несколько <code>impl</code> могут оказаться полезными, в Главе 10, рассматривающей обобщённые виды и свойства.</p>
<h2 id="Итоги-3"><a class="header" href="#Итоги-3">Итоги</a></h2>
<p>Устройства позволяют создавать собственные виды, которые имеют смысл в вашей предметной области. Используя устройства, вы храните сопряженные друг с другом отрывки данных и даёте название частям данных, чтобы ваш код был более понятным. Способы позволяют определить поведение, которое имеют образцы ваших устройств, а сопряженные функции позволяют привязать возможность к вашей устройстве, не обращаясь к её образцу.</p>
<p>Но устройства — не единственный способ создавать собственные виды: давайте обратимся к перечислениям в Rust, чтобы добавить ещё один средство в свой арсенал.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Перечисления-и-сопоставление-с-образцом"><a class="header" href="#Перечисления-и-сопоставление-с-образцом">Перечисления и сопоставление с образцом</a></h1>
<p>В этой главе мы рассмотрим <em>перечисления (enumerations)</em>, также называемые <em>enums</em>. Перечисления позволяют определить вид путём перечисления его возможных <em>исходов</em> . Сначала мы определим и используем перечисление, чтобы показать, как оно может объединить значения и данные. Далее мы рассмотрим особенно полезное перечисление под названием <code>Option</code>, которое выражает, что значение может быть либо чем-то, либо ничем. Затем мы рассмотрим, как сопоставление с образцом в выражении <code>match</code> позволяет легко запускать разный код для разных значений перечисления. Наконец, мы узнаем, насколько устройство <code>if let</code> удобна и кратка для обработки перечислений в вашем коде.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Определение-перечисления"><a class="header" href="#Определение-перечисления">Определение перечисления</a></h2>
<p>Там, где устройства дают вам возможность объединять связанные поля и данные, например <code>Rectangle</code> с его <code>width</code> и <code>height</code>, перечисления дают вам способ сказать, что значение является одним из возможных наборов значений. Например, мы можем захотеть сказать, что <code>Rectangle</code> — это одна из множества возможных фигур, в которую также входят <code>Circle</code> и <code>Triangle</code>. Для этого Ржавчина позволяет нам закодировать эти возможности в виде перечисления.</p>
<p>Давайте рассмотрим случай, которую мы могли бы захотеть отразить в коде, и поймём, почему перечисления полезны и более уместны, чем устройства в этом случае. Допустим, нам нужно работать с IP-адресами. В настоящее время для обозначения IP-адресов используются два основных исполнения: четвёртая и шестая исполнения. Поскольку это единственно возможные исходы IP-адресов, с которыми может столкнуться наша программа, мы можем <em>перечислить</em> все возможные исходы, откуда перечисление и получило своё название.</p>
<p>Любой IP-адрес может быть либо четвёртой, либо шестой исполнения, но не обеими одновременно. Эта особенность IP-адресов делает устройство данных enum подходящей, поскольку значение enum может представлять собой только один из его возможных исходов. Адреса как четвёртой, так и шестой исполнения по своей сути все равно являются IP-адресами, поэтому их следует рассматривать как один и тот же вид, когда в коде обрабатываются задачи, относящиеся к любому виду IP-адресов.</p>
<p>Можно выразить эту подход в коде, определив перечисление <code>IpAddrKind</code> и составив список возможных видов IP-адресов, <code>V4</code> и <code>V6</code>. Вот исходы перечислений:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> теперь является пользовательским видом данных, который мы можем использовать в другом месте нашего кода.</p>
<h3 id="Значения-перечислений"><a class="header" href="#Значения-перечислений">Значения перечислений</a></h3>
<p>Образцы каждого исхода перечисления <code>IpAddrKind</code> можно создать следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Обратите внимание, что исходы перечисления находятся в пространстве имён вместе с его определителем, а для их обособления мы используем двойное двоеточие. Это удобно тем, что теперь оба значения <code>IpAddrKind::V4</code> и <code>IpAddrKind::V6</code> относятся к одному виду: <code>IpAddrKind</code>. Затем мы можем, например, определить функцию, которая принимает любой из исходов <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>Можно вызвать эту функцию с любым из исходов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Использование перечислений позволяет получить ещё больше преимуществ. Если подумать о нашем виде для IP-адреса, то выяснится, что на данный мгновение у нас нет возможности хранить собственно сам <em>IP-адрес</em>; мы будем знать только его <em>вид</em>. Учитывая, что недавно в главе 5 вы узнали о устройствах, у вас может возникнуть соблазн решить эту неполадку с помощью устройств, как показано в приложении 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-1. Сохранение данных и <code>IpAddrKind</code> IP-адреса с использованием <code>struct</code></span></p>
<p>Здесь мы определили устройство <code>IpAddr</code>, у которой есть два поля: <code>kind</code> вида <code>IpAddrKind</code> (перечисление, которое мы определили ранее) и <code>address</code> вида <code>String</code>. У нас есть два образца этой устройства. Первый - <code>home</code>, который является <code>IpAddrKind::V4</code> в качестве значения <code>kind</code> с соответствующим адресом <code>127.0.0.1</code>. Второй образец - <code>loopback</code>. Он в качестве значения <code>kind</code> имеет другой исход <code>IpAddrKind</code>, <code>V6</code>, и с ним сопряжен адрес <code>::1</code>. Мы использовали устройство для объединения значений <code>kind</code> и <code>address</code> вместе, таким образом вид вида адреса теперь сопряжен со значением.</p>
<p>Однако представление этой же подходы с помощью перечисления более кратко: вместо того, чтобы помещать перечисление в устройство, мы можем поместить данные непосредственно в любой из исходов перечисления. Это новое определение перечисления <code>IpAddr</code> гласит, что оба исхода <code>V4</code> и <code>V6</code> будут иметь соответствующие значения <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>Мы прикрепляем данные к каждому исходу перечисления напрямую, поэтому нет необходимости в дополнительной устройстве. Здесь также легче увидеть ещё одну подробность того, как работают перечисления: имя каждого исхода перечисления, который мы определяем, также становится функцией, которая создаёт образец перечисления. То есть <code>IpAddr::V4()</code> - это вызов функции, который принимает <code>String</code> и возвращает образец вида <code>IpAddr</code>. Мы самостоятельно получаем эту функцию-строитель, определяемую в итоге определения перечисления.</p>
<p>Ещё одно преимущество использования перечисления вместо устройства заключается в том, что каждый исход перечисления может иметь разное количество сопряженных данных представленных в разных видах. Исполнение 4 для IP адресов всегда будет содержать четыре цифровых составляющих, которые будут иметь значения между 0 и 255. При необходимости сохранить адреса вида <code>V4</code> как четыре значения вида <code>u8</code>, а также описать адреса вида <code>V6</code> как единственное значение вида  <code>String</code>, мы не смогли бы с помощью устройства. Перечисления решают эту задачу легко:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>Мы показали несколько различных способов определения устройств данных для хранения IP-адресов четвёртой и шестой исполнений. Однако, как оказалось, желание хранить IP-адреса и указывать их вид настолько распространено, что в встроенной библиотеке есть определение, которое мы можем использовать!<!-- ignore --> Давайте посмотрим, как обычная библиотека определяет <code>IpAddr</code>: в ней есть точно такое же перечисление с исходами, которое мы определили и использовали, но она помещает данные об адресе внутрь этих исходов в виде двух различных устройств, которые имеют различные определения для каждого из исходов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код отображает что мы можем добавлять любой вид данных в значение перечисления: строку, число, устройство и пр. Вы даже можете включить в перечисление другие перечисления! Обычные виды данных не очень сложны, хотя, возможно, могут быть очень сложными (вложенность данных может быть очень глубокой).</p>
<p>Обратите внимание, что хотя определение перечисления <code>IpAddr</code> есть в встроенной библиотеке, мы смогли объявлять и использовать свою собственную выполнение с подобным названием без каких-либо несоответствий, потому что мы не добавили определение встроенной библиотеки в область видимости кода. Подробнее об этом поговорим в Главе 7.</p>
<p>Рассмотрим другой пример перечисления в приложении 6-2: в этом примере каждый элемент перечисления имеет свой особый вид данных внутри:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 6-2. Перечисление <code>Message</code>, в каждом из исходов которого хранятся разные количества и виды значений.</span></p>
<p>Это перечисление имеет 4 элемента:</p>
<ul>
<li><code>Quit</code> - пустой элемент без сопряженных данных,</li>
<li><code>Move</code> имеет именованные поля, как и устройства.</li>
<li><code>Write</code> - элемент с единственной строкой вида <code>String</code>,</li>
<li><code>ChangeColor</code> - упорядоченный ряд из трёх значений вида <code>i32</code>.</li>
</ul>
<p>Определение перечисления с исходами, такими как в приложении 6-2, похоже на определение значений различных видов внутри устройств, за исключением того, что перечисление не использует ключевое слово <code>struct</code> и все исходы объединены внутри вида <code>Message</code>. Следующие устройства могут содержать те же данные, что и предыдущие исходы перечислений:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Но когда мы использовали различные устройства, каждая из которых имеет свои собственные виды, мы не могли легко определять функции, которые принимают любые виды сообщений, как это можно сделать с помощью перечисления вида <code>Message</code>, объявленного в приложении 6-2, который является единым видом.</p>
<p>Есть ещё одно сходство между перечислениями и устройствами: так же, как мы можем определять способы для устройств с помощью <code>impl</code> раздела, мы можем определять и способы для перечисления. Вот пример способа с именем <code>call</code>, который мы могли бы определить в нашем перечислении <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>В теле способа будет использоваться <code>self</code> для получения значение того предмета. у которого мы вызвали этот способ. В этом примере мы создали переменную <code>m</code>, содержащую значение <code>Message::Write(String::from("hello"))</code>, и именно это значение будет представлять <code>self</code> в теле способа <code>call</code> при выполнении <code>m.call()</code>.</p>
<p>Теперь посмотрим на другое наиболее часто используемое перечисление из встроенной библиотеки, которое является очень распространённым и полезным: <code>Option</code>.</p>
<h3 id="Перечисление-option-и-его-преимущества-перед-null-значениями"><a class="header" href="#Перечисление-option-и-его-преимущества-перед-null-значениями">Перечисление <code>Option</code> и его преимущества перед Null-значениями</a></h3>
<p>В этом разделе рассматривается пример использования <code>Option</code>, ещё одного перечисления, определённого в встроенной библиотеке. Вид <code>Option</code> кодирует очень распространённый сценарий, в котором значение может быть чем-то, а может быть ничем.</p>
<p>Например, если вы запросите первый элемент из непустого списка, вы получите значение. Если вы запросите первый элемент пустого списка, вы ничего не получите. Выражение этой подходы в понятиях системы видов означает, что сборщик может проверить, обработали ли вы все случаи, которые должны были обработать; эта возможность может предотвратить ошибки, которые чрезвычайно распространены в других языках программирования.</p>
<p>Внешний вид языка программирования часто рассматривается с точки зрения того, какие функции вы включаете в него, но те функции, которые вы исключаете, также важны. Например в Ржавчина нет такого возможностей как null значения, однако он есть во многих других языках. <em>Null значение</em> - это значение, которое означает, что значения нет. В языках с null значением переменные всегда могут находиться в одном из двух состояний: <em>нет значения (null)</em> или <em>есть значение (not-null)</em>.</p>
<p>В своей презентации 2009 года «Null ссылки: ошибка в миллиард долларов» Тони Хоар (Tony Hoare), изобретатель null, сказал следующее:</p>
<blockquote>
<p>Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую комплексную систему видов для ссылок на предметно-направленном языке. Моя цель состояла в том, чтобы обеспечить, что любое использование ссылок должно быть абсолютно безопасным, с самостоятельной проверкой сборщиком. Но я не мог устоять перед соблазном вставить пустую ссылку просто потому, что это было так легко выполнить. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, причинили боль и ущерб на миллиард долларов за последние сорок лет.</p>
</blockquote>
<p>Неполадкас null значениями заключается в том, что если вы попытаетесь использовать null значение в качестве not-null значения, вы получите ошибку определённого рода. Поскольку свойство null или not-null распространено повсеместно, сделать такую ошибку очень просто.</p>
<p>Тем не менее, подход, которую null пытается выразить, является полезной: null - это значение, которое в настоящее время по какой-то причине недействительно или отсутствует.</p>
<p>Неполадкана самом деле не в подходы, а в именно выполнения. Таким образом, в Ржавчина нет значений null, но есть перечисление, которое может закодировать подход присутствия или отсутствия значения. Это перечисление <code>Option&lt;T&gt;</code> , и оно <a href="../std/option/enum.Option.html">определено встроенной библиотекой <!-- ignore --> следующим образом:</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Перечисление <code>Option&lt;T&gt;</code> настолько полезно, что оно даже включено в прелюдию; вам не нужно явно вводить его в область видимости. Его исходы также включены в прелюдию: вы можете использовать <code>Some</code> и <code>None</code> напрямую, без приставки <code>Option::</code>. При всём при этом, <code>Option&lt;T&gt;</code> является обычным перечислением, а <code>Some(T)</code> и <code>None</code> представляют собой его исходы.</p>
<p><code>&lt;T&gt;</code> - это особенность Rust, о которой мы ещё не говорили. Это свойство обобщённого вида, и мы рассмотрим его более подробно в главе 10. На данный мгновение всё, что вам нужно знать, это то, что <code>&lt;T&gt;</code> означает, что исход <code>Some</code> <code>Option</code> может содержать один отрывок данных любого вида, и что каждый определенный вид, который используется вместо <code>T</code> делает общий <code>Option&lt;T&gt;</code> другим видом. Вот несколько примеров использования <code>Option</code> для хранения числовых и строковых видов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>Вид <code>some_number</code> - <code>Option&lt;i32&gt;</code>. Вид <code>some_char</code> - <code>Option&lt;char&gt;</code>, это другой вид. Ржавчина может вывести эти виды, потому что мы указали значение внутри исхода <code>Some</code>. Для <code>absent_number</code> Ржавчина требует, чтобы мы определяли общий вид для <code>Option</code>: сборщик не может вывести вид, который будет в <code>Some</code>, глядя только на значение <code>None</code>. Здесь мы сообщаем Rust, что <code>absent_number</code> должен иметь вид <code>Option&lt;i32&gt;</code>.</p>
<p>Когда есть значение <code>Some</code>, мы знаем, что значение присутствует и содержится внутри <code>Some</code>. Когда есть значение <code>None</code>, это означает то же самое, что и null в некотором смысле: у нас нет действительного значения. Так почему наличие <code>Option&lt;T&gt;</code> лучше, чем null?</p>
<p>Вкратце, поскольку <code>Option&lt;T&gt;</code> и <code>T</code> (где <code>T</code> может быть любым видом) относятся к разным видам, сборщик не позволит нам использовать значение <code>Option&lt;T&gt;</code> даже если бы оно было определённо допустимым значением. Например, этот код не будет собираться, потому что он пытается добавить <code>i8</code> к значению вида <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>Если мы запустим этот код, то получим такое сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;i8 as Add&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Сильно! В действительности, это сообщение об ошибке означает, что Ржавчина не понимает, как сложить <code>i8</code> и <code>Option&lt;i8&gt;</code>, потому что это разные виды. Когда у нас есть значение вида наподобие <code>i8</code>, сборщик заверяет, что у нас всегда есть допустимое значение вида. Мы можем уверенно продолжать работу, не проверяя его на null перед использованием. Однако, когда у нас есть значение вида <code>Option&lt;T&gt;</code> (где <code>T</code> - это любое значение любого вида <code>T</code>, упакованное в <code>Option</code>, например значение вида <code>i8</code> или <code>String</code>), мы должны беспокоиться о том, что <em>значение</em> вида T возможно не имеет значения (является исходом <code>None</code>), и сборщик позаботится о том, чтобы мы обработали такой случай, прежде чем мы бы попытались использовать <code>None</code> значение.</p>
<p>Другими словами, вы должны преобразовать <code>Option&lt;T&gt;</code> в <code>T</code> прежде чем вы сможете выполнять действия с этим <code>T</code>. Как правило, это помогает выявить одну из наиболее распространённых неполадок с null: предполагая, что что-то не равно null, когда оно на самом деле равно null.</p>
<p>Устранение риска ошибочного предположения касательно не-null значения помогает вам быть более уверенным в своём коде. Чтобы иметь значение, которое может быть null, вы должны явно описать вид этого значения с помощью <code>Option&lt;T&gt;</code>. Затем, когда вы используете это значение, вы обязаны явно обрабатывать случай, когда значение равно null. Везде, где значение имеет вид, отличный от <code>Option&lt;T&gt;</code>, вы <em>можете</em> смело рассчитывать на то, что значение не равно null. Это продуманное расчетное решение в Rust, ограничивающее распространение null и увеличивающее безопасность кода на Rust.</p>
<p>Итак, как же получить значение <code>T</code> из исхода <code>Some</code>, если у вас на руках есть только предмет <code>Option&lt;T&gt;</code>, и как можно его, вообще, использовать? Перечисление <code>Option&lt;T&gt;</code> имеет большое количество способов, полезных в различных случаейх; вы можете ознакомиться с ними в <a href="../std/option/enum.Option.html">его документации</a><!-- ignore -->. Знакомство с способами перечисления <code>Option&lt;T&gt;</code> будет чрезвычайно полезным в вашем путешествии с Rust.</p>
<p>В общем случае, чтобы использовать значение <code>Option&lt;T&gt;</code>, нужен код, который будет обрабатывать все исходы перечисления <code>Option&lt;T&gt;</code>. Вам понадобится некоторый код, который будет работать только тогда, когда у вас есть значение <code>Some(T)</code>, и этому коду разрешено использовать внутри <code>T</code>. Также вам понадобится другой код, который будет работать, если у вас есть значение <code>None</code>, и у этого кода не будет доступного значения <code>T</code>. Выражение <code>match</code> — это устройство управления потоком выполнения программы, которая делает именно это при работе с перечислениями: она запускает разный код в зависимости от того, какой исход перечисления имеется, и этот код может использовать данные, находящиеся внутри совпавшего исхода.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="Управляющая-устройство-match"><a class="header" href="#Управляющая-устройство-match">Управляющая устройство <code>match</code></a></h2>
<p>В Ржавчина есть чрезвычайно мощный рычаг управления потоком, именуемый <code>match</code>, который позволяет сравнивать значение с различными образцами и затем выполнять код в зависимости от того, какой из образцов совпал. Образцы могут состоять из записанных значений, имён переменных, подстановочных знаков и многого другого; в главе 18 рассматриваются все различные виды образцов и то, что они делают. Сила <code>match</code> заключается в выразительности образцов и в том, что сборщик проверяет, что все возможные случаи обработаны.</p>
<p>Думайте о выражении <code>match</code> как о машине для сортировки монет: монеты скользят по дорожке с различными по размеру отверстиями, и каждая монета падает через первое попавшееся отверстие, в которое она поместилась. Таким же образом значения проходят через каждый образец в <code>match</code>, и при первом же "подходящем" образце значение попадает в соответствующий раздел кода, который будет использоваться во время выполнения.</p>
<p>Говоря о монетах, давайте используем их в качестве примера, используя <code>match</code>! Для этого мы напишем функцию, которая будет получать на вход неизвестную монету Соединённых Штатов и, подобно счётной машине, определять, какая это монета, и возвращать её стоимость в центах, как показано в приложении 6-3.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 6-3: Перечисление и выражение <code>match</code>, использующее в качестве образцов его исходы</span></p>
<p>Давайте разберём <code>match</code> в функции <code>value_in_cents</code>. Сначала пишется ключевое слово <code>match</code>, затем следует выражение, которое в данном случае является значением <code>coin</code>. Это выглядит очень похоже на условное выражение, используемое в <code>if</code>, но есть большая разница: с <code>if</code> выражение должно возвращать <em>булево значение</em>, а здесь это может быть любой вид. Вид <code>coin</code> в этом примере — перечисление вида <code>Coin</code>, объявленное в строке 1.</p>
<p>Далее идут ветки <code>match</code>. Ветки состоят из двух частей: образец и некоторый код. Здесь первая ветка имеет образец, который является значением <code>Coin::Penny</code>, затем идёт оператор <code>=&gt;</code>, который разделяет образец и код для выполнения. Код в этом случае - это просто значение <code>1</code>. Каждая ветка отделяется от последующей при помощи запятой.</p>
<p>Когда выполняется выражение <code>match</code>, оно сравнивает полученное значение с образцом каждого ответвления по порядку. Если образец совпадает со значением, то выполняется код, связанный с этим образцом. Если этот образец не соответствует значению, то выполнение продолжается со следующей ветки, так же, как в автомате по сортировке монет. У нас может быть столько ответвлений, сколько нужно: в приложении 6-3 наш <code>match</code> состоит из четырёх ответвлений.</p>
<p>Код, связанный с каждым ответвлением, является выражением, а полученное значение выражения в соответствующем ответвлении — это значение, которое возвращается для всего выражения <code>match</code>.</p>
<p>Обычно фигурные скобки не используются, если код совпадающей ветви невелик, как в приложении 6-3, где каждая ветвь просто возвращает значение. Если вы хотите выполнить несколько строк кода в одной ветви, вы должны использовать фигурные скобки, а запятая после этой ветви необязательна. Например, следующий код печатает "Lucky penny!" каждый раз, когда способ вызывается с <code>Coin::Penny</code>, но при этом он возвращает последнее значение раздела - <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="Образцы-привязывающие-значения"><a class="header" href="#Образцы-привязывающие-значения">Образцы, привязывающие значения</a></h3>
<p>Есть ещё одно полезное качество у веток в выражении <code>match</code>: они могут привязываться к частям тех значений, которые совпали с образцом. Благодаря этому можно извлекать значения из исходов перечисления.</p>
<p>В качестве примера, давайте изменим один из исходов перечисления так, чтобы он хранил в себе данные. С 1999 по 2008 год Соединённые Штаты чеканили 25 центов с различным внешнем видом на одной стороне для каждого из 50 штатов. Ни одна другая монета не получила внешнего видаштата, только четверть доллара имела эту дополнительную особенность. Мы можем добавить эту сведения в наш <code>enum</code> путём изменения исхода <code>Quarter</code> и включить в него значение <code>UsState</code>, как сделано в приложении 6-4.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 6-4: Перечисление <code>Coin</code>, в котором исход <code>Quarter</code> также сохраняет значение <code>UsState</code></span></p>
<p>Представьте, что ваш друг пытается собрать четвертаки всех 50 штатов. Сортируя монеты по виду, мы также будем сообщать название штата, к которому относится каждый четвертак, чтобы, если у нашего друга нет такой монеты, он мог добавить её в свою собрание.</p>
<p>В выражении match для этого кода мы добавляем переменную с именем <code>state</code> в образец, который соответствует значениям исхода <code>Coin::Quarter</code>. Когда <code>Coin::Quarter</code> совпадёт с образцом, переменная <code>state</code> будет привязана к значению штата этого четвертака. Затем мы сможем использовать <code>state</code> в коде этой ветки, вот так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Если мы сделаем вызов функции <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, то <code>coin</code> будет иметь значение <code>Coin::Quarter(UsState::Alaska)</code>. Когда мы будем сравнивать это значение с каждой из веток, ни одна из них не будет совпадать, пока мы не достигнем исхода <code>Coin::Quarter(state)</code>. В этот мгновение <code>state</code> привяжется к значению <code>UsState::Alaska</code>. Затем мы сможем использовать эту привязку в выражении <code>println!</code>, получив таким образом внутреннее значение исхода <code>Quarter</code> перечисления <code>Coin</code>.</p>
<h3 id="Сопоставление-образца-для-optiont"><a class="header" href="#Сопоставление-образца-для-optiont">Сопоставление образца для <code>Option&lt;T&gt;</code></a></h3>
<p>В предыдущем разделе мы хотели получить внутреннее значение <code>T</code> для случая <code>Some</code> при использовании <code>Option&lt;T&gt;</code>; мы можем обработать вид <code>Option&lt;T&gt;</code> используя <code>match</code>, как уже делали с перечислением <code>Coin</code>! Вместо сравнения монет мы будем сравнивать исходы <code>Option&lt;T&gt;</code>, независимо от этого изменения рычаг работы выражения <code>match</code> останется прежним.</p>
<p>Допустим, мы хотим написать функцию, которая принимает <code>Option&lt;i32&gt;</code> и если есть значение внутри, то добавляет 1 к существующему значению. Если значения нет, то функция должна возвращать значение <code>None</code> и не пытаться выполнить какие-либо действия.</p>
<p>Такую функцию довольно легко написать благодаря выражению <code>match</code>, код будет выглядеть как в приложении 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-5: Функция, использующая выражение <code>match</code> для <code>Option&lt;i32&gt;</code></span></p>
<p>Давайте более подробно рассмотрим первое выполнение <code>plus_one</code>. Когда мы вызываем <code>plus_one(five)</code>, переменная <code>x</code> в теле <code>plus_one</code> будет иметь значение <code>Some(5)</code>. Затем мы сравниваем это значение с каждой ветвью сопоставления:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Значение <code>Some(5)</code> не соответствует образцу <code>None</code>, поэтому мы продолжаем со следующим ответвлением:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Совпадает ли <code>Some(5)</code> с образцом <code>Some(i)</code>? Да, это так! У нас такой же исход. Тогда переменная <code>i</code> привязывается к значению, содержащемуся внутри <code>Some</code>, поэтому <code>i</code> получает значение <code>5</code>. Затем выполняется код сопряженный для данного ответвления, поэтому мы добавляем 1 к значению <code>i</code> и создаём новое значение <code>Some</code> со значением <code>6</code> внутри.</p>
<p>Теперь давайте рассмотрим второй вызов <code>plus_one</code> в приложении 6-5, где <code>x</code> является <code>None</code>. Мы входим в выражение <code>match</code> и сравниваем значение с первым ответвлением:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Оно совпадает! Для данной ветки образец (<em>None</em>) не подразумевает наличие какого-то значения к которому можно было бы что-то добавить, поэтому программа останавливается и возвращает значение которое находится справа от <code>=&gt;</code> - т.е. <code>None</code>. Так как образец первой ветки совпал, то никакие другие образцы веток не сравниваются.</p>
<p>Соединение <code>match</code> и перечислений полезно во многих случаейх. Вы часто будете видеть подобную сочетание в коде на Rust: сделать сопоставление значений перечисления используя <code>match</code>, привязать переменную к данным внутри значения, выполнить код на основе привязанных данных. Сначала это может показаться немного сложным, но как только вы привыкнете, то захотите чтобы такая возможность была бы во всех языках. Это неизменно любимый пользователями приём.</p>
<h3 id="match-охватывает-все-исходы-значения"><a class="header" href="#match-охватывает-все-исходы-значения">Match охватывает все исходы значения</a></h3>
<p>Есть ещё один особенность <code>match</code>, который мы должны обсудить: образцы должны покрывать все возможные исходы. Рассмотрим эту исполнение нашей функции <code>plus_one</code>, которая содержит ошибку и не собирается:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Мы не обработали исход <code>None</code>, поэтому этот код вызовет изъян в программе. К счастью, Ржавчина знает и умеет ловить такой случай. Если мы попытаемся собрать такой код, мы получим ошибку сборки:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/option.rs:571:1
 ::: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/option.rs:575:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust знает, что мы не описали все возможные случаи, и даже знает, какой именно из образцов мы упуисполнения! Сопоставления в Ржавчина являются <em>исчерпывающими</em>: мы должны покрыть все возможные исходы, чтобы код был правильным. Особенно в случае <code>Option&lt;T&gt;</code>, когда Ржавчина не даёт нам забыть обработать явным образом значение <code>None</code>, тем самым он защищает нас от предположения, что у нас есть значение, в то время как у нас может быть и null, что делает невозможным совершить ошибку на миллиард долларов, о которой говорилось ранее.</p>
<h3 id="Гибкие-образцы-и-заполнитель-_"><a class="header" href="#Гибкие-образцы-и-заполнитель-_">Гибкие образцы и заполнитель <code>_</code></a></h3>
<p>Используя перечисления, мы также можем выполнять особые действия для нескольких определённых значений, а для всех остальных значений выполнять одно действие по умолчанию. Представьте, что мы выполняем игру, в которой при выпадении 3 игрок не двигается, а получает новую нового образца шляпу. Если выпадает 7, игрок теряет шляпу. При всех остальных значениях ваш игрок перемещается на столько-то мест на игровом поле. Вот <code>match</code>, выполняющий эту логику, в котором итог броска костей жёстко закодирован, а не является случайным значением, а вся остальная логика представлена функциями без тел, поскольку их выполнение не входит в рамки данного примера:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Для первых двух веток образцами являются записанные значения 3 и 7. Для последней ветки, которая охватывает все остальные возможные значения, образцом является переменная, которую мы решили назвать <code>other</code>. Код, выполняемый для ветки <code>other</code>, использует эту переменную, передавая её в функцию <code>move_player</code>.</p>
<p>Этот код собирается, даже если мы не перечислили все возможные значения <code>u8</code>, потому что последний образец будет соответствовать всем значениям, не указанным в определенном списке. Этот гибкий образец удовлетворяет требованию, что соответствие должно быть исчерпывающим. Обратите внимание, что мы должны поместить ветку с гибким образцом последней, потому что образцы оцениваются по порядку. Ржавчина предупредит нас, если мы добавим ветки после гибкого образца, потому что эти последующие ветки никогда не будут выполняться!</p>
<p>В Ржавчина также есть образец, который можно использовать, когда мы не хотим использовать значение в гибком образце: <code>_</code>, который является особым образцом, который соответствует любому значению и не привязывается к этому значению. Это говорит Rust, что мы не собираемся использовать это значение, поэтому Ржавчина не будет предупреждать нас о неиспользуемой переменной.</p>
<p>Давайте изменим правила игры так: если выпадает что-то, кроме 3 или 7, нужно бросить ещё раз. Нам не нужно использовать значение в этом случае, поэтому мы можем изменить наш код, чтобы использовать <code>_</code> вместо переменной с именем <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Этот пример также удовлетворяет требованию исчерпывающей полноты, поскольку мы явно пренебрегаем все остальные значения в последней ветке; мы ничего не забыли.</p>
<p>Если мы изменим правила игры ещё раз, чтобы в ваш ход не происходило ничего другого, если вы бросаете не 3 или 7, мы можем выразить это, используя единичное значение (пустой вид упорядоченного ряда, о котором мы упоминали в разделе <a href="ch03-02-data-types.html#the-tuple-type">"Упорядоченные ряды"</a><!-- ignore -->) в качестве кода, который идёт вместе с веткой <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы явно говорим Rust, что не собираемся использовать никакое другое значение, которое не соответствует образцам в предыдущих ветках, и не хотим запускать никакой код в этом случае.</p>
<p>Подробнее о образцах и совпадениях мы поговорим в <a href="ch18-00-patterns.html">Главе 18</a><!-- ignore -->. Пока же мы перейдём к правилам написания <code>if let</code>, который может быть полезен в случаейх, когда выражение <code>match</code> слишком многословно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Краткое-управление-потоком-выполнения-с-if-let"><a class="header" href="#Краткое-управление-потоком-выполнения-с-if-let">Краткое управление потоком выполнения с <code>if let</code></a></h2>
<p>правила написания <code>if let</code> позволяет ссоединенять <code>if</code> и <code>let</code> в менее многословную устройство, и затем обработать значения соответствующе только одному образцу, одновременно пренебрегая все остальные. Рассмотрим программу в приложении 6-6, которая обрабатывает сопоставление значения <code>Option&lt;u8&gt;</code> в переменной <code>config_max</code>, но хочет выполнить код только в том случае, если значение является исходом <code>Some</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!("The maximum is configured to be {max}"),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-6. Выражение <code>match</code>, которое выполнит код только при значении равном <code>Some</code></span></p>
<p>Если значение равно <code>Some</code>, мы распечатываем значение в исходе <code>Some</code>, привязывая значение к переменной <code>max</code> в образце. Мы не хотим ничего делать со значением <code>None</code>. Чтобы удовлетворить выражение <code>match</code>, мы должны добавить <code>_ =&gt; ()</code> после обработки первой и единственной ветки, и добавление образцового кода раздражает.</p>
<p>Вместо этого, мы могли бы написать это более коротким способом, используя <code>if let</code>. Следующий код ведёт себя так же, как выражение <code>match</code> в приложении 6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {max}");
    }
<span class="boring">}</span></code></pre></pre>
<p>правила написания <code>if let</code> принимает образец и выражение, разделённые знаком равенства. Он работает так же, как <code>match</code>, когда в него на вход передадут выражение и подходящим образцом для этого выражения окажется первая ветка. В данном случае образцом является <code>Some(max)</code>, где <code>max</code> привязывается к значению внутри <code>Some</code>. Затем мы можем использовать <code>max</code> в теле раздела <code>if let</code> так же, как мы использовали <code>max</code> в соответствующей ветке <code>match</code>. Код в разделе <code>if let</code> не запускается, если значение не соответствует образцу.</p>
<p>Используя <code>if let</code> мы меньше печатаем, меньше делаем отступов и меньше получаем образцового кода. Тем не менее, мы теряем полную проверку всех исходов, предоставляемую выражением <code>match</code>. Выбор между <code>match</code> и <code>if let</code> зависит от того, что вы делаете в вашем определенном случае и является ли получение краткости при потере полноты проверки подходящим соглашением.</p>
<p>Другими словами, вы можете думать о устройства <code>if let</code> как о <em>синтаксическом сахаре</em> для <code>match</code>, который выполнит код если входное значение будет соответствовать единственному образцу, и пренебрегает все остальные значения.</p>
<p>Можно добавлять <code>else</code> к <code>if let</code>. Разделкода, который находится внутри <code>else</code> подобен по смыслу блоку кода ветки связанной с образцом <code>_</code> выражения <code>match</code> (которое эквивалентно сборной устройства <code>if let</code> и <code>else</code>). Вспомним объявление перечисления <code>Coin</code> в приложении 6-4, где исход <code>Quarter</code> также содержит внутри значение штата вида <code>UsState</code>. Если бы мы хотели посчитать все монеты не являющиеся четвертями, а для четвертей печатать название штата, то мы могли бы сделать это с помощью выражения <code>match</code> таким образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("State quarter from {state:?}!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>Или мы могли бы использовать выражение <code>if let</code> и <code>else</code> так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {state:?}!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<p>Если у вас есть случаей в которой ваша программа имеет логику которая слишком многословна для того чтобы её выражать используя <code>match</code>, помните, о том, что также в вашем наборе средств Ржавчина есть <code>if let</code>.</p>
<h2 id="Итоги-4"><a class="header" href="#Итоги-4">Итоги</a></h2>
<p>Мы рассмотрели как использовать перечисления для создания пользовательских видов, которые могут быть одним из наборов перечисляемых значений. Мы показали, как вид <code>Option&lt;T&gt;</code> из встроенной библиотеки помогает использовать систему видов для предотвращения ошибок. А когда значения перечисления имеют данные внутри них, можно использовать <code>match</code> или <code>if let</code>, чтобы извлечь и пользоваться значением, в зависимости от того, сколько случаев нужно обработать.</p>
<p>Теперь ваши программы на Ржавчина могут выражать подходы вашей предметной области, используя устройства и перечисления. Создание и использование пользовательских видов в API обеспечивает <em>типобезопасность</em>: сборщик позаботится о том, чтобы функции получали значения только того вида, который они ожидают.</p>
<p>Чтобы предоставить вашим пользователям хорошо согласованный API, который прост в использовании и предоставляет только то, что нужно вашим пользователям, надо поговорить о звенах в Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Управление-растущими-делами-с-помощью-дополнений-ящиков-и-звеньев"><a class="header" href="#Управление-растущими-делами-с-помощью-дополнений-ящиков-и-звеньев">Управление растущими делами с помощью дополнений, ящиков и звеньев</a></h1>
<p>По мере роста кодовой хранилища ваших программ, создание дела будет иметь большое значение, ведь отслеживание всей программы в голове будет становиться всё более сложным.  Объединенияя связанные функции и разделяя код по основным возможностям <em>(фичам, feature)</em>, вы делаете более прозрачным понимание о том, где искать код выполняющий определённую функцию и где стоит вносить изменения для того чтобы изменить её поведение.</p>
<p>Программы, которые мы писали до сих пор, были в одном файле одного звена. По мере роста дела, мы можем создавать код иначе, разделив его на несколько звеньев и несколько файлов. Дополнение может содержать несколько двоичных ящиков и дополнительно один ящик библиотеки. Дополнение может включать в себя много двоичных ящиков и дополнительно один библиотечный ящик. По мере роста дополнения вы можете извлекать части программы в отдельные ящики, которые затем станут внешними зависимостями для основного кода нашей программы. Эта глава охватывает все эти техники. В свою очередь для очень крупных дел, состоящих из набора взаимосвязанных дополнений развивающихся вместе, Cargo предоставляет рабочие пространства, <em>workspaces</em>, их мы рассмотрим за пределами данной главы, в разделе <a href="ch14-03-cargo-workspaces.html">"Рабочие пространства Cargo"</a> Главы 14.</p>
<p>Мы также обсудим инкапсуляцию подробностей, которая позволяет использовать код снова на более высоком уровне: единожды выполнив какую-то действие, другой код может вызывать этот код через открытый внешняя оболочка, не зная как работает выполнение. То, как вы пишете код, определяет какие части общедоступны для использования другим кодом и какие части являются закрытыми деталями выполнения для которых вы оставляете право на изменения только за собой. Это ещё один способ ограничить количество подробностей, которые вы должны держать в голове.</p>
<p>Связанное понятие - это область видимости: вложенный среда в котором написан код имеющий набор имён, которые определены «в текущей области видимости». При чтении, письме и сборки кода, программистам и сборщикам необходимо знать, относится ли определенное имя в определённом месте к переменной, к функции, к устройстве, к перечислению, к звену, к постоянных значенийе или другому элементу и что означает этот элемент. Можно создавать области видимости и изменять какие имена входят или выходят за их рамки. Нельзя иметь два элемента с тем же именем в одной области; есть доступные средства для разрешения несоответствий имён.</p>
<p>Rust имеет ряд функций, которые позволяют управлять согласованием кода, в том числе управлять тем какие подробности открыты, какие подробности являются частными, какие имена есть в каждой области вашей программы. Эти функции иногда вместе именуемые <em>состоящей из звеньев системой</em> включают в себя:</p>
<ul>
<li><strong>Дополнения:</strong> Возможности Cargo позволяющий собирать, проверять и делиться ящиками</li>
<li><strong>Ящики:</strong> Дерево звеньев, которое создаёт библиотечный или исполняемый файл</li>
<li><strong>Звенья</strong> и <strong>use:</strong> Позволяют вместе управлять устройство, область видимости и скрытие путей</li>
<li><strong>Пути:</strong> способ именования элемента, такого как устройства, функция или звено</li>
</ul>
<p>В этой главе мы рассмотрим все эти функции, обсудим как они взаимодействуют и объясним, как использовать их для управления областью видимости. К концу у вас должно появиться солидное понимание состоящей из звеньев системы и умение работать с областями видимости на уровне искуссника!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнения-и-ящики"><a class="header" href="#Дополнения-и-ящики">Дополнения и ящики</a></h2>
<p>Первые части состоящей из звеньев системы, которые мы рассмотрим — это дополнения и ящики.</p>
<p><em>Ящик</em> — это наименьший размер кода, который сборщик Ржавчина рассматривает за раз. Даже если вы запустите <code>rustc</code> вместо <code>cargo</code> и передадите один файл с исходным кодом (как мы уже делали в разделе «Написание и запуск программы на Rust» Главы 1), сборщик считает этот файл ящиком. Ящики могут содержать звенья, и звенья могут быть определены в других файлах, которые собираются вместе с ящиком, как мы увидим в следующих разделах.</p>
<p>Ящик может быть одним из двух видов: двоичный ящик или библиотечный ящик. <em>Бинарные ящики</em> — это программы, которые вы можете собрать в исполняемые файлы, которые вы можете запускать, например программу приказной строки или сервер. У каждого двоичного ящика должна быть функция с именем <code>main</code>, которая определяет, что происходит при запуске исполняемого файла. Все ящики, которые мы создали до сих пор, были двоичными ящиками.</p>
<p><em>Библиотечные ящики</em> не имеют функции <code>main</code> и не собираются в исполняемый файл. Вместо этого они определяют возможность, предназначенную для совместного использования другими делами. Например, ящик <code>rand</code>, который мы использовали в <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">Главе 2</a><!-- ignore --> обеспечивает возможность, которая порождает случайные числа. В большинстве случаев, когда Rustaceans говорят «ящик», они имеют в виду библиотечный ящик, и они используют «ящик» взаимозаменяемо с общей подходом программирования «библиотека».</p>
<p><em>Корневой звено ящика</em> — это исходный файл, из которого сборщик Ржавчина начинает собирать корневой звено вашего ящика (мы подробно объясним звенья в разделе <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">«Определение звеньев для управления видимости и закрытости»</a><!-- ignore -->).</p>
<p><em>Дополнение</em> — это набор из одного или нескольких ящиков, предоставляющий набор возможности. Дополнение содержит файл <em>Cargo.toml</em>, в котором описывается, как собирать эти ящики. На самом деле Cargo — это дополнение, содержащий двоичный ящик для средства приказной строки, который вы использовали для создания своего кода. Дополнение Cargo также содержит библиотечный ящик, от которого зависит двоичный ящик. Другие дела тоже могут зависеть от библиотечного ящика Cargo, чтобы использовать ту же логику, что и средство приказной строки Cargo.</p>
<p>Дополнение может содержать сколько угодно двоичных ящиков, но не более одного библиотечного ящика. Дополнение должен содержать хотя бы один ящик, библиотечный или двоичный.</p>
<p>Давайте пройдёмся по тому, что происходит, когда мы создаём дополнение. Сначала введём приказ <code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>После того, как мы запустили <code>cargo new</code>, мы используем <code>ls</code>, чтобы увидеть, что создал Cargo. В папке дела есть файл <em>Cargo.toml</em>, дающий нам дополнение. Также есть папка <em>src</em>, содержащий <em>main.rs</em>. Откройте <em>Cargo.toml</em> в текстовом редакторе и обратите внимание, что в нём нет упоминаний о <em>src/main.rs</em>. Cargo следует соглашению о том, что <em>src/main.rs</em> — это корневой звено двоичного ящика с тем же именем, что и у дополнения. Точно так же Cargo знает, что если папка дополнения содержит <em>src/lib.rs</em>, дополнение содержит библиотечный ящик с тем же именем, что и дополнение, а <em>src/lib.rs</em> является корневым звеном этого ящика. Cargo передаёт файлы корневого звена ящика в <code>rustc</code> для сборки библиотечного или двоичного ящика.</p>
<p>Здесь у нас есть дополнение, который содержит только <em>src/main.rs</em>, что означает, что он содержит только двоичный ящик с именем <code>my-project</code>. Если дополнение содержит <em>src/main.rs</em> и <em>src/lib.rs</em>, он имеет два ящика: двоичный и библиотечный, оба с тем же именем, что и дополнение. Дополнение может иметь несколько двоичных ящиков, помещая их файлы в папка <em>src/bin</em>: каждый файл будет отдельным двоичным ящиком.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Определение-звеньев-для-управления-видимости-и-закрытости"><a class="header" href="#Определение-звеньев-для-управления-видимости-и-закрытости">Определение звеньев для управления видимости и закрытости</a></h2>
<p>В этом разделе мы поговорим о звенах и других частях системы звеньев, а именно: <em>путях</em> (paths), которые позволяют именовать элементы; ключевом слове <code>use</code>, которое приносит путь в область видимости; ключевом слове <code>pub</code>, которое делает элементы общедоступными. Мы также обсудим ключевое слово <code>as</code>, внешние дополнения и оператор glob. А пока давайте сосредоточимся на звенах!</p>
<p>Во-первых, мы начнём со списка правил, чтобы вам было легче понять при согласования кода в будущем. Затем мы подробно объясним каждое из правил.</p>
<h3 id="Шпаргалка-по-звенам"><a class="header" href="#Шпаргалка-по-звенам">Шпаргалка по звенам</a></h3>
<p>Здесь мы даём краткий обзор того, как звенья, пути, ключевое слово <code>use</code> и ключевое слово <code>pub</code> работают в сборщике и как большинство разработчиков согласуют свой код. В этой главе мы рассмотрим примеры каждого из этих правил, и это удобный мгновение чтобы напомнить о том, как работают звенья.</p>
<ul>
<li><strong>Начнём с корня ящика</strong>: при сборки сборщик сначала ищет корневой звено ящика (обычно это <em>src/lib.rs</em> для библиотечного ящика или <em>src/main.rs</em> для двоичного ящика) для сборки кода.</li>
<li><strong>Объявление звеньев</strong>: В файле корневого звена ящика вы можете объявить новые звенья; скажем, вы объявляете звено “garden” с помощью <code>mod garden;</code>. Сборщик будет искать код звена в следующих местах:
<ul>
<li>в этом же файле, между фигурных скобок, которые заменяют точку с запятой после <code>mod garden</code></li>
<li>в файле <em>src/garden.rs</em></li>
<li>в файле <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Объявление подзвеньев</strong>: В любом файле, кроме корневого звена ящика, вы можете объявить подзвенья. К примеру, вы можете объявить  <code>mod vegetables;</code> в <em>src/garden.rs</em>. Сборщик будет искать код подзвена в папке с именем родительского звена в следующих местах:
<ul>
<li>в этом же файле, сразу после <code>mod vegetables</code>, между фигурных скобок, которые заменяют точку с запятой</li>
<li>в файле <em>src/garden/vegetables.rs</em></li>
<li>в файле <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Пути к коду в звенах</strong>: После того, как звено станет частью вашего ящика и если допускают правила закрытости, вы можете ссылаться на код в этом звене из любого места вашего ящика, используя путь к коду. Например, вид <code>Asparagus</code>, в подзвене vegetables звена garden, будет найден по пути <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>Скрытие или общедоступность</strong>: Код в звене по умолчанию скрыт от родительского звена. Чтобы сделать звено общедоступным, объявите его как <code>pub mod</code> вместо <code>mod</code>. Чтобы сделать элементы общедоступного звена тоже общедоступными, используйте <code>pub</code> перед их объявлением.</li>
<li><strong>Ключевое слово <code>use</code></strong>: Внутри области видимости использование ключевого слова <code>use</code> создаёт псевдонимы для элементов, чтобы уменьшить повторение длинных путей. В любой области видимости, в которой может обращаться к <code>crate::garden::vegetables::Asparagus</code>, вы можете создать псевдоним <code>use crate::garden::vegetables::Asparagus;</code> и после этого вам нужно просто писать <code>Asparagus</code>, чтобы использовать этот вид в этой области видимости.</li>
</ul>
<p>Мы создали двоичный ящик <code>backyard</code>, который отображает эти правила. Директория ящика, также названная как <code>backyard</code>, содержит следующие файлы и папки:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>Файл корневого звена ящика в нашем случае  <em>src/main.rs</em>, и его содержимое:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}</code></pre>
<p>Строка <code>pub mod garden;</code> говорит сборщику о подключении кода, найденном в <em>src/garden.rs</em>:</p>
<p><span class="filename">Файл: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
<p>А здесь <code>pub mod vegetables;</code> указывает на подключаемый код в <em>src/garden/vegetables.rs</em>. Этот код:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>Теперь давайте рассмотрим подробности этих правил и отобразим их в действии!</p>
<h3 id="Объединение-связанного-кода-в-звенах"><a class="header" href="#Объединение-связанного-кода-в-звенах">Объединение связанного кода в звенах</a></h3>
<p><em>Звенья</em> позволяют упорядочивать код внутри ящика для удобочитаемости и лёгкого повторного использования. Звенья также позволяют нам управлять <em>закрытостью</em> элементов, поскольку код внутри звена по умолчанию является закрытым. Частные элементы — это внутренние подробности выполнения, недоступные для внешнего использования. Мы можем сделать звенья и элементы внутри них общедоступными, что позволит внешнему коду использовать их и зависеть от них.</p>
<p>В качестве примера, давайте напишем библиотечный ящик предоставляющий возможность ресторана. Мы определим ярлыки функций, но оставим их тела пустыми, чтобы сосредоточиться на согласования кода, вместо выполнения кода для ресторана.</p>
<p>В ресторанной индустрии некоторые части ресторана называются <em>фронтом дома</em>, а другие <em>задней частью дома</em>. Фронт дома это там где находятся клиенты; здесь размещаются места клиентов, официанты принимают заказы и оплаты, а бармены делают напитки. Задняя часть дома это где шеф-повара и повара работают на кухне,  работают посудомоечные машины, а управленцы занимаются административной деятельностью.</p>
<p>Чтобы внутренне выстроить</p>
<p>ящик подобно тому, как работает настоящий ресторан, можно согласовать размещение функций во вложенных звенах. Создадим новую библиотеку (библиотечный ящик) с именем <code>restaurant</code> выполнив приказ <code>cargo new restaurant --lib</code>; затем вставим код из приложения 7-1 в <em>src/lib.rs</em> для определения некоторых звеньев и ярлыков функций. Это раздел фронта дома:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<p><span class="caption">Приложение 7-1: Звено <code>front_of_house</code> , содержащий другие звенья, которые в свою очередь содержат функции</span></p>
<p>Мы определяем звено, начиная с ключевого слова  <code>mod</code>, затем определяем название звена (в данном случае <code>front_of_house</code>) и размещаем фигурные скобки вокруг тела звена. Внутри звеньев, можно иметь другие звенья, как в случае с звенами <code>hosting</code> и <code>serving</code>. Звенья также могут содержать определения для других элементов, таких как устройства, перечисления, постоянные значения, особенности или — как в приложении 7-1 — функции.</p>
<p>Используя звенья, мы можем собъединять связанные определения вместе и сказать почему они являются связанными. Программистам будет легче найти необходимую возможность в объединенном коде, вместо того чтобы искать её в одном общем списке. Программисты, добавляющие новые функции в этот код, будут знать, где разместить код для поддержания порядка в программе.</p>
<p>Как мы упоминали ранее, файлы <em>src/main.rs</em> и <em>src/lib.rs</em> называются <em>корневыми звенами ящика</em>. Причина такого именования в том, что содержимое любого из этих двух файлов образует звено с именем <code>crate</code> в корне устройства звеньев ящика, известной как <em>дерево звеньев</em>.</p>
<p>В приложении 7-2 показано дерево звеньев для устройства звеньев, приведённой в коде приложения 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Приложение 7-2: Древо звеньев для программы из Приложения 7-1</span></p>
<p>Это дерево показывает, как некоторые из звеньев вкладываются друг в друга; например, <code>hosting</code> находится внутри <code>front_of_house</code>. Дерево также показывает, что некоторые звенья являются  <em>братьями</em> (siblings) друг для друга, то есть они определены в одном звене; <code>hosting</code> и <code>serving</code> это братья которые определены внутри <code>front_of_house</code>. Если звено A содержится внутри звена B, мы говорим, что звено A является <em>потомком</em> (child) звена B, а звено B является <em>родителем</em> (parent) звена A. Обратите внимание, что родителем всего дерева звеньев является неявный звено с именем <code>crate</code>.</p>
<p>Дерево звеньев может напомнить вам дерево папок файловой системы на компьютере; это очень удачное сравнение! По подобию с папкими в файловой системе, мы используется звенья для согласования кода. И так же, как нам надо искать файлы в папких на компьютере, нам требуется способ поиска нужных звеньев.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Пути-для-ссылки-на-элемент-в-дереве-звеньев"><a class="header" href="#Пути-для-ссылки-на-элемент-в-дереве-звеньев">Пути для ссылки на элемент в дереве звеньев</a></h2>
<p>Чтобы показать Rust, где найти элемент в дереве звеньев, мы используем путь так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать её путь.</p>
<p>Пути бывают двух видов:</p>
<ul>
<li><em>абсолютный путь</em> - это полный путь, начинающийся от корневого звена ящика; для кода из внешнего ящика абсолютный путь начинается с имени ящика, а для кода из текущего ящика он начинается с записи <code>crate</code>.</li>
<li><em>относительный путь</em> начинается с текущего звена и использует ключевые слова <code>self</code>, <code>super</code> или определитель в текущем звене.</li>
</ul>
<p>Как абсолютные, так и относительные, пути состоят из одного или нескольких определителей, разделённых двойными двоеточиями (<code>::</code>).</p>
<p>Вернёмся к приложению 7-1, скажем, мы хотим вызвать функцию <code>add_to_waitlist</code>. Это то же самое, что спросить: какой путь у функции <code>add_to_waitlist</code>? В приложении 7-3 мы немного упроисполнения код приложения 7-1, удалив некоторые звенья и функции.</p>
<p>Мы покажем два способа вызова функции <code>add_to_waitlist</code> из новой функции <code>eat_at_restaurant</code>, определённой в корневом звене ящика. Эти пути правильные, но остаётся ещё одна неполадка, которая не позволит этому примеру собраться как есть. Мы скоро объясним почему.</p>
<p>Функция <code>eat_at_restaurant</code> является частью общедоступного API нашего библиотечного ящика, поэтому мы помечаем её ключевым словом <code>pub</code>. В разделе <a data-md-type="raw_html" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Раскрываем закрытые пути с помощью ключевого слова <code>pub</code>"</a><!-- ignore --> мы рассмотрим более подробно <code>pub</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-3. Вызов функции <code>add_to_waitlist</code> с использованием абсолютного и относительного пути</span></p>
<p>При первом вызове функции <code>add_to_waitlist</code> из <code>eat_at_restaurant</code> мы используем абсолютный путь. Функция <code>add_to_waitlist</code> определена в том же ящике, что и <code>eat_at_restaurant</code>, и это означает, что мы можем использовать ключевое слово <code>crate</code> в начале абсолютного пути. Затем мы добавляем каждый из последующих дочерних звеньев, пока не составим путь до <code>add_to_waitlist</code>. Вы можете представить себе файловую систему с такой же устройством: мы указываем путь <code>/front_of_house/hosting/add_to_waitlist</code> для запуска программы <code>add_to_waitlist</code>; использование имени <code>crate</code> в качестве корневого звена ящика подобно использованию <code>/</code> для указания корня файловой системы в вашей оболочке.</p>
<p>Второй раз, когда мы вызываем <code>add_to_waitlist</code> из <code>eat_at_restaurant</code>, мы используем относительный путь. Путь начинается с имени звена <code>front_of_house</code>, определённого на том же уровне дерева звеньев, что и <code>eat_at_restaurant</code>. Для эквивалентной файловой системы использовался бы путь <code>front_of_house/hosting/add_to_waitlist</code>. Начало пути с имени звена означает, что путь является относительным.</p>
<p>Выбор, использовать относительный или абсолютный путь, является решением, которое вы примете на основании вашего дела. Решение должно зависеть от того, с какой вероятностью вы переместите объявление элемента отдельно от или вместе с кодом использующим этот элемент. Например, в случае перемещения звена <code>front_of_house</code> и его функции <code>eat_at_restaurant</code> в другой звено с именем <code>customer_experience</code>, будет необходимо обновить абсолютный путь до <code>add_to_waitlist</code>, но относительный путь всё равно будет действителен. Однако, если мы переместим отдельно функцию <code>eat_at_restaurant</code> в звено с именем <code>dining</code>, то абсолютный путь вызова <code>add_to_waitlist</code> останется прежним, а относительный путь нужно будет обновить. Мы предпочитаем указывать абсолютные пути, потому что это позволяет проще перемещать определения кода и вызовы элементов независимо друг от друга.</p>
<p>Давайте попробуем собрать код из приложения 7-3 и выяснить, почему он ещё не собирается. Ошибка, которую мы получаем, показана в приложении 7-4.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Приложение 7-4. Ошибки сборки при сборке кода из приложения 7-3</span></p>
<p>Сообщения об ошибках говорят о том, что звено <code>hosting</code> является закрытым. Другими словами, у нас есть правильные пути к звену <code>hosting</code> и функции <code>add_to_waitlist</code>, но Ржавчина не позволяет нам использовать их, потому что у него нет доступа к закрытым разделам. В Ржавчина все элементы (функции, способы, устройства, перечисления, звенья и постоянные значения) по умолчанию являются закрытыми для родительских звеньев. Если вы хотите сделать элемент, например функцию или устройство, закрытым, вы помещаете его в звено.</p>
<p>Элементы в родительском звене не могут использовать закрытые элементы внутри дочерних звеньев, но элементы в дочерних звенах могут использовать элементы у своих звенах-предках. Это связано с тем, что дочерние звенья оборачивают и скрывают подробности своей выполнения, но дочерние звенья могут видеть среда, в котором они определены. Продолжая нашу метафору, подумайте о правилах закрытости как о задней части ресторана: то, что там происходит, скрыто от клиентов ресторана, но офис-управленцы могут видеть и делать всё в ресторане, которым они управляют.</p>
<p>В Ржавчина решили, что система звеньев должна исполняться таким образом, чтобы по умолчанию скрывать подробности выполнения. Таким образом, вы знаете, какие части внутреннего кода вы можете изменять не нарушая работы внешнего кода. Тем не менее, Ржавчина даёт нам возможность открывать внутренние части кода дочерних звеньев для внешних звеньев-предков, используя ключевое слово <code>pub</code>, чтобы сделать элемент общедоступным.</p>
<h3 id="Раскрываем-закрытые-пути-с-помощью-ключевого-слова-pub"><a class="header" href="#Раскрываем-закрытые-пути-с-помощью-ключевого-слова-pub">Раскрываем закрытые пути с помощью ключевого слова <code>pub</code><a id="exposing-paths-with-the-pub-keyword"></a></a></h3>
<p>Давайте вернёмся к ошибке в приложении 7-4, которая говорит, что звено <code>hosting</code> является закрытым. Мы хотим, чтобы функция <code>eat_at_restaurant</code> из родительского звена имела доступ к функции <code>add_to_waitlist</code> в дочернем звене, поэтому мы помечаем звено <code>hosting</code> ключевым словом <code>pub</code>, как показано в приложении 7-5.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-5. Объявление звена <code>hosting</code> как <code>pub</code> для его использования из <code>eat_at_restaurant</code></span></p>
<p>К сожалению, код в приложении 7-5 всё ещё приводит к ошибке, как показано в приложении 7-6.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Приложение 7-6: Ошибки сборки при сборке кода в приложении 7-5</span></p>
<p>Что произошло? Добавление ключевого слова <code>pub</code> перед <code>mod hosting</code> сделало звено общедоступным. После этого изменения, если мы можем получить доступ к звену <code>front_of_house</code>, то мы можем получить доступ к звену <code>hosting</code>. Но <em>содержимое</em> звена <code>hosting</code> всё ещё является закрытым: превращение звена в общедоступный звено не делает его содержимое общедоступным. Ключевое слово <code>pub</code> позволяет внешнему коду в звенах-предках обращаться только к звену, без доступа ко внутреннему коду. Поскольку звенья являются дополнениями, мы мало что можем сделать, просто сделав звено общедоступным; нам нужно пойти дальше и сделать один или несколько элементов в звене общедоступными.</p>
<p>Ошибки в приложении 7-6 говорят, что функция <code>add_to_waitlist</code> является закрытой. Правила закрытости применяются к устройствам, перечислениям, функциям и способам, также как и к звенам.</p>
<p>Давайте также сделаем функцию <code>add_to_waitlist</code> общедоступной, добавив ключевое слово <code>pub</code> перед её определением, как показано в приложении 7-7.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-7. Добавление ключевого слова <code>pub</code> к <code>mod hosting</code> и к <code>fn add_to_waitlist</code> позволяет нам вызывать функцию из <code>eat_at_restaurant</code></span></p>
<p>Теперь код собирается! Чтобы понять, почему добавление ключевого слова <code>pub</code> позволяет нам использовать эти пути для <code>add_to_waitlist</code> в соответствии с правилами закрытости, давайте рассмотрим абсолютный и относительный пути.</p>
<p>В случае абсолютного пути мы начинаем с <code>crate</code>, корня дерева звеньев нашего ящика. Звено <code>front_of_house</code> определён в корневом звене ящика. Хотя <code>front_of_house</code> не является общедоступным, но поскольку функция <code>eat_at_restaurant</code> определена в том же звене, что и <code>front_of_house</code> (то есть, <code>eat_at_restaurant</code> и <code>front_of_house</code> являются потомками одного родителя), мы можем ссылаться на <code>front_of_house</code> из <code>eat_at_restaurant</code>. Далее идёт звено <code>hosting</code>, помеченный как <code>pub</code>. Мы можем получить доступ к родительскому звену звена <code>hosting</code>, поэтому мы можем получить доступ и к <code>hosting</code>. Наконец, функция <code>add_to_waitlist</code> помечена как <code>pub</code>, и так как мы можем получить доступ к её родительскому звену, то вызов этой функции разрешён!</p>
<p>В случае относительного пути логика такая же как для абсолютного пути, за исключением первого шага: вместо того, чтобы начинать с корневого звена ящика, путь начинается с <code>front_of_house</code>. Звено <code>front_of_house</code> определён в том же звене, что и <code>eat_at_restaurant</code>, поэтому относительный путь, начинающийся с звена, в котором определена <code>eat_at_restaurant</code> тоже работает. Тогда, по причине того, что <code>hosting</code> и <code>add_to_waitlist</code> помечены как <code>pub</code>, остальная часть пути работает и вызов этой функции разрешён!</p>
<p>Если вы собираетесь предоставить общий доступ к своему библиотечному ящику, чтобы другие дела могли использовать ваш код, ваш общедоступный API — это ваш договор с пользователями вашего ящика, определяющий, как они могут взаимодействовать с вашим кодом. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать необременительным для людей зависимость от вашего ящика. Эти соображения выходят за рамки этой книги; если вам важна эта тема, см. <a href="https://rust-lang.github.io/api-guidelines/">The Ржавчина API Guidelines</a>.</p>
<blockquote>
<h4 id="Лучшие-опытов-для-дополнений-с-двоичным-и-библиотечным-ящиками"><a class="header" href="#Лучшие-опытов-для-дополнений-с-двоичным-и-библиотечным-ящиками">Лучшие опытов для дополнений с двоичным и библиотечным ящиками</a></h4>
<p>Мы упоминали, что дополнение может содержать как корневой звено двоичного ящика <em>src/main.rs</em>, так и корневой звено библиотечного ящика <em>src/lib.rs</em>, и оба ящика будут по умолчанию иметь имя дополнения. Как правило, дополнения с таким образцом, содержащим как библиотечный, так и двоичный ящик, будут иметь достаточно кода в двоичном ящике, чтобы запустить исполняемый файл, который вызывает код из библиотечного ящика. Это позволяет другим делам извлечь выгоду из большей части возможности, предоставляемой дополнением, поскольку код библиотечного ящика можно использовать совместно.</p>
<p>Дерево звеньев должно быть определено в <em>src/lib.rs</em>. Затем любые общедоступные элементы можно использовать в двоичном ящике, начав пути с имени дополнения. Двоичный ящик становится пользователем библиотечного ящика точно так же, как полностью внешний ящик использует библиотечный ящик: он может использовать только общедоступный API. Это поможет вам разработать хороший API; вы не только автор, но и пользователь!</p>
<p>В <a href="ch12-00-an-io-project.html">Главе 12</a><!-- ignore --> мы эту опыт согласования кода с помощью окно выводаной программы, которая будет содержать как двоичный, так и библиотечный ящики.</p>
</blockquote>
<h3 id="Начинаем-относительный-путь-с-помощью-super"><a class="header" href="#Начинаем-относительный-путь-с-помощью-super">Начинаем относительный путь с помощью <code>super</code></a></h3>
<p>Также можно построить относительные пути, которые начинаются в родительском звене, используя ключевое слово <code>super</code> в начале пути. Это похоже на правила написания начала пути файловой системы <code>..</code>. Использование <code>super</code> позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском звене, что может упростить переупорядочение дерева звеньев, чем когда звено тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве звеньев.</p>
<p>Рассмотрим код в приложении 7-8, где расчитывается случаей, в которой повар исправляет неправильный заказ и лично приносит его клиенту. Функция <code>fix_incorrect_order</code> вызывает функцию <code>deliver_order</code>, определённую в родительском звене, указывая путь к <code>deliver_order</code>, начинающийся с <code>super</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<p><span class="caption">Приложение 7-8: Вызов функции с использованием относительного пути, начинающегося с <code>super</code></span></p>
<p>Функция <code>fix_incorrect_order</code> находится в звене <code>back_of_house</code>, поэтому мы можем использовать <code>super</code> для перехода к родительскому звену звена <code>back_of_house</code>, который в этом случае является <code>crate</code>, корневым звеном. В этом звене мы ищем <code>deliver_order</code> и находим его. Успех! Мы думаем, что звено <code>back_of_house</code> и функция <code>deliver_order</code>, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут перемещены вместе, если мы решим ресогласовать дерево звеньев ящика. Поэтому мы использовали <code>super</code>, чтобы в будущем у нас было меньше мест для обновления кода, если этот код будет перемещён в другой звено.</p>
<h3 id="Делаем-общедоступными-устройства-и-перечисления"><a class="header" href="#Делаем-общедоступными-устройства-и-перечисления">Делаем общедоступными устройства и перечисления</a></h3>
<p>Мы также можем использовать <code>pub</code> для обозначения устройств и перечислений как общедоступных, но есть несколько дополнительных подробностей использования <code>pub</code> со устройствами и перечислениями. Если мы используем <code>pub</code> перед определением устройства, мы делаем устройство общедоступной, но поля устройства по-прежнему остаются закрытыми. Мы можем сделать каждое поле общедоступным или нет в каждом определенном случае. В приложении 7-9 мы определили общедоступную устройство <code>back_of_house::Breakfast</code> с общедоступным полем <code>toast</code> и с закрытым полем <code>seasonal_fruit</code>. Это расчитывает случай в ресторане, когда клиент может выбрать вид хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому клиенты не могут выбирать фрукты или даже увидеть, какие фрукты они получат.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
<p><span class="caption">Приложение 7-9: Устройства с общедоступными и закрытыми полями</span></p>
<p>Поскольку поле <code>toast</code> в устройстве <code>back_of_house::Breakfast</code> является открытым, то в функции <code>eat_at_restaurant</code> можно писать и читать поле <code>toast</code>, используя точечную наставление. Обратите внимание, что мы не можем использовать поле <code>seasonal_fruit</code> в <code>eat_at_restaurant</code>, потому что <code>seasonal_fruit</code> является закрытым. Попробуйте убрать примечания с последней строки для значения поля <code>seasonal_fruit</code>, чтобы увидеть какую ошибку вы получите!</p>
<p>Также обратите внимание, что поскольку <code>back_of_house::Breakfast</code> имеет закрытое поле, то устройства должна предоставить открытую сопряженную функцию, которая создаёт образец <code>Breakfast</code> (мы назвали её <code>summer</code>). Если <code>Breakfast</code> не имел бы такой функции, мы бы не могли создать образец <code>Breakfast</code> внутри <code>eat_at_restaurant</code>, потому что мы не смогли бы установить значение закрытого поля <code>seasonal_fruit</code> в функции <code>eat_at_restaurant</code>.</p>
<p>В отличии от устройства, если мы сделаем общедоступным перечисление, то все его исходы будут общедоступными. Нужно только указать <code>pub</code> перед ключевым словом <code>enum</code>, как показано в приложении 7-10.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<p><span class="caption">Приложение 7-10. Определяя перечисление общедоступным мы делаем все его исходы общедоступными</span></p>
<p>Поскольку мы сделали общедоступным перечисление <code>Appetizer</code>, то можно использовать исходы <code>Soup</code> и <code>Salad</code> в функции <code>eat_at_restaurant</code>.</p>
<p>Перечисления не очень полезны, если их исходы не являются общедоступными: было бы досадно каждый раз определять все исходы перечисления как <code>pub</code>. По этой причине по умолчанию исходы перечислений являются общедоступными. Устройства часто полезны, если их поля не являются общедоступными, поэтому поля устройства следуют общему правилу, согласно которому, всё по умолчанию является закрытым, если не указано <code>pub</code>.</p>
<p>Есть ещё одна случаей с <code>pub</code>, которую мы не освещали, и это последняя особенность состоящей из звеньев системы: ключевое слово <code>use</code>. Мы сначала опишем <code>use</code> само по себе, а затем покажем как сочетать <code>pub</code> и <code>use</code> вместе.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Подключение-путей-в-область-видимости-с-помощью-ключевого-слова-use"><a class="header" href="#Подключение-путей-в-область-видимости-с-помощью-ключевого-слова-use">Подключение путей в область видимости с помощью ключевого слова <code>use</code></a></h2>
<p>Необходимость записывать пути к функциям вызова может показаться неудобной и повторяющейся. В приложении 7-7 независимо от того, выбирали ли мы абсолютный или относительный путь к функции <code>add_to_waitlist</code> , каждый раз, когда мы хотели вызвать <code>add_to_waitlist</code> , нам приходилось также указывать <code>front_of_house</code> и <code>hosting</code> . К счастью, есть способ упростить этот этап: мы можем один раз создать псевдоним на путь при помощи ключевого слова <code>use</code>, а затем использовать более короткое имя везде в области видимости.</p>
<p>В приложении 7-11 мы подключили звено <code>crate::front_of_house::hosting</code> в область действия функции <code>eat_at_restaurant</code>, поэтому нам достаточно только указать <code>hosting::add_to_waitlist</code> для вызова функции <code>add_to_waitlist</code> внутри <code>eat_at_restaurant</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-11. Добавление звена в область видимости при помощи <code>use</code></span></p>
<p>Добавление <code>use</code> и пути в область видимости подобно созданию символической ссылки в файловой системе. С добавлением <code>use crate::front_of_house::hosting</code> в корневой звено ящика, <code>hosting</code> становится допустимым именем в этой области, как если бы звено <code>hosting</code> был определён в корневом звене ящика. Пути, подключённые в область видимости с помощью <code>use</code>, также проверяются на доступность, как и любые другие пути.</p>
<p>Обратите внимание, что <code>use</code> создаёт псевдоним только для той именно области, в которой это объявление <code>use</code> и находится. В приложении 7-12 функция <code>eat_at_restaurant</code> перемещается в новый дочерний звено с именем <code>customer</code>, область действия которого отличается от области действия указания <code>use</code>, поэтому тело функции не будет собираться:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<p><span class="caption">Приложение 7-12. Указание <code>use</code> применяется только в её собственной области видимости</span></p>
<p>Ошибка сборщика показывает, что данный псевдоним не может использоваться в звене <code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Обратите внимание, что есть также предупреждение о том, что <code>use</code> не используется в своей области! Чтобы решить эту неполадку, можно переместить <code>use</code> в звено <code>customer</code>, или же можно сослаться на псевдоним в родительском звене с помощью <code>super::hosting</code> в дочернем звене <code>customer</code>.</p>
<h3 id="Создание-идиоматических-путей-с-use"><a class="header" href="#Создание-идиоматических-путей-с-use">Создание идиоматических путей с <code>use</code></a></h3>
<p>В приложении 7-11 вы могли бы задаться вопросом, почему мы указали  <code>use crate::front_of_house::hosting</code>, а затем вызвали <code>hosting::add_to_waitlist</code> внутри <code>eat_at_restaurant</code> вместо указания в  <code>use</code> полного пути прямо до функции <code>add_to_waitlist</code> для получения того же итога, что в приложении 7-13.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-13: Добавление функции <code>add_to_waitlist</code> в область видимости с <code>use</code> неидиоматическим способом</span></p>
<p>Хотя приложениеи 7-11 и 7-13 выполняют одну и ту же задачу, приложение 7-11 является идиоматическим способом подключения функции в область видимости с помощью <code>use</code>. Подключение родительского звена функции в область видимости при помощи <code>use</code> означает, что мы должны указывать родительский звено при вызове функции. Указание родительского звена при вызове функции даёт понять, что функция не определена местно, но в то же время сводя к уменьшению повторение полного пути. В коде приложения 7-13 не ясно, где именно определена <code>add_to_waitlist</code>.</p>
<p>С другой стороны, при подключении устройств, перечислений и других элементов используя <code>use</code>, идиоматически правильным будет указывать полный путь. Приложение 7-14 показывает идиоматический способ подключения устройства встроенной библиотеки <code>HashMap</code> в область видимости двоичного ящика.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Приложение 7-14. Включение <code>HashMap</code> в область видимости идиоматическим способом</span></p>
<p>За этой идиомой нет веской причины: это просто соглашение, которое появилось само собой. Люди привыкли читать и писать код на Ржавчина таким образом.</p>
<p>Исключением из этой идиомы является случай, когда мы подключаем два элемента с одинаковыми именами в область видимости используя указанию <code>use</code> — Ржавчина просто не позволяет этого сделать. Приложение 7-15 показывает, как подключить в область действия два вида с одинаковыми именами <code>Result</code>, но из разных родительских звеньев и как на них ссылаться.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Приложение 7-15. Для включения двух видов с одинаковыми именами в одну область видимости необходимо использовать их родительские звенья.</span></p>
<p>Как видите, использование имени родительских звеньев позволяет различать два вида <code>Result</code>. Если бы вместо этого мы указали <code>use std::fmt::Result</code> и <code>use std::io::Result</code>, мы бы имели два вида <code>Result</code> в одной области видимости, и Ржавчина не смог бы понять какой из двух <code>Result</code> мы имели в виду, когда нашёл бы их употребление в коде.</p>
<h3 id="Предоставление-новых-имён-с-помощью-ключевого-слова-as"><a class="header" href="#Предоставление-новых-имён-с-помощью-ключевого-слова-as">Предоставление новых имён с помощью ключевого слова <code>as</code></a></h3>
<p>Есть другое решение сбоев добавления двух видов с одинаковыми именами в одну и ту же область видимости используя <code>use</code>: после пути можно указать <code>as</code> и новое местное имя (псевдоним) для вида. Приложение 7-16 показывает как по-другому написать код из приложения 7-15, путём переименования одного из двух видов <code>Result</code> используя <code>as</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Приложение 7-16: Переименование вида, когда он включён в область видимости с помощью ключевого слова <code>as</code></span></p>
<p>Во второй указания <code>use</code> мы выбрали новое имя <code>IoResult</code> для вида <code>std::io::Result</code>, которое теперь не будет враждовать с видом <code>Result</code> из <code>std::fmt</code>, который также подключён в область видимости. Приложения 7-15 и 7-16 считаются идиоматичными, поэтому выбор за вами!</p>
<h3 id="Реэкспорт-имён-с-pub-use"><a class="header" href="#Реэкспорт-имён-с-pub-use">Реэкспорт имён с <code>pub use</code></a></h3>
<p>Когда мы подключаем имя в область видимости, используя ключевое слово <code>use</code>, то имя, доступное в новой области видимости, является закрытым. Чтобы позволить коду, который вызывает наш код, ссылаться на это имя, как если бы оно было определено в области видимости данного кода, можно объединить <code>pub</code> и <code>use</code>. Этот способ называется <em>реэкспортом (re-exporting)</em>, потому что мы подключаем элемент в область видимости, но также делаем этот элемент доступным для подключения в других областях видимости.</p>
<p>Приложение 7-17 показывает код из приложения 7-11, где <code>use</code> в корневом звене заменено на <code>pub use</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-17. Предоставление имени для использования любым кодом из новой области при помощи <code>pub use</code></span></p>
<p>До этого изменения внешний код должен был вызывать функцию <code>add_to_waitlist</code> , используя путь <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> . Теперь, когда это объявление <code>pub use</code> повторно экспортировало звено <code>hosting</code> из корневого звена, внешний код теперь может использовать вместо него путь <code>restaurant::hosting::add_to_waitlist()</code> .</p>
<p>Реэкспорт полезен, когда внутренняя устройства вашего кода отличается от того, как программисты, вызывающие ваш код, думают о предметной области. Например, по подобию с рестораном люди, управляющие им, думают о «передней части дома» и «задней части дома». Но клиенты, посещающие ресторан, вероятно, не будут думать о частях ресторана в таких понятиях. Используя <code>pub use</code> , мы можем написать наш код с одной устройством, но сделать общедоступной другую устройство. Благодаря этому наша библиотека хорошо согласована для программистов, работающих над библиотекой, и для программистов, вызывающих библиотеку. Мы рассмотрим ещё один пример <code>pub use</code> и его влияние на документацию вашего ящика в разделе <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use" data-md-type="link">«Экспорт удобного общедоступного API с <code>pub use</code>»</a><!-- ignore --> Главы 14.</p>
<h3 id="Использование-внешних-дополнений"><a class="header" href="#Использование-внешних-дополнений">Использование внешних дополнений</a></h3>
<p>В Главе 2 мы запрограммировали игру угадывания числа, где использовался внешний дополнение с именем <code>rand</code> для создания случайного числа. Чтобы использовать <code>rand</code> в нашем деле, мы добавили эту строку в <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
<p>Добавление <code>rand</code> в качестве зависимости в <em>Cargo.toml</em> указывает Cargo загрузить дополнение <code>rand</code> и все его зависимости из <a href="https://crates.io/">crates.io</a> и сделать <code>rand</code> доступным для нашего дела.</p>
<p>Затем, чтобы подключить определения <code>rand</code> в область видимости нашего дополнения, мы добавили строку <code>use</code> начинающуюся с названия дополнения <code>rand</code> и списка элементов, которые мы хотим подключить в область видимости. Напомним, что в разделе <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">"Создание случайного числа"</a><!-- ignore --> Главы 2, мы подключили особенность <code>Rng</code> в область видимости и вызвали функцию <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>Члены сообщества Ржавчина сделали много дополнений доступными на ресурсе <a href="https://crates.io/">crates.io</a>, и добавление любого из них в ваш дополнение включает в себя одни и те же шаги: добавить внешние дополнения в файл <em>Cargo.toml</em> вашего дополнения, использовать <code>use</code> для подключения элементов внешних дополнений в область видимости.</p>
<p>Обратите внимание, что обычная библиотека <code>std</code> также является ящиком, внешним по отношению к нашему дополнению. Поскольку обычная библиотека поставляется с языком Rust, нам не нужно изменять <em>Cargo.toml</em> для подключения <code>std</code>. Но нам нужно ссылаться на неё при помощи <code>use</code>, чтобы добавить элементы оттуда в область видимости нашего дополнения. Например, с <code>HashMap</code> мы использовали бы эту строку:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Это абсолютный путь, начинающийся с <code>std</code>, имени ящика встроенной библиотеки.</p>
<h3 id="Использование-вложенных-путей-для-уменьшения-длинных-списков-use"><a class="header" href="#Использование-вложенных-путей-для-уменьшения-длинных-списков-use">Использование вложенных путей для уменьшения длинных списков <code>use</code></a></h3>
<p>Если мы используем несколько элементов, определённых в одном ящике или в том же звене, то перечисление каждого элемента в отдельной строке может занимать много вертикального пространства в файле. Например, эти две указания <code>use</code> используются в программе угадывания числа (приложение 2-4) для подключения элементов из <code>std</code> в область видимости:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Вместо этого, мы можем использовать вложенные пути, чтобы добавить эти элементы в область видимости одной строкой. Мы делаем это, как показано в приложении 7-18, указывая общую часть пути, за которой следуют два двоеточия, а затем фигурные скобки вокруг списка тех частей продолжения пути, которые отличаются.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 7-18. Указание вложенного пути для добавления нескольких элементов с одинаковым приставкой в область видимости</span></p>
<p>В больших программах, подключение множества элементов из одного дополнения или звена с использованием вложенных путей может значительно сократить количество необходимых отдельных указаний <code>use</code>!</p>
<p>Можно использовать вложенный путь на любом уровне, что полезно при объединении двух указаний <code>use</code>, которые имеют общую часть пути. Например, в приложении 7-19 показаны две указания <code>use</code>: одна подключает <code>std::io</code>, а другая подключает <code>std::io::Write</code> в область видимости.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<p><span class="caption">Приложение 7-19: Две указания <code>use</code>, в которых один путь является частью другого</span></p>
<p>Общей частью этих двух путей является <code>std::io</code>, и это полный первый путь. Чтобы объединить эти два пути в одной указания <code>use</code>, мы можем использовать ключевое слово <code>self</code> во вложенном пути, как показано в приложении 7-20.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<p><span class="caption">Приложение 7-20: Объединение путей из Приложения 7-19 в одну указанию <code>use</code></span></p>
<p>Эта строка подключает <code>std::io</code> и <code>std::io::Write</code> в область видимости.</p>
<h3 id="Оператор--glob"><a class="header" href="#Оператор--glob">Оператор * (glob)</a></h3>
<p>Если мы хотим включить в область видимости <em>все</em> общедоступные элементы, определённые в пути, мы можем указать этот путь, за которым следует оператор <code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Эта указание <code>use</code> подключает все открытые элементы из звена <code>std::collections</code> в текущую область видимости. Будьте осторожны при использовании оператора <code>*</code>! Он может усложнить понимание, какие имена находятся в области видимости и где были определены имена, используемые в вашей программе.</p>
<p>Оператор <code>*</code> часто используется при проверке для подключения всего что есть в звене <code>tests</code>; мы поговорим об этом в разделе <a href="ch11-01-writing-tests.html#how-to-write-tests">"Как писать проверки"</a><!-- ignore --> Главы 11. Оператор <code>*</code> также иногда используется как часть образца <em>самостоятельного подключения (prelude)</em>: смотрите <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">документацию по встроенной библиотеке</a><!-- ignore --> для получения дополнительной сведений об этом образце.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Разделение-звеньев-на-разные-файлы"><a class="header" href="#Разделение-звеньев-на-разные-файлы">Разделение звеньев на разные файлы</a></h2>
<p>До сих пор все примеры в этой главе определяли несколько звеньев в одном файле. Когда звенья становятся большими, вы можете захотеть переместить их определения в отдельные файлы, чтобы упростить навигацию по коду.</p>
<p>Например, давайте начнём с кода из приложения 7-17, в котором было несколько звеньев ресторана. Мы будем извлекать звенья в файлы вместо того, чтобы определять все звенья в корневом звене ящика. В нашем случае корневой звено ящика - <em>src/lib.rs</em>, но это разделение также работает и с двоичными ящиками, у которых корневой звено ящика — <em>src/main.rs</em>.</p>
<p>Сначала мы извлечём звено <code>front_of_house</code> в свой собственный файл. Удалите код внутри фигурных скобок для звена <code>front_of_house</code>, оставив только объявление <code>mod front_of_house;</code>, так что теперь <em>src/lib.rs</em> содержит код, показанный в приложении 7-21. Обратите внимание, что этот исход не собирается, пока мы не создадим файл <em>src/front_of_house.rs</em> из приложении 7-22.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Приложение 7-21. Объявление звена <code>front_of_house</code>, чьё содержимое будет в <em>src/front_of_house.rs</em></span></p>
<p>Затем поместим код, который был в фигурных скобках, в новый файл с именем <em>src/front_of_house.rs</em>, как показано в приложении 7-22. Сборщик знает, что нужно искать в этом файле, потому что он наткнулся в корневом звене ящика на объявление звена с именем <code>front_of_house</code>.</p>
<p><span class="filename">Файл: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<p><span class="caption">Приложение 7-22. Определение содержимого звена <code>front_of_house</code> в файле <em>src/front_of_house.rs</em></span></p>
<p>Обратите внимание, что вам нужно только <em>один раз</em> загрузить файл с помощью объявления <code>mod</code> в вашем дереве звеньев. Как только сборщик узнает, что файл является частью дела (и узнает, где в дереве звеньев находится код из-за того, куда вы помеисполнения указанию <code>mod</code>), другие файлы в вашем деле должны ссылаться на код загруженного файла, используя путь к месту, где он был объявлен, как описано в разделе <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">«Пути для ссылки на элемент в дереве звеньев»</a><!-- ignore -->. Другими словами, <code>mod</code> — это <em>не</em> действие «включения», которую вы могли видеть в других языках программирования.</p>
<p>Далее мы извлечём звено <code>hosting</code> в его собственный файл. Этап немного отличается, потому что <code>hosting</code> является дочерним звеном для <code>front_of_house</code>, а не корневого звена. Мы поместим файл для <code>hosting</code> в новый папка, который будет назван по имени его предка в дереве звеньев, в данном случае это <em>src/front_of_house/</em>.</p>
<p>Чтобы начать перенос <code>hosting</code>, мы меняем <em>src/front_of_house.rs</em> так, чтобы он содержал только объявление звена <code>hosting</code>:</p>
<p><span class="filename">Файл: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
<p>Затем мы создаём папка <em>src/front_of_house</em> и файл <em>hosting.rs</em>, в котором будут  определения, сделанные в звене <code>hosting</code>:</p>
<p><span class="filename">Файл: src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
<p>Если вместо этого мы поместим <em>hosting.rs</em> в папка <em>src</em>, сборщик будет думать, что код в <em>hosting.rs</em> это звено <code>hosting</code>, объявленный в корне ящика, а не объявленный как дочерний звено <code>front_of_house</code>. Правила сборщика для проверки какие файлы содержат код каких звеньев предполагают, что папки и файлы точно соответствуют дереву звеньев.</p>
<blockquote>
<h3 id="Иные-пути-к-файлам"><a class="header" href="#Иные-пути-к-файлам">Иные пути к файлам</a></h3>
<p>До сих пор мы рассматривали наиболее идиоматические пути к файлам, используемые сборщиком Rust, но Ржавчина также поддерживает и старый исполнение пути к файлу. Для звена с именем <code>front_of_house</code>, объявленного в корневом звене ящика, сборщик будет искать код звена в:</p>
<ul>
<li><em>src/front_of_house.rs</em> (что мы рассматривали)</li>
<li><em>src/front_of_house/mod.rs</em> (старый исполнение, всё ещё поддерживаемый путь)</li>
</ul>
<p>Для звена с именем <code>hosting</code>, который является подзвеном <code>front_of_house</code>, сборщик будет искать код звена в:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (что мы рассматривали)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (старый исполнение, всё ещё поддерживаемый путь)</li>
</ul>
<p>Если вы используете оба исполнения для одного и того же звена, вы получите ошибку сборщика. Использование сочетания обоих исполнениий для разных звеньев в одном деле разрешено, но это может сбивать с толку людей, перемещающихся по вашему делу.</p>
<p>Основным недостатком исполнения, в котором используются файлы с именами <em>mod.rs</em>, является то, что в вашем деле может оказаться много файлов с именами <em>mod.rs</em>, что может привести к путанице, если вы одновременно откроете их в редакторе.</p>
</blockquote>
<p>Мы перенесли код каждого звена в отдельный файл, а дерево звеньев осталось прежним. Вызовы функций в <code>eat_at_restaurant</code> будут работать без каких-либо изменений, несмотря на то, что определения находятся в разных файлах. Этот способ позволяет перемещать звенья в новые файлы по мере увеличения их размеров.</p>
<p>Обратите внимание, что указание <code>pub use crate::front_of_house::hosting</code> в <em>src/lib.rs</em> также не изменилась, и <code>use</code> не влияет на то, какие файлы собираются как часть ящика. Ключевое слово <code>mod</code> объявляет звенья, и Ржавчина ищет в файле с тем же именем, что и у звена, код, который входит в этот звено.</p>
<h2 id="Итог"><a class="header" href="#Итог">Итог</a></h2>
<p>Rust позволяет разбить дополнение на несколько ящиков и ящик - на звенья, так что вы можете ссылаться на элементы, определённые в одном звене, из другого звена. Это можно делать при помощи указания абсолютных или относительных путей. Эти пути можно добавить в область видимости указанием <code>use</code>, поэтому вы можете пользоваться более короткими путями для многократного использования элементов в этой области видимости. Код звена по умолчанию является закрытым, но можно сделать определения общедоступными, добавив ключевое слово <code>pub</code>.</p>
<p>В следующей главе мы рассмотрим некоторые собрания устройств данных из встроенной библиотеки, которые вы можете использовать в своём правильноно согласованном коде.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Общие-собрания"><a class="header" href="#Общие-собрания">Общие собрания</a></h1>
<p>Обычная библиотека содержит несколько полезных устройств данных, которые называются <em>собраниями</em>. Большая часть других видов данных представляют собой хранение определенного значения, но особенностью собраний является хранение множества однотипных значений. В отличии от массива или упорядоченного ряда данные собраний хранятся в куче, а это значит, что размер собрания может быть неизвестен в мгновение сборки программы. Он может изменяться (увеличиваться, уменьшаться) во время работы программы. Каждый вид собраний имеет свои возможности и отличается по производительности, так что выбор именно собрания зависит от случаи и является умением разработчика, вырабатываемым со временем. В этой главе будет рассмотрено несколько собраний:</p>
<ul>
<li><em>Вектор (vector)</em> - позволяет нам сохранять различное количество последовательно хранящихся значений,</li>
<li><em>Строка (string)</em> - это последовательность символов. Мы же упоминали вид <code>String</code> ранее, но в данной главе мы поговорим о нем подробнее.</li>
<li><em>Хеш-таблица (hash map)</em> - собрание которая позволяет хранить перечень ассоциаций значения с ключом (перечень пар ключ:значение). Является именно выполнением более общей устройства данных называемой <em>map</em>.</li>
</ul>
<p>Для того, чтобы узнать о других видах собраний предоставляемых встроенной библиотекой смотрите <a href="https://doc.rust-lang.org/std/collections/index.html">документацию</a>.</p>
<p>Мы обсудим как создавать и обновлять векторы, строки и хеш-таблицы, а также объясним что делает каждую из них особенной.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Хранение-списков-значений-в-векторах"><a class="header" href="#Хранение-списков-значений-в-векторах">Хранение списков значений в векторах</a></h2>
<p>Первым видом собрания, который мы разберём, будет <code>Vec&lt;T&gt;</code>, также известный как <em>вектор</em> (vector). Векторы позволяют хранить более одного значения в единой устройстве данных, хранящей элементы в памяти один за другим. Векторы могут хранить данные только одного вида. Их удобно использовать, когда нужно хранить список элементов, например, список текстовых строк из файла, или список цен товаров в корзине покупок.</p>
<h3 id="Создание-нового-вектора"><a class="header" href="#Создание-нового-вектора">Создание нового вектора</a></h3>
<p>Чтобы создать новый пустой вектор, мы вызываем функцию <code>Vec::new</code>, как показано в приложении 8-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-1: Создание нового пустого вектора для хранения значений вида <code>i32</code></span></p>
<p>Обратите внимание, что здесь мы добавили изложение вида. Поскольку мы не вставляем никаких значений в этот вектор, Ржавчина не знает, какие элементы мы собираемся хранить. Это важный мгновение. Векторы выполнены с использованием обобщённых видов; мы рассмотрим, как использовать обобщённые виды с вашими собственными видами в Главе 10. А пока знайте, что вид <code>Vec&lt;T&gt;</code>, предоставляемый встроенной библиотекой, может хранить любой вид. Когда мы создаём новый вектор для хранения определенного вида, мы можем указать этот вид в угловых скобках. В приложении 8-1 мы сообщили Rust, что <code>Vec&lt;T&gt;</code> в <code>v</code> будет хранить элементы вида <code>i32</code>.</p>
<p>Чаще всего вы будете создавать <code>Vec&lt;T&gt;</code> с начальными значениями и Ржавчина может определить вид сохраняемых вами значений, но иногда вам всё же придётся указывать изложение вида. Для удобства Ржавчина предоставляет макрос <code>vec!</code>, который создаст новый вектор, содержащий заданные вами значения. В приложении 8-2 создаётся новый <code>Vec&lt;i32&gt;</code>, который будет хранить значения <code>1</code>, <code>2</code> и <code>3</code>. Числовым видом является <code>i32</code>, потому что это вид по умолчанию для целочисленных значений, о чём упоминалось в разделе <a href="ch03-02-data-types.html#data-types">“Виды данных”</a> Главы 3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-2: Создание нового вектора, содержащего значения</span></p>
<p>Поскольку мы указали начальные значения вида <code>i32</code>, Ржавчина может сделать вывод, что вид переменной <code>v</code> это <code>Vec&lt;i32&gt;</code> и изложение вида здесь не нужна. Далее мы посмотрим как изменять вектор.</p>
<h3 id="Изменение-вектора"><a class="header" href="#Изменение-вектора">Изменение вектора</a></h3>
<p>Чтобы создать вектор и затем добавить к нему элементы, можно использовать способ <code>push</code> показанный в приложении 8-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-3: Использование способа <code>push</code> для добавления значений в вектор</span></p>
<p>Как и с любой переменной, если мы хотим изменить её значение, нам нужно сделать её изменяемой с помощью ключевого слова <code>mut</code>, что обсуждалось в Главе 3. Все числа которые мы помещаем в вектор имеют вид <code>i32</code> по этому Ржавчина с лёгкостью выводит вид вектора, по этой причине нам не нужна здесь изложение вида вектора <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="Чтение-данных-вектора"><a class="header" href="#Чтение-данных-вектора">Чтение данных вектора</a></h3>
<p>Есть два способа сослаться на значение, хранящееся в векторе: с помощью порядкового указателя или способа <code>get</code> . В следующих примерах для большей ясности мы указали виды значений, возвращаемых этими функциями.</p>
<p>В приложении 8-4 показаны оба способа доступа к значению в векторе: либо с помощью правил написания упорядочевания и с помощью способа <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("The third element is {third}"),
        None =&gt; println!("There is no third element."),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-4. Использование правил написания упорядочевания и способа <code>get</code> для доступа к элементу в векторе</span></p>
<p>Обратите внимание здесь на пару подробностей. Мы используем значение порядкового указателя <code>2</code> для получения третьего элемента: векторы упорядочеваются начиная с нуля. Указывая <code>&amp;</code> и <code>[]</code> мы получаем ссылку на элемент по указанному порядковому указателю. Когда мы используем способ <code>get</code> содержащего порядковый указатель, переданный в качестве переменной, мы получаем вид <code>Option&lt;&amp;T&gt;</code>, который мы можем проверить с помощью <code>match</code>.</p>
<p>Причина, по которой Ржавчина предоставляет два способа ссылки на элемент, заключается в том, что вы можете выбрать, как программа будет себя вести, когда вы попытаетесь использовать значение порядкового указателя за пределами ряда существующих элементов. В качестве примера давайте посмотрим, что происходит, когда у нас есть вектор из пяти элементов, а затем мы пытаемся получить доступ к элементу с порядковым указателем 100 с помощью каждого способа, как показано в приложении 8-5.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-5. Попытка доступа к элементу с порядковым указателем 100 в векторе, содержащем пять элементов</span></p>
<p>Когда мы запускаем этот код, первая строка с <code>&amp;v[100]</code> вызовет панику программы, потому что происходит попытка получить ссылку на несуществующий элемент. Такой подход лучше всего использовать, когда вы хотите, чтобы ваша программа со сбоем завершила работу при попытке доступа к элементу за пределами вектора.</p>
<p>Когда способу <code>get</code> передаётся порядковый указатель, который находится за пределами вектора, он без паники возвращает <code>None</code>. Вы могли бы использовать такой подход, если доступ к элементу за пределами рядавектора происходит время от времени при обычных обстоятельствах. Тогда ваш код будет иметь логику для обработки наличия <code>Some(&amp;element)</code> или <code>None</code>, как обсуждалось в Главе 6. Например, порядковый указательможет исходить от человека, вводящего число. Если пользователь случайно введёт слишком большое число, то программа получит значение <code>None</code> и у вас будет возможность сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему возможность ввести допустимое значение. Такое поведение было бы более дружелюбным для пользователя, чем внезапный сбой программы из-за опечатки!</p>
<p>Когда у программы есть действительная ссылка, borrow checker (средство проверки заимствований), обеспечивает соблюдение правил владения и заимствования (описанные в Главе 4), чтобы обеспечить, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, которое гласит, что у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в приложении 8-6, где мы храним неизменяемую ссылку на первый элемент вектора и затем пытаемся добавить элемент в конец вектора. Данная программа не будет работать, если мы также попробуем сослаться на данный элемент позже в функции:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("The first element is: {first}");
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 8-6. Попытка добавить некоторый элемент в вектор, в то время когда есть ссылка на элемент вектора</span></p>
<p>Сборка этого кода приведёт к ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>Код в приложении 8-6 может выглядеть так, как будто он должен работать. Почему ссылка на первый элемент должна заботиться об изменениях в конце вектора? Эта ошибка возникает из-за особенности того, как работают векторы: поскольку векторы размещают значения в памяти друг за другом, добавление нового элемента в конец вектора может потребовать выделения новой памяти и повторения старых элементов в новое пространство, если нет достаточного места, чтобы разместить все элементы друг за другом там, где в данный мгновение хранится вектор. В этом случае ссылка на первый элемент будет указывать на освобождённую память. Правила заимствования предотвращают попадание программ в такую случай.</p>
<blockquote>
<p>Примечание: Дополнительные сведения о выполнения вида <code>Vec&lt;T&gt;</code> смотрите в разделе <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">"The Rustonomicon"</a>.</p>
</blockquote>
<h3 id="Перебор-значений-в-векторе"><a class="header" href="#Перебор-значений-в-векторе">Перебор значений в векторе</a></h3>
<p>Для доступа к каждому элементу вектора по очереди, мы повторяем все элементы, вместо использования порядковых указателей для доступа к одному за раз. В приложении 8-7 показано, как использовать цикл <code>for</code> для получения неизменяемых ссылок на каждый элемент в векторе значений вида <code>i32</code> и их вывода.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-7. Печать каждого элемента векторе, при помощи повторения по элементам вектора с помощью цикла <code>for</code></span></p>
<p>Мы также можем повторять изменяемые ссылки на каждый элемент изменяемого вектора, чтобы вносить изменения во все элементы. Цикл <code>for</code> в приложении 8-8 добавит <code>50</code> к каждому элементу.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-8. Повторение и изменение элементов вектора по изменяемым ссылкам</span></p>
<p>Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать оператор разыменования ссылки <code>*</code> для получения значения по ссылке в переменной <code>i</code> прежде чем использовать оператор <code>+=</code>. Мы поговорим подробнее об операторе разыменования в разделе <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“Следование по указателю к значению с помощью оператора разыменования”</a> Главы 15.</p>
<p>Перебор вектора, будь то неизменяемый или изменяемый, безопасен из-за правил проверки заимствования. Если бы мы попытались вставить или удалить элементы в телах цикла <code>for</code> в приложениях 8-7 и 8-8, мы бы получили ошибку сборщика, подобную той, которую мы получили с кодом в приложении 8-6. Ссылка на вектор, содержащийся в цикле for, предотвращает одновременную изменение всего вектора.</p>
<h3 id="Использование-перечислений-для-хранения-множества-разных-видов"><a class="header" href="#Использование-перечислений-для-хранения-множества-разных-видов">Использование перечислений для хранения множества разных видов</a></h3>
<p>Векторы могут хранить значения только одинакового вида. Это может быть неудобно; определённо могут быть случаи когда надо хранить список элементов разных видов. К счастью, исходы перечисления определены для одного и того же вида перечисления, поэтому, когда нам нужен один вид для представления элементов разных видов, мы можем определить и использовать перечисление!</p>
<p>Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, некоторые числа с плавающей точкой, а другие - строковые значения. Можно определить перечисление, исходы которого будут содержать разные виды значений и тогда все исходы перечисления будут считаться одним и тем же видом: видом самого перечисления. Затем мы можем создать вектор для хранения этого перечисления и, в конечном счёте, для хранения различных видов. Мы покажем это в приложении 8-9.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-9: Определение <code>enum</code> для хранения значений разных видов в одном векторе</span></p>
<p>Rust должен знать, какие виды будут в векторе во время сборки, чтобы точно знать сколько памяти в куче потребуется для хранения каждого элемента. Мы также должны чётко указать, какие виды разрешены в этом векторе. Если бы Ржавчина позволял вектору содержать любой вид, то был бы шанс что один или несколько видов вызовут ошибки при выполнении действий над элементами вектора. Использование перечисления вместе с выражением <code>match</code> означает, что во время сборки Ржавчина  заверяет, что все возможные случаи будут обработаны, как обсуждалось в главе 6.</p>
<p>Если вы не знаете исчерпывающий набор видов, которые программа получит во время выполнения для хранения в векторе, то техника использования перечисления не сработает. Вместо этого вы можете использовать особенность-предмет, который мы рассмотрим в главе 17.</p>
<p>Теперь, когда мы обсудили некоторые из наиболее распространённых способов использования векторов, обязательно ознакомьтесь <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">с документацией по API вектора</a>, чтобы узнать о множестве полезных способов, определённых в <code>Vec&lt;T&gt;</code> встроенной библиотеки. Например, в дополнение к способу <code>push</code>, существует способ <code>pop</code>, который удаляет и возвращает последний элемент.</p>
<h3 id="Удаление-элементов-из-вектора"><a class="header" href="#Удаление-элементов-из-вектора">Удаление элементов из вектора</a></h3>
<p>Подобно устройствам <code>struct</code>, вектор высвобождает свою память когда выходит из области видимости, что показано в приложении 8-10.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-10. Показано как удаляется вектор и его элементы</span></p>
<p>Когда вектор удаляется, всё его содержимое также удаляется: удаление вектора означает и удаление значений, которые он содержит. Средство проверки заимствования заверяет, что любые ссылки на содержимое вектора используются только тогда, когда сам вектор действителен.</p>
<p>Давайте перейдём к следующему виду собрания: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Хранение-закодированного-текста-utf-8-в-строках"><a class="header" href="#Хранение-закодированного-текста-utf-8-в-строках">Хранение закодированного текста UTF-8 в строках</a></h2>
<p>Мы говорили о строках в главе 4, но сейчас мы рассмотрим их более подробно. Новички в Ржавчина обычно застревают на строках из-за  сочетания трёх причин: склонность Ржавчина сборщика к выявлению возможных ошибок, более сложная устройства данных чем считают многие программисты и UTF-8. Эти обстоятельства объединяются таким образом, что направление может показаться сложной, если вы пришли из других языков программирования.</p>
<p>Полезно обсуждать строки в среде собраний, потому что строки выполнены в виде набора байтов, плюс некоторые способы для обеспечения полезной возможности, когда эти байты преобразуются как текст. В этом разделе мы поговорим об действиех над <code>String</code> таких как создание, обновление и чтение, которые есть у каждого вида собраний. Мы также обсудим какими особенностями <code>String</code> отличается от других собраний, а именно каким образом упорядочевание в  <code>String</code> осложняется различием между тем как люди и компьютеры преобразуют данные заключённые в  <code>String</code>.</p>
<h3 id="Что-же-такое-строка"><a class="header" href="#Что-же-такое-строка">Что же такое строка?</a></h3>
<p>Сначала мы определим, что мы подразумеваем под понятием  <em>строка</em> (string). В Ржавчина есть только один строковый вид в ядре языка - срез строки <code>str</code>, обычно используемый в заимствованном виде как <code>&amp;str</code>. В Главе 4 мы говорили о <em>срезах строк, string slices</em>, которые являются ссылками на некоторые строковые данные в кодировке UTF-8. Например, строковые записи хранятся в двоичном файле программы и поэтому являются срезами строк.</p>
<p>Вид <code>String</code> предоставляемый встроенной библиотекой Rust, не встроен в ядро языка и является расширяемым, изменяемым, владеющим, строковым видом в UTF-8 кодировке.  Когда Rustaceans говорят о "строках" то, они обычно имеют в виду виды <code>String</code> или строковые срезы <code>&amp;str</code>, а не просто один из них. Хотя этот раздел в основном посвящён <code>String</code>, оба вида усиленно используются в встроенной библиотеке Rust, оба, и <code>String</code> и строковые срезы, кодируются в UTF-8.</p>
<h3 id="Создание-новых-строк"><a class="header" href="#Создание-новых-строк">Создание новых строк</a></h3>
<p>Многие из тех же действий, которые доступны <code>Vec&lt;T&gt;</code> , доступны также в <code>String</code>, потому что <code>String</code> в действительности выполнен как обёртка вокруг вектора байтов с некоторыми дополнительными заверениями, ограничениями и возможностями. Примером функции, которая одинаково работает с <code>Vec&lt;T&gt;</code> и <code>String</code>, является функция  <code>new</code>, создающая новый образец вида, и показана в Приложении 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-11. Создание новой пустой <code>String</code> строки</span></p>
<p>Эта строка создаёт новую пустую строковую переменную с именем <code>s</code>, в которую мы можем затем загрузить данные. Часто у нас есть некоторые начальные данные, которые мы хотим назначить строке. Для этого мы используем способ <code>to_string</code> доступный для любого вида, который выполняет особенность <code>Display</code>, как у строковых записей. Приложение 8-12 показывает два примера.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-12: Использование способа <code>to_string</code> для создания образца вида <code>String</code>  из строкового записи</span></p>
<p>Эти выражения создают строку с  <code>initial contents</code>.</p>
<p>Мы также можем использовать функцию <code>String::from</code> для создания <code>String</code>  из строкового записи. Код приложения 8-13 является эквивалентным коду из приложения 8-12, который использует функцию <code>to_string</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-13: Использование функции <code>String::from</code> для создания образца вида <code>String</code> из строкового записи</span></p>
<p>Поскольку строки используются для очень многих вещей, можно использовать множество API для строк, предоставляющих множество возможностей. Некоторые из них могут показаться избыточными, но все они занимаются своим делом!  В данном случае <code>String::from</code> и <code>to_string</code> делают одно и тоже, поэтому выбор зависит от исполнения который вам больше импонирует.</p>
<p>Запомните, что строки хранятся в кодировке UTF-8, поэтому можно использовать любые правильно кодированные данные в них, как показано в приложении 8-14:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-14: Хранение приветствий в строках на разных языках</span></p>
<p>Все это допустимые <code>String</code> значения.</p>
<h3 id="Обновление-строковых-данных"><a class="header" href="#Обновление-строковых-данных">Обновление строковых данных</a></h3>
<p>Строка <code>String</code> может увеличиваться в размере, а её содержимое может меняться, по подобию как содержимое <code>Vec&lt;T&gt;</code> при вставке в него большего количества данных. Кроме того, можно использовать оператор <code>+</code> или макрос <code>format!</code> для объединения значений <code>String</code>.</p>
<h4 id="Присоединение-к-строке-с-помощью-push_str-и-push"><a class="header" href="#Присоединение-к-строке-с-помощью-push_str-и-push">Присоединение к строке с помощью <code>push_str</code> и <code>push</code></a></h4>
<p>Мы можем нарастить <code>String</code> используя способ <code>push_str</code> который добавит в исходное значение новый строковый срез, как показано в приложении 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-15. Добавление среза строки к <code>String</code> с помощью способа <code>push_str</code></span></p>
<p>После этих двух строк кода <code>s</code> будет содержать <code>foobar</code>. Способ <code>push_str</code> принимает строковый срез, потому что мы не всегда хотим владеть входным свойствоом. Например, код в приложении 8-16 показывает исход, когда будет не желательно поведение, при котором мы не сможем использовать <code>s2</code> после его добавления к содержимому значения переменной <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-16: Использование среза строки после добавления её содержимого к другой <code>String</code></span></p>
<p>Если способ <code>push_str</code> стал бы владельцем переменной<code>s2</code>, мы не смогли бы напечатать его значение в последней строке. Однако этот код работает так, как мы ожидали!</p>
<p>Способ <code>push</code> принимает один символ в качестве свойства и добавляет его к <code>String</code>. В приложении 8-17 показан код, добавляющий букву “l” к <code>String</code> используя способ <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-17: Добавление одного символа в <code>String</code> значение используя <code>push</code></span></p>
<p>В итоге <code>s</code> будет содержать <code>lol</code>.</p>
<h4 id="Объединение-строк-с-помощью-оператора--или-макроса-format"><a class="header" href="#Объединение-строк-с-помощью-оператора--или-макроса-format">Объединение строк с помощью оператора <code>+</code> или макроса <code>format!</code></a></h4>
<p>Часто хочется объединять две существующие строки. Один из возможных способов — это использование оператора <code>+</code> из приложения 8-18:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-18: Использование оператора <code>+</code> для объединения двух значений <code>String</code> в новое <code>String</code> значение</span></p>
<p>Строка <code>s3</code> будет содержать <code>Hello, world!</code>. Причина того, что <code>s1</code> после добавления больше недействительна и причина, по которой мы использовали ссылку на <code>s2</code> имеют отношение к ярлыке вызываемого способа при использовании оператора <code>+</code>. Оператор <code>+</code> использует способ <code>add</code>, чья ярлык выглядит примерно так:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>В встроенной библиотеке вы увидите способ <code>add</code> определённым с использованием обобщённых и связанных видов. Здесь мы видим ярлык  с определенными видами, заменяющими обобщённый, что происходит когда вызывается данный способ со значениями <code>String</code>. Мы обсудим обобщённые виды в Главе 10. Эта ярлык даёт нам ключ для понимания особенностей оператора <code>+</code>.</p>
<p>Во-первых, перед <code>s2</code> мы видим <code>&amp;</code>, что означает что мы складываем <em>ссылку</em> на вторую строку с первой строкой. Это происходит из-за  свойства <code>s</code> в функции <code>add</code>: мы можем добавить только <code>&amp;str</code> к <code>String</code>; мы не можем сложить два значения <code>String</code>. Но подождите — вид <code>&amp;s2</code> это <code>&amp;String</code>, а не <code>&amp;str</code>, как определён второй свойство в <code>add</code>. Так почему код в приложении 8-18 собирается?</p>
<p>Причина, по которой мы можем использовать <code>&amp;s2</code> в вызове <code>add</code> заключается в том, что сборщик может <em>принудительно привести (coerce)</em> переменная вида <code>&amp;String</code> к виду <code>&amp;str</code>. Когда мы вызываем способ <code>add</code> в Ржавчина используется <em>принудительное приведение</em> (deref coercion), которое превращает <code>&amp;s2</code> в <code>&amp;s2[..]</code>. Мы подробно обсудим принудительное приведение в Главе 15. Так как <code>add</code> не забирает во владение свойство <code>s</code>, <code>s2</code> по прежнему будет действительной строкой <code>String</code> после применения действия.</p>
<p>Во-вторых, как можно видеть в ярлыке, <code>add</code> забирает во владение <code>self</code>, потому что  <code>self</code> <em>не имеет</em> <code>&amp;</code>. Это означает, что <code>s1</code> в приложении 8-18 будет перемещён в вызов <code>add</code> и больше не будет действителен после этого вызова. Не смотря на то, что код <code>let s3 = s1 + &amp;s2;</code> выглядит как будто он воспроизведет обе строки и создаёт новую, эта указание в действительности забирает во владение переменную <code>s1</code>, присоединяет к ней повтор содержимого <code>s2</code>, а затем возвращает владение итогом.  Другими словами, это выглядит как будто код создаёт множество повторов, но это не так; данная выполнение более эффективна, чем повторение.</p>
<p>Если нужно объединить несколько строк, поведение оператора <code>+</code> становится громоздким:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>Здесь переменная <code>s</code> будет содержать <code>tic-tac-toe</code>. С множеством символов <code>+</code> и <code>"</code> становится трудно понять, что происходит. Для более сложного соединения строк можно использовать макрос <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>Этот код также устанавливает переменную <code>s</code> в значение <code>tic-tac-toe</code>. Макрос <code>format!</code> работает тем же способом что макрос <code>println!</code>, но вместо вывода на экран возвращает вид <code>String</code> с содержимым. Исполнение кода с использованием <code>format!</code> значительно легче читается, а также код, созданный макросом <code>format!</code>, использует ссылки, а значит не забирает во владение ни один из его свойств.</p>
<h3 id="Упорядочевание-в-строках"><a class="header" href="#Упорядочевание-в-строках">Упорядочевание в строках</a></h3>
<p>Доступ к отдельным символам в строке, при помощи ссылки на них по порядковому указателю, является допустимой и распространённой действием во многих других языках программирования. Тем не менее, если вы попытаетесь получить доступ к частям <code>String</code>, используя правила написания упорядочевания в Rust, то вы получите ошибку. Рассмотрим неверный код в приложении 8-19.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let h = s1[0];
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 8-19: Попытка использовать правила написания порядкового указателя со строкой</span></p>
<p>Этот код приведёт к следующей ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>Ошибка и примечание говорит, что в Ржавчина строки не поддерживают упорядочевание. Но почему так? Чтобы ответить на этот вопрос, нужно обсудить то, как Ржавчина хранит строки в памяти.</p>
<h4 id="Внутреннее-представление"><a class="header" href="#Внутреннее-представление">Внутреннее представление</a></h4>
<p>Вид <code>String</code> является оболочкой над видом  <code>Vec&lt;u8&gt;</code>. Давайте посмотрим на несколько закодированных правильным образом в UTF-8 строк из примера приложения 8-14. Начнём с этой:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>В этом случае <code>len</code> будет 4, что означает вектор, хранит строку "Hola" длиной 4 байта. Каждая из этих букв занимает 1 байт при кодировании в UTF-8. Но как насчёт следующей строки? (Обратите внимание, что эта строка начинается с заглавной кириллической "З", а не цифры 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>Отвечая на вопрос, какова длина строки, вы можете ответить 12. Однако ответ Ржавчина - 24, что равно числу байт, необходимых для кодирования «Здравствуйте» в UTF-8, так происходит, потому что каждое одиночное значение Unicode символа в этой строке занимает 2 байта памяти. Следовательно, порядковый указательпо байтам строки не всегда бы соответствовал действительному одиночному Unicode значению. Для отображения рассмотрим этот недопустимый код Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>Каким должно быть значение переменной <code>answer</code>? Должно ли оно быть значением первой буквы <code>З</code>? При кодировке в UTF-8, первый байт значения <code>З</code> равен <code>208</code>, а второй - <code>151</code>, поэтому значение в <code>answer</code> на самом деле должно быть <code>208</code>, но само по себе <code>208</code> не является действительным символом. Возвращение <code>208</code>, скорее всего не то, что хотел бы получить пользователь: ведь он ожидает первую букву этой строки; тем не менее, это единственный байт данных, который в Ржавчина доступен по порядковому указателю 0. Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если <code>&amp;"hello"[0] </code>было бы допустимым кодом, который вернул значение байта, то он вернул бы <code>104</code>, а не <code>h</code>.</p>
<p>Таким образом, чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки которые не могут быть сразу обнаружены, Ржавчина просто не собирает такой код и предотвращает недопонимание на ранних этапах этапа разработки.</p>
<h4 id="Байты-одиночные-значения-и-кластеры-графем-Боже-мой"><a class="header" href="#Байты-одиночные-значения-и-кластеры-графем-Боже-мой">Байты, одиночные значения и кластеры графем! Боже мой!</a></h4>
<p>Ещё один мгновение, касающийся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Rust: как байты, как одиночные значения и как кластеры графем (самая близкая вещь к тому, что мы назвали бы <em>буквами</em>).</p>
<p>Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор значений <code>u8</code> который выглядит следующим образом:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Эти 18 байт являются именно тем, как компьютеры в конечном итоге сохранят в памяти эту строку. Если мы посмотрим на 18 байт как на одиночные Unicode значения, которые являются Ржавчина видом <code>char</code>, то байты будут выглядеть так:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Здесь есть шесть значений вида <code>char</code>, но четвёртый и шестой являются не буквами: они диакритики, особые обозначения которые не имеют смысла сами по себе. Наконец, если мы посмотрим на байты как на кластеры графем, то получим то, что человек назвал бы словом на хинди состоящем из четырёх букв:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust предоставляет различные способы преобразования необработанных строковых данных, которые компьютеры хранят так, чтобы каждой программе можно было выбрать необходимую преобразование, независимо от того, на каком человеческом языке представлены эти данные.</p>
<p>Последняя причина, по которой Ржавчина не позволяет нам упорядочивать <code>String</code> для получения символов является то, что программисты ожидают, что действия упорядочевания всегда имеют постоянное время (O(1)) выполнения. Но невозможно обеспечить такую производительность для <code>String</code>, потому что Ржавчина понадобилось бы пройтись по содержимому от начала до порядкового указателя, чтобы определить, сколько было действительных символов.</p>
<h3 id="Срезы-строк"><a class="header" href="#Срезы-строк">Срезы строк</a></h3>
<p>Упорядочевание строк часто является плохой мыслью, потому что не ясно каким должен быть возвращаемый вид такой действия: байтовым значением, символом, кластером графем или срезом строки. Поэтому Ржавчина просит вас быть более определенным, если действительно требуется использовать порядковые указатели для создания срезов строк.</p>
<p>Вместо упорядочевания с помощью числового порядкового указателя <code>[]</code>, вы можете использовать оператор ряда<code>[]</code> при создании среза строки в котором содержится указание на то, срез каких байтов надо делать:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Здесь переменная <code>s</code> будет вида <code>&amp;str</code> который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов был по 2 байта, что означает, что <code>s</code> будет содержать <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end -->.</p>
<p>Что бы произошло, если бы мы использовали <code>&amp;hello[0..1]</code>? Ответ: Ржавчина бы запаниковал во время выполнения точно так же, как если бы обращались к недействительному порядковому указателю в векторе:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Вы должны использовать ряды для создания срезов строк с осторожностью, потому что это может привести к сбою вашей программы.</p>
<h3 id="Способы-для-перебора-строк"><a class="header" href="#Способы-для-перебора-строк">Способы для перебора строк</a></h3>
<p>Лучший способ работать с отрывками строк — чётко указать, нужны ли вам символы или байты. Для отдельных одиночных значений в Юникоде используйте способ <code>chars</code>. Вызов <code>chars</code> у <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end --> выделяет и возвращает два значения вида <code>char</code>, и вы можете выполнить повторение по итогу для доступа к каждому элементу:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>Код напечатает следующее:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Способ <code>bytes</code> возвращает каждый байт, который может быть подходящим в другой предметной области:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код выведет четыре байта, составляющих эту строку:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Но делая так, обязательно помните, что валидные одиночные Unicode значения могут состоять более чем из одного байта.</p>
<p>Извлечение кластеров графем из строк, как в случае с языком хинди, является сложным, поэтому эта возможность не предусмотрена встроенной библиотекой. На <a href="https://crates.io/">crates.io</a><!-- ignore --> есть доступные библиотеки, если Вам нужен данный возможности.</p>
<h3 id="Строки-не-так-просты"><a class="header" href="#Строки-не-так-просты">Строки не так просты</a></h3>
<p>Подводя итог, становится ясно, что строки сложны. Различные языки программирования выполняют различные исходы того, как представить эту сложность для программиста. В Ржавчина решили сделать правильную обработку данных <code>String</code> поведением по умолчанию для всех программ Rust, что означает, что программисты должны заранее продумать обработку UTF-8 данных. Этот соглашение раскрывает большую сложность строк, чем в других языках программирования, но это предотвращает от необходимости обрабатывать ошибки, связанные с не-ASCII символами которые могут появиться в ходе разработки позже.</p>
<p>Хорошая новость состоит в том что обычная библиотека предлагает множество полезных возможностей, построенных на основе видов <code>String</code> и <code>&amp;str</code>, чтобы помочь правильно обрабатывать эти сложные случаи. Обязательно ознакомьтесь с документацией для полезных способов, таких как <code>contains</code> для поиска в строке и <code>replace</code> для замены частей строки другой строкой.</p>
<p>Давайте переключимся на что-то немного менее сложное: HashMap!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Хранение-ключей-со-связанными-значениями-в-hashmap"><a class="header" href="#Хранение-ключей-со-связанными-значениями-в-hashmap">Хранение ключей со связанными значениями в HashMap</a></h2>
<p>Последняя собрание, которую мы рассмотрим, будет <em>hash map</em> (хеш-карта). Вид <code>HashMap&lt;K, V&gt;</code> хранит ключи вида <code>K</code> на значения вида <code>V</code>. Данная устройства согласует и хранит данные с помощью <em>функции хеширования</em>. Во множестве языков программирования выполнена данная устройства, но часто с разными наименованиями: такими как hash, map, object, hash table, dictionary или ассоциативный массив.</p>
<p>Хеш-карты полезны, когда нужно искать данные не используя порядковый указатель, как это например делается в векторах, а с помощью ключа, который может быть любого вида. Например, в игре вы можете отслеживать счёт каждой приказы в хеш-карте, в которой каждый ключ - это название приказы, а значение - счёт приказы. Имея имя приказы, вы можете получить её счёт из хеш-карты.</p>
<p>В этом разделе мы рассмотрим основной API хеш-карт. Остальной набор полезных функций скрывается в объявлении вида <code>HashMap&lt;K, V&gt;</code>. Как и прежде, советуем обратиться к документации по встроенной библиотеке для получения дополнительной сведений.</p>
<h3 id="Создание-новой-хеш-карты"><a class="header" href="#Создание-новой-хеш-карты">Создание новой хеш-карты</a></h3>
<p>Создать пустую хеш-карту можно с помощью <code>new</code>, а добавить в неё элементы - с помощью <code>insert</code>. В приложении 8-20 мы отслеживаем счёт двух приказов, синей <em>Blue</em> и жёлтой <em>Yellow</em>. Синяя приказ набрала 10 очков, а жёлтая приказ - 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-20: Создание новой хеш-карты и вставка в неё пары ключей и значений</span></p>
<p>Обратите внимание, что нужно сначала указать строку <code>use std::collections::HashMap;</code> для её подключения из собраний встроенной библиотеки. Из трёх собраний данная является наименее используемой, поэтому она не подключается в область видимости функцией самостоятельного подключения (prelude). Хеш-карты также имеют меньшую поддержку со стороны встроенной библиотеки; например, нет встроенного макроса для их разработки.</p>
<p>Подобно векторам, хеш-карты хранят свои данные в куче. Здесь вид <code>HashMap</code> имеет в качестве вида ключей <code>String</code>, а в качестве вида значений вид <code>i32</code>. Как и векторы, HashMap однородны: все ключи должны иметь одинаковый вид и все значения должны иметь тоже одинаковый вид.</p>
<h3 id="Доступ-к-данным-в-hashmap"><a class="header" href="#Доступ-к-данным-в-hashmap">Доступ к данным в HashMap<a name="accessing-values-in-a-hash-map"></a></a></h3>
<p>Мы можем получить значение из HashMap по ключу, с помощью способа <code>get</code>, как показано в приложении 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-21: Доступ к очкам приказы "Blue", которые хранятся в хеш-карте</span></p>
<p>Здесь <code>score</code> будет иметь количество очков, связанное с приказом "Blue", итог будет <code>10</code>. Способ <code>get</code> возвращает <code>Option&lt;&amp;V&gt;</code>; если для какого-то ключа нет значения в HashMap, <code>get</code> вернёт <code>None</code>. Из-за такого подхода программе следует обрабатывать <code>Option</code>, вызывая <code>copied</code> для получения <code>Option&lt;i32&gt;</code> вместо <code>Option&lt;&amp;i32&gt;</code>, затем <code>unwrap_or</code> для установки <code>score</code> в ноль, если scores не содержит данных по этому ключу.</p>
<p>Мы можем перебирать каждую пару ключ/значение в HashMap таким же образом, как мы делали с векторами, используя цикл <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>Этот код будет печатать каждую пару в произвольном порядке:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="Хеш-карты-и-владение"><a class="header" href="#Хеш-карты-и-владение">Хеш-карты и владение</a></h3>
<p>Для видов, которые выполняют особенность <code>Copy</code>, например <code>i32</code>, значения повторяются в HashMap. Для значений со владением, таких как <code>String</code>, значения  будут перемещены в хеш-карту и она станет владельцем этих значений, как показано в приложении 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-22: Показывает, что ключи и значения находятся во владении HashMap, как только они были вставлены</span></p>
<p>Мы не можем использовать переменные <code>field_name</code> и <code>field_value</code> после того, как их значения были перемещены в HashMap вызовом способа <code>insert</code>.</p>
<p>Если мы вставим в HashMap ссылки на значения, то они не будут перемещены в HashMap. Значения, на которые указывают ссылки, должны быть действительными хотя бы до тех пор, пока хеш-карта действительна. Мы поговорим подробнее об этих вопросах в разделе <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">"Валидация ссылок при помощи времён жизни"</a><!-- ignore --> главы 10.</p>
<h3 id="Обновление-данных-в-hashmap"><a class="header" href="#Обновление-данных-в-hashmap">Обновление данных в HashMap</a></h3>
<p>Хотя количество ключей и значений может увеличиваться в HashMap, каждый ключ может иметь только одно значение, связанное с ним в один мгновение времени (обратное утверждение неверно: приказы "Blue" и "Yellow" могут хранить в хеш-карте <code>scores</code> одинаковое количество очков, например 10).</p>
<p>Когда вы хотите изменить данные в хеш-карте, необходимо решить, как обрабатывать случай, когда ключ уже имеет назначенное значение. Можно заменить старое значение новым, полностью пренебрегая старое. Можно сохранить старое значение и пренебрегать новое, или добавлять новое значение, если только ключ <em>ещё не</em> имел значения. Или можно было бы объединить старое значение и новое значение. Давайте посмотрим, как сделать каждый из исходов!</p>
<h4 id="Перезапись-старых-значений"><a class="header" href="#Перезапись-старых-значений">Перезапись старых значений</a></h4>
<p>Если мы вставим ключ и значение в HashMap, а затем вставим тот же ключ с новым значением, то старое значение связанное с этим ключом, будет заменено на новое. Даже несмотря на то, что код в приложении 8-23 вызывает <code>insert</code> дважды, хеш-карта будет содержать только одну пару ключ/значение, потому что мы вставляем значения для одного и того же ключа - ключа приказы "Blue".</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-23: Замена значения, хранимого в определенном ключе</span></p>
<p>Код напечатает <code>{"Blue": 25}</code>. Начальное значение <code>10</code> было перезаписано.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="Вставка-значения-только-в-том-случае-когда-ключ-не-имеет-значения"><a class="header" href="#Вставка-значения-только-в-том-случае-когда-ключ-не-имеет-значения">Вставка значения только в том случае, когда ключ не имеет значения</a></h4>
<p>Обычно проверяют, существует ли определенный ключ в хеш-карте со значением, а затем предпринимаются следующие действия: если ключ существует в хеш-карте, существующее значение должно оставаться таким, какое оно есть. Если ключ не существует, то вставляют его и значение для него.</p>
<p>Хеш-карты имеют для этого особый API, называемый <code>entry</code> , который принимает ключ для проверки в качестве входного свойства. Возвращаемое значение способа <code>entry</code> - это перечисление <code>Entry</code>, с двумя исходами: первый представляет значение, которое может существовать, а второй говорит о том, что значение отсутствует. Допустим, мы хотим проверить, имеется ли ключ и связанное с ним значение для приказы "Yellow". Если хеш-карта не имеет значения для такого ключа, то мы хотим вставить значение 50. То же самое мы хотим проделать и для приказы "Blue". Используем API <code>entry</code> в коде приложения 8-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-24: Использование способа <code>entry</code> для вставки значения только в том случае, когда ключ не имеет значения</span></p>
<p>Способ <code>or_insert</code> определён в <code>Entry</code> так, чтобы возвращать изменяемую ссылку на соответствующее значение ключа внутри исхода перечисления <code>Entry</code>, когда этот ключ существует, а если его нет, то вставлять свойство в качестве нового значения этого ключа и возвращать изменяемую ссылку на новое значение. Эта техника намного чище, чем самостоятельное написание логики и, кроме того, она более безопасна и согласуется с правилами заимствования.</p>
<p>При выполнении кода приложения 8-24 будет напечатано <code>{"Yellow": 50, "Blue": 10}</code>. Первый вызов <code>способа entry</code> вставит ключ для приказы "Yellow" со значением 50, потому что для жёлтой приказы ещё не имеется значения в HashMap. Второй вызов <code>entry</code> не изменит хеш-карту, потому что для ключа приказы "Blue" уже имеется значение 10.</p>
<h4 id="Создание-нового-значения-на-основе-старого-значения"><a class="header" href="#Создание-нового-значения-на-основе-старого-значения">Создание нового значения на основе старого значения</a></h4>
<p>Другим распространённым исходом использования хеш-карт является поиск значения по ключу, а затем обновление этого значения на основе старого значения. Например, в приложении 8-25 показан код, который подсчитывает, сколько раз определённое слово встречается в некотором тексте. Мы используем HashMap со словами в качестве ключей и увеличиваем соответствующее слову значение, чтобы отслеживать, сколько раз мы встретили это слово. Если мы впервые встретили слово, то сначала вставляем значение 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-25: Подсчёт количества вхождений слов с использованием хеш-карты, которая хранит слова и счётчики</span></p>
<p>Этот код напечатает <code>{"world": 2, "hello": 1, "wonderful": 1}</code>. Если вы увидите, что пары ключ/значение печатаются в другом порядке, то вспомните, что мы писали в разделы <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">"Доступ к данным в HashMap"</a><!-- ignore -->, что повторение по хеш-карте происходит в произвольном порядке.</p>
<p>Способ <code>split_whitespace</code> возвращает повторитель по срезам строки, разделённых пробелам, для строки  <code>text</code>. Способ <code>or_insert</code> возвращает изменяемую ссылку (<code>&amp;mut V</code>) на значение ключа. Мы сохраняем изменяемую ссылку в переменной <code>count</code>, для этого, чтобы присвоить переменной значение, необходимо произвести разыменование с помощью звёздочки (*). Изменяемая ссылка удаляется сразу же после выхода из области видимости цикла <code>for</code>, поэтому все эти изменения безопасны и согласуются с правилами заимствования.</p>
<h3 id="Функция-хеширования"><a class="header" href="#Функция-хеширования">Функция хеширования</a></h3>
<p>По умолчанию <code>HashMap</code> использует функцию хеширования <em>SipHash</em>, которая может противостоять атакам класса отказ в обслуживании, Denial of Service (DoS) с использованием хеш-таблиц <a href="https://en.wikipedia.org/wiki/SipHash">siphash</a><!-- ignore -->. Это не самый быстрый из возможных алгоритмов хеширования, в данном случае производительность идёт на соглашение с обеспечением лучшей безопасности. Если после профилирования вашего кода окажется, что хеш-функция, используемая по умолчанию, очень медленная, вы можете заменить её используя другой hasher. <em>Hasher</em> - это вид, выполняющий особенность <code>BuildHasher</code>. Подробнее о особенностях мы поговорим в Главе 10. Вам совсем не обязательно выполнить свою собственную функцию хеширования; <a href="https://crates.io/">crates.io</a><!-- ignore --> имеет достаточное количество библиотек, предоставляющих разные выполнения hasher с множеством общих алгоритмов хеширования.</p>
<h2 id="Итоги-5"><a class="header" href="#Итоги-5">Итоги</a></h2>
<p>Векторы, строки и хеш-карты предоставят большое количество возможностей для программ, когда необходимо сохранять, получать доступ и изменять данные. Теперь вы готовы решить следующие учебные задания:</p>
<ul>
<li>Есть список целых чисел. Создайте функцию, используйте вектор и верните из списка: среднее значение; медиану (значение элемента из середины списка после его сортировки); режиму списка (mode of list, то значение которое встречается в списке наибольшее количество раз; HashMap будет полезна в данном случае).</li>
<li>Преобразуйте строку в кодировку "поросячьей латыни" (Pig Latin). Первая согласная каждого слова перемещается в конец и к ней добавляется окончание "ay", так "first" станет "irst-fay". Слову, начинающемуся на гласную, в конец добавляется "hay" ("apple" становится "apple-hay"). Помните о подробностях работы с кодировкой UTF-8!</li>
<li>Используя хеш-карту и векторы, создайте текстовый внешняя оболочка позволяющий пользователю добавлять имена сотрудников к названию отдела предприятия. Например, "Add Sally to Engineering" или "Add Amir to Sales". Затем позвольте пользователю получить список всех людей из отдела или всех людей в предприятия, отсортированных по отделам в алфавитном порядке.</li>
</ul>
<p>Документация API встроенной библиотеки описывает способы у векторов, строк и HashMap. Советуем воспользоваться ей при решении упражнений.</p>
<p>Потихоньку мы переходим к более сложным программам, в которых действия могут потерпеть неудачу. Наступило наилучшее время для обсуждения обработки ошибок.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обработка-ошибок"><a class="header" href="#Обработка-ошибок">Обработка ошибок</a></h1>
<p>Возникновение ошибок в ходе выполнения программ — это суровая действительность в жизни программного обеспечения, поэтому Ржавчина имеет ряд функций для обработки случаев, в которых что-то идёт не так. Во многих случаях Ржавчина требует, чтобы вы признали возможность ошибки и предприняли некоторые действия, прежде чем ваш код будет собран. Это требование делает вашу программу более надёжной, обеспечивая, что вы обнаружите ошибки и обработаете их надлежащим образом, прежде чем развернёте свой код в производственной среде!</p>
<p>В Ржавчина ошибки объединяются на две основные разряды: <em>исправимые</em> (recoverable) и <em>неисправимые</em> (unrecoverable). В случае исправимой ошибки, такой как <em>файл не найден</em>, мы, скорее всего, просто хотим сообщить о неполадке пользователю и повторить действие. Неисправимые ошибки всегда являются симптомами изъянов в коде, например, попытка доступа к ячейке за пределами границ массива, и поэтому мы хотим немедленно остановить программу.</p>
<p>Большинство языков не различают эти два вида ошибок и обрабатывают оба вида одинаково, используя такие рычаги, как исключения. В Ржавчина нет исключений. Вместо этого он имеет вид <code>Result&lt;T, E&gt;</code> для обрабатываемых (исправимых) ошибок и макрос <code>panic!</code>, который останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку. Сначала эта глава расскажет про вызов <code>panic!</code>, а потом расскажет о возврате значений <code>Result&lt;T, E&gt;</code>. Кроме того, мы рассмотрим, что нужно учитывать при принятии решения о том, следует ли попытаться исправить ошибку или остановить выполнение.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Неустранимые-ошибки-с-макросом-panic"><a class="header" href="#Неустранимые-ошибки-с-макросом-panic">Неустранимые ошибки с макросом <code>panic!</code></a></h2>
<p>Иногда в коде происходят плохие вещи, и вы ничего не можете с этим поделать. В этих случаях у Ржавчина есть макрос panic! В действительностисуществует два способа вызвать панику: путём выполнения действия, которое вызывает панику в нашем коде (например, обращение к массиву за пределами его размера) или путём явного вызова макроса <code>panic!</code>. В обоих случаях мы вызываем панику в нашей программе. По умолчанию паника выводит сообщение об ошибке, раскручивает и очищает обойма вызовов, и завершают работу. С помощью переменной окружения вы также можете заставить Ржавчина отображать обойма вызовов при возникновении паники, чтобы было легче отследить источник паники.</p>
<blockquote>
<h3 id="Раскручивать-обойма-или-прерывать-выполнение-программы-в-ответ-на-панику"><a class="header" href="#Раскручивать-обойма-или-прерывать-выполнение-программы-в-ответ-на-панику">Раскручивать обойма или прерывать выполнение программы в ответ на панику?</a></h3>
<p>По умолчанию, когда происходит паника, программа начинает этап <em>раскрутки обоймы</em>, означающий в Ржавчина проход обратно по обойме вызовов и очистку данных для каждой обнаруженной функции.  Тем не менее, этот обратный проход по обойме и очистка порождают много работы. Ржавчина как иное решение предоставляет вам возможность <em>немедленного прерывания</em> (aborting), которое завершает работу программы без очистки.</p>
<p>Память, которую использовала программа, должна быть очищена операционной системой. Если в вашем деле нужно насколько это возможно сделать маленьким исполняемый файл, вы можете переключиться с исхода раскрутки обоймы на исход прерывания при панике, добавьте <code>panic = 'abort'</code> в раздел [profile] вашего <code>Cargo.toml</code> файла. Например, если вы хотите прервать панику в режиме исполнения, добавьте это:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Давайте попробуем вызвать <code>panic!</code> в простой программе:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!("crash and burn");
}</code></pre></pre>
<p>При запуске программы, вы увидите что-то вроде этого:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

</code></pre>
<p>Выполнение макроса <code>panic!</code> вызывает сообщение об ошибке, содержащееся в двух последних строках. Первая строка показывает сообщение паники и место в исходном коде, где возникла паника: <em>src/main.rs:2:5</em> указывает, что это вторая строка, пятый символ внутри нашего файла <em>src/main.rs</em></p>
<p>В этом случае указанная строка является частью нашего кода, и если мы перейдём к этой строке, мы увидим  вызов макроса <code>panic!</code>. В других случаях вызов <code>panic!</code> мог бы произойти в стороннем коде, который вызывает наш код, тогда имя файла и номер строки для сообщения об ошибке будет из чужого кода, где макрос <code>panic!</code> выполнен, а не из строк нашего кода, которые в конечном итоге привели к выполнению <code>panic!</code>. Мы можем использовать обратную трассировку вызовов функций которые вызвали <code>panic!</code> чтобы выяснить, какая часть нашего кода вызывает неполадку. Мы обсудим обратную трассировку более подробно далее.</p>
<h3 id="Использование-обратной-трассировки-panic"><a class="header" href="#Использование-обратной-трассировки-panic">Использование обратной трассировки <code>panic!</code></a></h3>
<p>Давайте посмотрим на другой пример, где, вызов <code>panic!</code> происходит в сторонней библиотеке из-за ошибки в нашем коде (а не как в примере ранее, из-за вызова макроса нашим кодом напрямую). В приложении 9-1 приведён код, который пытается получить доступ по порядковому указателю в векторе за пределами допустимого рядазначений порядкового указателя.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<p><span class="caption">Приложение 9-1: Попытка доступа к элементу за пределами вектора, которая вызовет <code>panic!</code></span></p>
<p>Здесь мы пытаемся получить доступ к 100-му элементу вектора (который находится по порядковому указателю 99, потому что упорядочевание начинается с нуля), но вектор имеет только 3 элемента. В этой случаи, Ржавчина будет вызывать панику. Использование <code>[]</code> должно возвращать элемент, но вы передаёте неверный порядковый указатель: не существует элемента, который Ржавчина мог бы вернуть.</p>
<p>В языке C, например, попытка прочесть за пределами конца устройства данных (в нашем случае векторе) приведёт к <em>неопределённому поведению, undefined behavior, UB</em>. Вы всё равно получите значение, которое находится в том месте памяти компьютера, которое соответствовало бы этому элементу в векторе, несмотря на то, что память по тому адресу совсем не принадлежит вектору (всё просто: C рассчитал бы место хранения элемента с порядковым указателем 99 и считал бы то, что там хранится, упс). Это называется <em>чтением за пределом буфера, buffer overread,</em> и может привести к уязвимостям безопасности. Если злоумышленник может управлять порядковым указателем таким образом, то у него появляется возможность читать данные, которые он не должен иметь возможности читать.</p>
<p>Чтобы защитить вашу программу от такого рода уязвимостей при попытке прочитать элемент с порядковым указателем, которого не существует, Ржавчина остановит выполнение и откажется продолжить работу программы. Давайте попробуем так сделать и посмотрим на поведение Rust:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Следующая строка говорит, что мы можем установить переменную среды <code>RUST_BACKTRACE</code>, чтобы получить обратную трассировку того, что именно стало причиной ошибки. <em>Обратная трассировка</em> создаёт список всех функций, которые были вызваны до какой-то определённой точки выполнения программы. Обратная трассировка в Ржавчина работает так же, как и в других языках. По этому предлагаем вам читать данные обратной трассировки как и везде - читать сверху вниз, пока не увидите сведения о файлах написанных вами. Это место, где возникла неполадка. Другие строки, которые выше над строками с упоминанием наших файлов, - это код, который вызывается нашим кодом; строки ниже являются кодом, который вызывает наш код. Эти строки могут включать основной код Rust, код встроенной библиотеки или используемые ящики. Давайте попробуем получить обратную трассировку с помощью установки переменной среды <code>RUST_BACKTRACE</code> в любое значение, кроме 0. Приложение 9-2 показывает вывод, подобный тому, что вы увидите.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Приложение 9-2: Обратная трассировка, созданная вызовом <code>panic!</code>, когда установлена переменная окружения <code>RUST_BACKTRACE</code></span></p>
<p>Тут много вывода! Вывод, который вы увидите, может отличаться от представленного, в зависимости от вашей операционной системы и исполнения Rust. Для того, чтобы получить обратную трассировку с этой сведениями, должны быть включены <em>символы отладки, debug symbols</em>. Символы отладки включены по умолчанию при использовании <code>cargo build</code> или <code>cargo run</code> без флага <code>--release</code>, как у нас в примере.</p>
<p>В выводе обратной трассировки приложения 9-2, строка #6 указывает на строку в нашем деле, которая вызывала неполадку: строка 4 из файла <em>src/main.rs.</em> Если мы не хотим, чтобы наша программа запаниковала, мы должны начать исследование с места, на которое указывает первая строка с упоминанием нашего файла. В приложении 9-1, где мы для отображения обратной трассировки сознательно написали код, который паникует, способ исправления паники состоит в том, чтобы не запрашивать элемент за пределами ряда значений порядковых указателей вектора. Когда ваш код запаникует в будущем, вам нужно будет выяснить, какое выполняющееся кодом действие, с какими значениями вызывает панику и что этот код должен делать вместо этого.</p>
<p>Мы вернёмся к обсуждению макроса <code>panic!</code>, и того когда нам следует и не следует использовать <code>panic!</code> для обработки ошибок в разделе <a data-md-type="raw_html" href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">"<code>panic!</code> или НЕ <code>panic!</code>"</a><!--  --> этой главы. Далее мы рассмотрим, как восстановить выполнение программы после исправляемых ошибок, использующих вид <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Исправимые-ошибки-с-result"><a class="header" href="#Исправимые-ошибки-с-result">Исправимые ошибки с <code>Result</code></a></h2>
<p>Многие ошибки являются не настолько критичными, чтобы останавливать выполнение программы. Иногда, когда в функции происходит сбой, необходима просто правильная преобразование и обработка ошибки. К примеру, при попытке открыть файл может произойти ошибка из-за отсутствия файла. Вы, возможно, захотите исправить случай и создать новый файл вместо остановки программы.</p>
<p>Вспомните раздел ["Обработка возможного сбоя с помощью <code>Result</code>"]<!-- ignore --> главы 2: мы использовали там перечисление <code>Result</code>, имеющее два исхода. <code>Ok</code> и <code>Err</code> для обработки сбоев. Само перечисление определено следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Виды <code>T</code> и <code>E</code> являются свойствами обобщённого вида: мы обсудим обобщённые виды более подробно в Главе 10. Все что вам нужно знать прямо сейчас - это то, что <code>T</code> представляет вид значения, которое будет возвращено в случае успеха внутри исхода <code>Ok</code>, а <code>E</code> представляет вид ошибки, которая будет возвращена при сбое внутри исхода <code>Err</code>. Так как вид <code>Result</code> имеет эти обобщённые свойства (generic type parameters), мы можем использовать вид <code>Result</code> и функции, которые определены для него, в разных случаейх, когда вид успешного значение и значения ошибки, которые мы хотим вернуть, отличаются.</p>
<p>Давайте вызовем функцию, которая возвращает значение <code>Result</code>, потому что может потерпеть неудачу. В приложении 9-3 мы пытаемся открыть файл.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
<p><span class="caption">Приложение 9-3: Открытие файла</span></p>
<p><code>File::open</code> возвращает значения вида <code>Result&lt;T, E&gt;</code>. Гибкий вид <code>T</code> в выполнения <code>File::open</code> соответствует виду успешно полученного значения, <code>std::fs::File</code>, а именно указателю файла. Вид <code>E</code>, используемый для значения в случае возникновения ошибки, - <code>std::io::Error</code>. Такой возвращаемый вид означает, что вызов <code>File::open</code> может быть успешным и вернуть указатель файла, из которого мы можем читать или в который можем писать. Также вызов функции может завершиться неудачей: например, файл может не существовать, или у нас может не быть разрешения на доступ к файлу. Функция <code>File::open</code> должна иметь способ сообщить нам об успехе или неудаче и в то же время дать нам либо указатель файла, либо сведения об ошибке. Эту возможность как раз и предоставляет перечисление <code>Result</code>.</p>
<p>В случае успеха <code>File::open</code> значением переменной <code>greeting_file_result</code> будет образец <code>Ok</code>, содержащий указатель файла. В случае неудачи значение в переменной <code>greeting_file_result</code> будет образцом <code>Err</code>, содержащим дополнительную сведения о том, какая именно ошибка произошла.</p>
<p>Необходимо дописать в код приложения 9-3 выполнение разных действий в зависимости от значения, которое вернёт вызов <code>File::open</code>. Приложение 9-4 показывает один из способов обработки <code>Result</code> - пользуясь основным средством языка, таким как выражение <code>match</code>, рассмотренным в Главе 6.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem opening the file: {error:?}"),
    };
}</code></pre></pre>
<p><span class="caption">Приложение 9-4: Использование выражения <code>match</code> для обработки возвращаемых исходов вида <code>Result</code></span></p>
<p>Обратите внимание, что также как перечисление <code>Option</code>, перечисление <code>Result</code> и его исходы, входят в область видимости благодаря авто-подключения (prelude), поэтому не нужно указывать <code>Result::</code> перед использованием исходов <code>Ok</code> и <code>Err</code> в ветках выражения <code>match</code>.</p>
<p>Если итогом будет <code>Ok</code>, этот код вернёт значение <code>file</code> из исхода <code>Ok</code>, а мы затем присвоим это значение файлового указателя переменной <code>greeting_file</code>. После <code>match</code> мы можем использовать указатель файла для чтения или записи.</p>
<p>Другая ветвь <code>match</code> обрабатывает случай, где мы получаем значение <code>Err</code> после вызова <code>File::open</code>. В этом примере мы решили вызвать макрос <code>panic!</code>. Если в нашей текущей папки нет файла с именем <em>hello.txt</em> и мы выполним этот код, то мы увидим следующее сообщение от макроса <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Как обычно, данное сообщение точно говорит, что пошло не так.</p>
<h3 id="Обработка-различных-ошибок-с-помощью-match"><a class="header" href="#Обработка-различных-ошибок-с-помощью-match">Обработка различных ошибок с помощью match</a></h3>
<p>Код в приложении 9-4 будет вызывать <code>panic!</code> независимо от того, почему вызов <code>File::open</code> не удался. Однако мы хотим предпринять различные действия для разных причин сбоя. Если открытие <code>File::open</code> не удалось из-за отсутствия файла, мы хотим создать файл и вернуть его указатель. Если вызов <code>File::open</code> не удался по любой другой причине - например, потому что у нас не было прав на открытие файла, то все равно мы хотим вызвать <code>panic!</code> как у нас сделано в приложении 9-4. Для этого мы добавляем выражение внутреннего <code>match</code>, показанное в приложении 9-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {e:?}"),
            },
            other_error =&gt; {
                panic!("Problem opening the file: {other_error:?}");
            }
        },
    };
}</code></pre>
<p><span class="caption">Приложение 9-5: Обработка различных ошибок разными способами</span></p>
<p>Видом значения возвращаемого функцией <code>File::open</code> внутри <code>Err</code> исхода является <code>io::Error</code>, устройства из встроенной библиотеки. Данная устройства имеет способ <code>kind</code>, который можно вызвать для получения значения <code>io::ErrorKind</code>. Перечисление <code>io::ErrorKind</code> из встроенной библиотеки имеет исходы, представляющие различные виды ошибок, которые могут появиться при выполнении действий в <code>io</code>. Исход, который мы хотим использовать, это <code>ErrorKind::NotFound</code>, который даёт сведения, о том, что файл который мы пытаемся открыть ещё не существует. Итак, во второй строке мы вызываем сопоставление образца с переменной <code>greeting_file_result</code> и попадаем в ветку с обработкой ошибки, но также у нас есть внутренняя проверка для сопоставления <code>error.kind()</code> ошибки.</p>
<p>Условие, которое мы хотим проверить во внутреннем <code>match</code>, заключается в том, является ли значение, возвращаемое <code>error.kind()</code>, исходом <code>NotFound</code> перечисления <code>ErrorKind</code>. Если это так, мы пытаемся создать файл с помощью функции <code>File::create</code>. Однако, поскольку вызов <code>File::create</code> тоже может завершиться ошибкой, нам нужна обработка ещё одной ошибки, теперь уже во внутреннем выражении <code>match</code>. Заметьте: если файл не может быть создан, выводится другое, особое сообщение об ошибке. Вторая же ветка внешнего <code>match</code> (который обрабатывает вызов <code>error.kind()</code>), остаётся той же самой - в итоге программа паникует при любой ошибке, кроме ошибки отсутствия файла.</p>
<blockquote>
<h3 id="Иные-использованию-match-с-resultt-e"><a class="header" href="#Иные-использованию-match-с-resultt-e">Иные использованию <code>match</code> с <code>Result&lt;T, E&gt;</code></a></h3>
<p>Как много <code>match</code>! Выражение <code>match</code> является очень полезным, но в то же время довольно простым. В главе 13 вы узнаете о замыканиях (closures), которые используются во многих способах вида <code>Result&lt;T, E&gt;</code>. Эти способы помогают быть более кратким, чем использование <code>match</code> при работе со значениями <code>Result&lt;T, E&gt;</code> в вашем коде.</p>
<p>Например, вот другой способ написать ту же логику, что показана в Приложении 9-5, но с использованием замыканий и способа <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}</code></pre>
<p>Несмотря на то, что данный код имеет такое же поведение как в приложении 9-5, он не содержит ни одного выражения <code>match</code> и проще для чтения. Советуем вам вернуться к примеру этого раздела после того как вы прочитаете Главу 13 и изучите способ <code>unwrap_or_else</code> по документации встроенной библиотеки. Многие из способов о которых вы узнаете в документации и Главе 13 могут очистить код от больших, вложенных выражений <code>match</code> при обработке ошибок.</p>
</blockquote>
<h3 id="Краткие-способы-обработки-ошибок---unwrap-и-expect"><a class="header" href="#Краткие-способы-обработки-ошибок---unwrap-и-expect">Краткие способы обработки ошибок - <code>unwrap</code> и <code>expect</code></a></h3>
<p>Использование <code>match</code> работает достаточно хорошо, но может быть довольно многословным и не всегда хорошо передаёт смысл. Вид <code>Result&lt;T, E&gt;</code> имеет множество вспомогательных способов для выполнения различных, более отличительных задач. Способ <code>unwrap</code> - это способ быстрого доступа к значениям, выполненный так же, как и выражение <code>match</code>, которое мы написали в Приложении 9-4. Если значение <code>Result</code> является исходом <code>Ok</code>, <code>unwrap</code> возвращает значение внутри <code>Ok</code>. Если <code>Result</code> - исход <code>Err</code>, то <code>unwrap</code> вызовет для нас макрос <code>panic!</code>. Вот пример <code>unwrap</code> в действии:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
<p>Если мы запустим этот код при отсутствии файла <em>hello.txt</em>, то увидим сообщение об ошибке из вызова <code>panic!</code> способа <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
</code></pre>
<p>Другой способ, похожий на <code>unwrap</code>, это <code>expect</code>, позволяющий указать сообщение об ошибке для макроса <code>panic!</code>. Использование <code>expect</code> вместо <code>unwrap</code> с предоставлением хорошего сообщения об ошибке выражает ваше намерение и делает более простым отслеживание источника паники. правила написания способа <code>expect</code> выглядит так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}</code></pre></pre>
<p><code>expect</code> используется так же как и <code>unwrap</code>: либо возвращается указатель файла либо вызывается макрос <code>panic!</code>.<br>Наше сообщение об ошибке в <code>expect</code> будет передано в <code>panic!</code> и заменит обычное используемое сообщение.<br>Вот как это выглядит:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
</code></pre>
<p>В рабочем коде, большинство выбирает <code>expect</code> в угоду <code>unwrap</code> и добавляет описание, почему действие должна закончиться успешно. Но даже если предположение оказалось неверным, сведений для отладки будет больше.</p>
<h3 id="Проброс-ошибок"><a class="header" href="#Проброс-ошибок">Проброс ошибок</a></h3>
<p>Когда вы пишете функцию, выполнение которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать. Такой приём известен как <em>распространение ошибки</em> (<em>propagating the error</em>). Благодаря нему мы даём больше управления вызывающему коду, где может быть больше сведений или логики, которая диктует, как ошибка должна обрабатываться, чем было бы в месте появления этой ошибки.</p>
<p>Например, код программы 9-6 читает имя пользователя из файла. Если файл не существует или не может быть прочтён, то функция возвращает ошибку в код, который вызвал данную функцию.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-6: Функция, которая возвращает ошибки в вызывающий код, используя оператор <code>match</code></span></p>
<p>Эта функция может быть написана гораздо более коротким способом, но мы начнём с того, что многое сделаем вручную, чтобы изучить обработку ошибок; а в конце покажем более короткий способ. Давайте сначала рассмотрим вид возвращаемого значения: <code>Result&lt;String, io::Error&gt;</code>. Здесь есть возвращаемое значение функции вида <code>Result&lt;T, E&gt;</code> где образцовый свойство <code>T</code> был заполнен определенным видом <code>String</code> и образцовый свойство <code>E</code> был заполнен определенным видом <code>io::Error</code>.</p>
<p>Если эта функция выполнится без неполадок. то код, вызывающий эту функцию, получит значение <code>Ok</code>, содержащее <code>String</code> - имя пользователя, которое эта функция прочитала из файла. Если функция столкнётся с какими-либо неполадками, вызывающий код получит значение <code>Err</code>, содержащее образец <code>io::Error</code>, который включает дополнительную сведения о том, какие сбоев возникли. Мы выбрали <code>io::Error</code> в качестве возвращаемого вида этой функции, потому что это вид значения ошибки, возвращаемого из обеих действий, которые мы вызываем в теле этой функции и которые могут завершиться неудачей: функция <code>File::open</code> и способ <code>read_to_string</code>.</p>
<p>Тело функции начинается с вызова <code>File::open</code>. Затем мы обрабатываем значение <code>Result</code> с помощью <code>match</code>, подобно <code>match</code> из приложения 9-4. Если <code>File::open</code> завершается успешно, то указатель файла в переменной образца <code>file</code> становится значением в изменяемой переменной <code>username_file</code> и функция продолжит свою работу. В случае <code>Err</code>, вместо вызова <code>panic!</code>, мы используем ключевое слово <code>return</code> для досрочного возврата из функции и передаём значение ошибки из <code>File::open</code>, которое теперь находится в переменной образца <code>e</code>, обратно в вызывающий код как значение ошибки этой функции.</p>
<p>Таким образом, если у нас есть файловый указатель в <code>username_file</code>, функция создаёт новую <code>String</code> в переменной <code>username</code> и вызывает способ <code>read_to_string</code> для файлового указателя в <code>username_file</code>, чтобы прочитать содержимое файла в <code>username</code>. Способ <code>read_to_string</code> также возвращает <code>Result</code>, потому что он может потерпеть неудачу, даже если <code>File::open</code> завершился успешно. Поэтому нам нужен ещё один <code>match</code> для обработки этого <code>Result</code>: если <code>read_to_string</code> завершится успешно, то наша функция сработала, и мы возвращаем имя пользователя из файла, которое теперь находится в <code>username</code>, обёрнутое в <code>Ok</code>. Если <code>read_to_string</code> потерпит неудачу, мы возвращаем значение ошибки таким же образом, как мы возвращали значение ошибки в <code>match</code>, который обрабатывал возвращаемое значение <code>File::open</code>. Однако нам не нужно явно указывать <code>return</code>, потому что это последнее выражение в функции.</p>
<p>Затем код, вызывающий этот, будет обрабатывать получение либо значения <code>Ok</code>, содержащего имя пользователя, либо значения <code>Err</code>, содержащего <code>io::Error</code>. Вызывающий код должен решить, что делать с этими значениями. Если вызывающий код получает значение <code>Err</code>, он может вызвать <code>panic!</code> и завершить работу программы, использовать имя пользователя по умолчанию или найти имя пользователя, например, не в файле. У нас недостаточно сведений о том, что на самом деле пытается сделать вызывающий код, поэтому мы распространяем всю сведения об успехах или ошибках вверх, чтобы она могла обрабатываться соответствующим образом.</p>
<p>Эта схема передачи ошибок настолько распространена в Rust, что Ржавчина предоставляет оператор вопросительного знака <code>?</code>, чтобы облегчить эту задачу.</p>
<h4 id="Сокращение-для-проброса-ошибок-оператор-"><a class="header" href="#Сокращение-для-проброса-ошибок-оператор-">Сокращение для проброса ошибок: оператор <code>?</code></a></h4>
<p>В приложении 9-7 показана выполнение <code>read_username_from_file</code>, которая имеет ту же возможность, что и в приложении 9-6, но в этой выполнения используется оператор <code>?</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-7: Функция, возвращающая ошибки в вызывающий код с помощью оператора <code>?</code></span></p>
<p>Выражение <code>?</code>, расположенное после <code>Result</code>, работает почти так же, как и те выражения <code>match</code>, которые мы использовали для обработки значений <code>Result</code> в приложении 9-6. Если в качестве значения <code>Result</code> будет <code>Ok</code>, то значение внутри <code>Ok</code> будет возвращено из этого выражения, и программа продолжит работу. Если же значение представляет собой <code>Err</code>, то <code>Err</code> будет возвращено из всей функции, как если бы мы использовали ключевое слово <code>return</code>, так что значение ошибки будет передано в вызывающий код.</p>
<p>Существует разница между тем, что делает выражение <code>match</code> из приложения 9-6 и тем, что делает оператор <code>?</code>: значения ошибок, для которых вызван оператор <code>?</code>, проходят через функцию <code>from</code>, определённую в особенности <code>From</code> встроенной библиотеки, которая используется для преобразования значений из одного вида в другой. Когда оператор <code>?</code> вызывает функцию <code>from</code>, полученный вид ошибки преобразуется в вид ошибки, определённый в возвращаемом виде текущей функции. Это полезно, когда функция возвращает только один вид ошибки, для описания всех возможных исходов сбоев, даже если её отдельные составляющие могут выходить из строя по разным причинам.</p>
<p>Например, мы могли бы изменить функцию <code>read_username_from_file</code> в приложении 9-7, чтобы возвращать пользовательский вид ошибки с именем <code>OurError</code>, который мы определим. Если мы также определим <code>impl From&lt;io::Error&gt; for OurError</code> для создания образца <code>OurError</code> из <code>io::Error</code>, то оператор <code>?</code>, вызываемый в теле <code>read_username_from_file</code>, вызовет <code>from</code> и преобразует виды ошибок без необходимости добавления дополнительного кода в функцию.</p>
<p>В случае приложения 9-7 оператор <code>?</code> в конце вызова <code>File::open</code> вернёт значение внутри <code>Ok</code> в переменную <code>username_file</code>. Если произойдёт ошибка, оператор <code>?</code> выполнит ранний возврат значения <code>Err</code> вызывающему коду. То же самое относится к оператору <code>?</code> в конце вызова <code>read_to_string</code>.</p>
<p>Оператор <code>?</code> позволяет избавиться от большого количества образцового кода и упростить выполнение этой функции. Мы могли бы даже ещё больше сократить этот код, если бы использовали цепочку вызовов способов сразу после <code>?</code>, как показано в приложении 9-8.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-8: Цепочка вызовов способов после оператора <code>?</code></span></p>
<p>Мы перенесли создание новой <code>String</code> в <code>username</code> в начало функции; эта часть не изменилась. Вместо создания переменной <code>username_file</code> мы соединили вызов <code>read_to_string</code> непосредственно с итогом <code>File::open("hello.txt")?</code>. У нас по-прежнему есть <code>?</code> в конце вызова <code>read_to_string</code>, и мы по-прежнему возвращаем значение <code>Ok</code>, содержащее <code>username</code>, когда и <code>File::open</code> и <code>read_to_string</code> завершаются успешно, а не возвращают ошибки. Возможность снова такая же, как в Приложении 9-6 и Приложении 9-7; это просто другой, более удобный способ её написания.</p>
<p>Продолжая рассматривать разные способы записи данной функции, приложение 9-9 отображает способ сделать её ещё короче с помощью <code>fs::read_to_string</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-9: Использование <code>fs::read_to_string</code> вместо открытия и последующего чтения файла</span></p>
<p>Чтение файла в строку довольно распространённая действие, так что обычная библиотека предоставляет удобную функцию <code>fs::read_to_string</code>, которая открывает файл, создаёт новую <code>String</code>, читает содержимое файла, размещает его в <code>String</code> и возвращает её. Конечно, использование функции <code>fs::read_to_string</code> не даёт возможности объяснить обработку всех ошибок, поэтому мы сначала изучили длинный способ.</p>
<h4 id="Где-можно-использовать-оператор-"><a class="header" href="#Где-можно-использовать-оператор-">Где можно использовать оператор <code>?</code></a></h4>
<p>Оператор <code>?</code> может использоваться только в функциях, вид возвращаемого значения которых совместим со значением, для которого используется <code>?</code>. Это потому, что оператор <code>?</code> определён для выполнения раннего возврата значения из функции таким же образом, как и выражение <code>match</code>, которое мы определили в приложении 9-6. В приложении 9-6 <code>match</code> использовало значение <code>Result</code>, а ответвление с ранним возвратом вернуло значение <code>Err(e)</code>. Вид возвращаемого значения функции должен быть <code>Result</code>, чтобы он был совместим с этим <code>return</code>.</p>
<p>В приложении 9-10 давайте посмотрим на ошибку, которую мы получим, если воспользуемся оператором <code>?</code> в функции <code>main</code> с видом возвращаемого значения, несовместимым с видом значения, для которого мы используем <code>?</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
<p><span class="caption">Приложение 9-10: Попытка использовать <code>?</code> в <code>main</code> функции, которая возвращает <code>()</code> , не будет собираться</span></p>
<p>Этот код открывает файл, что может привести к сбою. <code>?</code> оператор следует за значением <code>Result</code> , возвращаемым <code>File::open</code> , но эта <code>main</code> функция имеет возвращаемый вид <code>()</code> , а не <code>Result</code> . Когда мы собираем этот код, мы получаем следующее сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>Эта ошибка указывает на то, что оператор <code>?</code> разрешено использовать только в функции, которая возвращает <code>Result</code>, <code>Option</code> или другой вид, выполняющий <code>FromResidual</code>.</p>
<p>Для исправления ошибки есть два исхода. Первый - изменить возвращаемый вид вашей функции так, чтобы он был совместим со значением, для которого вы используете оператор <code>?</code>, если у вас нет ограничений, препятствующих этому. Другой способ - использовать <code>match</code> или один из способов <code>Result&lt;T, E&gt;</code> для обработки <code>Result&lt;T, E&gt;</code> любым подходящим способом.</p>
<p>В сообщении об ошибке также упоминалось, что <code>?</code> можно использовать и со значениями <code>Option&lt;T&gt;</code>. Как и при использовании <code>?</code> для <code>Result</code>, вы можете использовать <code>?</code> только для <code>Option</code> в функции, которая возвращает <code>Option</code>. Поведение оператора <code>?</code> при вызове <code>Option&lt;T&gt;</code> похоже на его поведение при вызове <code>Result&lt;T, E&gt;</code>: если значение равно <code>None</code>, то <code>None</code> будет возвращено раньше из функции в этот мгновение. Если значение <code>Some</code>, значение внутри <code>Some</code> является результирующим значением выражения, и функция продолжает исполняться. В приложении 9-11 приведён пример функции, которая находит последний символ первой строки заданного текста:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hello, world\nHow are you today?"),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-11: Использование оператора <code>?</code> для значения <code>Option&lt;T&gt;</code></span></p>
<p>Эта функция возвращает <code>Option&lt;char&gt;</code>, потому что возможно, что там есть символ, но также возможно, что его нет. Этот код принимает переменная среза <code>text</code> строки и вызывает для него способ <code>lines</code>, который возвращает повторитель для строк в строке. Поскольку эта функция хочет проверить первую строку, она вызывает <code>next</code> у повторителя, чтобы получить первое значение от повторителя. Если <code>text</code> является пустой строкой, этот вызов <code>next</code> вернёт <code>None</code>, и в этом случае мы используем <code>?</code> чтобы остановить и вернуть <code>None</code> из <code>last_char_of_first_line</code>. Если <code>text</code> не является пустой строкой, <code>next</code> вернёт значение <code>Some</code>, содержащее отрывок строки первой строки в <code>text</code>.</p>
<p>Символ <code>?</code> извлекает отрывок строки, и мы можем вызвать <code>chars</code> для этого отрывка строки. чтобы получить повторитель символов. Нас важно последний символ в первой строке, поэтому мы вызываем <code>last</code>, чтобы вернуть последний элемент в повторителе. Вернётся <code>Option</code>, потому что возможно, что первая строка пустая - например, если <code>text</code> начинается с пустой строки, но имеет символы в других строках, как в <code>"\nhi"</code>. Однако, если в первой строке есть последний символ, он будет возвращён в исходе <code>Some</code>. Оператор <code>?</code> в середине даёт нам краткий способ выразить эту логику, позволяя выполнить функцию в одной строке. Если бы мы не могли использовать оператор <code>?</code> в <code>Option</code>, нам пришлось бы выполнить эту логику, используя больше вызовов способов или выражение <code>match</code>.</p>
<p>Обратите внимание, что вы можете использовать оператор <code>?</code> <code>Result</code> в функции, которая возвращает <code>Result</code> , и вы можете использовать оператор <code>?</code> для <code>Option</code> в функции, которая возвращает <code>Option</code> , но вы не можете смешивать и сопоставлять. Оператор <code>?</code> не будет самостоятельно преобразовывать <code>Result</code> в <code>Option</code> или наоборот; в этих случаях вы можете использовать такие способы, как способ <code>ok</code> для <code>Result</code> или способ <code>ok_or</code> для <code>Option</code>, чтобы выполнить преобразование явно.</p>
<p>До сих пор все функции <code>main</code>, которые мы использовали, возвращали <code>()</code>. Функция <code>main</code> - особенная, потому что это точка входа и выхода исполняемых программ, и существуют ограничения на вид возвращаемого значения, чтобы программы вели себя так, как ожидается.</p>
<p>К счастью, <code>main</code> также может возвращать <code>Result&lt;(), E&gt;</code> . В приложении 9-12 используется код из приложения 9-10, но мы изменили возвращаемый вид <code>main</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> и добавили возвращаемое значение <code>Ok(())</code> в конец. Теперь этот код будет собран:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
<p><span class="caption">Приложение 9-12: Замена <code>main</code> на return <code>Result&lt;(), E&gt;</code> позволяет использовать оператор <code>?</code> оператор над значениями <code>Result</code></span></p>
<p>Вид <code>Box&lt;dyn Error&gt;</code> является <em>особенность-предметом</em>, о котором мы поговорим в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование особенность-предметов, допускающих значения разных видов"</a><!-- ignore --> в главе 17. Пока что вы можете считать, что <code>Box&lt;dyn Error&gt;</code> означает "любой вид ошибки". Использование <code>?</code> для значения <code>Result</code> в функции <code>main</code> с видом ошибки <code>Box&lt;dyn Error&gt;</code> разрешено, так как позволяет вернуть любое значение <code>Err</code> раньше времени. Даже если тело этой функции <code>main</code> будет возвращать только ошибки вида <code>std::io::Error</code>, указав <code>Box&lt;dyn Error&gt;</code>, эта ярлык останется правильной, даже если в тело <code>main</code> будет добавлен код, возвращающий другие ошибки.</p>
<p>Когда <code>main</code> функция возвращает <code>Result&lt;(), E&gt;</code>, исполняемый файл завершится со значением <code>0</code>, если <code>main</code> вернёт <code>Ok(())</code>, и выйдет с ненулевым значением, если <code>main</code> вернёт значение <code>Err</code>. Исполняемые файлы, написанные на C, при выходе возвращают целые числа: успешно завершённые программы возвращают целое число <code>0</code>, а программы с ошибкой возвращают целое число, отличное от <code>0</code>. Ржавчина также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этим соглашением.</p>
<p>Функция <code>main</code> может возвращать любые виды, выполняющие <a href="../std/process/trait.Termination.html">особенность <code>std::process::Termination</code></a><!-- ignore -->, в которых имеется функция <code>report</code>, возвращающая <code>ExitCode</code>. Обратитесь к документации встроенной библиотеки за дополнительной сведениями о порядке выполнения особенности <code>Termination</code> для ваших собственных видов.</p>
<p>Теперь, когда мы обсудили подробности вызова <code>panic!</code> или возврата <code>Result</code>, давайте вернёмся к тому, как решить, какой из случаев подходит для какой случаи.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-или-не-panic"><a class="header" href="#panic-или-не-panic"><code>panic!</code> или не <code>panic!</code></a></h2>
<p>Итак, как принимается решение о том, когда следует вызывать <code>panic!</code>, а когда вернуть <code>Result</code>? При панике код не имеет возможности восстановить своё выполнение. Можно было бы вызывать <code>panic!</code> для любой ошибочной случаи, независимо от того, имеется ли способ восстановления или нет, но с другой стороны, вы принимаете решение от имени вызывающего вас кода, что случаей необратима. Когда вы возвращаете значение <code>Result</code>, вы делегируете принятие решения вызывающему коду. Вызывающий код может попытаться выполнить восстановление способом, который подходит в данной случаи, или же он может решить, что из ошибки в  <code>Err</code> нельзя восстановиться и вызовет <code>panic!</code>, превратив вашу исправимую ошибку в неисправимую. Поэтому возвращение <code>Result</code> является хорошим выбором по умолчанию для функции, которая может дать сбой.</p>
<p>В таких случаей как примеры, протовиды и проверки, более уместно писать код, который паникует вместо возвращения <code>Result</code>. Давайте рассмотрим почему, а затем мы обсудим случаи, в которых сборщик не может доказать, что ошибка невозможна, но вы, как человек, можете это сделать. Глава будет заканчиваться некоторыми общими руководящими принципами о том, как решить, стоит ли паниковать в коде библиотеки.</p>
<h3 id="Примеры-прототипирование-и-проверки"><a class="header" href="#Примеры-прототипирование-и-проверки">Примеры, прототипирование и проверки</a></h3>
<p>Когда вы пишете пример, отображающий некоторую подход, наличие хорошего кода обработки ошибок может сделать пример менее понятным. Понятно, что в примерах вызов способа <code>unwrap</code>, который может привести к панике, является лишь обозначением способа обработки ошибок в приложении, который может отличаться в зависимости от того, что делает остальная часть кода.</p>
<p>Точно так же способы <code>unwrap</code> и <code>expect</code> являются очень удобными при создании протовида, прежде чем вы будете готовы решить, как обрабатывать ошибки. Они оставляют чёткие отступыв коде до особенности, когда вы будете готовы сделать программу более надёжной.</p>
<p>Если в проверке происходит сбой при вызове способа, то вы бы хотели, чтобы весь проверка не прошёл, даже если этот способ не является проверяемой возможностью. Поскольку вызов <code>panic!</code> это способ, которым проверка помечается как провалившийся, использование <code>unwrap</code> или <code>expect</code> - именно то, что нужно.</p>
<h3 id="Случаи-в-которых-у-вас-больше-сведений-чем-у-сборщика"><a class="header" href="#Случаи-в-которых-у-вас-больше-сведений-чем-у-сборщика">Случаи, в которых у вас больше сведений, чем у сборщика</a></h3>
<p>Также было бы целесообразно вызывать <code>unwrap</code> или <code>expect</code> когда у вас есть какая-то другая логика, которая заверяет, что <code>Result</code> будет иметь значение <code>Ok</code>, но вашу логику не понимает сборщик. У вас по-прежнему будет значение <code>Result</code> которое нужно обработать: любая действие, которую вы вызываете, все ещё имеет возможность неудачи в целом, хотя это логически невозможно в вашей именно случаи. Если, проверяя код вручную, вы можете убедиться, что никогда не будет исход с <code>Err</code>, то вполне допустимо вызывать <code>unwrap</code>, а ещё лучше задокументировать причину, по которой, по вашему мнению, у вас никогда не будет исхода <code>Err</code> в тексте <code>expect</code>. Вот пример:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
<span class="boring">}</span></code></pre></pre>
<p>Мы создаём образец <code>IpAddr</code>, анализируя жёстко закодированную строку. Можно увидеть, что <code>127.0.0.1</code> является действительным IP-адресом, поэтому здесь допустимо использование <code>expect</code>. Однако наличие жёстко закодированной допустимой строки не меняет вид возвращаемого значения способа <code>parse</code>: мы все ещё получаем значение <code>Result</code> и сборщик все также заставляет нас обращаться с <code>Result</code>так, будто возможен исход <code>Err</code>, потому что сборщик недостаточно умён, чтобы увидеть, что эта строка всегда действительный IP-адрес. Если строка IP-адреса пришла от пользователя, то она не является жёстко запрограммированной в программе и, следовательно, <em>может</em> привести к ошибке, мы определённо хотели бы обработать <code>Result</code> более надёжным способом. Упоминание предположения о том, что этот IP-адрес жёстко закодирован, побудит нас изменить <code>expect</code> для лучшей обработки ошибок, если в будущем нам потребуется вместо этого получить IP-адрес из какого-либо другого источника.</p>
<h3 id="Руководство-по-обработке-ошибок"><a class="header" href="#Руководство-по-обработке-ошибок">Руководство по обработке ошибок</a></h3>
<p>Желательно, чтобы код паниковал, если он может оказаться в неправильном состоянии. В этом среде <em>неправильное состояние</em> это когда некоторое допущение, заверение, договор или неизменная величина были нарушены. Например, когда недопустимые, противоречивые или пропущенные значения передаются в ваш код - плюс один или несколько пунктов из следующего перечисленного в списке:</p>
<ul>
<li>Неправильное состояние — это что-то неожиданное, отличается от того, что может происходить время от времени, например, когда пользователь вводит данные в неправильном виде.</li>
<li>Ваш код после этой точки должен полагаться на то, что он не находится в неправильном состоянии, вместо проверок наличия сбоев на каждом этапе.</li>
<li>Нет хорошего способа закодировать данную сведения в видах, которые вы используете. Мы рассмотрим пример того, что мы имеем в виду в разделе <a href="ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“Кодирование состояний и поведения на основе видов”</a><!-- ignore --> главы 17.</li>
</ul>
<p>Если кто-то вызывает ваш код и передаёт значения, которые не имеют смысла, лучше всего вернуть ошибку, если вы это можете, чтобы пользователь библиотеки мог решить, что он хочет делать в этом случае. Однако в тех случаях, когда продолжение выполнения программы может быть небезопасным или вредным, лучшим выбором будет вызов <code>panic!</code> и оповещение пользователя, использующего вашу библиотеку, об ошибке в его коде, чтобы он мог исправить её во время разработки. Подобно <code>panic!</code> подходит, если вы вызываете внешний, неподуправлениеный вам код, и он возвращает недопустимое состояние, которое вы не можете исправить.</p>
<p>Однако, когда ожидается сбой, лучше вернуть <code>Result</code>, чем выполнить вызов <code>panic!</code>.  В качестве примера можно привести синтаксический анализатор, которому передали неправильно созданные данные, или HTTP-запрос, возвращающий значение указывающий на то, что вы достигли ограничения на частоту запросов. В этих случаях возврат <code>Result</code> означает, что ошибка является ожидаемой и вызывающий код должен решить, как её обрабатывать.</p>
<p>Когда ваш код выполняет действие, которая может подвергнуть пользователя риску, если она вызывается с использованием недопустимых значений, ваш код должен сначала проверить допустимость значений и паниковать, если значения недопустимы. Так советуется делать в основном из соображений безопасности: попытка оперировать неправильными данными может привести к уязвимостям. Это основная причина, по которой обычная библиотека будет вызывать <code>panic!</code>, если попытаться получить доступ к памяти вне границ массива: доступ к памяти, не относящейся к текущей устройстве данных, является известной неполадкой безопасности. Функции часто имеют договоры: их поведение обеспечивается, только если входные данные отвечают определённым требованиям. Паника при нарушении договора имеет смысл, потому что это всегда указывает на изъян со стороны вызывающего кода, и это не ошибка, которую вы хотели бы, чтобы вызывающий код явно обрабатывал. На самом деле, нет разумного способа для восстановления вызывающего кода; программисты, вызывающие ваш код, должны исправить свой. Договоры для функции, особенно когда нарушение вызывает панику, следует описать в документации по API функции.</p>
<p>Тем не менее, наличие множества проверок ошибок во всех ваших функциях было бы многословным и раздражительным. К счастью, можно использовать систему видов Ржавчина (следовательно и проверку видов сборщиком), чтобы она сделала множество проверок вместо вас. Если ваша функция имеет определённый вид в качестве свойства, вы можете продолжить работу с логикой кода зная, что сборщик уже обеспечил правильное значение. Например, если используется обычный вид, а не вид <code>Option</code>, то ваша программа ожидает наличие <em>чего-то</em> вместо <em>ничего</em>. Ваш код не должен будет обрабатывать оба исхода <code>Some</code> и <code>None</code>: он будет иметь только один исход для определённого значения. Код, пытающийся ничего не передавать в функцию, не будет даже собираться, поэтому ваша функция не должна проверять такой случай во время выполнения. Другой пример - это использование целого вида без знака, такого как <code>u32</code>, который заверяет, что свойство никогда не будет отрицательным.</p>
<h3 id="Создание-пользовательских-видов-для-проверки"><a class="header" href="#Создание-пользовательских-видов-для-проверки">Создание пользовательских видов для проверки</a></h3>
<p>Давайте разовьём мысль использования системы видов Ржавчина чтобы убедиться, что у нас есть правильное значение, и рассмотрим создание пользовательского вида для валидации. Вспомним игру угадывания числа из Главы 2, в которой наш код просил пользователя угадать число между 1 и 100. Мы никогда не проверяли, что предположение пользователя лежит между этими числами, перед сравнением предположения с загаданным нами числом; мы только проверяли, что оно положительно. В этом случае последствия были не очень страшными: наши сообщения «Слишком много» или «Слишком мало», выводимые в окно вывода, все равно были правильными. Но было бы лучше подталкивать пользователя к правильным догадкам и иметь различное поведение для случаев, когда пользователь предлагает число за пределами ряда, и когда пользователь вводит, например, буквы вместо цифр.</p>
<p>Один из способов добиться этого - пытаться разобрать введённое значение как <code>i32</code>, а не как <code>u32</code>, чтобы разрешить возможно отрицательные числа, а затем добавить проверку для нахождение числа в ряде, например, так:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p>Выражение <code>if</code> проверяет, находится ли наше значение вне ряда, сообщает пользователю о неполадке и вызывает <code>continue</code>, чтобы начать следующую повторение цикла и попросить ввести другое число. После выражения <code>if</code> мы можем продолжить сравнение значения <code>guess</code> с загаданным числом, зная, что <code>guess</code> лежит в ряде от 1 до 100.</p>
<p>Однако это не наилучшее решение: если бы было чрезвычайно важно, чтобы программа работала только со значениями от 1 до 100, существовало бы много функций, требующих этого, то такая проверка в каждой функции была бы утомительной (и могла бы отрицательно повлиять на производительность).</p>
<p>Вместо этого можно создать новый вид и поместить проверки в функцию создания образца этого вида, не повторяя их везде. Таким образом, функции могут использовать новый вид в своих ярлыках и быть уверены в значениях, которые им передают. Приложение 9-13 показывает один из способов, как определить вид <code>Guess</code>, чтобы образец <code>Guess</code> создавался только при условии, что функция <code>new</code> получает значение от 1 до 100.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-13. Вид <code>Guess</code>, который будет создавать образцы только для значений от 1 до 100</span></p>
<p>Сначала мы определяем устройство с именем <code>Guess</code>, которая имеет поле с именем <code>value</code> вида <code>i32</code>, в котором будет храниться число.</p>
<p>Затем мы выполняем сопряженную функцию <code>new</code>, создающую образцы значений вида <code>Guess</code>. Функция <code>new</code>  имеет один свойство <code>value</code> вида <code>i32</code>, и возвращает <code>Guess</code>. Код в теле функции <code>new</code> проверяет, что значение <code>value</code> находится между 1 и 100. Если <code>value</code> не проходит эту проверку, мы вызываем <code>panic!</code>, которая оповестит программиста, написавшего вызывающий код, что в его коде есть ошибка, которую необходимо исправить, поскольку попытка создания <code>Guess</code> со значением <code>value</code> вне заданного ряда нарушает договор, на который полагается <code>Guess::new</code>. Условия, в которых <code>Guess::new</code> паникует, должны быть описаны в документации к API; мы рассмотрим соглашения о документации, указывающие на возможность появления <code>panic!</code> в документации API, которую вы создадите в Главе 14. Если <code>value</code> проходит проверку, мы создаём новый образец <code>Guess</code>, у которого значение поля  <code>value</code> равно значению свойства <code>value</code>, и возвращаем <code>Guess</code>.</p>
<p>Затем мы выполняем способ с названием <code>value</code>, который заимствует <code>self</code>, не имеет других свойств, и возвращает значение вида <code>i32</code>. Этот способ иногда называют <em>извлекатель</em> (getter), потому что его цель состоит в том, чтобы извлечь данные из полей устройства и вернуть их. Этот открытый способ является необходимым, поскольку поле <code>value</code> устройства <code>Guess</code>  является закрытым. Важно, чтобы поле <code>value</code> было закрытым, чтобы код, использующий устройство <code>Guess</code>, не мог устанавливать <code>value</code> напрямую: код снаружи звена <em>должен</em> использовать функцию <code>Guess::new</code> для создания образца <code>Guess</code>, таким образом обеспечивая, что у <code>Guess</code> нет возможности получить <code>value</code>, не проверенное условиями в функции <code>Guess::new</code>.</p>
<p>Функция, которая принимает или возвращает только числа от 1 до 100, может объявить в своей ярлыке, что она принимает или возвращает <code>Guess</code>, вместо <code>i32</code>, таким образом не будет необходимости делать дополнительные проверки в теле такой функции.</p>
<h2 id="Итоги-6"><a class="header" href="#Итоги-6">Итоги</a></h2>
<p>Функции обработки ошибок в Ржавчина призваны помочь написанию более надёжного кода. Макрос <code>panic!</code> указывает , что ваша программа находится в состоянии, которое она не может обработать, и позволяет сказать этапу чтобы он прекратил своё выполнение, вместо попытки продолжить выполнение с неправильными или неверными значениями. Перечисление <code>Result</code> использует систему видов Rust, чтобы сообщить, что действия могут завершиться неудачей, и ваш код мог восстановиться. Можно использовать <code>Result</code>, чтобы сообщить вызывающему коду, что он должен обрабатывать вероятный успех или вероятную неудачу. Использование <code>panic!</code> и <code>Result</code> правильным образом сделает ваш код более надёжным перед лицом неизбежных неполадок.</p>
<p>Теперь, когда вы увидели полезные способы использования  обобщённых видов <code>Option</code> и <code>Result</code> в встроенной библиотеке, мы поговорим о том, как работают обобщённые виды и как вы можете использовать их в своём коде.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обобщённые-виды-особенности-и-время-жизни"><a class="header" href="#Обобщённые-виды-особенности-и-время-жизни">Обобщённые виды, особенности и время жизни</a></h1>
<p>Каждый язык программирования имеет в своём арсенале эффективные средства борьбы с повторением кода. В Ржавчина одним из таких средств являются обобщённые виды данных - <em>generics</em>. Это абстрактные подставные виды на место которых возможно поставить какой-либо определенный вид или другое свойство. Когда мы пишем код, мы можем выразить поведение обобщённых видов или их связь с другими обобщёнными видами, не зная какой вид будет использован на их месте при сборки и запуске кода.</p>
<p>Функции могут принимать свойства некоторого "обобщённого" вида вместо привычных "определенных" видов, вроде <code>i32</code> или <code>String</code>. Подобно, функция принимает свойства с неизвестными заранее значениями, чтобы выполнять одинаковые действия над несколькими определенными значениями. На самом деле мы уже использовали обобщённые виды данных в Главе 6 (<code>Option&lt;T&gt;</code>), в Главе 8 (<code>Vec&lt;T&gt;</code> и <code>HashMap&lt;K, V&gt;</code>) и в Главе 9 (<code>Result&lt;T, E&gt;</code>). В этой главе вы узнаете, как определить собственные виды данных, функции и способы, используя возможности обобщённых видов.</p>
<p>Прежде всего, мы рассмотрим как для уменьшения повторения извлечь из кода некоторую общую возможность. Далее, мы будем использовать тот же рычаг для создания обобщённой функции из двух функций, которые отличаются только видом их свойств. Мы также объясним, как использовать обобщённые виды данных при определении устройств и перечислений.</p>
<p>После этого мы изучим как использовать особенности (traits) для определения поведения в обобщённом виде. Можно соединенять особенности с обобщёнными видами, чтобы обобщённый вид мог принимать только такие виды, которые имеют определённое поведение, а не все подряд.</p>
<p>В конце мы обсудим <em>времена жизни (lifetimes)</em>, вариации обобщённых видов, которые дают сборщику сведения о том, как сроки жизни ссылок относятся друг к другу. Времена жизни позволяют нам указать дополнительную сведения об "одолженных" (borrowed) значениях, которая позволит сборщику удостовериться в соблюдения правил используемых ссылок в тех случаейх, когда сборщик не может сделать это самостоятельно .</p>
<h2 id="Удаление-повторения-кода-с-помощью-выделения-общей-возможности"><a class="header" href="#Удаление-повторения-кода-с-помощью-выделения-общей-возможности">Удаление повторения кода с помощью выделения общей возможности</a></h2>
<p>В обобщениях мы можем заменить определенный вид на "заполнитель" (placeholder), обозначающую несколько видов, что позволяет удалить повторяющийся код. Прежде чем углубляться в правила написания обобщённых видов, давайте сначала посмотрим, как удалить повторение, не задействуя гибкие виды, путём извлечения функции, которая заменяет определённые значения заполнителем, представляющим несколько значений. Затем мы применим ту же технику для извлечения гибкой функции! Изучив, как распознать повторяющийся код, который можно извлечь в функцию, вы начнёте распознавать повторяющийся код, который может использовать обобщённые виды.</p>
<p>Начнём с короткой программы в приложении 10-1, которая находит наибольшее число в списке.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
<p><span class="caption">Приложение 10-1: Поиск наибольшего числа в списке чисел</span></p>
<p>Сохраним список целых чисел в переменной <code>number_list</code> и поместим первое значение из списка в переменную <code>largest</code>. Далее, переберём все элементы списка, и, если текущий элемент больше числа сохранённого в переменной <code>largest</code>, заменим значение в этой переменной. Если текущий элемент меньше или равен "наибольшему", найденному ранее, значение переменной оставим прежним и перейдём к следующему элементу списка. После перебора всех элементов списка переменная <code>largest</code> должна содержать наибольшее значение, которое в нашем случае будет равно 100.</p>
<p>Теперь перед нами стоит задача найти наибольшее число в двух разных списках. Для этого мы можем повторять код из приложения 10-1 и использовать ту же логику в двух разных местах программы, как показано в приложении 10-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}</code></pre></pre>
<p><span class="caption">Приложение 10-2: Код для поиска наибольшего числа в <em>двух</em> списках чисел</span></p>
<p>Несмотря на то, что код программы работает, повторение кода утомительно и подвержено ошибкам. При внесении изменений мы должны не забыть обновить каждое место, где код повторяется.</p>
<p>Для устранения повторения мы можем создать дополнительную абстракцию с помощью функции которая сможет работать с любым списком целых чисел переданным ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает код более ясным и позволяет абстрактным образом выполнить алгоритм поиска наибольшего числа в списке.</p>
<p>В приложении 10-3 мы извлекаем код, который находит наибольшее число, в функцию с именем  <code>largest</code>. Затем мы вызываем функцию, чтобы найти наибольшее число в двух списках из приложения 10-2. Мы также можем использовать эту функцию для любого другого списка значений <code>i32</code> , который может встретиться позже.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
<p><span class="caption">Приложение 10-3: Абстрактный код для поиска наибольшего числа в двух списках</span></p>
<p>Функция <code>largest</code> имеет свойство с именем <code>list</code>, который представляет любой срез значений вида <code>i32</code>, которые мы можем передать в неё. В итоге вызова функции, код выполнится с определенными, переданными в неё значениями.</p>
<p>Итак, вот шаги выполненные для изменения кода из приложения 10-2 в приложение 10-3:</p>
<ol>
<li>Определить повторяющийся код.</li>
<li>Извлечь повторяющийся код и поместить его в тело функции, определив входные и выходные значения этого кода в ярлыке функции.</li>
<li>Обновить и заменить два участка повторяющегося кода вызовом одной функции.</li>
</ol>
<p>Далее, чтобы уменьшить повторение кода, мы воспользуемся теми же шагами для обобщённых видов. Обобщённые виды позволяют работать над абстрактными видами таким же образом, как тело функции может работать над абстрактным списком <code>list</code> вместо определенных значений.</p>
<p>Например, у нас есть две функции: одна ищет наибольший элемент внутри среза значений вида <code>i32</code>, а другая внутри среза значений вида <code>char</code>. Как уменьшить такое повторение? Давайте выяснять!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обобщённые-виды-данных"><a class="header" href="#Обобщённые-виды-данных">Обобщённые виды данных</a></h2>
<p>Мы используем обобщённые виды данных для объявления функций или устройств, которые затем можно использовать с различными определенными видами данных. Давайте сначала посмотрим, как объявлять функции, устройства, перечисления и способы, используя обобщённые виды данных. Затем мы обсудим, как обобщённые виды данных влияют на производительность кода.</p>
<h3 id="В-объявлении-функций"><a class="header" href="#В-объявлении-функций">В объявлении функций</a></h3>
<p>Когда мы объявляем функцию с обобщёнными видами, мы размещаем обобщённые виды в ярлыке функции, где мы обычно указываем виды данных переменных и возвращаемого значения. Используя обобщённые виды, мы делаем код более гибким и предоставляем большую возможность при вызове нашей функции, предотвращая повторение кода.</p>
<p>Рассмотрим пример с функцией <code>largest</code>. Приложение 10-4 показывает две функции, каждая из которых находит самое большое значение в срезе своего вида. Позже мы объединим их в одну функцию, использующую обобщённые виды данных.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("The largest char is {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<p><span class="caption">Приложение 10-4: две функции, отличающиеся только именем и видом обрабатываемых данных</span></p>
<p>Функция <code>largest_i32</code> уже встречалась нам: мы извлекли её в приложении 10-3, когда боролись с повторением кода — она находит наибольшее значение вида <code>i32</code> в срезе. Функция <code>largest_char</code> находит самое большое значение вида <code>char</code> в срезе. Тело у этих функций одинаковое, поэтому давайте избавимся от повторяемлшл кода, используя свойство обобщённого вида в одной функции.</p>
<p>Для свойствоизации видов данных в новой объявляемой функции нам нужно дать имя обобщённому виду — так же, как мы это делаем для переменных функций. Можно использовать любой определитель для имени свойства вида, но мы будем использовать <code>T</code>, потому что по соглашению имена свойств в Ржавчина должны быть короткими (обычно длиной в один символ), а именование видов в Ржавчина делается в наставлении UpperCamelCase. Сокращение слова «type» до одной буквы <code>T</code> является обычным выбором большинства программистов, использующих язык Rust.</p>
<p>Когда мы используем свойство в теле функции, мы должны объявить имя свойства в ярлыке, чтобы сборщик знал, что означает это имя. Подобно когда мы используем имя вида свойства в ярлыке функции, мы должны объявить это имя раньше, чем мы его используем. Чтобы определить обобщённую функцию <code>largest</code>, поместим объявление имён свойств в треугольные скобки <code>&lt;&gt;</code> между именем функции и списком свойств, как здесь:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Объявление читается так: функция <code>largest</code> является обобщённой по виду <code>T</code>. Эта функция имеет один свойство с именем <code>list</code>, который является срезом значений с видом данных <code>T</code>. Функция <code>largest</code> возвращает значение этого же вида <code>T</code>.</p>
<p>Приложение 10-5 показывает определение функции <code>largest</code> с использованием обобщённых видов данных в её ярлыке. Приложение также показывает, как мы можем вызвать функцию со срезом данных вида <code>i32</code> или <code>char</code>. Данный код пока не будет собираться, но мы исправим это к концу раздела.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {result}");
}</code></pre>
<p><span class="caption">Приложение 10-5: функция <code>largest</code>, использующая свойства обобщённого типа; пока ещё не собирается</span></p>
<p>Если мы соберем программу сейчас, мы получим следующую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>В подсказке упоминается <code>std::cmp::PartialOrd</code>, который является <em>особенностью</em>. Мы поговорим про особенности в следующем разделе. Сейчас ошибка в функции <code>largest</code> указывает, что функция не будет работать для всех возможных видов <code>T</code>. Так как мы хотим сравнивать значения вида <code>T</code> в теле функции, мы можем использовать только те виды, данные которых можно упорядочить: можем упорядочить — значит, можем и сравнить. Чтобы можно было задействовать сравнения, обычная библиотека имеет особенность <code>std::cmp::PartialOrd</code>, который вы можете выполнить для видов (смотрите дополнение С для большей сведений про данный особенность). Следуя совету в сообщении сборщика, ограничим вид <code>T</code> теми исходами, которые поддерживают особенность <code>PartialOrd</code>, и тогда пример успешно  собирается, так как обычная библиотека выполняет <code>PartialOrd</code> как для вида <code>i32</code>, так и для вида <code>char</code>.</p>
<h3 id="В-определении-устройств"><a class="header" href="#В-определении-устройств">В определении устройств</a></h3>
<p>Мы также можем определить устройства, использующие обобщённые виды в одном или нескольких своих полях, с помощью правил написания <code>&lt;&gt;</code>. Приложение 10-6 показывает, как определить устройство <code>Point&lt;T&gt;</code>, чтобы хранить поля координат <code>x</code> и <code>y</code> любого вида данных.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Приложение 10-6: устройства <code>Point</code>, содержащая поля <code>x</code> и <code>y</code> вида <code>T</code></span></p>
<p>правила написания использования обобщённых видов в определении устройства очень похож на правила написания в определении функции. Сначала мы объявляем имена видов свойств внутри треугольных скобок сразу после названия устройства. Затем мы можем использовать обобщённые виды в определении устройства в тех местах, где ранее мы указывали бы определенные виды.</p>
<p>Так как мы используем только один обобщённый вид данных для определения устройства <code>Point&lt;T&gt;</code>, это определение означает, что устройства <code>Point&lt;T&gt;</code> является обобщённой с видом <code>T</code>, и <em>оба</em> поля <code>x</code> и <code>y</code> имеют одинаковый вид, каким бы он не являлся. Если мы создадим образец устройства <code>Point&lt;T&gt;</code> со значениями разных видов, как показано в приложении 10-7, наш код не собирается.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
<p><span class="caption">Приложение 10-7: поля <code>x</code> и <code>y</code> должны быть одного вида, так как они имеют один и тот же обобщённый вид <code>T</code></span></p>
<p>В этом примере, когда мы присваиваем целочисленное значение 5 переменной <code>x</code> , мы сообщаем сборщику, что обобщённый вид <code>T</code> будет целым числом для этого образца <code>Point&lt;T&gt;</code>. Затем, когда мы указываем значение 4.0 (имеющее вид, отличный от целого числа) для <code>y</code>, который по нашему определению должен иметь тот же вид, что и <code>x</code>, мы получим ошибку несоответствия видов:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Чтобы определить устройство <code>Point</code>, где оба значения <code>x</code> и <code>y</code> являются обобщёнными, но различными видами, можно использовать несколько свойств обобщённого вида. Например, в приложении 10-8 мы изменим определение <code>Point</code> таким образом, чтобы оно использовало обобщённые виды <code>T</code> и <code>U</code>, где <code>x</code> имеет вид <code>T</code> а <code>y</code> имеет вид <code>U</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Приложение 10-8: устройства <code>Point&lt;T, U&gt;</code> обобщена для двух видов, так что <code>x</code> и <code>y</code> могут быть значениями разных видов</span></p>
<p>Теперь разрешены все показанные образцы вида <code>Point</code>! В объявлении можно использовать сколь угодно много свойств обобщённого вида, но если делать это в большом количестве, код будет тяжело читать. Если в вашем коде требуется много обобщённых видов, возможно, стоит разбить его на более мелкие части.</p>
<h3 id="В-определениях-перечислений"><a class="header" href="#В-определениях-перечислений">В определениях перечислений</a></h3>
<p>Как и устройства, перечисления также могут хранить обобщённые виды в своих исхода.. Давайте ещё раз посмотрим на перечисление <code>Option&lt;T&gt;</code>, предоставленное встроенной библиотекой, которое мы использовали в главе 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Это определение теперь должно быть вам более понятно. Как видите,  перечисление <code>Option&lt;T&gt;</code> является обобщённым по виду <code>T</code> и имеет два исхода: исход <code>Some</code>, который содержит одно значение вида <code>T</code>, и исход <code>None</code>, который не содержит никакого значения. Используя перечисление <code>Option&lt;T&gt;</code>, можно выразить абстрактную подход необязательного значения — и так как <code>Option&lt;T&gt;</code> является обобщённым, можно использовать эту абстракцию независимо от того, каким будет вид необязательного значения.</p>
<p>Перечисления также могут использовать несколько обобщённых видов. Определение перечисления <code>Result</code>, которое мы упоминали в главе 9, является примером такого использования:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Перечисление <code>Result</code> имеет два обобщённых вида: <code>T</code> и <code>E</code> — и два исхода:  <code>Ok</code>, который содержит вид <code>T</code>, и <code>Err</code>, содержащий вид <code>E</code>. С таким определением удобно использовать перечисление <code>Result</code> везде, где действия могут быть выполнены успешно (возвращая значение вида <code>T</code>) или неуспешно (возвращая ошибку вида <code>E</code>). Это то, что мы делали при открытии файла в приложении 9-3, где <code>T</code> заполнялось видом <code>std::fs::File</code>, если файл был открыт успешно, либо <code>E</code> заполнялось видом  <code>std::io::Error</code>, если при открытии файла возникали какие-либо сбоев.</p>
<p>Если вы встречаете в коде случаи, когда несколько определений устройств или перечислений отличаются только видами содержащихся в них значений, вы можете устранить повторение, используя обобщённые виды.</p>
<h3 id="В-определении-способов"><a class="header" href="#В-определении-способов">В определении способов</a></h3>
<p>Мы можем выполнить способы для устройств и перечислений (как мы делали в главе 5) и в определениях этих способов также использовать обобщённые виды. В приложении 10-9 показана устройства <code>Point&lt;T&gt;</code>, которую мы определили в приложении 10-6, с добавленным для неё способом <code>x</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
<p><span class="caption">Приложение 10-9: Выполнение способа с именем <code>x</code> у устройства <code>Point&lt;T&gt;</code>, которая будет возвращать ссылку на поле <code>x</code> вида <code>T</code></span></p>
<p>Здесь мы определили способ с именем <code>x</code> у устройства <code>Point&lt;T&gt;</code>, который возвращает ссылку на данные в поле <code>x</code>.</p>
<p>Обратите внимание, что мы должны объявить <code>T</code> сразу после <code>impl</code> .  В этом случае мы можем использовать <code>T</code> для указания на то, что выполняем способ для вида <code>Point&lt;T&gt;</code>. Объявив <code>T</code> гибким видом сразу после <code>impl</code> , Ржавчина может определить, что вид в угловых скобках в <code>Point</code> является гибким, а не определенным видом. Мы могли бы выбрать другое имя для этого обобщённого свойства, отличное от имени, использованного в определении устройства, но обычно используют одно и то же имя. Способы, написанные внутри раздела <code>impl</code> , который использует обобщённый вид, будут определены для любого образца вида, независимо от того, какой определенный вид в конечном итоге будет подставлен вместо этого обобщённого.</p>
<p>Мы можем также указать ограничения, какие обобщённые виды разрешено использовать при определении способов. Например, мы могли бы выполнить способы только для образцов вида <code>Point&lt;f32&gt;</code>, а не для образцов <code>Point&lt;T&gt;</code>, в которых используется произвольный обобщённый вид. В приложении 10-10 мы используем определенный вид <code>f32</code>, что означает, что мы не определяем никакие виды после <code>impl</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-10: раздел<code>impl</code>, который применяется только к устройстве, имеющей определенный вид для свойства обобщённого вида <code>T</code></span></p>
<p>Этот код означает, что вид <code>Point&lt;f32&gt;</code> будет иметь способ с именем <code>distance_from_origin</code>, а другие образцы <code>Point&lt;T&gt;</code>, где <code>T</code> имеет вид, отличный от <code>f32</code>, не будут иметь этого способа. Способ вычисляет, насколько далеко наша точка находится от точки с координатами (0.0, 0.0), и использует математические действия, доступные только для видов с плавающей точкой.</p>
<p>Свойства обобщённого вида, которые мы используем в определении устройства, не всегда совпадают с подобиями, использующимися в ярлыках способов этой устройства. Чтобы пример был более очевидным, в приложении 10-11 используются обобщённые виды <code>X1</code> и <code>Y1</code> для определения устройства <code>Point</code> и виды <code>X2</code> <code>Y2</code> для ярлыки способа <code>mixup</code>. Способ создаёт новый образец устройства <code>Point</code>, где значение <code>x</code> берётся из <code>self</code> <code>Point</code> (имеющей вид <code>X1</code>), а значение <code>y</code> - из переданной устройства <code>Point</code> (где эта переменная имеет вид <code>Y2</code>).</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
<p><span class="caption">Приложение 10-11: способ, использующий обобщённые виды, отличающиеся от видов, используемых в определении устройства</span></p>
<p>В функции <code>main</code> мы определили вид <code>Point</code>, который имеет вид <code>i32</code> для <code>x</code> (со значением <code>5</code> ) и вид <code>f64</code> для <code>y</code> (со значением <code>10.4</code>). Переменная <code>p2</code> является устройством <code>Point</code>, которая имеет строковый срез для <code>x</code> (со значением <code>«Hello»</code>) и <code>char</code> для <code>y</code> (со значением <code>c</code>). Вызов <code>mixup</code> на <code>p1</code> с переменнаяом <code>p2</code> создаст для нас образец устройства <code>p3</code>, который будет иметь вид <code>i32</code> для <code>x</code> (потому что <code>x</code> взят из <code>p1</code>). Переменная <code>p3</code> будет иметь вид <code>char</code>  для  <code>y</code> (потому что <code>y</code> взят из <code>p2</code>). Вызов макроса <code>println! </code> выведет <code>p3.x = 5, p3.y = c</code>.</p>
<p>Цель этого примера — отобразить случай, в которой некоторые обобщённые свойства объявлены с помощью <code>impl</code>, а некоторые объявлены в определении способа. Здесь обобщённые свойства <code>X1</code> и <code>Y1</code> объявляются после <code>impl</code>, потому что они относятся к определению устройства. Обобщённые свойства <code>X2</code> и <code>Y2</code> объявляются после <code>fn mixup</code>, так как они относятся только к способу.</p>
<h3 id="Производительность-кода-использующего-обобщённые-виды"><a class="header" href="#Производительность-кода-использующего-обобщённые-виды">Производительность кода, использующего обобщённые виды</a></h3>
<p>Вы могли бы задаться вопросом, возникают ли какие-нибудь дополнительные издержки при использовании свойств обобщённого вида. Хорошая новость в том, что при использовании обобщённых видов ваша программа работает ничуть ни медленнее, чем если бы она работала с использованием определенных видов.</p>
<p>В Ржавчина это достигается во время сборки при помощи мономорфизации кода, использующего обобщённые виды. <em>Мономорфизация</em> — это этап превращения обобщённого кода в определенный код путём подстановки определенных видов, использующихся при сборки. В этом этапе сборщик выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой функции в приложении 10-5: он просматривает все места, где вызывается обобщённый код, и порождает код для определенных видов, использовавшихся для вызова в обобщённом.</p>
<p>Давайте посмотрим, как это работает при использовании перечисления <code>Option&lt;T&gt;</code> из встроенной библиотеки:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Когда Ржавчина собирает этот код, он выполняет мономорфизацию. Во время этого этапа сборщик считывает значения, которые были использованы в образцах <code>Option&lt;T&gt;</code>, и определяет два вида <code>Option&lt;T&gt;</code>: один для вида <code>i32</code>, а другой — для <code>f64</code>. Таким образом, он разворачивает обобщённое определение <code>Option&lt;T&gt;</code> в два определения, именно для <code>i32</code> и <code>f64</code>, тем самым заменяя обобщённое определение определенными.</p>
<p>Мономорфизированная исполнение кода выглядит примерно так (сборщик использует имена, отличные от тех, которые мы используем здесь для отображения):</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>Обобщённое <code>Option&lt;T&gt;</code> заменяется определенными определениями, созданными сборщиком. Поскольку Ржавчина собирает обобщённый код в код, определяющий вид в каждом образце, мы не платим за использование обобщённых видов во время выполнения. Когда код запускается, он работает точно так же, как если бы мы сделали повторение каждое определение вручную. Этап мономорфизации делает обобщённые виды Ржавчина чрезвычайно эффективными во время выполнения.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Особенности-определение-общего-поведения"><a class="header" href="#Особенности-определение-общего-поведения">Особенности: определение общего поведения</a></h2>
<p><em>Особенность</em> сообщает сборщику Ржавчина о возможности, которой обладает определённый вид и которой он может поделиться с другими видами. Можно использовать особенности, чтобы определять общее поведение абстрактным способом. Мы можем использовать <em>ограничение особенности</em> (trait bounds) чтобы указать, что общим видом может быть любой вид, который имеет определённое поведение.</p>
<blockquote>
<p>Примечание: Особенности похожи на возможность часто называемую <em>внешней оболочкими</em> в других языках программирования, хотя и с некоторыми отличиями.</p>
</blockquote>
<h3 id="Определение-особенности"><a class="header" href="#Определение-особенности">Определение особенности</a></h3>
<p>Поведение вида определяется теми способами, которые мы можем вызвать у данного вида. Различные виды разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов. Определение особенностей - это способ собъединять ярлыки способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.</p>
<p>Например, пусть есть несколько устройств, которые имеют различный вид и различный размер текста: устройства <code>NewsArticle</code>, которая содержит новость, напечатанную в каком-то месте мира; устройства <code>Tweet</code>, которая содержит 280 символьную строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.</p>
<p>Мы хотим создать ящик библиотеки медиа-агрегатора <code>aggregator</code>, которая может отображать сводку данных сохранённых в образцах устройств <code>NewsArticle</code> или <code>Tweet</code>. Чтобы этого достичь, нам необходимо иметь возможность для каждой устройства получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ <code>summarize</code>. Приложение 10-12 показывает определение особенности <code>Summary</code>, который выражает это поведение.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
<p><span class="caption">Приложение 10-12: Определение особенности <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span></p>
<p>Здесь мы объявляем особенность с использованием ключевого слова <code>trait</code>, а затем его название, которым в нашем случае является <code>Summary</code>. Также мы объявляем ящик как <code>pub</code> что позволяет ящикам, зависящим от нашего ящика, тоже использовать наш ящик, что мы увидим в последующих примерах. Внутри фигурных скобок объявляются ярлыки способов, которые описывают поведения видов, выполняющих данный особенность, в данном случае поведение определяется только одной ярлыком способа <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>После ярлыки способа, вместо предоставления выполнения в фигурных в скобках, мы используем точку с запятой. Каждый вид, выполняющий данный особенность, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид содержащий особенность <code>Summary</code>, будет также иметь и способ <code>summarize</code> объявленный с точно такой же ярлыком.</p>
<p>Особенность может иметь несколько способов в описании его тела: ярлыки способов перечисляются по одной на каждой строке и должны закачиваться символом <code>;</code>.</p>
<h3 id="Выполнение-особенности-у-вида"><a class="header" href="#Выполнение-особенности-у-вида">Выполнение особенности у вида</a></h3>
<p>Теперь, после того как мы определили желаемое поведение используя особенность <code>Summary</code>, можно выполнить его у видов в нашем медиа-агрегаторе. Приложение 10-13 показывает выполнение особенности <code>Summary</code> у устройства <code>NewsArticle</code>, которая использует для создания сводки в способе <code>summarize</code> заголовок, автора и место обнародования статьи. Для устройства <code>Tweet</code> мы определяем выполнение <code>summarize</code> используя имя пользователя и следующий за ним полный текст твита, полагая что содержание твита уже ограничено 280 символами.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
<p><span class="caption">Приложение 10-13: Выполнение особенности <code>Summary</code> для устройств <code>NewsArticle</code> и <code>Tweet</code></span></p>
<p>Выполнение особенности у вида подобна выполнения обычных способов. Разница в том что после <code>impl</code> мы ставим имя особенности, который мы хотим выполнить, затем используем ключевое слово <code>for</code>, а затем указываем имя вида, для которого мы хотим сделать выполнение особенности. Внутри раздела <code>impl</code> мы помещаем ярлык способа объявленную в особенности. Вместо добавления точки с запятой в конце, после каждой ярлыки используются фигурные скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов особенности для определенного вида.</p>
<p>Теперь когда библиотека выполнила особенность <code>Summary</code> для <code>NewsArticle</code> и <code>Tweet</code>, программисты использующие ящик могут вызывать способы особенности у образцов видов <code>NewsArticle</code> и <code>Tweet</code> точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести особенность в область видимости точно так же как и виды. Здесь пример того как двоичный ящик может использовать наш <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}</code></pre>
<p>Данный код напечатает: <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Другие ящики, которые зависят от <code>aggregator</code>, тоже могу включить особенность <code>Summary</code> в область видимости для выполнения <code>Summary</code> в их собственных видах. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем выполнить особенность для вида только в том случае, если хотя бы один из особенностей вида является местным для нашего ящика. Например, мы можем выполнить обычный библиотечный особенность <code>Display</code> на собственном виде <code>Tweet</code> как часть возможности нашего ящика <code>aggregator</code> потому что вид <code>Tweet</code> является местным для ящика <code>aggregator</code>. Также мы можем выполнить <code>Summary</code> для <code>Vec&lt;T&gt;</code> в нашем ящике <code>aggregator</code>, потому что особенность <code>Summary</code> является местным для нашего ящика <code>aggregator</code>.</p>
<p>Но мы не можем выполнить внешние особенности для внешних видов. Например, мы не можем выполнить особенность <code>Display</code> для <code>Vec&lt;T&gt;</code> внутри нашего ящика <code>aggregator</code>, потому что <code>Display</code> и <code>Vec&lt;T&gt;</code> оба определены в встроенной библиотеке а не местно в нашем ящике <code>aggregator</code>. Это ограничение является частью свойства называемого <em>согласованность</em> (coherence), а ещё точнее <em>сиротское правило</em> (orphan rule), которое называется так потому что не представлен родительский вид. Это правило заверяет, что код других людей не может сломать ваш код и наоборот. Без этого правила два ящика могли бы выполнить один особенность для одинакового вида и Ржавчина не сможет понять, какой выполнением нужно пользоваться.</p>
<h3 id="Выполнение-поведения-по-умолчанию"><a class="header" href="#Выполнение-поведения-по-умолчанию">Выполнение поведения по умолчанию</a></h3>
<p>Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в особенности вместо того, чтобы требовать выполнения всех способов в каждом виде, выполняющим данный особенность. Затем, когда мы выполняем особенность для определённого вида, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов.</p>
<p>В примере 10-14 показано, как указать строку по умолчанию для способа <code>summarize</code> из особенности <code>Summary</code> вместо определения только ярлыки способа, как мы сделали в примере 10-12.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 10-14: Определение особенности <code>Summary</code> с выполнением способа <code>summarize</code> по умолчанию</span></p>
<p>Для использования выполнения по умолчанию при создании сводки у образцов <code>NewsArticle</code> вместо определения пользовательской выполнения, мы указываем пустой раздел<code>impl</code> с <code>impl Summary for NewsArticle {}</code>.</p>
<p>Хотя мы больше не определяем способ <code>summarize</code> непосредственно в <code>NewsArticle</code>, мы предоставили выполнение по умолчанию и указали, что <code>NewsArticle</code> выполняет особенность <code>Summary</code>. В итоге мы всё ещё можем вызвать способ <code>summarize</code> у образца <code>NewsArticle</code>, например так:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>Этот код печатает <code>New article available! (Read more...)</code> .</p>
<p>Создание выполнения по умолчанию не требует от нас изменений чего-либо в выполнения <code>Summary</code> для <code>Tweet</code> в приложении 10-13. Причина заключается в том, что правила написания для переопределения выполнения по умолчанию является таким же, как правила написания для выполнения способа особенности, который не имеет выполнения по умолчанию.</p>
<p>Выполнения по умолчанию могут вызывать другие способы в том же особенности, даже если эти другие способы не имеют выполнения по умолчанию. Таким образом, особенность может предоставить много полезной возможности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить особенность <code>Summary</code> имеющий способ <code>summarize_author</code>, выполнение которого требуется, а затем определить способ <code>summarize</code> который имеет выполнение по умолчанию, которая внутри вызывает способ <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Чтобы использовать такую исполнение особенности <code>Summary</code>, нужно только определить способ <code>summarize_author</code>, при выполнения особенности для вида:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(Read more from {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>После того, как мы определим <code>summarize_author</code>, можно вызвать <code>summarize</code> для образцов устройства <code>Tweet</code> и выполнение по умолчанию способа <code>summarize</code> будет вызывать определение <code>summarize_author</code> которое мы уже предоставили. Так как мы выполнили способ <code>summarize_author</code> особенности <code>Summary</code>, то особенность даёт нам поведение способа <code>summarize</code> без необходимости писать код.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
<span class="boring">}</span></code></pre>
<p>Этот код печатает <code>1 new tweet: (Read more from @horse_ebooks...)</code> .</p>
<p>Обратите внимание, что невозможно вызвать выполнение по умолчанию из переопределённой выполнения того же способа.</p>
<h3 id="Особенности-как-свойства"><a class="header" href="#Особенности-как-свойства">Особенности как свойства</a></h3>
<p>Теперь, когда вы знаете, как определять и выполнить особенности, можно изучить, как использовать особенности, чтобы определить функции, которые принимают много различных видов. Мы будем использовать особенность <code>Summary</code>,  выполненный для видов <code>NewsArticle</code> и <code>Tweet</code> в приложении 10-13, чтобы определить функцию <code>notify</code>, которая вызывает способ <code>summarize</code> для его свойства <code>item</code>, который имеет некоторый вид, выполняющий особенность <code>Summary</code>. Для этого мы используем правила написания <code>impl Trait</code> примерно так:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>Вместо определенного вида у свойства <code>item</code> указывается ключевое слово <code>impl</code> и имя особенности. Этот свойство принимает любой вид, который выполняет указанный особенность. В теле <code>notify</code> мы можем вызывать любые способы у образца <code>item</code> , которые приходят с особенностью <code>Summary</code>, такие как способ <code>summarize</code>. Мы можем вызвать <code>notify</code> и передать в него любой образец <code>NewsArticle</code> или <code>Tweet</code>. Код, который вызывает данную функцию с любым другим видом, таким как <code>String</code> или <code>i32</code>, не будет собираться, потому что эти виды не выполняют особенность <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="правила-написания-ограничения-особенности"><a class="header" href="#правила-написания-ограничения-особенности">правила написания ограничения особенности</a></h4>
<p>правила написания <code>impl Trait</code> работает для простых случаев, но на самом деле является синтаксическим сахаром для более длинной видовы, которая называется <em>ограничением особенности</em> (trait bound); это выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>Эта более длинная разновидность эквивалентна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида с ограничением особенности после двоеточия внутри угловых скобок.</p>
<p>правила написания <code>impl Trait</code> удобен и делает код более сжатым в простых случаях, в то время как более полный правила написания с ограничением особенности в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые выполняют особенность  <code>Summary</code>. Использование правил написания  <code>impl Trait</code> выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Использовать <code>impl Trait</code> удобнее если мы хотим разрешить функции иметь разные виды для <code>item1</code> и <code>item2</code> (но оба вида должны выполнить <code>Summary</code>). Если же мы хотим заставить оба свойства иметь один и тот же вид, то мы должны использовать ограничение особенности так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Обобщённый вид <code>T</code> указан для видов свойств <code>item1</code> и <code>item2</code> и ограничивает функцию так, что определенные значения видов переданные переменнойми для <code>item1</code> и <code>item2</code> должны быть одинаковыми.</p>
<h4 id="Задание-нескольких-границ-особенностей-с-помощью-правил-написания-"><a class="header" href="#Задание-нескольких-границ-особенностей-с-помощью-правил-написания-">Задание нескольких границ особенностей с помощью правил написания <code>+</code></a></h4>
<p>Также можно указать более одного ограничения особенности. Допустим, мы хотели бы чтобы <code>notify</code> использовал как изменение
вывода так и  <code>summarize</code> для свойства <code>item</code>: <br>тогда мы указываем что в <code>notify</code> свойство <code>item</code> должен выполнить оба особенности <code>Display</code> и <code>Summary</code>. Мы можем сделать это используя правила написания <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>правила написания <code>+</code> также допустим с ограничениями особенности для обобщённых видов:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>При наличии двух ограничений особенности, тело способа <code>notify</code> может вызывать <code>summarize</code> и использовать <code>{}</code> для изменения <code>item</code> при его печати.</p>
<h4 id="Более-ясные-границы-особенности-с-помощью-where"><a class="header" href="#Более-ясные-границы-особенности-с-помощью-where">Более ясные границы особенности с помощью <code>where</code></a></h4>
<p>Использование слишком большого количества ограничений особенности имеет свои недостатки. Каждый обобщённый вид имеет свои границы особенности, поэтому функции с несколькими свойствами обобщённого вида могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение ярлыки. По этой причине в Ржавчина есть иной правила написания для определения ограничений особенности внутри предложения <code>where</code> после ярлыки функции. Поэтому вместо того, чтобы писать так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>можно использовать <code>where</code> таким образом:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>Ярлык этой функции менее загромождена: название функции, список свойств, и возвращаемый вид находятся рядом, а ярлык не содержит в себе множество ограничений особенности.</p>
<h3 id="Возврат-значений-вида-выполняющего-определённый-особенность"><a class="header" href="#Возврат-значений-вида-выполняющего-определённый-особенность">Возврат значений вида выполняющего определённый особенность</a></h3>
<p>Также можно использовать правила написания <code>impl Trait</code> в возвращаемой позиции, чтобы вернуть значение некоторого вида выполняющего особенность, как показано здесь:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>Используя <code>impl Summary</code> для возвращаемого вида, мы указываем, что функция <code>returns_summarizable</code> возвращает некоторый вид, который выполняет особенность <code>Summary</code> без обозначения определенного вида. В этом случае <code>returns_summarizable</code> возвращает <code>Tweet</code>, но код, вызывающий эту функцию, этого не знает.</p>
<p>Возможность возвращать вид, который определяется только выполняемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды, которые знает только сборщик или виды, которые очень долго указывать. правила написания <code>impl Trait</code> позволяет кратко указать, что функция возвращает некоторый вид, который выполняет особенность <code>Iterator</code> без необходимости писать очень длинный вид.</p>
<p>Однако, <code>impl Trait</code> возможно использовать, если возвращаете только один вид. Например, данный код, который возвращает значения или вида <code>NewsArticle</code> или вида <code>Tweet</code>, но в качестве возвращаемого вида объявляет <code>impl Summary</code> , не будет работать:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p>Возврат либо <code>NewsArticle</code> либо <code>Tweet</code> не допускается из-за ограничений того, как выполнен правила написания <code>impl Trait</code> в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование предметов особенностей, которые разрешены для значений или разных видов"</a><!--  --> Главы 17.</p>
<h3 id="Использование-ограничений-особенности-для-условной-выполнения-способов"><a class="header" href="#Использование-ограничений-особенности-для-условной-выполнения-способов">Использование ограничений особенности для условной выполнения способов</a></h3>
<p>Используя ограничение особенности с разделом <code>impl</code>, который использует свойства обобщённого вида, можно выполнить способы условно, для тех видов, которые выполняют указанный особенность. Например, вид <code>Pair&lt;T&gt;</code>  в приложении 10-15 всегда выполняет функцию  <code>new</code> для возврата нового образца <code>Pair&lt;T&gt;</code> (вспомните раздел <a href="ch05-03-method-syntax.html#defining-methods">“Определение способов”</a><!-- ignore --> Главы 5 где <code>Self</code> является псевдонимом вида для вида раздела <code>impl</code>, который в данном случае является <code>Pair&lt;T&gt;</code>). Но в следующем разделе <code>impl</code> вид <code>Pair&lt;T&gt;</code> выполняет способ  <code>cmp_display</code> только если его внутренний вид <code>T</code> выполняет особенность <code>PartialOrd</code> (позволяющий сравнивать) <em>и</em> особенность <code>Display</code> (позволяющий выводить на печать).</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}</code></pre>
<p><span class="caption">Приложение 10-15: Условная выполнение способов у обобщённых видов в зависимости от ограничений особенности</span></p>
<p>Мы также можем условно выполнить особенность для любого вида, который выполняет другой особенность. Выполнения особенности для любого вида, который удовлетворяет ограничениям особенности, называются <em>общими выполнениеми</em> и широко используются в встроенной библиотеке Rust. Например, обычная библиотека выполняет особенность <code>ToString</code> для любого вида, который выполняет особенность <code>Display</code>. Раздел<code>impl</code> в встроенной библиотеке выглядит примерно так:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Поскольку обычная библиотека имеет эту общую выполнение, то можно вызвать способ <code>to_string</code> определённый особенностью <code>ToString</code> для любого вида, который выполняет особенность <code>Display</code>. Например, мы можем превратить целые числа в их соответствующие <code>String</code> значения, потому что целые числа выполняют особенность <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Общие выполнения приведены в документации к особенности в разделе "Implementors".</p>
<p>Особенности и ограничения особенностей позволяют писать код, который использует свойства обобщённого вида для уменьшения повторения кода, а также указывая сборщику, что мы хотим обобщённый вид, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения особенности, чтобы проверить, что все определенные виды, используемые с нашим кодом, обеспечивают правильное поведение.  В изменяемых строго определенных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида, который не выполняет вид определяемый способом. Но Ржавчина перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить сбоев, прежде чем наш код начнёт работать. Кроме того, мы не должны писать код, который проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Валидация-ссылок-при-помощи-времён-жизни"><a class="header" href="#Валидация-ссылок-при-помощи-времён-жизни">Валидация ссылок при помощи времён жизни<a name="validating-references-with-lifetimes"></a></a></h2>
<p>Сроки (времена) жизни - ещё один вид обобщений, с которыми мы уже встречались. Если раньше мы использовали обобщения, чтобы убедиться, что вид обладает нужным нам поведением, теперь мы будем использовать сроки жизни для того, чтобы быть уверенными, что ссылки действительны как самое меньшее столько времени в этапе исполнения программы, сколько нам требуется.</p>
<p>В разделе <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">"Ссылки и заимствование"</a> главы 4, мы кое о чём умолчали: у каждой ссылки в Ржавчина есть своё <em>время жизни</em> — область кода, на протяжении которого данная ссылка действительна (valid). В большинстве случаев сроки жизни выводятся неявно — так же, как у видов (нам требуется явно объявлять виды лишь в тех случаях, когда при самостоятельном выведении вида возможны исходы). Точно так же мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены сборщиком по-разному. Ржавчина требует от нас объявлять взаимосвязи посредством обобщённых свойств сроков жизни, чтобы убедиться в том, что во время исполнения все действующие ссылки будут правильными.</p>
<p>Определение времени жизни — это подход, отсутствующая в большинстве других языков программирования, так что она может показаться незнакомой. Хотя в этой главе мы не будем рассматривать времена жизни во всех подробностях, тем не менее, мы обсудим основные случаи, в которых вы можете столкнуться с правилами написания времени жизни, что позволит вам получше ознакомиться с этой подходом.</p>
<h3 id="Времена-жизни-предотвращают-появление-повисших-ссылок"><a class="header" href="#Времена-жизни-предотвращают-появление-повисших-ссылок">Времена жизни предотвращают появление "повисших" ссылок</a></h3>
<p>Основное предназначение сроков жизни — предотвращать появление так называемых <em>"повисших ссылок"</em> (<em>dangling references</em>), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться. Рассмотрим программу из приложения 10-16, имеющую внешнюю и внутреннюю области видимости.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
<p><span class="caption">Приложение 10-16: Попытка использования ссылки, значение которой вышло из области видимости</span></p>
<blockquote>
<p>Примечание: примеры в приложениях 10-16, 10-17 и 10-23 объявляют переменные без указания их начального значения, поэтому имя переменной существует во внешней области видимости. На первый взгляд может показаться, что это противоречит отсутствию в Ржавчина нулевых (null) значений. Однако, если мы попытаемся использовать переменную, прежде чем присвоить ей значение, мы получим ошибку сборки, которая показывает, что Ржавчина действительно не разрешает нулевые (null) значения.</p>
</blockquote>
<p>Внешняя область видимости объявляет переменную с именем <code>r</code> без начального значения, а внутренняя область объявляет переменную с именем <code>x</code> с начальным значением <code>5</code>. Во внутренней области мы пытаемся установить значение <code>r</code> как ссылку на <code>x</code>. Затем внутренняя область видимости заканчивается и мы пытаемся напечатать значение из <code>r</code>. Этот код не будет собран, потому что значение на которое ссылается <code>r</code> исчезает из области видимости, прежде чем мы попробуем использовать его. Вот сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Переменная <code>x</code> «не живёт достаточно долго». Причина в том, что <code>x</code> выйдет из области видимости, когда эта внутренняя область закончится в строке 7. Но <code>r</code> все ещё является действительной во внешней области видимости; поскольку её охват больше, мы говорим, что она «живёт дольше». Если бы Ржавчина позволил такому коду работать, то переменная <code>r</code> смогла бы ссылаться на память, которая уже была освобождена (в тот мгновение, когда <code>x</code> вышла из внутренней области видимости), и всё что мы попытались бы сделать с <code>r</code> работало бы неправильно. Как же Ржавчина определяет, что этот код неправилен? Он использует для этого анализатор заимствований (<em>borrow checker</em>).</p>
<h3 id="Анализатор-заимствований"><a class="header" href="#Анализатор-заимствований">Анализатор заимствований</a></h3>
<p>Сборщик Ржавчина имеет в своём составе <em>анализатор заимствований</em>, который сравнивает области видимости для определения, являются ли все заимствования действительными. В приложении 10-17 показан тот же код, что и в приложении 10-16, но с изложениями, показывающими времена жизни переменных.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
<p><span class="caption">Пример 10-17: Изложение времён жизни переменных <code>r</code> и <code>x</code>, с помощью определителей времени жизни <code>'a</code> и <code>'b</code>, соответственно</span></p>
<p>Здесь мы описали время жизни для <code>r</code> с помощью <code>'a</code> и время жизни <code>x</code> с помощью <code>'b</code> . Как видите, время жизни <code>'b</code> внутреннего раздела гораздо меньше, чем время жизни <code>'a</code> внешнего раздела. Во время сборки Ржавчина сравнивает продолжительность двух времён жизни и видит, что <code>r</code> имеет время жизни <code>'a</code>, но ссылается на память со временем жизни <code>'b</code>. Программа отклоняется, потому что <code>'b</code> короче, чем <code>'a</code>: предмет ссылки не живёт так же долго, как сама ссылка.</p>
<p>Приложение 10-18 исправляет код, чтобы в нём не было повисшей ссылки, и собирается без ошибок.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<p><span class="caption">Приложение 10-18: Ссылка правильна, так как данные имеют более продолжительное время жизни, чем ссылка на эти данные</span></p>
<p>Здесь переменная <code>x</code> имеет время жизни <code>'b</code>, которое больше, чем время жизни <code>'a</code>. Это означает, что переменная <code>r</code> может ссылаться на переменную <code>x</code> потому что Ржавчина знает, что ссылка в переменной <code>r</code> будет всегда действительной до тех пор, пока переменная <code>x</code> является валидной.</p>
<p>После того, как мы на примерах рассмотрели времена жизни ссылок и обсудили как Ржавчина их анализирует, давайте поговорим об обобщённых временах жизни входных свойств и возвращаемых значений функций.</p>
<h3 id="Обобщённые-времена-жизни-в-функциях"><a class="header" href="#Обобщённые-времена-жизни-в-функциях">Обобщённые времена жизни в функциях</a></h3>
<p>Напишем функцию, которая возвращает более длинный из двух срезов строки. Эта функция принимает два среза строки и возвращает один срез строки. После того как мы выполнили функцию <code>longest</code>, код в приложении 10-19 должен вывести <code>The longest string is abcd</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
<p><span class="caption">Приложение 10-19: Функция <code>main</code> вызывает функцию <code>longest</code> для поиска наибольшего из двух срезов строки</span></p>
<p>Обратите внимание, что мы хотим чтобы функция принимала строковые срезы, которые являются ссылками, а не строки, потому что мы не хотим, чтобы функция <code>longest</code> забирала во владение свои свойства. Обратитесь к разделу <a href="ch04-03-slices.html#string-slices-as-parameters">"Строковые срезы как свойства"</a><!--  --> Главы 4 для более подробного обсуждения того, почему свойства используемые в приложении 10-19 выбраны именно таким образом.</p>
<p>Если мы попробуем выполнить функцию <code>longest</code> так, как это показано в приложении 10-20, программа не собирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<p><span class="caption">Приложение 10-20: Выполнение функции <code>longest</code>, которая возвращает наибольший срез строки, но пока не собирается</span></p>
<p>Вместо этого мы получим следующую ошибку, говорящую о временах жизни:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Текст ошибки показывает, что возвращаемому виду нужен обобщённый свойство времени жизни, потому что Ржавчина не может определить, относится ли возвращаемая ссылка к <code>x</code> или к <code>y</code>. На самом деле, мы тоже не знаем, потому что раздел<code>if</code> в теле функции возвращает ссылку на <code>x</code>, а раздел<code>else</code> возвращает ссылку на <code>y</code>!</p>
<p>Когда мы определяем эту функцию, мы не знаем определенных значений, которые будут в неё передаваться. Поэтому мы не знаем какая из ветвей оператора <code>if</code> или <code>else</code> будет выполнена. Мы также не знаем определенных времён жизни ссылок, которые будут переданы в функцию, поэтому мы не можем посмотреть на их области видимости, как мы делали в примерах 10-17 и 10-18, чтобы определить, будет ли возвращаемая нами ссылка правильной во всех случаях. Анализатор заимствований также не может этого определить, потому что он не знает как времена жизни переменных <code>x</code> и <code>y</code> соотносятся с временем жизни возвращаемого значения. Чтобы исправить эту ошибку, мы добавим обобщённый свойство времени жизни, который определит отношения между ссылками таким образом, чтобы анализатор заимствований мог провести свой анализ.</p>
<h3 id="правила-написания-изложении-времени-жизни"><a class="header" href="#правила-написания-изложении-времени-жизни">правила написания изложении времени жизни</a></h3>
<p>Изложения времени жизни не меняют срок, как долго живёт та или иная ссылка. Они скорее описывают, как соотносятся между собой времена жизни нескольких ссылок, не влияя на само время жизни. Точно так же, как функции могут принимать любой вид, когда в ярлыке указан свойство обобщённого вида, функции могут принимать ссылки с любым временем жизни, указанным с помощью свойства обобщённого времени жизни.</p>
<p>Изложения времени жизни имеют немного необычный правила написания: имена свойств времени жизни должны начинаться с апострофа (<code>'</code>), пишутся маленькими буквами, и обычно очень короткие, как и имена обобщённых видов. Большинство людей использует имя <code>'a</code> в качестве первой изложении времени жизни. Изложения свойств времени жизни следуют после символа <code>&amp;</code> и отделяются пробелом от названия ссылочного вида.</p>
<p>Приведём несколько примеров: у нас есть ссылка на <code>i32</code> без указания времени жизни, ссылка на <code>i32</code>, с временем жизни имеющим имя <code>'a</code> и изменяемая ссылка на <code>i32</code>, которая также имеет время жизни <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>Одна изложение времени жизни сама по себе не имеет большого значения, поскольку изложении предназначены для того, чтобы уведомить Ржавчина о том, как времена жизни нескольких ссылок соотносятся между собой. Давайте рассмотрим, как изложении времени жизни связаны друг с другом в среде функции <code>longest</code>.</p>
<h3 id="Изложения-времени-жизни-в-ярлыках-функций"><a class="header" href="#Изложения-времени-жизни-в-ярлыках-функций">Изложения времени жизни в ярлыках функций</a></h3>
<p>Чтобы использовать изложении времени жизни в ярлыках функций, нам нужно объявить свойства обобщённого <em>времени жизни</em> внутри угловых скобок между именем функции и списком свойств, как мы это делали с свойствами обобщённого <em>вида</em> .</p>
<p>Мы хотим, чтобы ярлык отражала следующее ограничение: возвращаемая ссылка будет действительна до тех пор, пока валидны оба свойства. Это связь между временами жизни свойств и возвращаемого значения. Мы назовём это время жизни <code>'a</code>, а затем добавим его к каждой ссылке, как показано в приложении 10-21.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Приложение 10-21: В определении функции <code>longest</code> указано, что все ссылки должны иметь одинаковое время жизни, обозначенное как <code>'a</code></span></p>
<p>Этот код должен собираться и давать желаемый итог, когда мы вызовем его в функции <code>main</code> приложения 10-19.</p>
<p>Ярлык функции теперь сообщает Rust, что для некоторого времени жизни <code>'a</code> функция принимает два свойства, оба из которых являются срезами строк, которые живут не меньше, чем время жизни <code>'a</code>. Ярлык функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как самое меньшее столько, сколько длится время жизни <code>'a</code>. В действительностиэто означает, что время жизни ссылки, возвращаемой функцией <code>longest</code>, равно меньшему времени жизни передаваемых в неё ссылок. Мы хотим, чтобы Ржавчина использовал именно такие отношения при анализе этого кода.</p>
<p>Помните, когда мы указываем свойства времени жизни в этой ярлыке функции, мы не меняем время жизни каких-либо переданных или возвращённых значений. Скорее, мы указываем, что анализатор заимствований должен отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что самой функции <code>longest</code> не нужно точно знать, как долго будут жить <code>x</code> и <code>y</code>, достаточно  того, что некоторая область может быть заменена на <code>'a</code>, которая будет удовлетворять этой ярлыке.</p>
<p>При определении времён жизни функций, изложении помещаются в ярлык функции, а не в тело функции. Изложения времени жизни становятся частью договора функции, как и виды в ярлыке. Наличие ярлыков функций, содержащих договор времени жизни, означает, что анализ который выполняет сборщик Rust, может быть проще. Если есть неполадка с тем, как функция определяется или как она вызывается, ошибки сборщика могут указать на часть нашего кода и ограничения более точно. Если бы вместо этого сборщик Ржавчина сделал больше предположений о том, какие отношения времён жизни мы хотели получить, сборщик смог бы указать только на использование нашего кода за много шагов от источника сбоев.</p>
<p>Когда мы передаём определенные ссылки в функцию <code>longest</code>, определенным временем жизни, которое будет заменено на <code>'a</code>, является часть области видимости <code>x</code>, которая пересекается с областью видимости <code>y</code>. Другими словами, обобщённое время жизни <code>'a</code> получит определенное время жизни, равное меньшему из времён жизни <code>x</code> и <code>y</code>. Так как мы определяли возвращаемую ссылку тем же свойствоом времени жизни <code>'a</code>, то возвращённая ссылка также будет действительна на протяжении меньшего из времён жизни <code>x</code> и <code>y</code>.</p>
<p>Давайте посмотрим, как изложении времени жизни ограничивают функцию <code>longest</code> путём передачи в неё ссылок, которые имеют разные определенные времена жизни. Приложение 10-22 является очевидным примером.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-22: Использование функции <code>longest</code> со ссылками на значения вида <code>String</code>, имеющими разное время жизни</span></p>
<p>В этом примере переменная <code>string1</code> действительна до конца внешней области, <code>string2</code> действует до конца внутренней области видимости и <code>result</code> ссылается на что-то, что является действительным до конца внутренней области видимости. Запустите этот код, и вы увидите что анализатор заимствований разрешает такой код; он собирает и напечатает <code>The longest string is long string is long</code>.</p>
<p>Теперь, давайте попробуем пример, который показывает, что время жизни ссылки <code>result</code> должно быть меньшим временем жизни одного из двух переменных. Мы переместим объявление переменной <code>result</code> за пределы внутренней области видимости, но оставим присвоение значения переменной <code>result</code> в области видимости <code>string2</code>. Затем мы переместим <code>println!</code>, который использует <code>result</code> за пределы внутренней области видимости, после того как внутренняя область видимости закончилась. Код в приложении 10-23 не собирается.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 10-23: Попытка использования <code>result</code>, после того как <code>string2</code> вышла из области видимости</span></p>
<p>При попытке собрать этот код, мы получим такую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Эта ошибка говорит о том, что если мы хотим использовать <code>result</code> в указания <code>println!</code>, переменная <code>string2</code> должна бы быть действительной до конца внешней области видимости. Ржавчина знает об этом, потому что мы определяли свойства функции и её возвращаемое значение одинаковым временем жизни <code>'a</code>.</p>
<p>Будучи людьми, мы можем посмотреть на этот код и увидеть, что <code>string1</code> длиннее, чем <code>string2</code> и, следовательно, <code>result</code> будет содержать ссылку на <code>string1</code>. Поскольку <code>string1</code> ещё не вышла из области видимости, ссылка на <code>string1</code> будет все ещё действительной в указания <code>println!</code>. Однако сборщик не видит, что ссылка в этом случае валидна. Мы сказали Rust, что время жизни ссылки, возвращаемой из функции <code>longest</code>, равняется меньшему из времён жизни переданных в неё ссылок. Таким образом, анализатор заимствований запрещает код в приложении 10-23, как возможно имеющий недействительную ссылку.</p>
<p>Попробуйте провести больше экспериментов с различными значениями и временами жизни ссылок, передаваемых в функцию <code>longest</code>, а также с тем, как используется возвращаемое значение  Перед сборкой делайте предположения о том, пройдёт ли ваш код анализ заимствований, а затем проверяйте, насколько вы были правы.</p>
<h3 id="Мышление-в-понятиях-времён-жизни"><a class="header" href="#Мышление-в-понятиях-времён-жизни">Мышление в понятиях времён жизни</a></h3>
<p>В зависимости от того, что делает ваша функция, следует использовать разные способы указания свойств времени жизни. Например, если мы изменим выполнение функции <code>longest</code> таким образом, чтобы она всегда возвращала свой первый переменная вместо самого длинного среза строки, то время жизни для свойства <code>y</code> можно совсем не указывать. Этот код собирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Мы указали свойство времени жизни <code>'a</code> для свойства <code>x</code> и возвращаемого значения, но не для свойства <code>y</code>, поскольку время жизни свойства <code>y</code> никак не соотносится с временем жизни свойства <code>x</code> или возвращаемого значения.</p>
<p>При возврате ссылки из функции, свойство времени жизни для возвращаемого вида должен соответствовать свойству времени жизни одного из переменных. Если возвращаемая ссылка <em>не</em> ссылается на один из свойств, она должна ссылаться на значение, созданное внутри функции. Однако, это приведёт к недействительной ссылке, поскольку значение, на которое она ссылается, выйдет из области видимости в конце функции. Посмотрите на попытку выполнения функции <code>longest</code>, которая не собирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
<p>Здесь, несмотря на то, что мы указали свойство времени жизни <code>'a</code> для возвращаемого вида, выполнение не будет собрана, потому что время жизни возвращаемого значения никак не связано с временем жизни свойств. Получаем сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Неполадказаключается в том, что <code>result</code> выходит за область видимости и очищается в конце функции <code>longest</code>. Мы также пытаемся вернуть ссылку на <code>result</code> из функции. Мы не можем указать свойства времени жизни, которые могли бы изменить недействительную ссылку, а Ржавчина не позволит нам создать недействительную ссылку. В этом случае лучшим решением будет вернуть владеющий вид данных, а не ссылку: в этом случае вызывающая функция будет нести ответственность за очистку полученного ею значения.</p>
<p>В конечном итоге, правила написания времён жизни выполняет связывание времён жизни различных переменных и возвращаемых значений функций. Описывая времена жизни, мы даём Ржавчина достаточно сведений, чтобы разрешить безопасные действия с памятью и запретить действия, которые могли бы создать недействительные ссылки или иным способом нарушить безопасность памяти.</p>
<h3 id="Определение-времён-жизни-при-объявлении-устройств"><a class="header" href="#Определение-времён-жизни-при-объявлении-устройств">Определение времён жизни при объявлении устройств</a></h3>
<p>До сих пор мы объявляли устройства, которые всегда содержали владеющие виды данных. Устройства могут содержать и ссылки, но при этом необходимо добавить изложение времени жизни для каждой ссылки в определении устройства. Приложение 10-24 описывает устройство <code>ImportantExcerpt</code>, содержащую срез строки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<p><span class="caption">Приложение 10-25. Устройства, содержащая ссылку, требует изложении времени жизни</span></p>
<p>У устройства имеется одно поле <code>part</code>, хранящее срез строки, который сам по себе является ссылкой. Как и в случае с обобщёнными видами данных, мы объявляем имя обобщённого свойства времени жизни внутри угловых скобок после имени устройства, чтобы иметь возможность использовать его внутри определения устройства. Данная изложение означает, что образец <code>ImportantExcerpt</code> не может пережить ссылку, которую он содержит в своём поле <code>part</code>.</p>
<p>Функция <code>main</code> здесь создаёт образец устройства <code>ImportantExcerpt</code>, который содержит ссылку на первое предложение вида <code>String</code> принадлежащее переменной <code>novel</code>. Данные в <code>novel</code> существуют до  создания образца <code>ImportantExcerpt</code>. Кроме того, <code>novel</code> не выходит из области видимости до тех пор, пока <code>ImportantExcerpt</code> не выйдет за область видимости, поэтому ссылка в внутри образца <code>ImportantExcerpt</code>  является действительной.</p>
<h3 id="Правила-неявного-выведения-времени-жизни"><a class="header" href="#Правила-неявного-выведения-времени-жизни">Правила неявного выведения времени жизни</a></h3>
<p>Вы изучили, что у каждой ссылки есть время жизни и что нужно указывать свойства времени жизни для функций или устройств, которые используют ссылки. Однако в Главе 4 у нас была функция в приложении 4-9, которая затем снова показана в приложении 10-25, в которой код собрался без наставлений времени жизни.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-25: Функция, которую мы определили в приложении 4-9  собирается без наставлений времени жизни, несмотря на то, что входной и возвращаемый вид свойств являются ссылками</span></p>
<p>Причина, по которой этот код собирается — историческая. В ранних (до-1.0) исполнениях Ржавчина этот код не собрался бы, поскольку каждой ссылке нужно было явно назначать время жизни. В те времена, ярлык функции была бы написана примерно так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>После написания большого количества кода на Ржавчина разработчики языка обнаружили, что в определённых случаейх программисты описывают одни и те же изложении времён жизни снова и снова. Эти случаи были предсказуемы и следовали нескольким определенным образцовым моделям. Объединение Ржавчина решила запрограммировать эти образцы в код сборщика Rust, чтобы анализатор заимствований мог вывести времена жизни в таких случаейх без необходимости явного указания наставлений программистами.</p>
<p>Мы упоминаем этот отрывок истории Rust, потому что возможно, что в будущем появится больше образцов для самостоятельного выведения времён жизни, которые будут добавлены в сборщик. Таким образом, в будущем может понадобится ещё меньшее количество наставлений.</p>
<p>Образцы, запрограммированные в анализаторе ссылок языка Rust, называются <em>правилами неявного выведения времени жизни</em>. Это не правила, которым должны следовать программисты; а набор частных случаев, которые рассмотрит сборщик, и, если ваш код попадает в эти случаи, вам не нужно будет указывать время жизни явно.</p>
<p>Правила выведения не предоставляют полного заключения. Если Ржавчина определенно применяет правила, но некоторая неясность относительно времён жизни ссылок все ещё остаётся, сборщик не будет догадываться, какими должны быть времена жизни оставшихся ссылок. В этом случае, вместо угадывания сборщик выдаст ошибку, которую вы можете устранить, добавив изложении времени жизни.</p>
<p>Времена жизни свойств функции или способа называются <em>временем жизни ввода</em>, а времена жизни возвращаемых значений называются <em>временем жизни вывода</em>.</p>
<p>Сборщик использует три правила, чтобы выяснить времена жизни ссылок при отсутствии явных наставлений. Первое правило относится ко времени жизни ввода, второе и третье правила применяются ко временам жизни вывода. Если сборщик доходит до конца проверки трёх правил и всё ещё есть ссылки, для которых он не может выяснить время жизни, сборщик остановится с ошибкой. Эти правила применяются к объявлениям <code>fn</code>, а также к разделам <code>impl</code>.</p>
<p>Первое правило заключается в том, что каждый свойство являющийся ссылкой, получает свой собственный свойство времени жизни. Другими словами, функция с одним свойствоом получит один свойство времени жизни: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; функция с двумя переменнойми получит два отдельных свойства времени жизни: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, и так далее.</p>
<p>Второе правило говорит, что если есть ровно один входной свойство времени жизни, то его время жизни назначается всем выходным свойствам: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Третье правило о том, что если есть множество входных свойств времени жизни, но один из них является ссылкой <code>&amp;self</code> или <code>&amp;mut self</code>, так как эта функция является способом, то время жизни <code>self</code> назначается временем жизни всем выходным свойствам. Это третье правило делает способы намного приятнее для чтения и записи, потому что требуется меньше символов.</p>
<p>Представим, что мы сборщик и применим эти правила, чтобы вывести времена жизни ссылок в ярлыке функции <code>first_word</code> приложения 10-25. Ярлык этой функции начинается без объявления времён жизни ссылок:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Теперь мы (в качестве сборщика) применим первое правило, утверждающее, что каждый свойство функции получает своё собственное время жизни. Как обычно, назовём его <code>'a</code> и теперь ярлык выглядит так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Далее применяем второе правило, поскольку в функции указан только один входной свойство времени жизни. Второе правило гласит, что время жизни единственного входного свойства назначается выходным свойствам, поэтому ярлык теперь преобразуется таким образом:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Теперь все ссылки в этой функции имеют свойства времени жизни и сборщик может продолжить свой анализ без необходимости просить у программиста указать изложении времён жизни в ярлыке этой функции.</p>
<p>Давайте рассмотрим ещё один пример: на этот раз функцию <code>longest</code>, в которой не было свойств времени жизни, когда мы начали с ней работать в приложении 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Применим первое правило: каждому свойству назначается собственное время жизни. На этот раз у функции есть два свойства, поэтому есть два времени жизни:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Можно заметить, что второе правило здесь не применимо, так как в ярлыке указано больше одного входного свойства времени жизни. Третье правило также не применимо, так как <code>longest</code> — функция, а не способ, следовательно, в ней нет свойства <code>self</code>.  Итак, мы прошли все три правила, но так и не смогли вычислить время жизни выходного свойства. Поэтому мы и получили ошибку при попытке собрать код приложения 10-20: сборщик работал по правилам неявного выведения времён жизни, но не мог выяснить все времена жизни ссылок в ярлыке.</p>
<p>Так как третье правило применяется только к способам, далее мы рассмотрим времена жизни в этом среде, чтобы понять, почему нам часто не требуется определять времена жизни в ярлыках способов.</p>
<h3 id="Изложение-времён-жизни-в-определении-способов"><a class="header" href="#Изложение-времён-жизни-в-определении-способов">Изложение времён жизни в определении способов</a></h3>
<p>Когда мы выполняем способы для устройств с временами жизни, мы используем тот же правила написания, который применялся для наставлений обобщённых видов данных на приложении 10-11. Место, где мы объявляем и используем времена жизни, зависит от того, с чем они связаны — с полями устройства, либо с переменнойми способов и возвращаемыми значениями.</p>
<p>Имена свойств времени жизни для полей устройств всегда описываются после ключевого слова <code>impl</code> и затем используются после имени устройства, поскольку эти времена жизни являются частью вида устройства.</p>
<p>В ярлыках способов внутри раздела <code>impl</code> ссылки могут быть привязаны ко времени жизни ссылок в полях устройства, либо могут быть независимыми. Вдобавок, правила неявного выведения времён жизни часто делают так, что изложении переменных времён жизни являются необязательными в ярлыках способов. Рассмотрим несколько примеров, использующих устройство с названием <code>ImportantExcerpt</code>, которую мы определили в приложении 10-24.</p>
<p>Сначала, воспользуемся способом <code>level</code>, чей  единственный свойство является ссылкой на <code>self</code>, а возвращаемое значение <code>i32</code>, не является ссылкой ни на что:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Объявление свойства времени жизни после <code>impl</code> и его использование после имени вида является обязательным, но нам не нужно определять время жизни ссылки на <code>self</code>, благодаря первому правилу неявного выведения времён жизни.</p>
<p>Вот пример, где применяется третье правило неявного выведения времён жизни:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>В этом способе имеется два входных свойства, поэтому Ржавчина применит первое правило и назначит обоим свойствам <code>&amp;self</code> и <code>announcement</code> собственные времена жизни. Далее, поскольку один из свойств является <code>&amp;self</code>, то возвращаемое значение получает время жизни переменой <code>&amp;self</code> и все времена жизни теперь выведены.</p>
<h3 id="Постоянное-время-жизни"><a class="header" href="#Постоянное-время-жизни">Постоянное время жизни</a></h3>
<p>Одно особенное время жизни, которое мы должны обсудить, называется <code>'static</code>. Оно означает, что данная ссылка  <em>может</em> жить всю продолжительность работы программы. Все строковые записи по умолчанию имеют время жизни <code>'static</code>, но мы можем указать его явным образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>Содержание этой строки сохраняется внутри двоичного файл программы и всегда доступно для использования. Следовательно, время жизни всех строковых записей равно <code>'static</code>.</p>
<p>Сообщения сборщика об ошибках в качестве решения сбоев могут предлагать вам использовать время жизни <code>'static</code>. Но прежде чем указывать <code>'static</code> как время жизни для ссылки, подумайте, на самом ли деле данная ссылка будет доступна во всё время работы программы. В большинстве случаев, сообщения об ошибках, предлагающие использовать время жизни <code>'static</code> появляются при попытках создания недействительных ссылок или несовпадения имеющихся времён жизни. В таких случаях, решение заключается в исправлении таких неполадок. а не в указании постоянного времени жизни <code>'static</code>.</p>
<h2 id="Обобщённые-виды-свойств-ограничения-особенностей-и-времена-жизни-вместе"><a class="header" href="#Обобщённые-виды-свойств-ограничения-особенностей-и-времена-жизни-вместе">Обобщённые виды свойств, ограничения особенностей и времена жизни вместе</a></h2>
<p>Давайте кратко рассмотрим правила написания задания свойств обобщённых видов, ограничений особенности и времён жизни совместно в одной функции:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Today is someone's birthday!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Это функция <code>longest</code>  из приложения 10-21, которая возвращает наибольший из двух срезов строки. Но теперь у неё есть дополнительный свойство с именем <code>ann</code> обобщённого вида <code>T</code>, который может быть представлен любым видом, выполняющим особенность <code>Display</code>, как указано в предложении <code>where</code>. Этот дополнительный свойство будет напечатан с использованием <code>{}</code> , поэтому ограничение особенности <code>Display</code> необходимо. Поскольку время жизни является обобщённым видом, то объявления свойства времени жизни <code>'a</code> и свойства обобщённого вида <code>T</code> помещаются в один список внутри угловых скобок после имени функции.</p>
<h2 id="Итоги-7"><a class="header" href="#Итоги-7">Итоги</a></h2>
<p>В этой главе мы рассмотрели много всего! Теперь вы знакомы с свойствами обобщённого вида, особенностями и ограничениями особенности, обобщёнными свойствами времени жизни, вы готовы писать код без повторений, который будет работать во множестве различных случаев. Свойства обобщённого вида позволяют использовать код для различных видов данных. Особенности и ограничения особенности помогают убедиться, что, хотя виды и обобщённые, они будут вести себя, как этого требует ваш код. Вы изучили, как использовать изложении времени жизни чтобы убедиться, что этот гибкий код не будет порождать никаких повисших ссылок. И весь этот анализ происходит в мгновение сборки и не влияет на производительность программы во время работы!</p>
<p>Верите или нет, но в рамках этой темы всё есть ещё чему поучиться: в Главе 17 обсуждаются особенности-предметы, которые являются ещё одним способом использования особенностей. Существуют также более сложные сценарии с изложениями времени жизни, которые вам понадобятся только в очень сложных случаях; для этого вам следует прочитать <a href="../reference/index.html">Rust Reference</a>. Далее вы узнаете, как писать проверки на Rust, чтобы убедиться, что ваш код работает так, как задумано.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Написание-автоматизированных-проверок"><a class="header" href="#Написание-автоматизированных-проверок">Написание автоматизированных проверок</a></h1>
<p>В своём эссе 1972 года “The Humble Programmer,” Edsger W. Dijkstra сказал, что «Проверка программы может быть очень эффективным способом показать наличие ошибок, но это безнадёжно неадекватно для показа их отсутствия». Это не значит, что мы не должны пытаться проверять столько, сколько мы можем!</p>
<p>Соблюдение правил программы считается то, в какой степени наш код выполняет именно то, что мы задумывали. Ржавчина разработан с учётом большой озабоченности соблюдением правил программ, но соблюдение правил сложна и нелегко доказуема. Система определения Ржавчина берет на себя огромную часть этого бремени, но она не может уловить абсолютно все сбоев. Поэтому в Ржавчина предусмотрена возможность написания автопроверок.</p>
<p>Допустим, мы пишем функцию <code>add_two</code>, которая прибавляет 2 к любому переданному ей числу. Ярлык этой функции принимает целое число в качестве свойства и возвращает целое число в качестве итога. Когда мы выполняем и собираем эту функцию, Ржавчина выполняет всю проверку видов и проверку заимствований, которую вы уже изучили, чтобы убедиться, что, например, мы не передаём значение <code>String</code> или недопустимую ссылку в эту функцию. Но Ржавчина <em>не способен</em> проверить, что эта функция сделает именно то, что мы задумали, то есть вернёт свойство плюс 2, а не, скажем, свойство плюс 10 или свойство - 50! Вот тут-то и приходят на помощь проверки.</p>
<p>Мы можем написать проверки, которые утверждают, например, что когда мы передаём <code>3</code> в функцию <code>add_two</code>, возвращаемое значение будет <code>5</code>. Мы можем запускать эти проверки всякий раз, когда мы вносим изменения в наш код, чтобы убедиться, что любое существующее правильное поведение не изменилось.</p>
<p>Проверка - сложный навык: мы не сможем охватить все подробности написания хороших проверок в одной главе, но мы обсудим основные подходы к проверке в Rust. Мы поговорим об изложениех и макросах, доступных вам для написания проверок, о поведении по умолчанию и свойствах, предусмотренных для запуска проверок, а также о том, как согласовать проверки в состоящие из звеньев проверки и встроенные проверки.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Как-писать-проверки"><a class="header" href="#Как-писать-проверки">Как писать проверки</a></h2>
<p>Проверки - это функции Rust, которые проверяют, что не проверочный код работает ожидаемым образом. Содержимое проверочных функций обычно выполняет следующие три действия:</p>
<ol>
<li>Установка любых необходимых данных или состояния.</li>
<li>Запуск кода, который вы хотите проверить.</li>
<li>Утверждение, что итоги являются теми, которые вы ожидаете.</li>
</ol>
<p>Давайте рассмотрим функции предоставляемые в Ржавчина целенаправленно для написания проверок, которые выполнят все эти действия, включая свойство <code>test</code>, несколько макросов и свойство <code>should_panic</code>.</p>
<h3 id="Устройства-проверяющей-функции"><a class="header" href="#Устройства-проверяющей-функции">Устройства проверяющей функции<a id="the-anatomy-of-a-test-function"></a></a></h3>
<p>В простейшем случае в Ржавчина проверка - это функция, определенная свойством <code>test</code>. Свойства представляют собой метаданные о отрывках кода Rust; один из примеров свойство <code>derive</code>, который мы использовали со устройствами в главе 5. Чтобы превратить функцию в проверяющую функцию добавьте <code>#[test]</code>  в строку перед <code>fn</code>.  Когда вы запускаете проверки приказом <code>cargo test</code>, Ржавчина создаёт двоичный звено выполняющий функции определеные свойством test и сообщающий о том, успешно или нет прошла каждая проверяющая функция.</p>
<p>Когда мы создаём новый дело библиотеки с помощью Cargo, то в нём самостоятельно порождается проверочный звено с проверку-функцией для нас. Этот звено даст вам образец для написания ваших проверок, так что вам не нужно искать точную устройство и правила написания проверочных функций каждый раз, когда вы начинаете новый дело. Вы можете добавить столько дополнительных проверочных функций и столько проверочных звеньев, сколько захотите!</p>
<p>Мы исследуем некоторые особенности работы проверок, экспериментируя с образцовым проверкой созданным для нас, без существующего проверки любого кода. Затем мы напишем некоторые существующие проверки, которые вызывают некоторый написанный код и убедимся в его правильном поведении. Мы рассмотрим некоторые особенности работы проверок, поэкспериментируем с образцовым проверкой, прежде чем приступать к действительному проверке любого кода. Затем мы напишем несколько существующих проверок, которые вызывают некоторый написанный нами код и проверяют, что его поведение правильное.</p>
<p>Давайте создадим новый библиотечный дело под названием <code>adder</code>, который складывает два числа:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Содержимое файла <em>src/lib.rs</em> вашей библиотеки <code>adder</code> должно выглядеть как в приложении 11-1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Приложение 11-1: Проверочный звено и функция, созданные самостоятельно с помощью <code>cargo new</code></span></p>
<p>Сейчас давайте пренебрегаем первые две строчки кода и сосредоточимся на функции. Обратите внимание на правила написания изложении <code>#[test]</code>: этот свойство указывает, что это проверочная функция, поэтому запускающий проверка знает, что эту функцию следует рассматривать как проверочную. У нас также могут быть не проверяемые функции в звене <code>tests</code>, которые помогут настроить общие сценарии или выполнить общие действия, поэтому нам всегда нужно указывать, какие функции являются проверкими.</p>
<p>В теле функции проверки используется макрос <code>assert_eq!</code>, чтобы утверждать, что <code>result</code>, который содержит итог сложения 2 и 2, равен 4. Это утверждение служит примером вида для типичного проверки. Давайте запустим его, чтобы убедиться, что этот проверка пройден.</p>
<p>Приказ <code>cargo test</code> выполнит все проверки в выбранном деле и сообщит о итогах как в приложении 11-2:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Приложение 11-2: Вывод сведений о работе самостоятельно созданных проверок</span></p>
<p>Cargo собрал и выполнил проверку. Мы видим строку <code>running 1 test</code>. Следующая строка показывает имя созданной проверочной функции, называемой  <code>it_works</code>, и итог запуска этого проверки равный <code>ok</code>. Текст <code>test result: ok.</code> означает, что все проверки пройдены успешно и часть вывода <code>1 passed; 0 failed</code> сообщает общее количество проверок, которые прошли или были ошибочными.</p>
<p>Можно пометить проверка как пренебрегаемый, чтобы он не выполнялся в определенном случае; мы рассмотрим это в разделе <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“Пренебрежение некоторых проверок, если их целенаправленно не запрашивать”</a><!-- ignore --> позже в этой главе. Поскольку в данный мгновение мы этого не сделали, в сводке показано, что <code>0 ignored</code>. Мы также можем передать переменная приказу <code>cargo test</code> для запуска только тех проверок, имя которых соответствует строке; это называется <em>выборкой</em>, и мы рассмотрим это в разделе <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“Запуск подмножества проверок по имени”</a><!-- ignore -->. Мы также не фильтровали выполняемые проверки, поэтому в конце сводки показано, что <code>0 filtered out</code>.</p>
<p>Исчисление <code>0 measured</code> предназначена для проверок производительности. На мгновение написания этой статьи такие проверки доступны только в ночной сборке Rust. Посмотрите <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">документацию о проверках производительности</a>, чтобы узнать больше.</p>
<p>Следующая часть вывода проверок начинается с <code>Doc-tests adder</code> - это сведения о проверках в документации. У нас пока нет проверок документации, но Ржавчина может собирать любые примеры кода, которые находятся в API документации. Такая возможность помогает поддерживать документацию и код в согласованном состоянии. Мы поговорим о написании проверок документации в разделы <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">"Примечания документации как проверки"</a><!-- ignore --> Главы 14. Пока просто пренебрегаем часть <code>Doc-tests</code> вывода.</p>
<p>Давайте начнём настраивать проверка в соответствии с нашими собственными потребностями. Сначала поменяем название нашего проверки <code>it_works</code> на <code>exploration</code>, вот так:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Снова выполним приказ <code>cargo test</code>. Вывод показывает наименование нашей проверку-функции - <code>exploration</code> вместо <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Добавим ещё один проверка, но в этот раз целенаправленно сделаем так, чтобы этот новый проверка не отработал! Проверка терпит неудачу, когда что-то паникует в проверяемой функции. Каждый проверка запускается в новом потоке и когда главный поток видит, что проверочный поток упал, то помечает проверка как завершившийся со сбоем. Мы говорили о простейшем способе вызвать панику в главе 9, используя для этого известный макрос <code>panic!</code>. Введём код проверку-функции <code>another</code>, как в файле <em>src/lib.rs</em> из приложения 11-3.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground"><span class="boring">pub fn add(left: usize, right: usize) -&gt; usize {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn exploration() {
</span><span class="boring">        let result = add(2, 2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn another() {
</span><span class="boring">        panic!("Make this test fail");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 11-3: Добавление второго проверки, который завершится ошибкой, потому что мы вызываем <code>panic!</code> макрос</span></p>
<p>Запустим приказ <code>cargo test</code>. Вывод итогов показан в приложении 11-4, который сообщает, что проверка <code>exploration</code> пройден, а <code>another</code> нет:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p><span class="caption">Приложение 11-4. Итоги проверки, когда один проверка пройден, а другой нет</span></p>
<p>Вместо <code>ok</code>, строка <code>test tests::another</code> сообщает <code>FAILED</code>. Две новые разделы появились между отдельными итогами и сводкой: в первом отображается подробная причина каждого сбоя проверки. В данном случае проверка <code>another</code> не сработал, потому что <code>panicked at 'Make this test fail'</code>, произошло в строке 10 файла <em>src/lib.rs</em>. В следующем разделе перечисляют имена всех не пройденных проверок, что удобно, когда есть много проверок и много подробных итогов неудачных проверок. Мы можем использовать имя не пройденного проверки для его дальнейшей отладки; мы больше поговорим о способах запуска проверок в разделе <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">"Управление хода выполнения проверок"</a><!-- ignore -->.</p>
<p>Итоговая строка отображается в конце: общий итог нашего проверки <code>FAILED</code>. У нас один проверка пройден и один проверка завершён со сбоем.</p>
<p>Теперь, когда вы увидели, как выглядят итоги проверки при разных сценариях, давайте рассмотрим другие макросы полезные в проверках, кроме <code>panic!</code>.</p>
<h3 id="Проверка-итогов-с-помощью-макроса-assert"><a class="header" href="#Проверка-итогов-с-помощью-макроса-assert">Проверка итогов с помощью макроса <code>assert!</code></a></h3>
<p>Макрос <code>assert!</code> доступен из встроенной библиотеки и является удобным, когда вы хотите проверить что некоторое условие в проверке вычисляется в значение <code>true</code>. Мы передаём в макрос <code>assert!</code> переменная, который вычисляется в логическое значение. Если оно <code>true</code>, то ничего не происходит и проверка считается пройденным. Если же значение вычисляется в <code>false</code>, то макрос <code>assert!</code> вызывает макрос <code>panic!</code>, чтобы вызвать сбой проверки. Использование макроса <code>assert!</code> помогает проверить, что код исполняется как ожидалось.</p>
<p>В главе 5, приложении 5-15, мы использовали устройство <code>Rectangle</code> и способ <code>can_hold</code>, который повторён в приложении 11-5. Давайте поместим этот код в файл <em>src/lib.rs</em> и напишем несколько проверок для него используя макрос <code>assert!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 11-5: Использование устройства <code>Rectangle</code> и её способа can_hold из главы 5</span></p>
<p>Способ <code>can_hold</code> возвращает логическое значение, что означает, что он является наилучшим исходом использования в макросе <code>assert!</code>. В приложении 11-6 мы пишем проверка, который выполняет способ <code>can_hold</code> путём создания образца <code>Rectangle</code> шириной 8 и высотой 7 и убеждаемся, что он может содержать другой образец <code>Rectangle</code> имеющий ширину 5 и высоту 1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<p><span class="caption">Приложение 11-6: Проверка для способа <code>can_hold</code>, который проверяет что больший прямоугольник действительно может содержать меньший</span></p>
<p>Также, в звене <code>tests</code> обратите внимание на новую добавленную строку <code>use super::*;</code>. Звено <code>tests</code> является обычным и подчиняется тем же правилам видимости, которые мы обсуждали в главе 7 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Пути для ссылки на элементы внутри дерева звена"</a><!--  -->. Так как этот звено <code>tests</code> является внутренним, нужно подключить проверяемый код из внешнего звена в область видимости внутреннего звена с проверкими. Для этого используется вездесущеее подключение, так что все что определено во внешнем звене становится доступным внутри <code>tests</code> звена.</p>
<p>Мы назвали наш проверка <code>larger_can_hold_smaller</code> и создали два нужных образца <code>Rectangle</code>. Затем вызвали макрос <code>assert!</code> и передали итог вызова <code>larger.can_hold(&amp;smaller)</code> в него. Это выражение должно возвращать <code>true</code>, поэтому наш проверка должен пройти. Давайте выясним!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Проверка проходит. Теперь добавим другой проверка, в этот раз мы попытаемся убедиться, что меньший прямоугольник не может содержать больший прямоугольник:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Поскольку правильный итог функции <code>can_hold</code> в этом случае <code>false</code>, то мы должны инвертировать этот итог, прежде чем передадим его в <code>assert!</code> макро. Как итог, наш проверка пройдёт, если <code>can_hold</code> вернёт <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Два проверки работают. Теперь проверим, как отреагируют проверки, если мы добавим ошибку в код. Давайте изменим выполнение способа <code>can_hold</code> заменив одно из логических выражений знак сравнения с "больше чем" на противоположный "меньше чем" при сравнении ширины:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Запуск проверок теперь производит следующее:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Наши проверки нашли ошибку! Так как в проверке <code>larger.width</code> равно 8 и <code>smaller.width</code> равно 5 сравнение ширины в способе <code>can_hold</code> возвращает итог <code>false</code>, поскольку число 8 не меньше чем 5.</p>
<h3 id="Проверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne"><a class="header" href="#Проверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne">Проверка на равенство с помощью макросов <code>assert_eq!</code> и <code>assert_ne!</code></a></h3>
<p>Общим способом проверки возможности является использование сравнения итога проверяемого кода и ожидаемого значения, чтобы убедиться в их равенстве. Для этого можно использовать макрос <code>assert!</code>, передавая ему выражение с использованием оператора <code>==</code>. Важно также знать, что кроме этого обычная библиотека предлагает пару макросов <code>assert_eq!</code> и <code>assert_ne!</code>, чтобы сделать проверка более удобным. Эти макросы сравнивают два переменной на равенство или неравенство соответственно. Макросы также печатают два значения входных свойств, если проверка завершился ошибкой, что позволяет легче увидеть <em>почему</em> проверка ошибочен. Противоположно этому, макрос <code>assert!</code> может только отобразить, что он вычислил значение <code>false</code> для выражения <code>==</code>, но не значения, которые привели к итогу <code>false</code>.</p>
<p>В приложении 11-7, мы напишем функцию <code>add_two</code>, которая прибавляет к входному свойству <code>2</code> и возвращает значение. Затем, проверим эту функцию с помощью макроса <code>assert_eq!</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Приложение 11-7: Проверка функции <code>add_two</code> с помощью макроса <code>assert_eq!</code></span></p>
<p>Проверим, что проверки проходят!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Первый переменная, который мы передаём в макрос <code>assert_eq!</code> число <code>4</code> чей итог вызова равен <code>add_two(2)</code> . Строка для этого проверки - <code>test tests::it_adds_two ... ok</code> , а текст <code>ok</code> означает, что наш проверка пройден!</p>
<p>Давайте введём ошибку в код, чтобы увидеть, как она выглядит, когда проверка, который использует <code>assert_eq!</code> завершается ошибкой. Измените выполнение функции <code>add_two</code>, чтобы добавлять <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Попробуем выполнить данный проверка ещё раз:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Наш проверка нашёл ошибку! Проверка <code>it_adds_two</code> не выполнился, отображается сообщение <code>assertion failed: </code>(left == right)`` и показывает, что <code>left</code> было <code>4</code>, а <code>right</code> было <code>5</code>. Это сообщение полезно и помогает начать отладку: это означает <code>left</code> переменная <code>assert_eq!</code> имел значение <code>4</code>, но <code>right</code> переменная для вызова <code>add_two(2)</code> был со значением <code>5</code>.</p>
<p>Обратите внимание, что в некоторых языках (таких как Java) в библиотеках кода для проверки принято именовать входные свойства проверочных функций как "ожидаемое" (<code>expected</code>) и "действительное" (<code>actual</code>). В Ржавчина приняты следующие обозначения <code>left</code> и <code>right</code> соответственно, а порядок в котором определяются ожидаемое значение и производимое проверяемым кодом значение не имеют значения. Мы могли бы написать выражение в проверке как <code>assert_eq!(add_two(2), 4)</code>, что приведёт к отображаемому сообщению об ошибке <code>assertion failed: </code>(left == right)``, слева <code>left</code> было бы <code>5</code>, а справа <code>right</code> было бы <code>4</code>.</p>
<p>Макрос <code>assert_ne!</code> сработает успешно, если входные свойства не равны друг другу и завершится с ошибкой, если значения равны. Этот макрос наиболее полезен в тех случаях, когда мы не знаем заранее, каким значение <em>будет</em>, но знаем точно, каким оно <em>не может</em> быть. К примеру, если проверяется функция, которая обязательно изменяет входные данные определённым образом, но способ изменения входного свойства зависит от дня недели, в который запускаются проверки, что лучший способ проверить правильность работы такой функции - это сравнить и убедиться, что выходное значение функции не должно быть равным входному значению.</p>
<p>В своей работе макросы <code>assert_eq!</code> и <code>assert_ne!</code> неявным образом используют операторы <code>==</code> и <code>!=</code> соответственно. Когда проверка не срабатывает, макросы печатают значения переменных с помощью отладочного изменения и это означает, что значения сравниваемых переменных должны выполнить особенности <code>PartialEq</code> и <code>Debug</code>. Все простые и большая часть видов встроенной библиотеки Ржавчина выполняют эти особенности. Для устройств и перечислений, которые вы выполняете сами будет необходимо выполнить особенность <code>PartialEq</code> для сравнения значений на равенство или неравенство. Для печати отладочной сведений в виде сообщений в строку вывода окне вывода необходимо выполнить особенность <code>Debug</code>. Так как оба особенности являются выводимыми особенностями, как упоминалось в приложении 5-12 главы 5, то эти особенности можно выполнить добавив изложение <code>#[derive(PartialEq, Debug)]</code> к определению устройства или перечисления. Смотрите больше подробностей в Appendix C <a href="appendix-03-derivable-traits.html">"Выводимые особенности"</a><!-- ignore --> про эти и другие выводимые особенности.</p>
<h3 id="Создание-сообщений-об-ошибках"><a class="header" href="#Создание-сообщений-об-ошибках">Создание сообщений об ошибках</a></h3>
<p>Также можно добавить пользовательское сообщение как дополнительный переменная макросов для печати в сообщении об ошибке проверки <code>assert!</code>, <code>assert_eq!</code>, и <code>assert_ne!</code>. Любые переменные, указанные после обязательных переменных, далее передаются в макрос <code>format!</code> (он обсуждается в разделе <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">"Сцепление с помощью оператора <code>+</code> или макроса format!"</a><!-- ignore -->), так что вы можете передать измененную строку, которая содержит  <code>{}</code> для заполнителей и значения, заменяющие эти заполнители. Пользовательские сообщения полезны для пояснения того, что означает утверждение (assertion); когда проверка завершается неудачей, у вас будет лучшее представление о том, в чем неполадка с кодом.</p>
<p>Например, есть функция, которая приветствует человека по имени и мы хотим проверять эту функцию. Мы хотим чтобы передаваемое ей имя выводилось в окно вывода:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>Требования к этой программе ещё не были согласованы и мы вполне уверены, что текст <code>Hello</code> в начале приветствия ещё изменится. Мы решили, что не хотим обновлять проверка при изменении требований, поэтому вместо проверки на точное равенство со значением возвращённым из <code>greeting</code>, мы просто будем проверять, что вывод содержит текст из входного свойства.</p>
<p>Давайте внесём ошибку в этот код, изменив <code>greeting</code> так, чтобы оно не включало <code>name</code> и увидим, как выглядит сбой этого проверки:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Запуск этого проверки выводит следующее:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Сообщение содержит лишь сведения о том что сравнение не было успешным и в какой строке это произошло. В данном случае, более полезный текст сообщения был бы, если бы также выводилось значение из функции <code>greeting</code>. Изменим проверяющую функцию так, чтобы выводились пользовательское сообщение измененное строкой с заменителем и действительными данными из кода <code>greeting</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>После того, как выполним проверка ещё раз мы получим подробное сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Мы можем увидеть значение, которое мы на самом деле получили в проверочном выводе, что поможет нам отлаживать произошедшее, а не то, что мы ожидали.</p>
<h3 id="Проверка-с-помощью-макроса-should_panic"><a class="header" href="#Проверка-с-помощью-макроса-should_panic">Проверка с помощью макроса <code>should_panic</code></a></h3>
<p>В дополнение к проверке того, что наш код возвращает правильные, ожидаемые значения, важным также является проверить, что наш код обрабатывает ошибки, которые мы ожидаем. Например, рассмотрим вид <code>Guess</code> который мы создали в главе 9, приложения 9-10. Другой код, который использует <code>Guess</code> зависит от заверения того, что <code>Guess</code> образцы будут содержать значения только от 1 до 100. Мы можем написать проверка, который заверяет, что попытка создать образец <code>Guess</code> со значением вне этого ряда вызывает панику.</p>
<p>Выполняем это с помощью другого свойства проверку-функции <code>#[should_panic]</code>. Этот свойство сообщает системе проверки, что проверка проходит, когда способ порождает ошибку. Если ошибка не порождается - проверка считается не пройденным.</p>
<p>Приложение 11-8 показывает проверка, который проверяет, что условия ошибки <code>Guess::new</code> произойдут, когда мы их ожидаем их.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Приложение 11-8: Проверка того, что условие вызовет макрос <code>panic!</code></span></p>
<p>Свойство <code>#[should_panic]</code> следует после <code>#[test]</code> и до объявления проверочной функции. Посмотрим на вывод итога, когда проверка проходит:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Выглядит хорошо! Теперь давайте внесём ошибку в наш код, убрав условие о том, что функция <code>new</code> будет паниковать если значение больше 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Когда мы запустим проверка в приложении 11-8, он потерпит неудачу:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Мы получаем не очень полезное сообщение в этом случае, но когда мы смотрим на проверяющую функцию, мы видим, что она <code>#[should_panic]</code>. Со сбоеме выполнение, которое мы получили означает, что код в проверяющей функции не вызвал паники.</p>
<p>Проверки, которые используют <code>should_panic</code> могут быть неточными, потому что они только указывают, что код вызвал панику. Проверка с свойством <code>should_panic</code> пройдёт, даже если проверка паникует по причине, отличной от той, которую мы ожидали. Чтобы сделать проверки с <code>should_panic</code> более точными, мы можем добавить необязательный свойство <code>expected</code>  для свойства <code>should_panic</code>. Такая подробностизация проверки позволит удостовериться, что сообщение об ошибке содержит предоставленный текст. Например, рассмотрим измененный код для <code>Guess</code> в приложении 11-9, где <code>new</code> функция паникует с различными сообщениями в зависимости от того, является ли значение слишком маленьким или слишком большим.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Приложение 11-9: Проверка <code>panic!</code> на наличие в его сообщении указанной подстроки</span></p>
<p>Этот проверка пройдёт, потому что значение, которое мы помеисполнения для <code>should_panic</code> в свойство свойства <code>expected</code> является подстрокой сообщения, с которым функция <code>Guess::new</code> вызывает панику. Мы могли бы указать полное, ожидаемое сообщение для паники, в этом случае это будет <code>Guess value must be less than or equal to 100, got 200</code>. То что вы выберите для указания как ожидаемого свойства у <code>should_panic</code> зависит от того, какая часть сообщения о панике неповторима или динамична, насколько вы хотите, чтобы ваш проверка был точным. В этом случае достаточно подстроки из сообщения паники, чтобы обеспечить выполнение кода в проверочной функции <code>else if value &gt; 100</code> .</p>
<p>Чтобы увидеть, что происходит, когда проверка <code>should_panic</code> неуспешно завершается с сообщением <code>expected</code>, давайте снова внесём ошибку в наш код, поменяв местами <code>if value &lt; 1</code> и <code>else if value &gt; 100</code> блоки:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>На этот раз, когда мы выполним <code>should_panic</code> проверка, он потерпит неудачу:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Сообщение об ошибке указывает, что этот проверка действительно вызвал панику, как мы и ожидали, но сообщение о панике не включено ожидаемую строку <code>'Guess value must be less than or equal to 100'</code>. Сообщение о панике, которое мы получили в этом случае, было <code>Guess value must be greater than or equal to 1, got 200.</code> Теперь мы можем начать выяснение, где ошибка!</p>
<h3 id="Использование-resultt-e-в-проверках"><a class="header" href="#Использование-resultt-e-в-проверках">Использование <code>Result&lt;T, E&gt;</code> в проверках</a></h3>
<p>Пока что мы написали проверки, которые паникуют, когда терпят неудачу. Мы также можем написать проверки которые используют <code>Result&lt;T, E&gt;</code>! Вот проверка из приложения 11-1, переписанный с использованием <code>Result&lt;T, E&gt;</code> и возвращающий <code>Err</code> вместо паники:</p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    // ANCHOR: here
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
    // ANCHOR_END: here
}</code></pre>
<p>Функция <code>it_works</code> теперь имеет возвращаемый вид <code>Result&lt;(), String&gt;</code>. В теле функции, вместо вызова макроса <code>assert_eq!</code>, мы возвращаем <code>Ok(())</code> когда проверка успешно выполнен и <code>Err</code> со <code>String</code> внутри, когда проверка не проходит.</p>
<p>Написание проверок так, чтобы они возвращали <code>Result&lt;T, E&gt;</code> позволяет использовать оператор "вопросительный знак"  в теле проверок, который может быть удобным способом писать проверки, которые должны выполниться не успешно, если какая-либо действие внутри них возвращает исход ошибки <code>Err</code>.</p>
<p>Вы не можете использовать изложение <code>#[should_panic]</code> в проверках, использующих <code>Result&lt;T, E&gt;</code>. Чтобы утверждать, что действие возвращает исход <code>Err</code>, <em>не</em> используйте оператор вопросительного знака для значения <code>Result&lt;T, E&gt;</code>. Вместо этого используйте <code>assert!(value.is_err())</code>.</p>
<p>Теперь, когда вы знаете несколько способов написания проверок, давайте взглянем на то, что происходит при запуске проверок и исследуем разные возможности используемые с приказом <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Управление-хода-выполнения-проверок"><a class="header" href="#Управление-хода-выполнения-проверок">Управление хода выполнения проверок</a></h2>
<p>Подобно тому, как <code>cargo run</code> выполняет сборку вашего кода, а затем запускает полученный двоичный файл, <code>cargo test</code> собирает ваш код в режиме проверки и запускает полученный двоичный файл с проверкими. Двоичный файл, создаваемый <code>cargo test</code>, по умолчанию запускает все проверки одновременно и перехватывает вывод, порождаемый во время выполнения проверок, предотвращая их вывод на экран для облегчения чтения вывода, относящегося к итогам проверки. Однако вы можете указать свойства приказной строки, чтобы изменить это поведение по умолчанию.</p>
<p>Часть свойств приказной строки передаётся в <code>cargo test</code>, а часть - в итоговый двоичный файл с проверкими. Чтобы разделить эти два вида переменных, нужно сначала указать переменные, которые идут в <code>cargo test</code>, затем использовать разделитель <code>--</code>, а потом те, которые попадут в двоичный файл проверки. Выполнение <code>cargo test --help</code> выводит возможности, которые вы можете использовать с <code>cargo test</code>, а выполнение <code>cargo test -- --help</code> выводит возможности, которые вы можете использовать за разделителем.</p>
<h3 id="Выполнение-проверок-одновременно-или-последовательно"><a class="header" href="#Выполнение-проверок-одновременно-или-последовательно">Выполнение проверок одновременно или последовательно</a></h3>
<p>Когда вы запускаете несколько проверок, по умолчанию они выполняются одновременно с использованием потоков, что означает, что они завершатся быстрее, и вы быстрее получите итоги. Поскольку проверки выполняются одновременно, вы должны убедиться, что ваши проверки не зависят друг от друга или от какого-либо общего состояния, включая общее окружение, например, текущий рабочий папка или переменные окружения.</p>
<p>Например, допустим, каждый из ваших проверок запускает код, который создаёт файл на диске с именем <em>test-output.txt</em> и записывает некоторые данные в этот файл. Затем каждый проверка считывает данные из этого файла и утверждает, что файл содержит определённое значение, которое в каждом проверке разное. Поскольку все проверки выполняются одновременно, один из проверок может перезаписать файл в промежутке между записью и чтением файла другим проверкой. Тогда второй проверка потерпит неудачу, но не потому, что код неверен, а потому, что эти проверки мешали друг другу при одновременном выполнении. Одно из решений - убедиться, что каждый проверка пишет в свой отдельный файл; другое решение - запускать проверки по одному.</p>
<p>Если вы не хотите запускать проверки одновременно или хотите более подробный управление над количеством используемых потоков, можно установить флаг <code>--test-threads</code> и то количество потоков, которое вы хотите использовать для проверки. Взгляните на следующий пример:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Мы устанавливаем количество проверочных потоков равным <code>1</code> , указывая программе не использовать одновременность. Выполнение проверок с использованием одного потока займёт больше времени, чем их одновременное выполнение, но проверки не будут мешать друг другу, если они совместно используют состояние.</p>
<h3 id="Отображение-итогов-работы-функции"><a class="header" href="#Отображение-итогов-работы-функции">Отображение итогов работы функции</a></h3>
<p>По умолчанию, если проверка пройден, система управления запуска проверок блокирует вывод на печать, т.е. если вы вызовете макрос <code>println!</code> внутри кода проверки и проверка будет пройден, вы не увидите вывода на окно вывода итогов вызова <code>println!</code>. Если же проверка не был пройден, все несущие сведения сообщения, а также описание ошибки будут выведены на окно вывода.</p>
<p>Например, в коде (11-10) функция выводит значение свойства с поясняющим текстовым сообщением, а также возвращает целочисленное постоянных значенийное значение <code>10</code>. Далее следует проверка, который имеет правильный входной свойство и проверка, который имеет ошибочный входной свойство:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
<p><span class="caption">Приложение 11-10: Проверка функции, которая использует макрос <code>println!</code></span></p>
<p>Итог вывода на окно вывода приказы <code>cargo test</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Обратите внимание, что нигде в этом выводе мы не видим сообщения <code>I got the value 4</code> , которое печатается при выполнении пройденного проверки. Этот вывод был записан. Итог неудачного проверки, <code>I got the value 8</code> , появляется в разделе итоговых итогов проверки, который также показывает причину неудачного проверки.</p>
<p>Если мы хотим видеть напечатанные итоги прохождения проверок, мы можем сказать Rust, чтобы он также показывал итоги успешных проверок с помощью <code>--show-output</code>.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Когда мы снова запускаем проверки из Приложения 11-10 с флагом <code>--show-output</code> , мы видим следующий итог:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 5
 right: 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="Запуск-подмножества-проверок-по-имени"><a class="header" href="#Запуск-подмножества-проверок-по-имени">Запуск подмножества проверок по имени</a></h3>
<p>Бывают случаи, когда в запуске всех проверок нет необходимости и нужно запустить только несколько проверок. Если вы работаете над функцией и хотите запустить проверки, которые исследуют её работу - это было бы удобно. Вы можете это сделать, используя приказ <code>cargo test</code>, передав в качестве переменной имена проверок.</p>
<p>Для отображения, как запустить объединение проверок, мы создадим объединение проверок для функции <code>add_two</code> function, как показано в Приложении 11-11, и постараемся выбрать какие из них запускать.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
<p><span class="caption">Приложение 11-11: Три проверки с различными именами</span></p>
<p>Если вы выполните приказ <code>cargo test</code> без уточняющих переменных, все проверки выполнятся одновременно:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="Запуск-одного-проверки"><a class="header" href="#Запуск-одного-проверки">Запуск одного проверки</a></h4>
<p>Мы можем запустить один проверка с помощью указания его имени в приказу <code>cargo test</code>:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Был запущен только проверка с названием <code>one_hundred</code>; два других проверки не соответствовали этому названию. Итоги проверки с помощью вывода <code>2 filtered out</code> дают нам понять, что у нас было больше проверок, но они не были запущены.</p>
<p>Таким образом мы не можем указать имена нескольких проверок; будет использоваться только первое значение, указанное для <code>cargo test</code> . Но есть способ запустить несколько проверок.</p>
<h4 id="Использование-фильтров-для-запуска-нескольких-проверок"><a class="header" href="#Использование-фильтров-для-запуска-нескольких-проверок">Использование фильтров для запуска нескольких проверок</a></h4>
<p>Мы можем указать часть имени проверки, и будет запущен любой проверка, имя которого соответствует этому значению. Например, поскольку имена двух наших проверок содержат <code>add</code>, мы можем запустить эти два, запустив <code>cargo test add</code>:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>Этот приказ запускала все проверки с <code>add</code> в имени и отфильтровывала проверка с именем <code>one_hundred</code> . Также обратите внимание, что звено, в котором появляется проверка, становится частью имени проверки, поэтому мы можем запускать все проверки в звене, фильтруя имя звена.</p>
<h3 id="Пренебрежение-проверок"><a class="header" href="#Пренебрежение-проверок">Пренебрежение проверок</a></h3>
<p>Бывает, что некоторые проверки требуют продолжительного времени для своего исполнения, и вы хотите исключить их из исполнения при запуске <code>cargo test</code>. Вместо перечисления в приказной строке всех проверок, которые вы хотите запускать, вы можете определять проверки, требующие много времени для прогона, свойством <code>ignore</code>, чтобы исключить их, как показано здесь:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

// ANCHOR: here
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}
// ANCHOR_END: here</code></pre>
<p>После <code>#[test]</code> мы добавляем строку <code>#[ignore]</code> в проверка, который хотим исключить. Теперь, когда мы запускаем наши проверки, <code>it_works</code> запускается, а <code>expensive_test</code> пренебрегается:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Функция <code>expensive_test</code> помечена как <code>ignored</code>. Если вы хотите выполнить только пренебреженные проверки, вы можете воспользоваться приказом <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Управляя тем, какие проверки запускать, вы можете быть уверены, что итоги вашего <code>cargo test</code> будут быстрыми. Когда вы дойдёте до особенности, где имеет смысл проверить итоги проверок <code>ignored</code>, и у вас есть время дождаться их итогов, вы можете запустить их с помощью <code>cargo test -- --ignored</code>. Если вы хотите запустить все проверки независимо от того, пренебрегаются они или нет, выполните <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Создание-проверок"><a class="header" href="#Создание-проверок">Создание проверок</a></h2>
<p>Как упоминалось в начале главы, проверка является сложной пунктом и разные люди используют разную совокупность понятий и устройство. Сообщество Ржавчина думает о проверках с точки зрения двух основных разрядов: <em>состоящие из звеньев проверки</em> и <em>встроенные проверки</em>. Состоящие из звеньев проверки это небольшие и более сосредоточенные на проверке одного звена в отдельности или могут проверяться закрытые внешние оболочки. Встраиваемые проверки являются полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные внешние оболочки и возможно выполняя проверка нескольких звеньев в одном проверке.</p>
<p>Написание обоих видов проверок важно для обеспечения того, чтобы кусочки вашей библиотеки по отдельности и вместе делали то, что вы ожидаете.</p>
<h3 id="Состоящие-из-звеньев-проверки"><a class="header" href="#Состоящие-из-звеньев-проверки">Состоящие из звеньев проверки</a></h3>
<p>Целью состоящих из звеньев проверок является проверка каждого раздела кода, изолированное от остального возможностей, чтобы можно было быстро понять, что работает неправильно или не так как ожидается. Мы разместим состоящие из звеньев проверки в папке <em>src</em>, в каждый проверяемый файл. Но в Ржавчина принято создавать проверяемый звено <code>tests</code> и код проверки сохранять в файлы с таким же именем, как составляющие которые предстоит проверять. Также необходимо добавить изложение <code>cfg(test)</code> к этому звену.</p>
<h4 id="Звено-проверок-и-изложение-cfgtest"><a class="header" href="#Звено-проверок-и-изложение-cfgtest">Звено проверок и изложение <code>#[cfg(test)]</code></a></h4>
<p>Изложение <code>#[cfg(test)]</code> у звена с проверкими указывает Ржавчина собирать и запускать только код проверок, когда выполняется приказ <code>cargo test</code>, а не когда запускается <code>cargo build</code>. Это уменьшает время сборки, если вы только хотите собрать библиотеку и уменьшить место для результирующих собранных артефактов, потому что проверки не будут включены. Вы увидите что, по причине того, что встроенные проверки помещаются в другой папка им не нужна изложение <code>#[cfg(test)]</code>. Тем не менее, так как состоящие из звеньев проверки идут в тех же файлах что и основной код, вы будете использовать <code>#[cfg(test)]</code> чтобы указать, что они не должны быть включены в собранный итог.</p>
<p>Напомним, что когда мы порождали новый дело <code>adder</code> в первом разделе этой главы, то Cargo создал для нас код ниже:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Этот код является самостоятельно созданным проверочным звеном. Свойство <code>cfg</code> предназначен для <em>настройке</em> и говорит Rust, что следующий элемент должен быть включён только учитывая определённую возможность настройке. В этом случае возможностью настройке является <code>test</code>, который предоставлен в Ржавчина для сборки и запуска текущих проверок. Используя свойство <code>cfg</code>, Cargo собирает только проверочный код при активном запуске проверок приказом <code>cargo test</code>. Это включает в себя любые вспомогательные функции, которые могут быть в этом звене в дополнение к функциям помеченным <code>#[test]</code>.</p>
<h4 id="Проверка-закрытых-функций-private"><a class="header" href="#Проверка-закрытых-функций-private">Проверка закрытых функций (private)</a></h4>
<p>Сообщество программистов не имеет однозначного мнения по поводу проверять или нет закрытые функции. В некоторых языках весьма сложно или даже невозможно проверять такие функции. Независимо от того, какой технологии проверки вы придерживаетесь, в Ржавчина закрытые функции можно проверять. Рассмотрим приложение 11-12 с закрытой функцией <code>internal_adder</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Приложение 11-12: Проверка закрытых функций</span></p>
<p>Обратите внимание, что функция <code>internal_adder</code> не помечена как <code>pub</code>. Проверки — это просто Ржавчина код, а звено <code>tests</code> — это ещё один звено. Как мы обсуждали в разделе <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Пути для ссылки на элемент в дереве звеньев“</a><!--  -->, элементы в дочерних звенах могут использовать элементы из своих родительских звеньев. В этом проверке мы помещаем все элементы родительского звена <code>test</code> в область видимости с помощью <code>use super::*</code> и затем проверка может вызывать <code>internal_adder</code>. Если вы считаете, что закрытые функции не нужно проверять, то Ржавчина не заставит вас это сделать.</p>
<h3 id="Встраиваемые-проверки"><a class="header" href="#Встраиваемые-проверки">Встраиваемые проверки</a></h3>
<p>В Ржавчина встроенные проверки являются полностью внешними по отношению к вашей библиотеке. Они используют вашу библиотеку так же, как любой другой код, что означает, что они могут вызывать только функции, которые являются частью открытого API библиотеки. Их целью является проверка, много ли частей вашей библиотеки работают вместе правильно. У звеньев кода правильно работающих самостоятельно, могут возникнуть сбоев при встраивани, поэтому проверочное покрытие встроенного кода также важно. Для создания встроенных проверок сначала нужен папка <em>tests</em> .</p>
<h4 id="Папка-tests"><a class="header" href="#Папка-tests">Папка <em>tests</em></a></h4>
<p>Мы создаём папку <em>tests</em> в корневой папке вашего дела, рядом с папкой <em>src</em>. Cargo знает, что искать файлы с встроенными проверкими нужно в этой папки. После этого мы можем создать столько проверочных файлов, сколько захотим, и Cargo собирает каждый из файлов в отдельный ящик.</p>
<p>Давайте создадим встроенный проверку. Рядом с кодом из приложения 11-12, который всё ещё в файле <em>src/lib.rs</em>, создайте папка <em>tests</em>, создайте новый файл с именем <em>tests/integration_test.rs</em>. Устройства папок должна выглядеть так:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Введите код из приложения 11-13 в файл <em>tests/integration_test.rs</em> file:</p>
<p><span class="filename">Файл: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p><span class="caption">Приложение 11-13: Встраиваемая проверка функция из ящика <code>adder</code></span></p>
<p>Каждый файл в папке <code>tests</code> представляет собой отдельный ящик, поэтому нам нужно подключить нашу библиотеку в область видимости каждого проверочного ящика. По этой причине мы добавляем <code>use adder</code> в верхней части кода, что не нужно нам делать в состоящих из звеньев проверках.</p>
<p>Нам не нужно вносить примечания в код в <em>tests/integration_test.rs</em> с помощью <code>#[cfg(test)]</code>. Cargo особым образом обрабатывает папка <code>tests</code> и собирает файлы в этом папке только тогда, когда мы запускаем приказ <code>cargo test</code>. Запустите <code>cargo test</code> сейчас:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Выходные данные представлены тремя разделами: состоящие из звеньев проверки, встроенные проверки и проверки документации. Обратите внимание, что если какой-нибудь проверка в одной из разделов не пройдёт, последующие разделы выполняться не будут. Например, если состоящий из звеньев проверка провалился, не будет выведено итогов встроенных и документационных проверок, потому что эти проверки будут выполняться только в том случае, если все состоящие из звеньев проверки завершатся успешно.</p>
<p>Первый раздел для состоящих из звеньев проверок такой же, как мы видели: одна строка для каждого состоящего из звеньев проверки (один с именем <code>internal</code>, который мы добавили в приложении 11-12), а затем сводная строка для состоящих из звеньев проверок.</p>
<p>Раздел встроенных проверок начинается со строки <code>Running tests/integration_test.rs</code>. Далее идёт строка для каждой проверочной функции в этом встроенном проверке и итоговая строка для итогов встроенного проверки непосредственно перед началом раздела <code>Doc-tests adder</code>.</p>
<p>Каждый файл встроенного проверки имеет свой собственный раздел, поэтому, если мы добавим больше файлов в папка <em>tests</em>, то здесь будет больше разделов встроенного проверки.</p>
<p>Мы всё ещё можем запустить определённую функцию в встроенных проверках, указав имя проверка функции в качестве переменной в <code>cargo test</code>. Чтобы запустить все проверки в определенном файле встроенных проверок, используйте переменная <code>--test</code> сопровождаемый именем файла у приказы <code>cargo test</code>:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Этот приказ запускает только проверки в файле <em>tests/integration_test.rs</em>.</p>
<h4 id="Подзвенья-в-встроенных-проверках"><a class="header" href="#Подзвенья-в-встроенных-проверках">Подзвенья в встроенных проверках</a></h4>
<p>По мере добавления большего количества встроенных проверок, можно создать более одного файла в папке  <em>tests</em>, чтобы легче создавать их; например, вы можете собъединять функции проверки по возможности, которую они проверяют. Как упоминалось ранее, каждый файл в папке <em>tests</em> собран как отдельный ящик, что полезно для создания отдельных областей видимости, чтобы более точно создавать видимость то, как конечные пользователи будут использовать ваш ящик. Однако это означает, что файлы в папке <em>tests</em> ведут себя не так, как файлы в <em>src</em>, как вы узнали в Главе 7 относительно того как разделить код на звенья и файлы.</p>
<p>Различное поведение файлов в папке <em>tests</em> наиболее заметно, когда у вас есть набор вспомогательных функций, которые будут полезны в нескольких встроенных проверочных файлах. Представим, что вы пытаетесь выполнить действия, описанные в разделе <a href="ch07-05-separating-modules-into-different-files.html">«Разделение звеньев в разные файлы»</a><!--  --> главы 7, чтобы извлечь их в общий звено. Например, вы создали файл <em>tests/common.rs</em> и помеисполнения в него функцию <code>setup</code>, содержащую некоторый код, который вы будете вызывать из разных проверочных функций в нескольких проверочных файлах</p>
<p><span class="filename">Файл: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>Когда мы снова запустим проверки, мы увидим новый раздел в итогах проверок для файла <em>common.rs</em>, хотя этот файл не содержит никаких проверочных функций, более того, мы даже не вызывали функцию <code>setup</code> откуда либо:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Упоминание файла <code>common</code> и появление в итогах выполнения проверок сообщения вида <code>running 0 tests</code> - это не то, чего мы хотели. Мы только хотели выделить некоторый общий код, который будет использоваться другими файлами встроенных проверок.</p>
<p>Чтобы звено <code>common</code> больше не появлялся в итогах выполнения проверок, вместо файла <em>tests/common.rs</em> мы создадим файл <em>tests/common/mod.rs</em>. Директория дела теперь выглядит следующим образом:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>Здесь используется более раннее соглашение об именовании файлов, которое Ржавчина также понимает. Мы говорили об этом в разделе <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“Иные пути к файлам”</a> главы 7. Именование файла таким образом говорит, что Ржавчина не должен рассматривать звено <code>common</code> как файл встроенных проверок. Когда мы перемещаем код функции <code>setup</code> в файл <em>tests/common/mod.rs</em> и удаляем файл <em>tests/common.rs</em>, дополнительный раздел больше не будет отображаться в итогах проверок. Файлы в подпапких папки <em>tests</em> не собираются как отдельные ящики или не появляются в итогах выполнения проверок.</p>
<p>После того, как мы создали файл <em>tests/common/mod.rs</em>, мы можем использовать его в любых файлах встроенных проверок как обычный звено. Вот пример вызова функции <code>setup</code> из проверки <code>it_adds_two</code> в файле <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Файл: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>Обратите внимание, что  объявление <code>mod common;</code> совпадает с объявлением звена, которое отображено в приложении 7-21. Затем в проверочной функции мы можем вызвать функцию <code>common::setup()</code>.</p>
<h4 id="Встраиваемые-проверки-для-двоичных-ящиков"><a class="header" href="#Встраиваемые-проверки-для-двоичных-ящиков">Встраиваемые проверки для двоичных ящиков</a></h4>
<p>Если наш дело является двоичным ящиком, который содержит только <em>src/main.rs</em> и не содержит <em>src/lib.rs</em>, мы не сможем создать встроенные проверки в папке <em>tests</em> и подключить функции определённые в файле <em>src/main.rs</em> в область видимости с помощью указания <code>use</code>. Только библиотечные ящики могут предоставлять функции, которые можно использовать в других ящиках; двоичные ящики предназначены только для самостоятельного запуска.</p>
<p>Это одна из причин, почему дела на Rust, которые порождают исполняемые звенья, обычно имеют простой файл <em>src/main.rs</em>, который в свою очередь вызывает логику, которая находится в файле <em>src/lib.rs</em>. Используя такую устройство, встроенные проверки <em>могут</em> проверить библиотечный ящик, используя оператор <code>use</code> для подключения важного возможностей. Если этот важный возможности работает, то и небольшое количество кода в файле <em>src/main.rs</em> также будет работать, а значит этот небольшой объём кода не нуждается в проверке.</p>
<h2 id="Итоги-8"><a class="header" href="#Итоги-8">Итоги</a></h2>
<p>Средства проверки языка Ржавчина предоставляют способ задать ожидаемое поведение кода, чтобы убедиться, что он всё ещё соответствует вашим ожиданиям даже после внесения изменений. Состоящие из звеньев проверки проверяют различные части библиотеки по отдельности и могут проверять закрытые подробности выполнения. Встраиваемые проверки проверяют, что части библиотеки работают правильно сообща. Эти проверки используют для проверки кода открытый API библиотеки, таким же образом, как его будет использовать внешний код. Хотя система видов Ржавчина и правила владения помогают предотвратить некоторые виды ошибок, проверки по-прежнему важны для уменьшения количества логических ошибок, связанных с поведением вашего кода.</p>
<p>Давайте объединим  знания, полученные в этой и предыдущей главах, чтобы поработать над делом!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Дело-с-вводомвыводом-io-создание-с-окном-вывода-приложения"><a class="header" href="#Дело-с-вводомвыводом-io-создание-с-окном-вывода-приложения">Дело с вводом/выводом (I/O): создание с окном вывода приложения</a></h1>
<p>В этой главе вы примените многие знания, полученные ранее, а также познакомитесь с ещё неизученными API встроенной библиотеки. Мы создадим окно выводаное приложение, которое будет взаимодействовать с файлом и с окно выводаным вводом / выводом, чтобы применить в некоторых подходах Rust, с которыми вы уже знакомы.</p>
<p>Скорость, безопасность, сборка в один исполняемый файл и кроссплатформенность делают Ржавчина наилучшим языком для создания окно выводаных средств, так что в нашем деле мы создадим свою собственную исполнение обычной утилиты поиска <code>grep</code>, что расшифровывается, как "вездесущеее средство поиска и печати" (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). В простейшем случае <code>grep</code> используется для поиска в выбранном файле указанного текста. Для этого утилита <code>grep</code> получает имя файла и текст в качестве переменных. Далее она читает файл, находит и выводит строки, содержащие искомый текст.</p>
<p>Попутно мы покажем, как сделать так, чтобы наше окно выводаное приложение использовало возможности окна вызова, которые используются многими другими окно выводаными средствами. Мы будем читать значение переменной окружения, чтобы позволить пользователю настроить поведение нашего средства. Мы также будем печатать сообщения об ошибках в обычный окно выводаный поток ошибок ( <code>stderr</code> ) вместо принятого вывода ( <code>stdout</code> ), чтобы, к примеру, пользователь мог перенаправить успешный вывод в файл, в то время, как сообщения об ошибках останутся на экране.</p>
<p>Один из участников Rust-сообщества, Andrew Gallant, уже выполнил полновозможный, очень быстрый подобие программы <code>grep</code> и назвал его <code>ripgrep</code>. По сравнению с ним, наша исполнение будет довольно простой, но эта глава даст вам знания, которые нужны для понимания существующих дел, таких как <code>ripgrep</code>.</p>
<p>Наш дело <code>grep</code> будет использовать ранее изученные подходы:</p>
<ul>
<li>Создание кода (используя то, что вы узнали о звенах в <a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"> главе 7</a><!--  -->)</li>
<li>Использование векторов и строк (собрания, <a href="ch08-00-common-collections.html">глава 8</a><!--  -->)</li>
<li>Обработка ошибок (<a href="ch09-00-error-handling.html">Глава 9</a><!--  -->)</li>
<li>Использование особенностей и времени жизни там, где это необходимо (<a href="ch10-00-generics.html">глава 10</a><!--  -->)</li>
<li>Написание проверок ( <a href="ch11-00-testing.html">Глава 11</a><!--  -->)</li>
</ul>
<p>Мы также кратко представим замыкания, повторители и предметы особенности, которые будут объяснены подробно в главах <a href="ch13-00-functional-features.html">13</a><!--  --> и <a href="ch17-00-oop.html">17</a><!--  -->.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Принятие-переменных-приказной-строки"><a class="header" href="#Принятие-переменных-приказной-строки">Принятие переменных приказной строки</a></h2>
<p>Создадим новый дело с окном вывода приложения как обычно с помощью приказы <code>cargo new</code>. Мы назовём дело <code>minigrep</code>, чтобы различать наше приложение от <code>grep</code>, которое возможно уже есть в вашей системе.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Первая задача - заставить <code>minigrep</code> принимать два переменной приказной строки: путь к файлу и строку для поиска. То есть мы хотим иметь возможность запускать нашу программу через <code>cargo run</code>, с использованием двойного дефиса, чтобы указать, что следующие переменные предназначены для нашей программы, а не для <code>cargo</code>, строки для поиска и пути к файлу в котором нужно искать, как описано ниже:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>В данный мгновение программа созданная <code>cargo new</code> не может обрабатывать переменные, которые мы ей передаём. Некоторые существующие библиотеки на <a href="https://crates.io/">crates.io</a> могут помочь с написанием программы, которая принимает переменные приказной строки, но так как вы просто изучаете эту подход, давайте выполняем эту возможность сами.</p>
<h3 id="Чтение-значений-переменных"><a class="header" href="#Чтение-значений-переменных">Чтение значений переменных</a></h3>
<p>Чтобы <code>minigrep</code> мог воспринимать значения переменных приказной строки, которые мы ему передаём, нам понадобится функция <code>std::env::args</code>, входящая в обычную библиотеку Rust. Эта функция возвращает повторитель переменных приказной строки, переданных в <code>minigrep</code>. Мы подробно рассмотрим повторители в <a href="ch13-00-functional-features.html">главе 13</a><!-- ignore -->. Пока вам достаточно знать две вещи об повторителях: повторители порождают серию значений, и мы можем вызвать способ <code>collect</code> у повторителя, чтобы создать из него собрание, например вектор, который будет содержать все элементы, произведённые повторителем.</p>
<p>Код представленный в Приложении 12-1 позволяет вашей программе <code>minigrep</code> читать любые переданные ей переменные приказной строки, а затем собирать значения в вектор.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<p><span class="caption">Приложение 12-1: Собираем переменные приказной строки в вектор и выводим их на печать</span></p>
<p>Сначала мы вводим звено <code>std::env</code> в область видимости с помощью указания <code>use</code>, чтобы мы могли использовать его функцию <code>args</code>. Обратите внимание, что функция <code>std::env::args</code> вложена в два уровня звеньев. Как мы обсуждали в <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">главе 7</a><!-- ignore -->, в случаях, когда нужная функция оказывается вложенной в более чем один звено, советуется выносить в область видимости родительский звено, а не функцию. Таким образом, мы можем легко использовать другие функции из <code>std::env</code>. Это менее двусмысленно, чем добавление <code>use std::env::args</code> и последующий вызов функции только с <code>args</code>, потому что <code>args</code> может быть легко принят за функцию, определённую в текущем звене.</p>
<blockquote>
<h3 id="Функция-args-и-недействительный-Юникод-символ-unicode"><a class="header" href="#Функция-args-и-недействительный-Юникод-символ-unicode">Функция <code>args</code> и недействительный Юникод символ (Unicode)</a></h3>
<p>Обратите внимание, что <code>std::env::args</code> вызовет панику, если какой-либо переменная содержит недопустимый символ Юникода. Если вашей программе необходимо принимать переменные, содержащие недопустимые символы Unicode, используйте вместо этого <code>std::env::args_os</code>. Эта функция возвращает повторитель , который выдаёт значения <code>OsString</code> вместо значений <code>String</code>. Мы решили использовать <code>std::env::args</code> здесь для простоты, потому что значения <code>OsString</code> отличаются для каждой площадки и с ними сложнее работать, чем со значениями <code>String</code>.</p>
</blockquote>
<p>В первой строке кода функции <code>main</code> мы вызываем <code>env::args</code> и сразу используем способ <code>collect</code>, чтобы превратить повторитель в вектор содержащий все полученные значения. Мы можем использовать функцию <code>collect</code> для создания многих видов собраний, поэтому мы явно определяем вид <code>args</code> чтобы указать, что мы хотим вектор строк. Хотя нам очень редко нужно определять виды в Rust, <code>collect</code> - это одна из функций, с которой вам часто нужна изложение вида, потому что Ржавчина не может сам вывести какую собрание вы хотите.</p>
<p>И в заключение мы печатаем вектор с помощью отладочного макроса. Попробуем запустить код сначала без переменных, а затем с двумя переменнойми:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>Обратите внимание, что первое значение в векторе <code>"target/debug/minigrep"</code> является названием нашего двоичного файла. Это соответствует поведению списка переменных в Си, позволяя программам использовать название с которым они были вызваны при выполнении. Часто бывает удобно иметь доступ к имени программы, если вы хотите распечатать его в сообщениях или изменить поведение программы в зависимости от того, какой псевдоним приказной строки был использован для вызова программы. Но для целей этой главы, мы пренебрегаем его и сохраним только два переменной, которые нам нужны.</p>
<h3 id="Сохранения-значений-переменных-в-переменные"><a class="header" href="#Сохранения-значений-переменных-в-переменные">Сохранения значений переменных в переменные</a></h3>
<p>На текущий мгновение программа может получить доступ к значениям, указанным в качестве переменных приказной строки. Теперь нам требуется сохранять значения этих двух переменных в переменных, чтобы мы могли использовать их в остальных частях программы. Мы сделаем это в приложении 12-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
<p><span class="caption">Приложение 12-2: Создание переменных для хранения значений переменных искомой подстроки и пути к файлу</span></p>
<p>Как видно из распечатки вектора, имя программы занимает первое значение в векторе по адресу <code>args[0]</code>, значит, переменные начинаются с порядкового указателя <code>1</code>. Первый переменная <code>minigrep</code> - это строка, которую мы ищем, поэтому мы помещаем ссылку на первый переменная в переменную <code>query</code>. Вторым переменнаяом является путь к файлу, поэтому мы помещаем ссылку на второй переменная в переменную <code>file_path</code>.</p>
<p>Для проверки соблюдения правил работы нашей программы, значения переменных выводятся в окно вывода. Далее, запустим нашу программу со следующими переменнойми: <code>test</code> и <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Отлично, программа работает! Нам нужно чтобы значения переменных были сохранены в правильных переменных. Позже мы добавим обработку ошибок с некоторыми вероятными ошибочными случаейми, например, когда пользователь не предоставляет переменные; сейчас мы пренебрегаем эту случай и поработаем над добавлением возможности чтения файла.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Чтение-файла"><a class="header" href="#Чтение-файла">Чтение файла</a></h2>
<p>Теперь добавим возможность чтения файла, указанного как переменная приказной строки <code>file_path</code>. Во-первых, нам нужен пример файла для проверки: мы будем использовать файл с небольшим объёмом текста в несколько строк с несколькими повторяющимися словами. В приложении 12-3 представлено стихотворение Эмили Дикинсон, которое будет хорошо работать! Создайте файл с именем <em>poem.txt</em> в корне вашего дела и введите стихотворение "I’m nobody! Who are you?"</p>
<p><span class="filename">Файл: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Приложение 12-3: Стихотворение Эмили Дикинсон - хороший пример для проверки</span></p>
<p>Текст на месте, изменените <em>src/main.rs</em> и добавьте код для чтения файла, как показано в приложении 12-4.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span>    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}</code></pre>
<p><span class="caption">Приложение 12-4: Чтение содержимого файла указанного во втором переменной</span></p>
<p>Во-первых, мы добавляем ещё одну указанию <code>use</code> чтобы подключить соответствующую часть встроенной библиотеки: нам нужен <code>std::fs</code> для обработки файлов.</p>
<p>В <code>main</code> мы добавили новую указанию: функция <code>fs::read_to_string</code> принимает <code>file_path</code>, открывает этот файл и возвращает содержимое файла как <code>std::io::Result&lt;String&gt;</code>.</p>
<p>После этого, мы снова добавили временную указанию <code>println!</code> для печати значения <code>contents</code> после чтения файла, таким образом мы можем проверить, что программа отрабатывает до этого места.</p>
<p>Давайте запустим этот код с любой строкой в качестве первого переменной приказной строки (потому что мы ещё не выполнили поисковую часть) и файл <em>poem.txt</em> как второй переменная:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Отлично! Этот код прочитал и затем напечатал содержимое файла. Но у программы есть несколько недостатков. Прежде всего, функция <code>main</code> решает слишком много задач: как правило функция понятнее и проще в обслуживании если она воплощает только одну мысль. Другая неполадка заключается в том, что мы не обрабатываем ошибки так хорошо, как могли бы. Пока наша программа небольшая, то эти недостатки не являются большой неполадкой, но по мере роста программы эти недостатки будет всё труднее исправлять. Хорошей опытом является начинать переработка кода на ранней стадии разработки программы, потому что гораздо проще перерабатывать код меньшие объёмы кода. Мы сделаем это далее.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Переработка-кода-для-улучшения-выделения-на-звенья-и-обработки-ошибок"><a class="header" href="#Переработка-кода-для-улучшения-выделения-на-звенья-и-обработки-ошибок">Переработка кода для улучшения выделения на звенья и обработки ошибок</a></h2>
<p>Для улучшения программы мы исправим 4 имеющихся сбоев, связанных со устройством программы и тем как обрабатываются вероятные ошибки. Во-первых, функция <code>main</code> на данный мгновение решает две задачи:  анализирует переменные приказной строки и читает файлы. По мере роста программы количество отдельных задач, которые обрабатывает функция <code>main</code>, будет увеличиваться. Поскольку эта функция получает больше обязанностей, то становится все труднее понимать её, труднее проверять и труднее изменять, не сломав одну из её частей. Лучше всего разделить возможность, чтобы каждая функция отвечала за одну задачу.</p>
<p>Эта неполадка также связана со второй неполадкой: хотя переменные <code>query</code> и <code>file_path</code> являются переменными настройке нашей программы, переменные вида <code>contents</code> используются для выполнения логики программы. Чем длиннее становится <code>main</code>, тем больше переменных нам нужно будет добавить в область видимости; чем больше у нас переменных в области видимости, тем сложнее будет отслеживать назначение каждой переменной. Лучше всего собъединять переменные настройке в одну устройство, чтобы сделать их назначение понятным.</p>
<p>Третья неполадка заключается в том, что мы используем <code>expect</code> для вывода сведений об ошибке при неполадке с чтением файла, но сообщение об ошибке просто выведет текст<code>Should have been able to read the file</code>. Чтение файла может не сработать по разным причинам, например: файл не найден или у нас может не быть разрешения на его чтение. Сейчас же, независимо от случаи, мы напечатаем одно и то же сообщение об ошибке, что не даст пользователю никакой сведений!</p>
<p>В-четвёртых, мы используем <code>expect</code> неоднократно для обработки различных ошибок и если пользователь запускает нашу программу без указания достаточного количества переменных он получит ошибку <code>index out of bounds</code> из Rust, что не совсем понятно описывает неполадку. Было бы лучше, если бы весь код обработки ошибок находился в одном месте, чтобы тем, кто будет поддерживать наш код в дальнейшем, нужно было бы вносить изменения только здесь, если потребуется изменить логику обработки ошибок. Наличие всего кода обработки ошибок в одном месте заверяет, что мы напечатаем сообщения, которые будут иметь смысл для наших конечных пользователей.</p>
<p>Давайте решим эти четыре сбоев путём переработки кода нашего дела.</p>
<h3 id="Разделение-ответственности-для-двоичных-дел"><a class="header" href="#Разделение-ответственности-для-двоичных-дел"><a name="separation-of-concerns-for-binary-projects"></a>Разделение ответственности для двоичных дел</a></h3>
<p>Внутренняя неполадка распределения ответственности за выполнение нескольких задач функции <code>main</code>  является общей для многих двоичных дел. В итоге Ржавчина сообщество разработало этап для использования в качестве руководства по разделению ответственности двоичной программы, когда код в <code>main</code> начинает увеличиваться. Этап имеет следующие шаги:</p>
<ul>
<li>Разделите код программы на два файла <em>main.rs</em> и <em>lib.rs</em>. Перенесите всю логику работы программы в файл <em>lib.rs</em>.</li>
<li>Пока ваша логика синтаксического анализа приказной строки мала, она может оставаться в файле <em>main.rs</em>.</li>
<li>Когда логика синтаксического анализа приказной строки становится сложной, извлеките её из <em>main.rs</em> и переместите в <em>lib.rs.</em></li>
</ul>
<p>Полезные  обязанности, которые остаются в функции <code>main</code> после этого этапа должно быть ограничено следующим:</p>
<ul>
<li>Вызов логики разбора приказной строки со значениями переменных</li>
<li>Настройка любой другой настройке</li>
<li>Вызов функции <code>run</code> в <em>lib.rs</em></li>
<li>Обработка ошибки, если <code>run</code> возвращает ошибку</li>
</ul>
<p>Этот образец о разделении ответственности: <em>main.rs</em> занимается запуском программы, а <em>lib.rs</em> обрабатывает всю логику задачи. Поскольку нельзя проверить функцию <code>main</code> напрямую, то такая устройства позволяет проверить всю логику программы путём перемещения её в функции внутри <em>lib.rs</em>. Единственный код, который остаётся в <em>main.rs</em> будет достаточно маленьким, чтобы проверить его соблюдение правил прочитав код. Давайте переработаем нашу программу, следуя этому этапу.</p>
<h4 id="Извлечение-обработчика-переменных"><a class="header" href="#Извлечение-обработчика-переменных">Извлечение обработчика переменных</a></h4>
<p>Мы извлечём возможность для разбора переменных в функцию, которую вызовет <code>main</code> для подготовки к перемещению логики разбора приказной строки в файл <em>src/lib.rs</em>. Приложение 12-5 показывает новый запуск <code>main</code>, который вызывает новую функцию <code>parse_config</code>, которую мы определим сначала в <em>src/main.rs.</em></p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<p><span class="caption">Приложение 12-5: Выделение функции <code>parse_config</code> из <code>main</code></span></p>
<p>Мы все ещё собираем переменные приказной строки в вектор, но вместо присваивания значение переменной с порядковым указателем 1 переменной <code>query</code> и значение переменной с порядковым указателем 2 переменной с именем <code>file_path</code> в функции <code>main</code>, мы передаём весь вектор в функцию <code>parse_config</code>. Функция <code>parse_config</code> затем содержит логику, которая определяет, какой переменная идёт в какую переменную и передаёт значения обратно в <code>main</code>. Мы все ещё создаём переменные <code>query</code> и <code>file_path</code> в <code>main</code>, но <code>main</code> больше не несёт ответственности за определение соответствия переменной приказной строки и соответствующей переменной.</p>
<p>Эта доработка может показаться излишней для нашей маленькой программы, но мы проводим переработка кода небольшими, постепенными шагами. После внесения этого изменения снова запустите программу и убедитесь, что анализ переменных все ещё работает. Также хорошо часто проверять все этапы, чтобы помочь определить причину неполадок. когда они возникают.</p>
<h4 id="Объединение-настроечных-переменных"><a class="header" href="#Объединение-настроечных-переменных">Объединение настроечных переменных</a></h4>
<p>Мы можем сделать ещё один маленький шаг для улучшения функции <code>parse_config</code>. На данный мгновение мы возвращаем упорядоченный ряд, но затем мы немедленно разделяем его снова на отдельные части. Это признак того, что, возможно,  пока у нас нет правильной абстракции.</p>
<p>Ещё один индикатор, который показывает, что есть место для улучшения, это часть <code>config</code> из <code>parse_config</code>, что подразумевает, что два значения, которые мы возвращаем, связаны друг с другом и оба являются частью одного настроечного значения. В настоящее время мы не отражаем этого смысла в устройстве данных, кроме объединения двух значений в упорядоченный ряд; мы могли бы поместить оба значения в одну устройство и дать каждому из полей устройства понятное имя. Это облегчит будущую поддержку этого кода, чтобы понять, как различные значения относятся друг к другу и какое их назначение.</p>
<p>В приложении 12-6 показаны улучшения функции <code>parse_config</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<p><span class="caption">Приложение 12-6: Переработка кода функции <code>parse_config</code>, чтобы возвращать образец устройства <code>Config</code></span></p>
<p>Мы добавили устройство с именем <code>Config</code> объявленную с полями назваными как <code>query</code> и <code>file_path</code>. Ярлык <code>parse_config</code> теперь указывает, что она возвращает значение <code>Config</code>. В теле <code>parse_config</code>, где мы возвращали срезы строк, которые ссылаются на значения <code>String</code> в <code>args</code>, теперь мы определяем <code>Config</code> как содержащие собственные <code>String</code> значения. Переменная <code>args</code> в <code>main</code> является владельцем значений переменной и позволяют функции <code>parse_config</code> только одалживать их, что означает, что мы бы нарушили правила заимствования Rust, если бы <code>Config</code> попытался бы взять во владение значения в <code>args</code> .</p>
<p>Мы можем управлять данными <code>String</code> разным количеством способов, но самый простой, хотя и отчасти неэффективный это вызвать способ <code>clone</code> у значений. Он сделает полную повтор данных для образца <code>Config</code> для владения, что занимает больше времени и памяти, чем сохранение ссылки на строку данных. Однако клонирование данных также делает наш код очень простым, потому что нам не нужно управлять временем жизни ссылок; в этом обстоятельстве, отказ от небольшой производительности, чтобы получить простоту, стоит небольших соглашениеа.</p>
<blockquote>
<p><h>К при использовании способа <code>clone</code></h>Существует тенденция в среде программистов Ржавчина избегать использования <code>clone</code>, т.к. это понижает эффективность работы кода. В <a href="ch13-00-functional-features.html">Главе 13</a><!-- ignore -->, вы изучите более эффективные способы, которые могут подойти в подобной случаи. Но сейчас можно воспроизводить несколько строк, чтобы продолжить работу, потому что вы сделаете эти повторы только один раз, а ваше имя файла и строка запроса будут очень маленькими. Лучше иметь работающую программу, которая немного неэффективна, чем пытаться заранее перерабатывать код при первом написании. По мере приобретения опыта работы с Ржавчина вам будет проще начать с наиболее эффективного решения, но сейчас вполне приемлемо вызвать <code>clone</code>.</p>
</blockquote>
<p>Мы обновили код в <code>main</code> поэтому он помещает образец <code>Config</code> возвращённый из <code>parse_config</code> в переменную с именем <code>config</code>, и мы обновили код, в котором ранее использовались отдельные переменные <code>query</code> и <code>file_path</code>, так что теперь он использует вместо этого поля в устройстве <code>Config</code>.</p>
<p>Теперь наш код более чётко передаёт то, что <code>query</code> и <code>file_path</code> связаны и что цель из использования состоит в том, чтобы настроить, как программа будет работать. Любой код, который использует эти значения знает, что может найти их в именованных полях образца <code>config</code> по их назначению.</p>
<h4 id="Создание-строителя-для-устройства-config"><a class="header" href="#Создание-строителя-для-устройства-config">Создание строителя для устройства <code>Config</code></a></h4>
<p>Пока что мы извлекли логику, отвечающую за синтаксический анализ переменных приказной строки из <code>main</code> и помеисполнения его в функцию <code>parse_config</code>. Это помогло нам увидеть, что значения <code>query</code> и <code>file_path</code> были связаны и что их отношения должны быть отражены в нашем коде. Затем мы добавили устройство <code>Config</code> в качестве названия связанных общей целью <code>query</code> и <code>file_path</code> и чтобы иметь возможность вернуть именованные значения как имена полей устройства из функции <code>parse_config</code>.</p>
<p>Итак, теперь целью функции <code>parse_config</code> является создание образца <code>Config</code>, мы можем изменить <code>parse_config</code> из простой функции на функцию названную <code>new</code>, которая связана со устройством <code>Config</code>. Выполняя это изменение мы сделаем код более идиоматичным. Можно создавать образцы видов в встроенной библиотеке, такие как <code>String</code> с помощью вызова <code>String::new</code>. Точно так же изменив название <code>parse_config</code> на название функции <code>new</code>, связанную с <code>Config</code>, мы будем уметь создавать образцы <code>Config</code>, вызывая <code>Config::new</code>. Приложение 12-7 показывает изменения, которые мы должны сделать.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<p><span class="caption">Приложение 12-7: Переименование <code>parse_config</code> в <code>Config::new</code></span></p>
<p>Мы обновили <code>main</code> где вызывали <code>parse_config</code>, чтобы вместо этого вызывалась <code>Config::new</code>. Мы изменили имя <code>parse_config</code> на <code>new</code> и перенесли его внутрь раздела <code>impl</code>, который связывает функцию <code>new</code> с <code>Config</code>. Попробуйте снова собрать код, чтобы убедиться, что он работает.</p>
<h3 id="Исправление-ошибок-обработки"><a class="header" href="#Исправление-ошибок-обработки">Исправление ошибок обработки</a></h3>
<p>Теперь мы поработаем над исправлением обработки ошибок. Напомним, что попытки получить доступ к значениям в векторе <code>args</code> с порядковым указателем 1 или порядковым указателем 2 приведут к панике, если вектор содержит менее трёх элементов. Попробуйте запустить программу без каких-либо переменных; это будет выглядеть так:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Строка <code>index out of bounds: the len is 1 but the index is 1</code> является сообщением об ошибке предназначенной для программистов. Она не поможет нашим конечным пользователям понять, что случилось и что они должны сделать вместо этого. Давайте исправим это сейчас.</p>
<h4 id="Улучшение-сообщения-об-ошибке"><a class="header" href="#Улучшение-сообщения-об-ошибке">Улучшение сообщения об ошибке</a></h4>
<p>В приложении 12-8 мы добавляем проверку в функцию <code>new</code>, которая будет проверять, что срез достаточно длинный, перед попыткой доступа по порядковым указателям 1 и 2. Если срез не достаточно длинный, программа паникует и отображает улучшенное сообщение об ошибке.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-8: Добавление проверки количества переменных</span></p>
<p>Этот код похож на <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">функцию <code>Guess::new</code> написанную в приложении 9-13</a>, где мы вызывали <code>panic!</code>, когда <code>value</code> переменной вышло за пределы допустимых значений. Здесь вместо проверки на рядзначений, мы проверяем, что длина <code>args</code> не менее 3 и остальная часть функции может работать при условии, что это условие было выполнено. Если в <code>args</code> меньше трёх элементов, это условие будет истинным и мы вызываем макрос <code>panic!</code> для немедленного завершения программы.</p>
<p>Имея нескольких лишних строк кода в <code>new</code>, давайте запустим программу снова без переменных, чтобы увидеть, как выглядит ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Этот вывод лучше: у нас теперь есть разумное сообщение об ошибке. Тем не менее, мы также имеем постороннюю сведения, которую мы не хотим предоставлять нашим пользователям. Возможно, использованная техника, которую мы использовали в приложении 9-13, не является лучшей для использования: вызов <code>panic!</code> больше подходит для программирования сбоев, чем решения сбоев, <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">как обсуждалось в главе 9</a><!-- ignore -->. Вместо этого мы можем использовать другую технику, о которой вы узнали в главе 9 [возвращая <code>Result</code>]<!-- ignore -->, которая указывает либо на успех, либо на ошибку.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="Возвращение-result-вместо-вызова-panic"><a class="header" href="#Возвращение-result-вместо-вызова-panic">Возвращение <code>Result</code> вместо вызова <code>panic!</code></a></h4>
<p>Мы можем вернуть значение <code>Result</code>, которое будет содержать образец <code>Config</code> в успешном случае и опишет неполадку в случае ошибки. Мы так же изменим функцию <code>new</code> на <code>build</code> потому что многие программисты ожидают что <code>new</code> никогда не завершится неудачей. Когда <code>Config::build</code> взаимодействует с <code>main</code>, мы можем использовать вид <code>Result</code> как сигнал возникновения сбоев. Затем мы можем изменить <code>main</code>, чтобы преобразовать исход <code>Err</code> в более применимую ошибку для наших пользователей без окружающего текста вроде <code>thread 'main'</code> и <code>RUST_BACKTRACE</code>, что происходит при вызове <code>panic!</code>.</p>
<p>Приложение 12-9 показывает изменения, которые нужно внести в возвращаемое значения функции <code>Config::build</code>, и в тело функции, необходимые для возврата вида <code>Result</code>. Заметьте, что этот код не собирается, пока мы не обновим <code>main</code>, что мы и сделаем в следующем приложении.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<p><span class="caption">Приложение 12-9. Возвращение вида <code>Result</code> из <code>Config::build</code></span></p>
<p>Наша функция <code>build</code> теперь возвращает <code>Result</code> с образцом <code>Config</code> в случае успеха и <code>&amp;'static str</code> в случае ошибки. Значения ошибок всегда будут строковыми записями, которые имеют время жизни <code>'static</code>.</p>
<p>Мы внесли два изменения в тело функции <code>build</code>: вместо вызова <code>panic!</code>, когда пользователь не передаёт достаточно переменных, мы теперь возвращаем <code>Err</code> значение и мы завернули возвращаемое значение <code>Config</code> в <code>Ok</code> . Эти изменения заставят функцию соответствовать своей новой ярлыке вида.</p>
<p>Возвращение значения <code>Err</code> из <code>Config::build</code> позволяет функции <code>main</code> обработать значение <code>Result</code> возвращённое из функции <code>build</code> и выйти из этапа более чисто в случае ошибки.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="Вызов-configbuild-и-обработка-ошибок"><a class="header" href="#Вызов-configbuild-и-обработка-ошибок">Вызов <code>Config::build</code> и обработка ошибок</a></h4>
<p>Чтобы обработать ошибку и вывести более дружественное сообщение об ошибке, нам нужно обновить код <code>main</code> для обработки <code>Result</code>, возвращаемого из <code>Config::build</code> как показано в приложении 12-10. Мы также возьмём на себя ответственность за выход из программы приказной строки с ненулевым кодом ошибки <code>panic!</code> и выполняем это вручную. Не нулевой значение выхода - это соглашение, которое указывает этапу, который вызывает нашу программу, что программа завершилась с ошибкой.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-10. Выход с кодом ошибки если создание новой <code>Config</code> терпит неудачу</span></p>
<p>В этом приложении мы использовали способ, который мы ещё не рассматривали подробно: <code>unwrap_or_else</code>, который в встроенной библиотеке определён как <code>Result&lt;T, E&gt;</code>. Использование <code>unwrap_or_else</code> позволяет нам определить некоторые пользовательские ошибки обработки, не содержащие <code>panic!</code>. Если <code>Result</code> является значением <code>Ok</code>, поведение этого способа подобно <code>unwrap</code>: возвращает внутреннее значение из обёртки <code>Ok</code>. Однако, если значение является значением <code>Err</code>, то этот способ вызывает код <em>замыкания</em>, которое является анонимной функцией, определённой заранее и передаваемую в качестве переменной в <code>unwrap_or_else</code>. Мы рассмотрим замыкания более подробно в <a href="ch13-00-functional-features.html">главе 13</a>. В данный мгновение, вам просто нужно знать, что <code>unwrap_or_else</code> передаст внутреннее значение <code>Err</code>, которое в этом случае является постоянной строкой <code>not enough arguments</code>, которое мы добавили в приложении 12-9, в наше замыкание как переменная <code>err</code> указанное между вертикальными линиями. Код в замыкании может затем использовать значение <code>err</code> при выполнении.</p>
<p>Мы добавили новую строку <code>use</code>, чтобы подключить <code>process</code> из встроенной библиотеки в область видимости. Код в замыкании, который будет запущен в случае ошибки содержит только две строчки: мы печатаем значение <code>err</code> и затем вызываем <code>process::exit</code>. Функция <code>process::exit</code> немедленно остановит программу и вернёт номер, который был передан в качестве кода состояния выхода. Это похоже на обработку с помощью макроса <code>panic!</code>, которую мы использовали в приложении 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Замечательно! Этот вывод намного дружелюбнее для наших пользователей.</p>
<h3 id="Извлечение-логики-из-main"><a class="header" href="#Извлечение-логики-из-main">Извлечение логики из <code>main</code></a></h3>
<p>Теперь, когда мы закончили переработка кода разбора настройке, давайте обратимся к логике программы. Как мы указали в разделе <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">«Разделение ответственности в двоичных делах»</a><!-- ignore -->, мы извлечём функцию с именем <code>run</code>, которая будет содержать всю логику, присутствующую в настоящее время в функции <code>main</code> и которая не связана с настройкой настройке или обработкой ошибок. Когда мы закончим, то <code>main</code> будет краткой, легко проверяемой и мы сможем написать проверки для всей остальной логики.</p>
<p>Код 12-11 отображает извлечённую логику в функцию <code>run</code>. Мы делаем маленькое, инкрементальное приближение к извлечению функции. Код всё ещё сосредоточен в файле <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-11. Извлечение функции <code>run</code>, содержащей остальную логику программы</span></p>
<p>Функция <code>run</code> теперь содержит всю оставшуюся логику из <code>main</code>, начиная от чтения файла. Функция <code>run</code> принимает образец <code>Config</code> как переменная.</p>
<h4 id="Возврат-ошибок-из-функции-run"><a class="header" href="#Возврат-ошибок-из-функции-run">Возврат ошибок из функции <code>run</code></a></h4>
<p>Оставшаяся логика программы выделена в функцию <code>run</code>, где мы можем улучшить обработку ошибок как мы уже делали с <code>Config::build</code> в приложении 12-9. Вместо того, чтобы позволить программе паниковать с помощью вызова <code>expect</code>, функция <code>run</code> вернёт <code>Result&lt;T, E&gt;</code>, если что-то пойдёт не так. Это позволит далее окне выводадировать логику обработки ошибок в <code>main</code> удобным способом. Приложение 12-12 показывает изменения, которые мы должны внести в ярлык и тело <code>run</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-12. Изменение функции <code>run</code> для возврата <code>Result</code></span></p>
<p>Здесь мы сделали три значительных изменения. Во-первых, мы изменили вид возвращаемого значения функции <code>run</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> . Эта функция ранее возвращала вид <code>()</code> и мы сохраняли его как значение, возвращаемое в случае <code>Ok</code>.</p>
<p>Для вида ошибки мы использовали <em>предмет особенность</em> <code>Box&lt;dyn Error&gt;</code> (и вверху мы подключили вид <code>std::error::Error</code> в область видимости с помощью указания <code>use</code>). Мы рассмотрим особенности предметов в <a href="ch17-00-oop.html">главе 17</a><!-- ignore -->. Сейчас просто знайте, что <code>Box&lt;dyn Error&gt;</code> означает, что функция будет возвращать вид выполняющий особенность <code>Error</code>, но не нужно указывать, какой именно будет вид возвращаемого значения. Это даёт возможность возвращать значения ошибок, которые могут быть разных видов в разных случаях. Ключевое слово <code>dyn</code> сокращение для слова «изменяемый».</p>
<p>Во-вторых, мы убрали вызов <code>expect</code> в пользу использования оператора <code>?</code>, как мы обсудили в <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">главе 9</a><!-- ignore -->. Скорее, чем вызывать <code>panic!</code> в случае ошибки, оператор <code>?</code> вернёт значение ошибки из текущей функции для вызывающего, чтобы он её обработал.</p>
<p>В-третьих, функция <code>run</code> теперь возвращает значение <code>Ok</code> в случае успеха. В ярлыке функции <code>run</code> успешный вид объявлен как <code>()</code>, который означает, что нам нужно обернуть значение единичного вида в значение <code>Ok</code>. Данный правила написания <code>Ok(())</code> поначалу может показаться немного странным, но использование <code>()</code> выглядит как идиоматический способ указать, что мы вызываем <code>run</code> для его побочных эффектов; он не возвращает значение, которое нам нужно.</p>
<p>Когда вы запустите этот код, он собирается, но отобразит предупреждение:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust говорит, что наш код пренебрег <code>Result</code> значение и значение <code>Result</code> может указывать на то, что произошла ошибка. Но мы не проверяем, была ли ошибка и сборщик напоминает нам, что мы, вероятно, хотели здесь выполнить некоторый код обработки ошибок! Давайте исправим эту неполадку сейчас.</p>
<h4 id="Обработка-ошибок-возвращённых-из-run-в-main"><a class="header" href="#Обработка-ошибок-возвращённых-из-run-в-main">Обработка ошибок, возвращённых из <code>run</code> в <code>main</code></a></h4>
<p>Мы будем проверять и обрабатывать ошибки используя способику, подобную той, которую мы использовали для <code>Config::build</code> в приложении 12-10, но с небольшой разницей:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Мы используем <code>if let</code> вместо <code>unwrap_or_else</code> чтобы проверить, возвращает ли <code>run</code> значение <code>Err</code> и вызывается <code>process::exit(1)</code>, если это так. Функция <code>run</code> не возвращает значение, которое мы хотим развернуть способом <code>unwrap</code>, таким же образом как <code>Config::build</code> возвращает образец <code>Config</code>. Так как <code>run</code> возвращает <code>()</code> в случае успеха и мы заботимся только об обнаружении ошибки, то нам не нужно вызывать <code>unwrap_or_else</code>, чтобы вернуть развёрнутое значение, потому что оно будет только <code>()</code>.</p>
<p>Тело функций <code>if let</code> и <code>unwrap_or_else</code> одинаковы в обоих случаях: мы печатаем ошибку и выходим.</p>
<h3 id="Разделение-кода-на-библиотечный-ящик"><a class="header" href="#Разделение-кода-на-библиотечный-ящик">Разделение кода на библиотечный ящик</a></h3>
<p>Наш дело <code>minigrep</code> пока выглядит хорошо! Теперь мы разделим файл <em>src/main.rs</em> и поместим некоторый код в файл <em>src/lib.rs</em>. Таким образом мы сможем его проверять и чтобы в файле <em>src/main.rs</em> было меньшее количество полезных обязанностей.</p>
<p>Давайте перенесём весь код не относящийся к функции <code>main</code> из файла <em>src/main.rs</em> в новый файл <em>src/lib.rs</em>:</p>
<ul>
<li>Определение функции <code>run</code></li>
<li>Соответствующие указания <code>use</code></li>
<li>Определение устройства <code>Config</code></li>
<li>Определение функции <code>Config::build</code></li>
</ul>
<p>Содержимое <em>src/lib.rs</em> должно иметь ярлыки, показанные в приложении 12-13 (мы опуисполнения тела функций для краткости). Обратите внимание, что код не будет собираться пока мы не изменим <em>src/main.rs</em> в приложении 12-14.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Приложение 12-13. Перемещение <code>Config</code> и <code>run</code> в <em>src/lib.rs</em></span></p>
<p>Мы добавили определетель доступа <code>pub</code> к устройстве <code>Config</code>, а также её полям, к способу <code>build</code> и функции <code>run</code>. Теперь у нас есть библиотечный ящик, который содержит открытый API, который мы можем проверять!</p>
<p>Теперь нам нужно подключить код, который мы перемеисполнения в <em>src/lib.rs,</em> в область видимости двоичного ящика внутри <em>src/main.rs</em>, как показано в приложении 12-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Приложение 12-14. Использование ящика библиотеки <code>minigrep</code> внутри <em>src/main.rs</em></span></p>
<p>Мы добавляем <code>use minigrep::Config</code> для подключения вида <code>Config</code> из ящика библиотеки в область видимости двоичного ящика и добавляем к имени функции <code>run</code> приставка нашего ящика. Теперь все функции должны быть подключены и должны работать. Запустите программу с <code>cargo run</code> и убедитесь, что все работает правильно.</p>
<p>Уф! Было много работы, но мы настроены на будущий успех. Теперь проще обрабатывать ошибки и мы сделали код более состоящим из звеньев. С этого особенности почти вся наша работа будет выполняться внутри <em>src/lib.rs</em>.</p>
<p>Давайте воспользуемся этой новой выделения на звенья, сделав что-то, что было бы трудно со старым кодом, но легко с новым кодом: мы напишем несколько проверок!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Развитие-возможности-библиотеки-разработкой-на-основе-проверок"><a class="header" href="#Развитие-возможности-библиотеки-разработкой-на-основе-проверок">Развитие возможности библиотеки разработкой на основе проверок</a></h2>
<p>Теперь, когда мы извлекли логику в <em>src/lib.rs</em> и оставили разбор переменных приказной строки и обработку ошибок в <em>src/main.rs</em>, стало гораздо проще писать проверки для основной возможности нашего кода. Мы можем вызывать функции напрямую с различными переменнойми и проверить возвращаемые значения без необходимости вызова нашего двоичного файла из приказной строки.</p>
<p>В этом разделе в программу <code>minigrep</code> мы добавим логику поиска с использованием этапа разработки через проверка (TDD), который следует этим шагам:</p>
<ol>
<li>Напишите проверка, который завершается неудачей, и запустите его, чтобы убедиться, что он не сработал именно по той причине, которую вы ожидаете.</li>
<li>Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый проверку.</li>
<li>Выполните переработка кода кода, который вы только что добавили или изменили, и убедитесь, что проверки продолжают проходить.</li>
<li>Повторите с шага 1!</li>
</ol>
<p>Хотя это всего лишь один из многих способов написания программного обеспечения, TDD может помочь в разработке кода. Написание проверки перед написанием кода, обеспечивающего прохождение проверки, помогает поддерживать высокое покрытие проверкими на протяжении всего этапа разработки.</p>
<p>Мы проверим выполнение возможности, которая делает поиск строки запроса в содержимом файла и создание списка строк, соответствующих запросу. Мы добавим эту возможность в функцию под названием <code>search</code>.</p>
<h3 id="Написание-проверки-с-ошибкой"><a class="header" href="#Написание-проверки-с-ошибкой">Написание проверки с ошибкой</a></h3>
<p>Поскольку они нам больше не нужны, давайте удалим указания с <code>println!</code>, которые мы использовали для проверки поведения программы в <em>src/lib.rs</em> и <em>src/main.rs</em>. Затем в <em>src/lib.rs</em> мы добавим звено <code>tests</code> с проверочной функцией, как делали это в <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">главе 11</a><!-- ignore -->. Проверочная функция определяет поведение, которое мы хотим проверить в функции <code>search</code>: она должна принимать запрос и текст для поиска, а возвращать только те строки из текста, которые содержат запрос. В приложении 12-15 показан этот проверка, который пока не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
<p><span class="caption">Приложение 12-15: Создание безуспешного проверки для функции <code>search</code>, которую мы хотим создать</span></p>
<p>Этот проверка ищет строку <code>"duct"</code>. Текст, в котором мы ищем, состоит из трёх строк, только одна из которых содержит <code>"duct"</code> (обратите внимание, что обратная косая черта после открывающей двойной кавычки говорит Ржавчина не помещать символ новой строки в начало содержимого этого строкового записи). Мы проверяем, что значение, возвращаемое функцией <code>search</code>, содержит только ожидаемую нами строку.</p>
<p>Мы не можем запустить этот проверка и увидеть сбой, потому что проверка даже не собирается: функции <code>search</code> ещё не существует! В соответствии с принципами TDD мы добавим ровно столько кода, чтобы проверка собирался и запускался, добавив определение функции <code>search</code>, которая всегда возвращает пустой вектор, как показано в приложении 12-16. Потом проверка должен собраться и потерпеть неудачу при запуске, потому что пустой вектор не равен вектору, содержащему строку <code>"safe, fast, productive."</code></p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-16. Определение функции <code>search</code>, достаточное, чтобы проверка собрался</span></p>
<p>Заметьте, что в ярлыке <code>search</code> нужно явно указать время жизни <code>'a</code> для переменной <code>contents</code> и возвращаемого значения. Напомним из <a href="ch10-03-lifetime-syntax.html">Главы 10</a><!-- ignore -->, что свойства времени жизни указывают с временем жизни какого переменной связано время жизни возвращаемого значения. В данном случае мы говорим, что возвращаемый вектор должен содержать срезы строк, ссылающиеся на содержимое переменной <code>contents</code> (а не переменной <code>query</code>).</p>
<p>Другими словами, мы говорим Rust, что данные, возвращаемые функцией <code>search</code>, будут жить до тех пор, пока живут данные, переданные в функцию <code>search</code> через переменная <code>contents</code>. Это важно! Чтобы ссылки были действительными, данные, на которые ссылаются <em>с помощью</em> срезов тоже должны быть действительными; если сборщик предполагает, что мы делаем строковые срезы переменной <code>query</code>, а не переменной <code>contents</code>, он неправильно выполнит проверку безопасности.</p>
<p>Если мы забудем изложении времени жизни и попробуем собрать эту функцию, то получим следующую ошибку:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust не может понять, какой из двух переменных нам нужен, поэтому нужно сказать ему об этом. Так как <code>contents</code> является тем переменнаяом, который содержит весь наш текст, и мы хотим вернуть части этого текста, которые совпали при поиске, мы понимаем, что <code>contents</code> является переменнаяом, который должен быть связан с возвращаемым значением временем жизни.</p>
<p>Другие языки программирования не требуют от вас связывания в ярлыке переменных с возвращаемыми значениями, но после определённой опытов вам станет проще. Можете сравнить этот пример с разделом <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">«Проверка ссылок с временами жизни»</a><!-- ignore --> главы 10.</p>
<p>Запустим проверку:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: ["safe, fast, productive."]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Отлично. Наш проверка не сработал, как мы и ожидали. Давайте сделаем так, чтобы он срабатывал!</p>
<h3 id="Написание-кода-для-прохождения-проверки"><a class="header" href="#Написание-кода-для-прохождения-проверки">Написание кода для прохождения проверки</a></h3>
<p>Сейчас наш проверка не проходит, потому что мы всегда возвращаем пустой вектор. Чтобы исправить это и выполнить <code>search</code>, наша программа должна выполнить следующие шаги:</p>
<ul>
<li>Повторение по каждой строке содержимого.</li>
<li>Проверить, содержит ли данная строка искомую.</li>
<li>Если это так, добавить её в список значений, которые мы возвращаем.</li>
<li>Если это не так, ничего не делать.</li>
<li>Вернуть список итогов.</li>
</ul>
<p>Давайте проработаем каждый шаг, начиная с перебора строк.</p>
<h4 id="Перебор-строк-с-помощью-способа-lines"><a class="header" href="#Перебор-строк-с-помощью-способа-lines">Перебор строк с помощью способа <code>lines</code></a></h4>
<p>В Ржавчина есть полезный способ для построчной повторения строк, удобно названный <code>lines</code>, как показано в приложении 12-17. Обратите внимание, код пока не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-17: Повторение по каждой строке из <code>contents</code></span></p>
<p>Способ <code>lines</code> возвращает повторитель . Мы подробно поговорим об повторителях в <a href="ch13-02-iterators.html">Главе 13</a><!-- ignore -->, но вспомните, что вы видели этот способ использования повторителя в <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Приложении 3-5</a><!-- ignore -->, где мы использовали цикл <code>for</code> с повторителем, чтобы выполнить некоторый код для каждого элемента в собрания.</p>
<h4 id="Поиск-в-каждой-строке-текста-запроса"><a class="header" href="#Поиск-в-каждой-строке-текста-запроса">Поиск в каждой строке текста запроса</a></h4>
<p>Далее мы проверяем, содержит ли текущая строка нашу искомую строку. К счастью, у строк есть полезный способ <code>contains</code>, который именно это и делает! Добавьте вызов способа <code>contains</code> в функции <code>search</code>, как показано в приложении 12-18. Обратите внимание, что это все ещё не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-18. Добавление проверки, содержится ли <code>query</code> в строке</span></p>
<p>На данный мгновение мы наращиваем возможность. Чтобы заставить это собираться, нам нужно вернуть значение из тела функции, как мы указали в ярлыке функции.</p>
<h4 id="Сохранение-совпавшей-строки"><a class="header" href="#Сохранение-совпавшей-строки">Сохранение совпавшей строки</a></h4>
<p>Чтобы завершить эту функцию, нам нужен способ сохранить совпадающие строки, которые мы хотим вернуть. Для этого мы можем создать изменяемый вектор перед циклом <code>for</code> и вызывать способ <code>push</code> для сохранения <code>line</code> в векторе. После цикла <code>for</code> мы возвращаем вектор, как показано в приложении 12-19.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-19: Сохраняем совпавшие строки, чтобы впоследствии их можно было вернуть</span></p>
<p>Теперь функция <code>search</code> должна возвратить только строки, содержащие <code>query</code>, и проверка должен пройти. Запустим его:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Наш проверка пройден, значит он работает!</p>
<p>На этом этапе мы могли бы рассмотреть возможности изменения выполнения функции поиска, сохраняя прохождение проверок и поддерживая имеющуюся возможность. Код в функции поиска не так уж плох, но он не использует некоторые полезные функции повторителей. Вернёмся к этому примеру в <a href="ch13-02-iterators.html">главе 13</a><!-- ignore -->, где будем исследовать повторители подробно, и посмотрим как его улучшить.</p>
<h4 id="Использование-функции-search-в-функции-run"><a class="header" href="#Использование-функции-search-в-функции-run">Использование функции <code>search</code> в функции <code>run</code></a></h4>
<p>Теперь, когда функция <code>search</code> работает и проверена, нужно вызвать <code>search</code> из нашей функции <code>run</code>. Нам нужно передать значение <code>config.query</code> и <code>contents</code>, которые <code>run</code> читает из файла, в функцию <code>search</code>. Тогда <code>run</code> напечатает каждую строку, возвращаемую из <code>search</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Мы по-прежнему используем цикл <code>for</code> для возврата каждой строки из функции <code>search</code> и её печати.</p>
<p>Теперь вся программа должна работать! Давайте попробуем сначала запустить её со словом «frog», которое должно вернуть только одну строчку из стихотворения Эмили Дикинсон:</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Здорово! Теперь давайте попробуем слово, которое будет соответствовать нескольким строкам, например «body»:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>И наконец, давайте удостоверимся, что мы не получаем никаких строк, когда ищем слово, отсутствующее в стихотворении, например «monomorphization»:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Отлично! Мы создали собственную простое-исполнение обычного средства и научились тому, как внутренне выстроить</p>
<p>приложения. Мы также немного узнали о файловом вводе и выводе, временах жизни, проверке и разборе переменных приказной строки.</p>
<p>Чтобы завершить этот дело, мы кратко выполним пару вещей: как работать с переменными окружения и как печатать в обычный поток ошибок, обе из которых полезны при написании окно выводаных программ.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Работа-с-переменными-окружения"><a class="header" href="#Работа-с-переменными-окружения">Работа с переменными окружения</a></h2>
<p>Мы улучшим <code>minigrep</code>, добавив дополнительную функцию: возможность для поиска без учёта регистра, которую пользователь может включить с помощью переменной среды окружения. Мы могли бы сделать эту функцию свойствоом приказной строки и потребовать, чтобы пользователи вводили бы её каждый раз при её применении, но вместо этого мы будем использовать переменную среды окружения, что позволит нашим пользователям устанавливать переменную среды один раз и все поиски будут не чувствительны к регистру в этом окно вызоваьном сеансе.</p>
<h3 id="Написание-ошибочного-проверки-для-функции-search-с-учётом-регистра"><a class="header" href="#Написание-ошибочного-проверки-для-функции-search-с-учётом-регистра">Написание ошибочного проверки для функции <code>search</code> с учётом регистра</a></h3>
<p>Мы, во-первых, добавим новую функцию <code>search_case_insensitive</code>, которую мы будем вызывать, когда переменная окружения содержит значение. Мы продолжим следовать этапу TDD, поэтому первый шаг - это снова написать не проходящий проверку. Мы добавим новый проверка для новой функции <code>search_case_insensitive</code> и переименуем наш старый проверка из <code>one_result</code> в <code>case_sensitive</code>, чтобы прояснить различия между двумя проверкими, как показано в приложении 12-20.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Приложение 12-20. Добавление нового не проходящего проверки для функции поиска нечувствительной к регистру, которую мы собираемся добавить</span></p>
<p>Обратите внимание, что мы также отредактировали содержимое переменной <code>contents</code> из старого проверки. Мы добавили новую строку с текстом <code>"Duct tape."</code>, используя заглавную D, которая не должна соответствовать запросу <code>"duct"</code> при поиске с учётом регистра. Такое изменение старого проверки помогает избежать случайного нарушения возможности поиска чувствительного к регистру, который мы уже выполнили. Этот проверка должен пройти сейчас и должен продолжать выполняться успешно, пока мы работаем над поиском без учёта регистра.</p>
<p>Новый проверка для поиска <em>нечувствительного</em> к регистру использует <code>"rUsT"</code> качестве строки запроса. В функции <code>search_case_insensitive</code>, которую мы собираемся выполнить, запрос <code>"rUsT"</code> должен соответствовать строке содержащей <code>"Rust:"</code> с большой буквы R и соответствовать строке <code>"Trust me."</code>, хотя обе имеют разные регистры из запроса. Это наш не проходящий проверка, он не собирается, потому что мы ещё не определили функцию <code>search_case_insensitive</code>. Не стесняйтесь добавлять скелет выполнение, которая всегда возвращает пустой вектор, подобно тому, как мы это делали для функции <code>search</code> в приложении 12-16, чтобы увидеть сборку проверки и его сбой.</p>
<h3 id="Выполнение-функции-search_case_insensitive"><a class="header" href="#Выполнение-функции-search_case_insensitive">Выполнение функции <code>search_case_insensitive</code></a></h3>
<p>Функция <code>search_case_insensitive</code>, показанная в приложении 12-21, будет почти такая же, как функция <code>search</code>. Разница лишь в том, что текст будет в нижнем регистре для <code>query</code> и для каждой <code>line</code>, так что для любого регистра входных переменных это будет тот же случай, когда мы проверяем, содержит ли строка запрос.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-21. Определение функции <code>search_case_insensitive</code> с уменьшением регистра строки запроса и строки содержимого перед их сравнением</span></p>
<p>Сначала преобразуем в нижний регистр строку <code>query</code> и сохраняем её в затенённой переменной с тем же именем. Вызов <code>to_lowercase</code> для строки запроса необходим, так что независимо от того, будет ли пользовательский запрос <code>"rust"</code> , <code>"RUST"</code>, <code>"Rust"</code> или <code>"rUsT"</code>, мы будем преобразовывать запрос к <code>"rust"</code> и делать значение нечувствительным к регистру. Хотя <code>to_lowercase</code> будет обрабатывать Unicode, он не будет точным на 100%. Если бы мы писали существующее приложение, мы бы хотели проделать здесь немного больше работы, но этот раздел посвящён переменным среды, а не Unicode, поэтому мы оставим это здесь.</p>
<p>Обратите внимание, что <code>query</code> теперь имеет вид <code>String</code>, а не срез строки, потому что вызов <code>to_lowercase</code> создаёт новые данные, а не ссылается на существующие.  К примеру, запрос: <code>"rUsT"</code> это срез строки не содержащий строчных букв <code>u</code> или <code>t</code>, которые мы можем использовать, поэтому мы должны выделить новую <code>String</code>, содержащую <code>«rust»</code>. Когда мы передаём запрос <code>query</code> в качестве переменной способа <code>contains</code>, нам нужно добавить знак, поскольку ярлык <code>contains</code>, определена для приёмы среза строки.</p>
<p>Затем мы добавляем вызов <code>to_lowercase</code> для каждой строки <code>line</code> для преобразования к нижнему регистру всех символов. Теперь, когда мы преобразовали <code>line</code> и <code>query</code> в нижний регистр, мы найдём совпадения независимо от того, в каком регистре находится переменная с запросом.</p>
<p>Давайте посмотрим, проходит ли эта выполнение проверки:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Отлично! Проверки прошли. Теперь давайте вызовем новую функцию <code>search_case_insensitive</code> из функции <code>run</code>. Во-первых, мы добавим свойство настройке в устройство <code>Config</code> для переключения между поиском с учётом регистра и без учёта регистра. Добавление этого поля приведёт к ошибкам сборщика, потому что мы ещё нигде не объявим это поле:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Мы добавили поле <code>ignore_case</code>, которое содержит логическое значение. Далее нам нужна функция <code>run</code>, чтобы проверить значение поля <code>ignore_case</code> и использовать его, чтобы решить, вызывать ли функцию <code>search</code> или функцию <code>search_case_insensitive</code>, как показано в приложении 12-22. Этот код все ещё не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-22. Вызов либо <code>search</code>, либо <code>search_case_insensitive</code> на основе значения в <code>config.ignore_case</code></span></p>
<p>Наконец, нам нужно проверить переменную среды. Функции для работы с переменными среды находятся в звене <code>env</code> встроенной библиотеки, поэтому мы хотим подключить этот звено в область видимости в верхней части <em>src/lib.rs</em>. Затем мы будем использовать функцию <code>var</code> из звена <code>env</code> для проверки установлено ли любое значение в переменной среды с именем <code>IGNORE_CASE</code>, как показано в приложении 12-23.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 12-23. Проверка переменной среды с именем <code>IGNORE_CASE</code></span></p>
<p>Здесь мы создаём новую переменную <code>ignore_case</code>. Чтобы установить её значение, мы вызываем функцию <code>env::var</code> и передаём ей имя переменной окружения <code>IGNORE_CASE</code>. Функция <code>env::var</code> возвращает <code>Result</code>, который будет успешным исходом <code>Ok</code> содержащий значение переменной среды, если переменная среды установлена. Он вернёт исход <code>Err</code>, если переменная окружения не установлена.</p>
<p>Мы используем способ <code>is_ok</code> у <code>Result</code>, чтобы проверить установлена ли переменная окружения, что будет означать, что программа должна выполнить поиск без учёта регистра. Если переменная среды <code>IGNORE_CASE</code> не содержит любого значения, то <code>is_ok</code> вернёт значение false и программа выполнит поиск c учётом регистра. Мы не заботимся о <em>значении</em> переменной среды, нас важно только установлена она или нет, поэтому мы проверяем <code>is_ok</code>, а не используем <code>unwrap</code>, <code>expect</code> или любой другой способ, который мы видели у <code>Result</code>.</p>
<p>Мы передаём значение переменной <code>ignore_case</code> образцу <code>Config</code>, чтобы функция <code>run</code> могла прочитать это значение и решить, следует ли вызывать <code>search</code> или <code>search_case_insensitive</code>, как мы выполнили в приложении 12-22.</p>
<p>Давайте попробуем! Во-первых, мы запустим нашу программу без установленной переменной среды и с помощью значения запроса <code>to</code>, который должен соответствовать любой строке, содержащей слово «to» в нижнем регистре:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Похоже, все ещё работает! Теперь давайте запустим программу с <code>IGNORE_CASE</code>, установленным в <code>1</code>, но с тем же значением запроса <code>to</code>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Если вы используете PowerShell, вам нужно установить переменную среды и запустить программу двумя приказми, а не одной:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Это заставит переменную окружения <code>IGNORE_CASE</code> сохраниться до конца сеанса работы окне вывода. Переменную можно отключить с помощью приказы <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Мы должны получить строки, содержащие «to», которые могут иметь заглавные буквы:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Отлично, мы также получили строки, содержащие «To»! Наша программа <code>minigrep</code> теперь может выполнять поиск без учёта регистра, управляемая переменной среды. Теперь вы знаете, как управлять свойствами, заданными с помощью переменных приказной строки или переменных среды.</p>
<p>Некоторые программы допускают использование переменных <em>и</em> переменных среды для одной и той же настройке. В таких случаях программы решают, что из них имеет больший приоритет. Для другого самостоятельного упражнения попробуйте управлять чувствительностью к регистру с помощью переменной приказной строки или переменной окружения. Решите, переменная приказной строки или переменная среды будет иметь приоритет, если программа выполняется со значениями "учитывать регистр" в одном случае, и "пренебрегать регистр" в другом.</p>
<p>Звено <code>std::env</code> содержит много других полезных функций для работы с переменными среды: ознакомьтесь с его документацией, чтобы узнать доступные.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Запись-сообщений-ошибок-в-поток-ошибок-вместо-принятого-потока-вывода"><a class="header" href="#Запись-сообщений-ошибок-в-поток-ошибок-вместо-принятого-потока-вывода">Запись сообщений ошибок в поток ошибок вместо принятого потока вывода</a></h2>
<p>В данный мгновение мы записываем весь наш вывод в окно вызова, используя функцию <code>println!</code>. В большинстве окно вызоваов предоставлено два вида вывода: <em>обычный поток вывода</em> ( <code>stdout</code> ) для общей сведений и <em>обычный поток ошибок</em> ( <code>stderr</code> ) для сообщений об ошибках. Это различие позволяет пользователям выбирать, направлять ли успешный вывод программы в файл, но при этом выводить сообщения об ошибках на экран.</p>
<p>Функция  <code>println!</code> может печатать только в обычный вывод, поэтому мы должны использовать что-то ещё для печати в обычный поток ошибок.</p>
<h3 id="Проверка-куда-записываются-ошибки"><a class="header" href="#Проверка-куда-записываются-ошибки">Проверка, куда записываются ошибки</a></h3>
<p>Во-первых, давайте посмотрим, как содержимое, напечатанное из <code>minigrep</code> в настоящее время записывается в обычный вывод, включая любые сообщения об ошибках, которые мы хотим вместо этого записать в обычный поток ошибок. Мы сделаем это, перенаправив обычный поток вывода в файл и намеренно вызовем ошибку. Мы не будем перенаправлять обычный поток ошибок, поэтому любой содержание, отправленный в поток принятых ошибок будет продолжать отображаться на экране.</p>
<p>Ожидается, что программы приказной строки будут отправлять сообщения об ошибках в обычный поток ошибок, поэтому мы все равно можем видеть сообщения об ошибках на экране, даже если мы перенаправляем обычный поток вывода в файл. Наша программа в настоящее время не ведёт себя правильно: мы увидим, что она сохраняет вывод сообщения об ошибке в файл!</p>
<p>Чтобы отобразить это поведение, мы запустим программу с помощью <code>&gt;</code> и именем файла <em>output.txt</em> в который мы хотим перенаправить обычный поток вывода. Мы не будем передавать никаких переменных, что должно вызвать ошибку:</p>
<pre><code class="language-console">$  cargo run &gt; output.txt
</code></pre>
<p>правила написания <code>&gt;</code> указывает оболочке записывать содержимое принятого вывода в <em>output.txt</em> вместо экрана. Мы не увидели сообщение об ошибке, которое мы ожидали увидеть на экране, так что это означает, что оно должно быть в файле. Вот что содержит <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Да, наше сообщение об ошибке выводится в обычный вывод. Гораздо более полезнее, чтобы подобные сообщения об ошибках печатались в встроенной поток ошибок, поэтому в файл попадают только данные из успешного запуска. Мы поменяем это.</p>
<h3 id="Печать-ошибок-в-поток-ошибок"><a class="header" href="#Печать-ошибок-в-поток-ошибок">Печать ошибок в поток ошибок</a></h3>
<p>Мы будем использовать код в приложении 12-24, чтобы изменить способ вывода сообщений об ошибках. Из-за переработки кода, который мы делали ранее в этой главе, весь код, который печатает сообщения об ошибках, находится в одной функции: <code>main</code>. Обычная библиотека предоставляет макрос <code>eprintln!</code>который печатает в обычный поток ошибок, поэтому давайте изменим два места, где мы вызывали <code>println!</code> для печати ошибок, чтобы использовать <code>eprintln!</code> вместо этого.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}</code></pre>
<p><span class="caption">Запись сообщений об ошибках в Standard Error вместо Standard Output используя <code>eprintln!</code></span></p>
<p>Давайте снова запустим программу таким же образом, без каких-либо переменных и перенаправим обычный вывод с помощью <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Теперь мы видим ошибку на экране и <em>output.txt</em> не содержит ничего, что мы ожидаем от программы приказной строки.</p>
<p>Давайте снова запустим программу с переменнойми, которые не вызывают ошибку, но все же перенаправляют обычный вывод в файл, например так:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Мы не увидим никакого вывода в окно вызова, а <em>output.txt</em> будет содержать наши итоги:</p>
<p><span class="filename">Файл: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Это отображает, что в зависимости от случаи мы теперь используем обычный поток вывода для успешного текста и обычный поток ошибок для вывода ошибок.</p>
<h2 id="Итоги-9"><a class="header" href="#Итоги-9">Итоги</a></h2>
<p>В этой главе были повторены некоторые основные подходы, которые вы изучили до сих пор и было рассказано, как выполнять обычные действия ввода-вывода в Rust. Используя переменные приказной строки, файлы, переменные среды и макрос<code>eprintln!</code> для печати ошибок и вы теперь готовы писать приложения приказной строки. В сочетании с  подходами из предыдущих главах, ваш код будет хорошо согласован, будет эффективно хранить данные в соответствующих устройствах, хорошо обрабатывать ошибки и хорошо проверяться.</p>
<p>Далее мы рассмотрим некоторые возможности Rust, на которые повлияли полезные  языки: замыкания и повторители.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Полезные--возможности-языка-повторители-и-замыкания"><a class="header" href="#Полезные--возможности-языка-повторители-и-замыкания">Полезные  возможности языка: повторители и замыкания</a></h1>
<p>Внешний вид языка Ржавчина черпал вдохновение из многих других языков и техник, среди которых значительное влияние оказало <em>функциональное программирование</em>. Программирование в функциональном исполнении подразумевает использование функций взначении предметов, передавая их в качестве переменных, возвращая их из других функций, присваивая их переменным для последующего выполнения и так далее.</p>
<p>В этой главе мы не будем рассуждать о том, что из себя представляет функциональное программирование, а обсудим возможности Rust, присущие многим языкам, которые принято называть функциональными.</p>
<p>Более подробно мы поговорим про:</p>
<ul>
<li><em>Замыкания</em> - устройства, подобные функциям, которые можно помещать в переменные</li>
<li><em>Повторители</em> — способ обработки последовательности элементов,</li>
<li>То, как, используя замыкания и повторители, улучшить работу с действиеми ввода-вывода в деле из главы 12</li>
<li>Производительность замыканий и повторителей (спойлер: они быстрее, чем вы думаете!)</li>
</ul>
<p>Мы уже рассмотрели другие возможности Rust, такие как сопоставление с образцом и перечисления, которые также появились под влиянием функционального исполнения. Поскольку освоение замыканий и повторителей — важная часть написания идиоматичного, быстрого кода на Rust, мы посвятим им всю эту главу.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="Замыкания-анонимные-функции-которые-запечатлевают-захватывают-своё-окружение"><a class="header" href="#Замыкания-анонимные-функции-которые-запечатлевают-захватывают-своё-окружение">Замыкания: анонимные функции, которые запечатлевают ("захватывают") своё окружение</a></h2>
<p>Замыкания в Ржавчина - это анонимные функции, которые можно сохранять в переменных или передавать в качестве переменных другим функциям. Вы можете создать замыкание в одном месте, а затем вызвать его в каком-нибудь другом, чтобы выполнить обработку в ином среде. В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены. Мы выполним, как эти функции замыканий открывают возможности для повторного использования кода и изменения его поведения.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="Захват-переменных-окружения-с-помощью-замыкания"><a class="header" href="#Захват-переменных-окружения-с-помощью-замыкания">Захват переменных окружения с помощью замыкания</a></h3>
<p>Сначала мы рассмотрим, как с помощью замыканий можно использовать предметы из области, в которой они вместе были определены, для их последующего использования. Вот сценарий: Время от времени наша предприятие по производству футболок в качестве акции дарит эксклюзивные футболки, выпущенные ограниченным тиражом, каким-нибудь пользователям из нашего списка рассылки. Люди из списка рассылки при желании могут выбрать любимый цвет в своём профиле. Если человек, выбранный для получения бесплатной футболки, указал свой любимый цвет, он получает футболку этого цвета. Если человек не указал свой любимый цвет, он получит рубашку того цвета, которых у предприятия на данный мгновение больше всего.</p>
<p>Существует множество способов выполнить это. В данном примере мы будем использовать перечисление <code>ShirtColor</code>, которое может быть двух исходов <code>Red</code> и <code>Blue</code> (для простоты ограничим количество доступных цветов этими двумя). Запасы предприятия мы представим устройством <code>Inventory</code>, которая состоит из поля <code>shirts</code>, содержащего <code>Vec&lt;ShirtColor&gt;</code>, в котором перечислены рубашки тех цветов, которые есть в наличии. Способ <code>giveaway</code>, определённый в <code>Inventory</code>, принимает необязательный свойство - цвет, предпочитаемый пользователем, выбранным для получения бесплатной рубашки, и возвращает тот цвет рубашки, который он получит в действительности. Эта схема показана в приложении 13-1:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
<p><span class="caption">Приложение 13-1: Случаей с раздачей рубашек предприятием</span></p>
<p>В магазине <code>store</code>, определённом в <code>main</code>, осталось две синие и одна красная рубашки для этой ограниченной акции. Мы вызываем способ <code>giveaway</code> для пользователя предпочитающего красную рубашку и для пользователя без каких-либо предпочтений.</p>
<p>Опять же, этот код мог быть выполнен множеством способов, но в данном случае, чтобы сосредоточиться на замыканиях, мы придерживались изученных ранее подходов, за исключением тела способа <code>giveaway</code>, в котором используется замыкание. В способе <code>giveaway</code> мы получаем пользовательское предпочтение цвета как свойство вида <code>Option&lt;ShirtColor&gt;</code> и вызываем способ <code>unwrap_or_else</code> на <code>user_preference</code>. Способ <a data-md-type="raw_html" href="../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> перечисления <code>Option&lt;T&gt;</code></a><!-- ignore --> определён встроенной библиотекой. Он принимает один переменная: замыкание без переменных, которое возвращает значение <code>T</code> (преобразуется в вид значения, которое окажется в исходе <code>Some</code> перечисления <code>Option&lt;T&gt;</code>, в нашем случае <code>ShirtColor</code>). Если <code>Option&lt;T&gt;</code> окажется исходом <code>Some</code>, <code>unwrap_or_else</code> вернёт значение из <code>Some</code>. А если <code>Option&lt;T&gt;</code> будет является исходом <code>None</code>, <code>unwrap_or_else</code> вызовет замыкание и вернёт значение, возвращённое замыканием.</p>
<p>В качестве переменной <code>unwrap_or_else</code> мы передаём замыкание <code>|| self.most_stocked()</code>. Это замыкание, которое не принимает никаких свойств (если бы у замыкания были свойства, они были бы перечислены между двумя вертикальными полосами). В теле замыкания вызывается <code>self.most_stocked()</code>. Здесь мы определили замыкание, а выполнение <code>unwrap_or_else</code> такова, что выполнится оно позднее, когда потребуется получить итог.</p>
<p>Выполнение этого кода выводит:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Важной особенностью здесь является то, что мы передали замыкание, которое вызывает <code>self.most_stocked()</code> текущего образца <code>Inventory</code>. Обычной библиотеке не нужно знать ничего о видах <code>Inventory</code> или <code>ShirtColor</code>, которые мы определили, или о логике, которую мы хотим использовать в этом сценарии. Замыкание определяет неизменяемую ссылку на <code>self</code> <code>Inventory</code> и передаёт её с указанным нами кодом в способ <code>unwrap_or_else</code>. А вот функции не могут определять своё окружение таким образом.</p>
<h3 id="Выведение-и-изложение-видов-замыкания"><a class="header" href="#Выведение-и-изложение-видов-замыкания">Выведение и изложение видов замыкания</a></h3>
<p>Есть и другие различия между функциями и замыканиями. Замыкания обычно не требуют определенния видов входных свойств или возвращаемого значения, как это делается в функциях <code>fn</code>. Изложения видов требуются для функций, потому что виды являются частью явного внешней оболочки, предоставляемого пользователям. Жёсткое определение таких внешних оболочек важно для того, чтобы все были согласованы в том, какие виды значений использует и возвращает функция. А вот замыкания, напротив, не употребляются взначении подобных открытых внешних оболочек: они хранятся в переменных, используются не имея имени и незримо для пользователей нашей библиотеки.</p>
<p>Замыкания, как правило, небольшие и уместны в каком-то узконаправленном среде, а не в произвольных случаях. В этих ограниченных средах сборщик может вывести виды свойств и возвращаемого вида, подобно тому, как он может вывести виды большинства переменных (есть редкие случаи, когда сборщику также нужны изложении видов замыканий).</p>
<p>Как и в случае с переменными, мы можем добавить изложении видов, если хотим повысить ясность и чёткость описания ценой увеличения многословности, большей чем это необходимо. Определение видов для замыкания будет выглядеть как определение, показанное в приложении 13-2. В этом примере мы определяем замыкание и храним его в переменной, а не определяем замыкание в том месте, куда мы передаём его в качестве переменной, как это было в приложении 13-1.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-2: Добавление необязательных наставлений видов свойств и возвращаемых значений в замыкании</span></p>
<p>С добавлением наставлений видов правила написания замыканий выглядит более похожим на правила написания функций. Здесь мы, для сравнения, определяем функцию, которая добавляет 1 к своему свойству, и замыкание, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, что правила написания замыкания похож на правила написания функции, за исключением использования труб (вертикальная черта) и количества необязательного правил написания:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>В первой строке показано определение функции, а во второй - полностью определенное определение замыкания. В третьей строке мы удаляем изложении видов из определения замыкания. В четвёртой строке мы убираем скобки, которые являются необязательными, поскольку тело замыкания содержит только одну действие. Это всё правильные определения, которые будут иметь одинаковое поведение при вызове. Строки <code>add_one_v3</code> и <code>add_one_v4</code> требуют, чтобы замыкания были вычислены до сборки, поскольку виды будут выведены из их использования. Это похоже на <code>let v = Vec::new();</code>, когда в <code>Vec</code> необходимо вставить либо изложении видов, либо значения некоторого вида, чтобы Ржавчина смог вывести вид.</p>
<p>Для определений замыкания сборщик выводит определенные виды для каждого из свойств и возвращаемого значения. Например, в приложении 13-3 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве свойства. Это замыкание не очень полезно, кроме как для целей данного примера. Обратите внимание, что мы не добавили в определение никаких наставлений видов. Поскольку наставлений видов нет, мы можем вызвать замыкание для любого вида, что мы и сделали в первый раз с <code>String</code>. Если затем мы попытаемся вызвать <code>example_closure</code> для целого числа, мы получим ошибку.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-3: Попытка вызова замыкания, виды которого выводятся из двух разных видов</span></p>
<p>Сборщик вернёт нам вот такую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>При первом вызове <code>example_closure</code> со значением <code>String</code> сборщик определяет вид <code>x</code> и возвращаемый вид замыкания как <code>String</code>. Эти виды затем определятся в замыкании в <code>example_closure</code>, и мы получаем ошибку вида при следующей попытке использовать другой вид с тем же замыканием.</p>
<h3 id="Захват-ссылок-или-передача-владения"><a class="header" href="#Захват-ссылок-или-передача-владения">Захват ссылок или передача владения</a></h3>
<p>Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать свойства: заимствование неизменяемых, заимствование изменяемых и получение владения. Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело функции делает с полученными значениями.</p>
<p>В приложении 13-4 мы определяем замыкание, которое захватывает неизменяемую ссылку на вектор с именем <code>list</code>, поскольку неизменяемой ссылки достаточно для печати значения:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<p><span class="caption">Приложение 13-4: Определение и вызов замыкания, которое захватывает неизменяемую ссылку</span></p>
<p>Этот пример также отображает, то что переменная может быть привязана к определению замыкания, и в дальнейшем мы можем вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем функции.</p>
<p>Поскольку мы можем иметь несколько неизменяемых ссылок на <code>list</code> одновременно, <code>list</code> остаётся доступным из кода до определения замыкания, после определения замыкания, а также до вызова замыкания и после. Этот код собирается, выполняется и печатает:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/carolnichols/rust/book/tmp/listings/ch13-functional-features/listing-13-04)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>В следующем приложении 13-5 мы изменили тело замыкания так, чтобы оно добавляло элемент в вектор <code>list</code>. Теперь замыкание захватывает изменяемую ссылку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<p><span class="caption">Приложение 13-5. Определение и вызов замыкания, захватывающего изменяемую ссылку</span></p>
<p>Этот код собирается, запускается и печатает:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/carolnichols/rust/book/tmp/listings/ch13-functional-features/listing-13-05)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Обратите внимание, что между определением и вызовом замыкания <code>borrows_mutably</code> больше нет <code>println!</code>: когда определяется <code>borrows_mutably</code>, оно захватывает изменяемую ссылку на <code>list</code>. После вызова замыкания мы больше не используем его, поэтому изменяемое заимствование заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для печати недоступно, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда <code>println!</code> и посмотрите, какое сообщение об ошибке вы получите!</p>
<p>Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет кода, требующего владения, вы можете использовать ключевое слово <code>move</code> перед списком свойств.</p>
<p>Эта техника в основном полезна при передаче замыкания новому потоку, чтобы переместить данные так, чтобы они принадлежали новому потоку. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о одновременности, а пока давайте вкратце рассмотрим порождение нового потока с помощью замыкания, в котором используется ключевое слово <code>move</code>. В приложении 13-6 показан код из приложения 13-4, измененный для печати вектора в новом потоке, а не в основном потоке:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 13-6: Использование <code>move</code> для принуждения замыкания потока принять на себя владение <code>list</code></span></p>
<p>Мы порождаем новый поток, передавая ему в качестве переменной замыкание для выполнения. Тело замыкания распечатывает список. В приложении 13-4 замыкание захватило <code>list</code> только с помощью неизменяемой ссылки, потому что это наименьше необходимый доступ к <code>list</code> для его печати. В этом примере, несмотря на то, что тело замыкания по-прежнему требует только неизменяемой ссылки, нам нужно указать, что <code>list</code> должен быть перемещён в замыкание, поместив ключевое слово <code>move</code> в начало определения замыкания. Новый поток может завершиться раньше, чем завершится основной поток, или основной поток может завершиться первым. Если основной поток сохранил владение <code>list</code>, но завершился раньше нового потока и удалил <code>list</code>, то неизменяемая ссылка в потоке будет недействительной. Поэтому сборщик требует, чтобы <code>list</code> был перемещён в замыкание, переданное новому потоку, чтобы ссылка была действительной. Попробуйте убрать ключевое слово <code>move</code> или использовать <code>list</code> в основном потоке после определения замыкания и посмотрите, какие ошибки сборщика вы получите!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="Перемещение-захваченных-значений-из-замыканий-и-особенности-fn"><a class="header" href="#Перемещение-захваченных-значений-из-замыканий-и-особенности-fn">Перемещение захваченных значений из замыканий и особенности <code>Fn</code></a></h3>
<p>После того, как замыкание захватило ссылку или владение значением из среды, в которой оно определено (тем самым влияя на то, что перемещается <em>в</em> замыкание), код в теле замыкания определяет, что происходит со ссылками или значениями, в мгновение последующего выполнения замыкания (тем самым влияя на то, что перемещается <em>из</em> замыкания). Тело замыкания может делать любое из следующих действий: перемещать захваченное значение из замыкания, изменять захваченное значение, не перемещать и не изменять значение или вообще ничего не захватывать из среды.</p>
<p>То, как замыкание получает и обрабатывает значения из своего окружения, указывает на то, какие особенности выполняет замыкание, а с помощью особенностей функции и устройства могут определять, какие виды замыканий они могут использовать. Замыканиям самостоятельно присваивается выполнение одного, двух или всех трёх из нижеперечисленных особенностей <code>Fn</code>, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:</p>
<ol>
<li><code>FnOnce</code> применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания выполняют по крайней мере этот особенность, потому что все замыкания могут быть вызваны. Замыкание, которое перемещает захваченные значения из своего тела, выполняет только <code>FnOnce</code> и ни один из других признаков <code>Fn</code>, потому что оно может быть вызвано только один раз.</li>
<li><code>FnMut</code> применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но могут изменять захваченные значения. Такие замыкания могут вызываться более одного раза.</li>
<li><code>Fn</code> применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не изменяют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения. Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.</li>
</ol>
<p>Давайте рассмотрим определение способа <code>unwrap_or_else</code> у <code>Option&lt;T&gt;</code>, который мы использовали в приложении 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Напомним, что <code>T</code> - это гибкий вид, отображающий вид значения в <code>Some</code> исходе <code>Option</code>. Этот вид <code>T</code> также является возвращаемым видом функции <code>unwrap_or_else</code>: например, код, вызывающий <code>unwrap_or_else</code> у <code>Option&lt;String&gt;</code>, получит <code>String</code>.</p>
<p>Далее, обратите внимание, что функция <code>unwrap_or_else</code> имеет дополнительный свойство гибкого вида <code>F</code>. Здесь <code>F</code> - это вид входного свойства <code>f</code>, который является замыканием, заданным нами при вызове <code>unwrap_or_else</code>.</p>
<p>Ограничением особенности, заданным для обобщённого вида <code>F</code>, является <code>FnOnce() -&gt; T</code>, что означает, что <code>F</code> должен вызываться один раз, не принимать никаких переменных и возвращать <code>T</code>. Использование <code>FnOnce</code> в ограничении особенности говорит о том, что <code>unwrap_or_else</code> должен вызывать <code>f</code> не более одного раза. В теле <code>unwrap_or_else</code> мы видим, что если <code>Option</code> будет равен <code>Some</code>, то <code>f</code> не будет вызван. Если же значение <code>Option</code> будет равным <code>None</code>, то <code>f</code> будет вызван один раз. Поскольку все замыкания выполняют <code>FnOnce</code>, <code>unwrap_or_else</code> принимает самые разные виды замыканий и является настолько гибким, насколько это возможно.</p>
<blockquote>
<p>Примечание: Функции также могут выполнить все три особенности <code>Fn</code>. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем передавать имя какой-либо функции, а не замыкания, когда нам нужно что-то, выполняющее один из особенностей <code>Fn</code>. Например, для значения <code>Option&lt;Vec&lt;T&gt;&gt;</code> мы можем вызвать <code>unwrap_or_else(Vec::new)</code>, чтобы получить новый пустой вектор, если значение окажется <code>None</code>.</p>
</blockquote>
<p>Теперь рассмотрим способ встроенной библиотеки <code>sort_by_key</code>, определённый у срезов, чтобы увидеть, чем он отличается от <code>unwrap_or_else</code> и почему <code>sort_by_key</code> использует <code>FnMut</code> вместо <code>FnOnce</code> для ограничения особенности. Замыкание принимает единственный переменная в виде ссылки на текущий элемент в рассматриваемом срезе и возвращает значение вида <code>K</code>, к которому применима сортировка. Эта функция полезна, когда вы хотите отсортировать срез по определённому свойству каждого элемента. В приложении 13-7 у нас есть список образцов <code>Rectangle</code>, и мы используем <code>sort_by_key</code>, чтобы упорядочить их по свойству <code>width</code> от меньшего к большему:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<p><span class="caption">Приложение 13-7: Использование <code>sort_by_key</code> для сортировки прямоугольников по ширине</span></p>
<p>Этот код печатает:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>Причина, по которой <code>sort_by_key</code> определена как принимающая замыкание <code>FnMut</code>, заключается в том, что она вызывает замыкание несколько раз: по одному разу для каждого элемента в срезе. Замыкание <code>|r| r.width</code> не захватывает, не изменяет и не перемещает ничего из своего окружения, поэтому оно удовлетворяет требованиям связанности признаков.</p>
<p>И наоборот, в приложении 13-8 показан пример замыкания, которое выполняет только признак <code>FnOnce</code>, потому что оно перемещает значение из среды. Сборщик не позволит нам использовать это замыкание с <code>sort_by_key</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
<p><span class="caption">Приложение 13-8: Попытка использовать замыкание <code>FnOnce</code> с <code>sort_by_key</code></span></p>
<p>Это надуманный, замысловатый способ (который не работает) подсчёта количества вызовов <code>sort_by_key</code> при сортировке <code>list</code>. Этот код пытается выполнить подсчёт, перемещая <code>value</code> - <code>String</code> из окружения замыкания - в вектор <code>sort_operations</code>. Замыкание захватывает <code>value</code>, затем перемещает <code>value</code> из замыкания, передавая владение на <code>value</code> вектору <code>sort_operations</code>. Это замыкание можно вызвать один раз; попытка вызвать его второй раз не сработает, потому что <code>value</code> уже не будет находиться в той среде, из которой его можно будет снова поместить в <code>sort_operations</code>! Поэтому это замыкание выполняет только <code>FnOnce</code>. Когда мы попытаемся собрать этот код, мы получим ошибку сообщающую о том что <code>value</code> не может быть перемещено из замыкания, потому что замыкание должно выполнить <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>Ошибка указывает на строку в теле замыкания, которая перемещает <code>value</code> из окружения. Чтобы исправить это, нужно изменить тело замыкания так, чтобы оно не перемещало значения из окружения. Для подсчёта количества вызовов <code>sort_by_key</code> более простым способом является хранение счётчика в окружении и увеличение его значения в теле замыкания. Замыкание в приложении 13-9 работает с <code>sort_by_key</code>, поскольку оно определяет только изменяемую ссылку на счётчик <code>num_sort_operations</code> и поэтому может быть вызвано более одного раза:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}</code></pre></pre>
<p><span class="caption">Приложение 13-9: Использование замыкания <code>FnMut</code> с <code>sort_by_key</code> разрешено</span></p>
<p>Особенности <code>Fn</code> важны при определении или использовании функций или видов, использующих замыкания. В следующем разделе мы обсудим повторители. Многие способы повторителей принимают переменные в виде замыканий, поэтому не забывайте об этих подробностях, пока мы продвигаемся дальше!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обработка-последовательности-элементов-с-помощью-повторителей"><a class="header" href="#Обработка-последовательности-элементов-с-помощью-повторителей">Обработка последовательности элементов с помощью повторителей</a></h2>
<p>Использование образца Повторитель  помогает при необходимости поочерёдного выполнения какой-либо действия над элементами последовательности. Повторитель  отвечает за логику перебора элементов и определение особенности завершения последовательности. Используя повторители, вам не нужно самостоятельно выполнить всю эту логику.</p>
<p>В Ржавчина повторители <em>ленивые (lazy)</em>, то есть они не делают ничего, пока вы не вызовете особые способы, потребляющие повторитель , чтобы задействовать его. Например, код в приложении 13-10 создаёт повторитель элементов вектора <code>v1</code>, вызывая способ <code>iter</code>, определённый у <code>Vec&lt;T&gt;</code>. Сам по себе этот код не делает ничего полезного.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-10: Создание повторителя</span></p>
<p>Повторитель  хранится в переменной <code>v1_iter</code>. Создав повторитель , мы можем использовать его различными способами. В приложении 3-5 главы 3 мы совершали обход элементов массива используя цикл <code>for</code> для выполнения какого-то кода над каждым из его элементов. Под капотом это неявно создавало, а затем потребляло повторитель , но до сих пор мы не касались того, как именно это работает.</p>
<p>В примере из приложения 13-11 мы отделили создание повторителя от его использования в цикле for. В цикле for, использующем повторитель в v1_iter, каждый элемент повторителя участвует только в одной повторения цикла, в ходе которой выводится на экран его значение.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-11: Использование повторителя в цикле <code>for</code></span></p>
<p>В языках, обычные библиотеки которых не предоставляют повторители, вы, скорее всего, напишите эту же возможность так: создадите переменную со значением 0 затем, в цикле, использовав её для получения элемента вектора по порядковому указателю, будете увеличивать её значение, и так, пока оно не достигнет числа равного количеству элементов в векторе.</p>
<p>Повторители выполняют всю эту логику за вас, сокращая количество повторяющегося кода, который возможно может быть написан неправильно. Повторители дают вам гибкость, позволяя использовать одинаковые принципы работы с различными видами последовательностей, а не только со устройствами данных, которые можно упорядочивать, например, векторами. Давайте рассмотрим, как повторители это делают.</p>
<h3 id="Особенность-iterator-и-способ-next"><a class="header" href="#Особенность-iterator-и-способ-next">Особенность <code>Iterator</code> и способ <code>next</code></a></h3>
<p>Все повторители выполняют особенность <code>Iterator</code>, который определён в встроенной библиотеке. Его определение выглядит так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Обратите внимание данное объявление использует новый правила написания: <code>type Item</code> и <code>Self::Item</code>, которые определяют <em>сопряженный вид</em> (associated type) с этим особенностью. Мы подробнее поговорим о сопряженных видах в главе 19. Сейчас вам нужно знать, что этот код требует от выполнений особенности <code>Iterator</code> определить требуемый им вид <code>Item</code> и данный вид <code>Item</code> используется в способе <code>next</code>. Другими словами, вид <code>Item</code> будет являться видом элемента, который возвращает повторитель .</p>
<p>Особенность <code>Iterator</code> требует, чтобы разработчики определяли только один способ: способ <code>next</code>, который возвращает один элемент повторителя за раз обёрнутый в исход <code>Some</code> и когда повторение завершена, возвращает <code>None</code>.</p>
<p>Мы можем вызывать способ <code>next</code> у повторителей напрямую; в приложении 13-12 показано, какие значения возвращаются при повторных вызовах <code>next</code> у повторителя, созданного из вектора.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-12: Вызов способа <code>next</code> повторителя</span></p>
<p>Обратите внимание, что нам нужно сделать переменную <code>v1_iter</code> изменяемой: вызов способа <code>next</code> повторителя изменяет внутреннее состояние повторителя, которое повторитель использует для отслеживания того, где он находится в последовательности. Другими словами, этот код <em>потребляет</em> (consume) или использует повторитель . Каждый вызов <code>next</code> потребляет элемент из повторителя. Нам не нужно было делать изменяемой <code>v1_iter</code> при использовании цикла <code>for</code>, потому что цикл забрал во владение <code>v1_iter</code> и сделал её изменяемой неявно для нас.</p>
<p>Заметьте также, что значения, которые мы получаем при вызовах <code>next</code> являются неизменяемыми ссылками на значения в векторе. Способ <code>iter</code> создаёт повторитель по неизменяемым ссылкам. Если мы хотим создать повторитель , который становится владельцем <code>v1</code> и возвращает принадлежащие ему значения, мы можем вызвать <code>into_iter</code> вместо <code>iter</code>. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать <code>iter_mut</code> вместо <code>iter</code>.</p>
<h3 id="Способы-которые-потребляют-повторитель"><a class="header" href="#Способы-которые-потребляют-повторитель">Способы, которые потребляют повторитель</a></h3>
<p>У особенности <code>Iterator</code> есть несколько способов, выполнение которых по умолчанию предоставляется встроенной библиотекой; вы можете узнать об этих способах, просмотрев документацию API встроенной библиотеки для <code>Iterator</code>. Некоторые из этих способов вызывают <code>next</code> в своём определении, поэтому вам необходимо выполнить способ <code>next</code> при выполнения особенности <code>Iterator</code>.</p>
<p>Способы, вызывающие <code>next</code>, называются <em>потребляющими переходниками</em>, поскольку их вызов потребляет повторитель . Примером может служить способ <code>sum</code>, который забирает во владение повторитель и перебирает элементы, многократно вызывая <code>next</code>, тем самым потребляя повторитель . В этапе повторения он добавляет каждый элемент к текущей сумме и возвращает итоговое значение по завершении повторения. В приложении 13-13 приведён проверка, отображающий использование способа <code>sum</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-13: Вызов способа <code>sum</code> для получения суммы всех элементов в повторителе</span></p>
<p>Мы не можем использовать <code>v1_iter</code> после вызова способа <code>sum</code>, потому что <code>sum</code> забирает во владение повторитель у которого вызван способ.</p>
<h3 id="Способы-которые-создают-другие-повторители"><a class="header" href="#Способы-которые-создают-другие-повторители">Способы, которые создают другие повторители</a></h3>
<p><em>Переходники повторителей</em> - это способы, определённые для особенности <code>Iterator</code>, которые не потребляют повторитель . Вместо этого они создают различные повторители, изменяя некоторые особенности исходного повторителя.</p>
<p>В приложении 13-14 показан пример вызова способа переходника повторителя <code>map</code>, который принимает замыкание и вызывает его для каждого элемента по мере повторения элементов. Способ <code>map</code> возвращает новый повторитель , который создаёт изменённые элементы. Замыкание здесь создаёт новый повторитель , в котором каждый элемент из вектора будет увеличен на 1:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-14: Вызов переходника повторителя <code>map</code> для создания нового повторителя</span></p>
<p>Однако этот код выдаёт предупреждение:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Код в приложении 13-14 ничего не делает; указанное нами замыкание никогда не вызывается. Предупреждение напоминает нам, почему: переходники повторителей ленивы, и здесь нам нужно потребить повторитель .</p>
<p>Чтобы устранить это предупреждение и потребить повторитель , мы воспользуемся способом <code>collect</code>, который мы использовали в главе 12 с <code>env::args</code> в приложении 12-1. Этот способ потребляет повторитель и собирает полученные значения в собрание указанного вида.</p>
<p>В приложении 13-15 мы собираем в вектор итоги перебора повторителя, который возвращается в итоге вызова <code>map</code>. Этот вектор в итоге будет содержать каждый элемент исходного вектора, увеличенный на 1.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-15: Вызов способа <code>map</code> для создания нового повторителя, а затем вызов способа <code>collect</code> для потребления нового повторителя и создания вектора</span></p>
<p>Поскольку <code>map</code> принимает замыкание, мы можем указать любую действие, которую хотим выполнить над каждым элементом. Это отличный пример того, как замыкания позволяют задавать желаемое поведение, используя при этом особенности повторения, которые обеспечивает особенность <code>Iterator</code>.</p>
<p>Вы можете выстроить цепочку из нескольких вызовов переходников повторителя для выполнения сложных действий в удобочитаемом виде. Но поскольку все повторители являются "ленивыми", для получения итогов вызовов переходников повторителя необходимо вызвать один из способов потребляющего переходника.</p>
<h3 id="Использование-замыканий-которые-захватывают-переменные-окружения"><a class="header" href="#Использование-замыканий-которые-захватывают-переменные-окружения">Использование замыканий, которые захватывают переменные окружения</a></h3>
<p>Многие переходники повторителей принимают замыкания в качестве переменных, и обычно замыкания, которые мы будем указывать в качестве переменных переходникам повторителей, это замыкания, которые определяют (захватывают) своё окружение.</p>
<p>В этом примере мы будем использовать способ <code>filter</code>, который принимает замыкание. Замыкание получает элемент из повторителя и возвращает <code>bool</code>. Если замыкание возвращает <code>true</code>, значение будет включено в повторение, создаваемую <code>filter</code>. Если замыкание возвращает <code>false</code>, значение не будет включено.</p>
<p>В приложении 13-16 мы используем <code>filter</code> с замыканием, которое захватывает переменную <code>shoe_size</code> из своего окружения для повторения по собрания образцов устройства <code>Shoe</code>. Он будет возвращать обувь только указанного размера.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Приложение 13-16. Использование способа <code>filter</code> с замыканием, определяющим <code>shoe_size</code></span></p>
<p>Функция <code>shoes_in_size</code> принимает в качестве свойств вектор с образцами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера.</p>
<p>В теле <code>shoes_in_my_size</code> мы вызываем <code>into_iter</code> чтобы создать повторитель , который становится владельцем вектора. Затем мы вызываем <code>filter</code>, чтобы превратить этот повторитель в другой, который содержит только элементы, для которых замыкание возвращает <code>true</code>.</p>
<p>Замыкание захватывает свойство <code>shoe_size</code> из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов <code>collect</code> собирает значения, возвращаемые приспособленным повторителем, в вектор, возвращаемый функцией.</p>
<p>Проверка показывает, что когда мы вызываем <code>shoes_in_my_size</code>, мы возвращаем только туфли, размер которых совпадает с указанным нами значением.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Улучшение-нашего-дела-с-вводомвыводом"><a class="header" href="#Улучшение-нашего-дела-с-вводомвыводом">Улучшение нашего дела с вводом/выводом</a></h2>
<p>Вооружившись полученными знаниями об повторителях, мы можем улучшить выполнение работы с вводом/выводом в деле главы 12, применяя повторители для того, чтобы сделать некоторые места в коде более понятными и краткими. Давайте рассмотрим, как повторители могут улучшить нашу выполнение функции <code>Config::build</code> и функции <code>search</code>.</p>
<h3 id="Удаляем-clone-используем-повторитель"><a class="header" href="#Удаляем-clone-используем-повторитель">Удаляем <code>clone</code>, используем повторитель</a></h3>
<p>В приложении 12-6 мы добавили код, который принимает срез значений <code>String</code> и создаёт образец устройства <code>Config</code> путём упорядочевания среза и клонирования значений, позволяя устройстве <code>Config</code> владеть этими значениями. В приложении 13-17 мы воспроизвели выполнение функции <code>Config::build</code>, как это было в приложении 12-23:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-17: Репродукция функции <code>Config::build</code> из приложения 12-23</span></p>
<p>Ранее мы говорили, что не стоит беспокоиться о неэффективных вызовах <code>clone</code>, потому что мы удалим их в будущем. Ну что же, время пришло!</p>
<p>Нам понадобился здесь <code>clone</code>, потому что в свойстве <code>args</code> у нас срез с элементами <code>String</code>, но функция <code>build</code> не владеет <code>args</code>. Чтобы образец <code>Config</code> владел значениями, нам пришлось клонировать их из <code>args</code> в переменные <code>query</code> и <code>file_path</code>.</p>
<p>Благодаря нашим новым знаниям об повторителях мы можем изменить функцию <code>build</code>, чтобы вместо заимствования среза она принимала в качестве переменной повторитель . Мы будем использовать возможность повторителя вместо кода, который проверяет длину среза и обращается по порядковому указателю к определённым значениям. Это позволит лучше понять, что делает функция <code>Config::build</code>, поскольку повторитель будет обращаться к значениям.</p>
<p>Как только <code>Config::build</code> получит в своё распоряжение повторитель и перестанет использовать действия упорядочевания с заимствованием, мы сможем переместить значения <code>String</code> из повторителя в <code>Config</code> вместо того, чтобы вызывать <code>clone</code> и создавать новое выделение памяти.</p>
<h4 id="Использование-возвращённого-повторителя-напрямую"><a class="header" href="#Использование-возвращённого-повторителя-напрямую">Использование возвращённого повторителя напрямую</a></h4>
<p>Откройте файл <em>src/main.rs</em> дела ввода-вывода, который должен выглядеть следующим образом:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>Сначала мы изменим начало функции <code>main</code>, которая была в приложении 12-24, на код в приложении 13-18, который теперь использует повторитель . Это не будет собираться, пока мы не обновим <code>Config::build</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Приложение 13-18: Передача возвращаемого значения из <code>env::args</code> в <code>Config::build</code></span></p>
<p>Функция <code>env::args</code> возвращает повторитель ! Вместо того чтобы собирать значения повторителя в вектор и затем передавать срез в <code>Config::build</code>, теперь мы передаём владение повторителем, возвращённым из <code>env::args</code> в <code>Config::build</code> напрямую.</p>
<p>Далее нам нужно обновить определение <code>Config::build</code>. В файле <em>src/lib.rs</em> вашего дела ввода-вывода изменим ярлык <code>Config::build</code> так, чтобы она выглядела как в приложении 13-19. Это все ещё не собирается, потому что нам нужно обновить тело функции.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-19: Обновление ярлыки <code>Config::build</code> для определения повторителя как ожидаемого свойства</span></p>
<p>Документация встроенной библиотеки для функции <code>env::args</code> показывает, что вид возвращаемого ею повторителя - <code>std::env::Args</code>, и этот вид выполняет признак <code>Iterator</code> и возвращает значения <code>String</code>.</p>
<p>Мы обновили ярлык функции <code>Config::build</code>, чтобы свойство <code>args</code> имел гибкий вид ограниченный особенностью <code>impl Iterator&lt;Item = String&gt;</code> вместо <code>&amp;[String]</code>. Такое использование правил написания <code>impl Trait</code>, который мы обсуждали в разделе <a href="ch10-02-traits.html#traits-as-parameters">" Особенности как свойства"</a><!-- ignore --> главы 10, означает, что <code>args</code> может быть любым видом, выполняющим вид <code>Iterator</code> и возвращающим элементы <code>String</code>.</p>
<p>Поскольку мы владеем <code>args</code> и будем изменять <code>args</code> в этапе повторения над ним, мы можем добавить ключевое слово <code>mut</code> в свод требований свойства <code>args</code>, чтобы сделать его изменяемым.</p>
<h4 id="Использование-способов-особенности-iterator-вместо-порядковых-указателей"><a class="header" href="#Использование-способов-особенности-iterator-вместо-порядковых-указателей">Использование способов особенности <code>Iterator</code> вместо порядковых указателей</a></h4>
<p>Далее мы подправим содержимое <code>Config::build</code>. Поскольку <code>args</code> выполняет признак <code>Iterator</code>, мы знаем, что можем вызвать у него способ <code>next</code>! В приложении 13-20 код из приложения 12-23 обновлён для использования способа <code>next</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-20: Изменяем тело <code>Config::build</code> так, чтобы использовать способы повторителя</span></p>
<p>Помните, что первое значение в возвращаемых данных <code>env::args</code> - это имя программы. Мы хотим пренебрегать его и перейти к следующему значению, поэтому сперва мы вызываем <code>next</code> и ничего не делаем с возвращаемым значением. Затем мы вызываем <code>next</code>, чтобы получить значение, которое мы хотим поместить в поле <code>query</code> в <code>Config</code>. Если <code>next</code> возвращает <code>Some</code>, мы используем <code>match</code> для извлечения значения. Если возвращается <code>None</code>, это означает, что было задано недостаточно переменных, и мы досрочно возвращаем значение <code>Err</code>. То же самое мы делаем для значения <code>file_path</code>.</p>
<h3 id="Делаем-код-понятнее-с-помощью-переходников-повторителей"><a class="header" href="#Делаем-код-понятнее-с-помощью-переходников-повторителей">Делаем код понятнее с помощью переходников повторителей</a></h3>
<p>Мы также можем воспользоваться преимуществами повторителей в функции <code>search</code> в нашем деле с действиеми ввода-вывода, которая воспроизведена здесь в приложении 13-21 так же, как и в приложении 12-19:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-21: Выполнение функции <code>search</code> из приложения 12-19</span></p>
<p>Мы можем написать этот код в более сжатом виде, используя способы переходника повторителя. Это также позволит нам избежать наличия изменяемого временного вектора <code>results</code>. Функциональный исполнение программирования предпочитает уменьшить количество изменяемого состояния, чтобы сделать код более понятным. Удаление изменяемого состояния может позволить в будущем сделать поиск одновременным, поскольку нам не придётся управлять одновременным доступом к вектору <code>results</code>. В приложении 13-22 показано это изменение:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Didn't get a query string"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Didn't get a file path"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 13-22: Использование способов переходника повторителя в выполнения функции <code>search</code></span></p>
<p>Напомним, что назначение функции <code>search</code> - вернуть все строки в <code>contents</code>, которые содержат <code>query</code>. Подобно примеру <code>filter</code> в приложении 13-16, этот код использует переходник <code>filter</code>, чтобы сохранить только те строки, для которых <code>line.contains(query)</code> возвращает <code>true</code>. Затем мы собираем совпадающие строки в другой вектор с помощью <code>collect</code>. Так гораздо проще! Не стесняйтесь сделать такое же изменение для использования способов повторителя в функции <code>search_case_insensitive</code>.</p>
<h3 id="Выбор-между-циклами-или-повторителями"><a class="header" href="#Выбор-между-циклами-или-повторителями">Выбор между циклами или повторителями</a></h3>
<p>Следующий логичный вопрос - какой исполнение вы должны выбрать в своём коде и почему: подлинную выполнение в приложении 13-21 или исполнение с использованием повторителей в приложении 13-22. Большинство программистов на языке Ржавчина предпочитают использовать исполнение повторителей. Сначала разобраться с ним немного сложно, но как только вы почувствуете, что такое различные переходники повторителей и что они делают, понять повторители станет проще. Вместо того чтобы возиться с различными элементами цикла и создавать новые векторы, код сосредотачивается на высокоуровневой цели цикла. Это абстрагирует часть обычного кода, поэтому легче увидеть подходы, единственные для этого кода, такие как условие выборки, которое должен пройти каждый элемент в повторителе.</p>
<p>Но действительно ли эти две выполнения эквивалентны? Интуитивно можно предположить, что более низкоуровневый цикл будет быстрее. Давайте поговорим о производительности.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Сравнение-производительности-циклов-и-повторителей"><a class="header" href="#Сравнение-производительности-циклов-и-повторителей">Сравнение производительности циклов и повторителей</a></h2>
<p>Чтобы определить, что лучше использовать циклы или повторители, нужно знать, какая выполнение быстрее: исполнение функции <code>search</code> с явным циклом <code>for</code> или исполнение с повторителями.</p>
<p>Мы выполнили проверка производительности, разместив всё содержимое книги <em>(“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)</em> в строку вида <code>String</code> и поискали слово <em>the</em> в её содержимом. Вот итоги проверки функции <code>search</code> с использованием цикла <code>for</code> и с использованием повторителей:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Исполнение с использованием повторителей была немного быстрее! Мы не будем приводить здесь непосредственно код проверки, поскольку мысль не в том, чтобы доказать, что решения в точности эквивалентны, а в том, чтобы получить общее представление о том, как эти две выполнения близки по производительности.</p>
<p>Для более исчерпывающего проверки, вам нужно проверить различные тексты разных размеров в качестве содержимого для <code>contents</code>, разные слова и слова различной длины в качестве <code>query</code> и всевозможные другие исходы. Дело в том, что повторители, будучи высокоуровневой абстракцией, собираются примерно в тот же код, как если бы вы написали его низкоуровневый исход самостоятельно. Повторители - это одна из <em>абстракций с нулевой стоимостью</em> ( zero-cost abstractions ) в Rust, под которой мы подразумеваем, что использование абстракции не накладывает дополнительных расходов во время выполнения. Подобно тому, как Бьёрн Страуструп, внешнем видер и разработчик C++, определяет <em>нулевые накладные расходы</em> ( zero-overhead ) в книге “Foundations of C++” (2012):</p>
<blockquote>
<p>В целом, выполнение C++ подчиняется принципу отсутствия накладных расходов: за то, чем вы не пользуетесь, платить не нужно. И далее: тот код, что вы используете, нельзя сделать ещё лучше.</p>
</blockquote>
<p>В качестве другого примера приведём код, взятый из аудио декодера. Алгоритм декодирования использует математическую действие линейного предсказания для оценки будущих значений на основе линейной функции предыдущих выборок. Код использует соединение вызовов повторителя для выполнения математических вычислений для трёх переменных в области видимости: срез данных <code>buffer</code>, массив из 12 коэффициентов <code>coefficients</code> и число для сдвига данных в переменной <code>qlp_shift</code>. Переменные определены в примере, но не имеют начальных значений. Хотя этот код не имеет большого значения вне среды, он является кратким, существующим примером того, как Ржавчина переводит мысли высокого уровня в код низкого уровня.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>Чтобы вычислить значение переменной <code>prediction</code>, этот код перебирает каждое из 12 значений в переменной <code>coefficients</code> и использует способ <code>zip</code> для объединения значений коэффициентов с предыдущими 12 значениями в переменной <code>buffer</code>. Затем, для каждой пары мы перемножаем значения, суммируем все итоги и у суммы сдвигаем биты вправо в переменную <code>qlp_shift</code>.</p>
<p>Для вычислений в таких приложениях, как аудио декодеры, часто требуется производительность. Здесь мы создаём повторитель , используя два переходника, впоследствии потребляющих значение. В какой ассемблерный код будет собираться этот код на Rust? На мгновение написания этой главы он собирается в то же самое, что вы написали бы руками. Не существует цикла, соответствующего повторения по значениям в «коэффициентах»<code>coefficients</code>: Ржавчина знает, что существует двенадцать повторений, поэтому он «разворачивает» цикл. <em>Разворачивание</em> - это улучшение, которая устраняет издержки кода управления циклом и вместо этого порождает повторяющийся код для каждой повторения цикла.</p>
<p>Все коэффициенты сохраняются в регистрах, что означает очень быстрый доступ к значениям. Нет никаких проверок границ доступа к массиву во время выполнения. Все эти переработки, которые может применить Rust, делают полученный код чрезвычайно эффективным. Теперь, когда вы это знаете, используйте повторители и замыкания без страха! Они представляют код в более высокоуровневом виде, но без потери производительности во время выполнения.</p>
<h2 id="Итоги-10"><a class="header" href="#Итоги-10">Итоги</a></h2>
<p>Замыкания (closures) и повторители (iterators) это возможности Rust, вдохновлённые мыслями полезных языков. Они позволяют Ржавчина ясно выражать мысли высокого уровня с производительностью низкоуровневого кода. Выполнения замыканий и повторителей таковы, что нет влияния на производительность выполнения кода. Это одна из целей Rust, направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).</p>
<p>Теперь, когда мы улучшили представление кода в нашем деле, рассмотрим некоторые возможности, которые нам предоставляет <code>cargo</code> для обнародования нашего кода в хранилища.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Больше-о-cargo-и-cratesio"><a class="header" href="#Больше-о-cargo-и-cratesio">Больше о Cargo и Crates.io</a></h1>
<p>До сих пор мы использовали только самые основные возможности Cargo для сборки, запуска и проверки нашего кода, но он может гораздо больше. В этой главе мы обсудим некоторые другие, более продвинутые возможности, чтобы показать вам, как делать следующее:</p>
<ul>
<li>Настройка сборки с помощью готовых профилей</li>
<li>Обнародование библиотеки на <a href="https://crates.io/">crates.io</a><!--  --></li>
<li>Управление крупными делами с помощью рабочих пространств</li>
<li>Установка двоичных файлов с <a href="https://crates.io/">crates.io</a><!--  --></li>
<li>Расширение возможностей Cargo с помощью возможности добавления собственных приказов</li>
</ul>
<p>Cargo может делать значительно больше того, что мы рассмотрим в этой главе, полное описание всех его функций см. в <a href="https://doc.rust-lang.org/cargo/">документации</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Настройка-сборок-с-профилями-исполнений"><a class="header" href="#Настройка-сборок-с-профилями-исполнений">Настройка сборок с профилями исполнений</a></h2>
<p>В Ржавчина <em>профили выпуска</em> — это предопределённые и настраиваемые профили с различными настройками, которые позволяют программисту лучше управлять различные свойства сборки кода. Каждый профиль настраивается независимо от других.</p>
<p>Cargo имеет два основных профиля: профиль <code>dev</code>, используемый Cargo при запуске <code>cargo build</code>, и профиль <code>release</code>, используемый Cargo при запуске <code>cargo build --release</code>. Профиль <code>dev</code> определён со значениями по умолчанию для разработки, а профиль <code>release</code> имеет значения по умолчанию для сборок в исполнение.</p>
<p>Эти имена профилей могут быть знакомы по итогам ваших сборок:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p><code>dev</code> и <code>release</code> — это разные профили, используемые сборщиком.</p>
<p>Cargo содержит настройки по умолчанию для каждого профиля, которые применяются, если вы явно не указали разделы <code>[profile.*]</code> в файле дела <em>Cargo.toml</em>. Добавляя разделы <code>[profile.*]</code> для любого профиля, который вы хотите настроить, вы переопределяете любое подмножество свойств по умолчанию. Например, вот значения по умолчанию для свойства <code>opt-level</code> для профилей <code>dev</code> и <code>release</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Свойство <code>opt-level</code> управляет количеством переработок, которые Ржавчина будет применять к вашему коду, в ряде от 0 до 3. Использование большего количества переработок увеличивает время сборки, поэтому если вы находитесь в этапе разработки и часто собираете свой код, целесообразно использовать меньшее количество переработок, чтобы сборка происходила быстрее, даже если в итоге код будет работать медленнее. Поэтому <code>opt-level</code> по умолчанию для <code>dev</code> установлен в <code>0</code>. Когда вы готовы обнародовать свой код, то лучше потратить больше времени на сборку. Вы собираете программу в режиме исполнения только один раз, но выполняться она будет многократно, так что использование режима исполнения позволяет увеличить скорость выполнения кода за счёт времени сборки. Вот почему по умолчанию <code>opt-level</code> для профиля <code>release</code> равен <code>3</code>.</p>
<p>Вы можете переопределить настройки по умолчанию, добавив другое значение для них в <em>Cargo.toml</em>. Например, если мы хотим использовать уровень переработки 1 в профиле разработки, мы можем добавить эти две строки в файл <em>Cargo.toml</em> нашего дела:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Этот код переопределяет настройку по умолчанию <code>0</code>. Теперь, когда мы запустим <code>cargo build</code>, Cargo будет использовать значения по умолчанию для профиля <code>dev</code> плюс нашу настройку для <code>opt-level</code>. Поскольку мы установили для <code>opt-level</code> значение <code>1</code>, Cargo будет применять больше переработок, чем было задано по умолчанию, но не так много, как при сборке исполнения.</p>
<p>Полный список свойств настройке и значений по умолчанию для каждого профиля вы можете найти в <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">документации Cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обнародование-библиотеки-в-cratesio"><a class="header" href="#Обнародование-библиотеки-в-cratesio">Обнародование библиотеки в Crates.io</a></h2>
<p>Мы использовали дополнения из <a href="https://crates.io/">crates.io</a><!--  --> в качестве зависимостей нашего дела, но вы также можете поделиться своим кодом с другими людьми, обнародовав свои собственные дополнения. Реестр библиотек по адресу <a href="https://crates.io/">crates.io</a><!--  --> распространяет исходный код ваших дополнений, поэтому он в основном размещает код с открытым исходным кодом.</p>
<p>В Ржавчина и Cargo есть функции, которые облегчают поиск и использование обнародованного дополнения. Далее мы поговорим о некоторых из этих функций, а затем объясним, как обнародовать дополнение.</p>
<h3 id="Создание-полезных-примечаниев-к-документации"><a class="header" href="#Создание-полезных-примечаниев-к-документации">Создание полезных примечаниев к документации</a></h3>
<p>Правильноное документирование ваших дополнений поможет другим пользователям знать, как и когда их использовать, поэтому стоит потратить время на написание документации. В главе 3 мы обсуждали, как вносить примечания в код Rust, используя две косые черты, <code>//</code>. В Ржавчина также есть особый вид примечаниев к документации, который обычно называется <em>примечанием к документации</em>, который порождает документацию HTML. HTML-код отображает содержимое примечаниев к документации для открытых элементов API, предназначенных для программистов, увлеченных в знании того, как <em>использовать</em> вашу библиотеку, в отличие от того, как она <em>выполнена</em>.</p>
<p>Примечания к документации используют три слеша, <code>///</code> вместо двух и поддерживают наставление Markdown для изменения текста. Размещайте примечания к документации непосредственно перед элементом, который они документируют. В приложении 14-1 показаны примечания к документации для функции <code>add_one</code> в библиотеке с именем <code>my_crate</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p><span class="caption">Приложение 14-1: Примечание к документации для функции</span></p>
<p>Здесь мы даём описание того, что делает функция <code>add_one</code>, начинаем раздел с заголовка <code>Examples</code>, а затем предоставляем код, который отображает, как использовать функцию <code>add_one</code>. Мы можем создать документацию HTML из этого примечания к документации, запустив <code>cargo doc</code>. Этот приказ запускает средство <code>rustdoc</code>, поставляемый с Rust, и помещает созданную HTML-документацию в папка <em>target/doc</em>.</p>
<p>Для удобства, запустив <code>cargo doc --open</code>, мы создадим HTML для документации вашей текущей библиотеки (а также документацию для всех зависимостей вашей библиотеки) и откроем итог в веб-браузере. Перейдите к функции <code>add_one</code> и вы увидите, как отображается текст в примечаниях к документации, что показано на рисунке 14-1:</p>
 <img alt="HTML-документация для функции `add_one`` my_crate`" src="img/trpl14-01.png" class="center">
<p><span class="caption">Рисунок 14-1: HTML документация для функции <code>add_one</code></span></p>
<h4 id="Часто-используемые-разделы"><a class="header" href="#Часто-используемые-разделы">Часто используемые разделы</a></h4>
<p>Мы использовали Markdown заголовок <code># Examples</code> в приложении 14-1 для создания раздела в HTML с заголовком "Examples". Вот некоторые другие разделы, которые авторы библиотек обычно используют в своей документации:</p>
<ul>
<li><strong>Panics</strong>: Сценарии, в которых документированная функция может вызывать панику. Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих случаейх.</li>
<li><strong>Ошибки</strong>: Если функция возвращает <code>Result</code>, описание видов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных видов ошибок разными способами.</li>
<li><strong>Безопасность</strong>: Если функция является <code>unsafe</code> для вызова (мы обсуждаем безопасность в главе 19), должен быть раздел, объясняющий, почему функция небезопасна и охватывающий неизменные величины, которые функция ожидает от вызывающих сторон.</li>
</ul>
<p>В подавляющем большинстве случаев примечания к документации не нуждаются во всех этих разделах, но это хорошая подсказка, напоминающая вам о тех особенностях вашего кода, о которых пользователям будет важно узнать.</p>
<h4 id="Примечания-к-документации-как-проверки"><a class="header" href="#Примечания-к-документации-как-проверки">Примечания к документации как проверки</a></h4>
<p>Добавление примеров кода в примечания к документации может помочь отобразить, как использовать вашу библиотеку, и это даёт дополнительный бонус: запуск <code>cargo test</code> запустит примеры кода в вашей документации как проверки! Нет ничего лучше, чем документация с примерами. Но нет ничего хуже, чем примеры, которые не работают, потому что код изменился с особенности написания документации. Если мы запустим <code>cargo test</code> с документацией для функции <code>add_one</code> из приложения 14-1, мы увидим раздел итогов проверки, подобный этому:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Теперь, если мы изменим либо функцию, либо пример, так что <code>assert_eq!</code> в примере паникует, и снова запустим <code>cargo test</code>, мы увидим, что проверки документации обнаруживают, что пример и код не согласованы друг с другом!</p>
<h4 id="Указание-примечаний-содержащихся-элементов"><a class="header" href="#Указание-примечаний-содержащихся-элементов">Указание примечаний содержащихся элементов</a></h4>
<p>Исполнение примечаниев к документам <code>//!</code> добавляет документацию к элементу, содержащему примечания, а не к элементам, следующим за примечаниями. Обычно мы используем эти примечания внутри корневого файла ящика (по соглашению <em>src/lib.rs</em> ) или внутри звена для документирования ящика или звена в целом.</p>
<p>Например, чтобы добавить документацию, описывающую назначение <code>my_crate</code> , содержащего функцию <code>add_one</code> , мы добавляем примечания к документации, начинающиеся с <code>//!</code> в начало файла <em>src/lib.rs</em> , как показано в приложении 14-2:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 14-2: Документация для ящика <code>my_crate</code> в целом</span></p>
<p>Обратите внимание, что после последней строки, начинающейся с <code>//!</code>, нет никакого кода. Поскольку мы начали примечания с <code>//!</code> вместо <code>///</code>, мы документируем элемент, который содержит этот примечание, а не элемент, который следует за этим примечанием. В данном случае таким элементом является файл <em>src/lib.rs</em>, который является корнем crate. Эти примечания описывают весь ящик.</p>
<p>Когда мы запускаем <code>cargo doc --open</code>, эти примечания будут отображаться на первой странице документации для <code>my_crate</code> над списком открытых элементов в библиотеке, как показано на рисунке 14-2:</p>
 <img alt="Документация для библиотеки `art`, в которой перечислены звенья `types` и `utils`" src="img/trpl14-02.png" class="center">
<p><span class="caption">Рисунок 14-2: Предоставленная документация для <code>my_crate</code>, включая примечание, описывающие ящик в целом</span></p>
<p>Примечания к документации внутри элементов полезны для описания ящиков и звеньев особенно. Используйте их, чтобы объяснить общую цель дополнения, чтобы помочь вашим пользователям понять устройство ящика.</p>
<h3 id="Экспорт-удобного-общедоступного-api-с-pub-use"><a class="header" href="#Экспорт-удобного-общедоступного-api-с-pub-use">Экспорт удобного общедоступного API с <code>pub use</code><a id="exporting-a-convenient-public-api-with-pub-use"></a></a></h3>
<p>Устройства вашего открытого API является основным обстоятельством при обнародования ящика. Люди, которые используют вашу библиотеку, менее знакомы со устройством, чем вы и могут столкнуться с трудностями при поиске частей, которые они хотят использовать, если ваша библиотека имеет большую упорядочевание звеньев.</p>
<p>В главе 7 мы рассмотрели, как сделать элементы общедоступными с помощью ключевого слова <code>pub</code> и ввести элементы в область видимости с помощью ключевого слова <code>use</code>. Однако устройства, которая имеет смысл для вас при разработке ящика, может быть не очень удобной для пользователей. Вы можете согласовать устройство в виде упорядочевания с несколькими уровнями, но тогда люди, желающие использовать вид, который вы определили в глубине упорядочевания, могут столкнуться с неполадкой его поиска. Их также может раздражать необходимость вводить <code>use</code> <code>my_crate::some_module::another_module::UsefulType;</code> вместо <code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>Хорошей новостью является то, что если устройства <em>не</em> удобна для использования другими из другой библиотеки, вам не нужно перестраивать внутреннюю устройство: вместо этого вы можете реэкспортировать элементы, чтобы сделать открытую устройство, отличную от вашей внутренней устройства, используя <code>pub use</code>. Реэкспорт берет открытый элемент в одном месте и делает его открытым в другом месте, как если бы он был определён в другом месте.</p>
<p>Например, скажем, мы создали библиотеку с именем <code>art</code> для расчетов художественных подходов. Внутри этой библиотеки есть два звена: звено <code>kinds</code> содержащий два перечисления с именами <code>PrimaryColor</code> и <code>SecondaryColor</code> и звено <code>utils</code>, содержащий функцию с именем <code>mix</code>, как показано в приложении 14-3:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<p><span class="caption">Приложение 14-3: Библиотека <code>art</code> с элементами, согласованными в звенья <code>kinds</code> и <code>utils</code></span></p>
<p>На рисунке 14-3 показано, как будет выглядеть титульная страница документации для этого ящика, созданный <code>cargo doc</code>:</p>
 <img alt="Предоставлена Документация для библиотеки `art` с реэкспортом на первой странице" src="img/trpl14-03.png" class="center">
<p><span class="caption">Рисунок 14-3: Первая страница документации для <code>art</code>, в которой перечислены звенья <code>kinds</code> и <code>utils</code></span></p>
<p>Обратите внимание, что виды <code>PrimaryColor</code> и <code>SecondaryColor</code> не указаны на главной странице, равно как и функция <code>mix</code>. Мы должны нажать <code>kinds</code> и <code>utils</code>, чтобы увидеть их.</p>
<p>В другой библиотеке, которая зависит от этой библиотеки, потребуются операторы <code>use</code>, которые подключают элементы из <code>art</code> в область видимости, определяя устройство звена, которая определена в данный мгновение. В приложении 14-4 показан пример ящика, в котором используются элементы <code>PrimaryColor</code> и <code>mix</code> из ящика <code>art</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<p><span class="caption">Приложение 14-4: Ящик использующий элементы из ящика <code>art</code> с экспортированной внутренней устройством</span></p>
<p>Автору кода в приложении 14-4, который использует ящик <code>art</code>, пришлось выяснить, что <code>PrimaryColor</code> находится в звене <code>kinds</code>, а <code>mix</code> - в звене <code>utils</code>. Устройства звена <code>art</code> ящика больше подходит для разработчиков, работающих над <code>art</code> ящиком, чем для тех, кто его использует. Внутренняя устройства не содержит никакой полезной сведений для того, кто пытается понять, как использовать ящик <code>art</code>, а скорее вызывает путаницу, поскольку разработчики, использующие его, должны понять, где искать, и должны указывать имена звеньев в выражениях <code>use</code>.</p>
<p>Чтобы удалить внутреннюю устройство из общедоступного API, мы можем изменить код ящика <code>art</code> в приложении 14-3, чтобы добавить операторы <code>pub use</code> для повторного реэкспорта элементов на верхнем уровне, как показано в приложении 14-5:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Приложение 14-5: Добавление операторов <code>pub use</code> для реэкспорта элементов</span></p>
<p>Документация API, которую <code>cargo doc</code> порождает для этой библиотеки, теперь будет перечислять и связывать реэкспорты на главной странице, как показано на рисунке 14-4, упрощая поиск видов <code>PrimaryColor</code>, <code>SecondaryColor</code> и функции <code>mix</code>.</p>
 <img alt="HTML-документация с примечанием для библиотеки в целом" src="img/trpl14-04.png" class="center">
<p><span class="caption">Рисунок 14-4: Первая страница документации для <code>art</code>,  которая перечисляет реэкспорт</span></p>
<p>Пользователи ящика <code>art</code> могут по-прежнему видеть и использовать внутреннюю устройство из приложения 14-3, как показано в приложении 14-4, или они могут использовать более удобную устройство в приложении 14-5, как показано в приложении 14-6:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<p><span class="caption">Приложение 14-6: Программа, использующая реэкспортированные элементы из ящика <code>art</code></span></p>
<p>В случаях, когда имеется много вложенных звеньев, реэкспорт видов на верхнем уровне с помощью <code>pub use</code> может существенно повысить удобство работы для людей, использующих ящик. Ещё одно распространённое использование <code>pub use</code> - это реэкспорт определений зависимого звена в текущем ящике, чтобы сделать определения этого ящика частью открытого API вашего ящика.</p>
<p>Создание полезной открытой устройства API - это больше искусство чем наука, и вы можете повторять, чтобы найти API, который лучше всего подойдёт вашим пользователям. Использование <code>pub use</code> даёт вам гибкость в том, как вы внутренне выстраиваете</p>
<p>свою библиотеку внутри и отделяете эту внутреннюю устройство от того, что вы предоставляете пользователям. Посмотрите на код некоторых установленных ящиков, чтобы увидеть отличается ли их внутренняя устройства от их открытого API.</p>
<h3 id="Настройка-учётной-записи-cratesio"><a class="header" href="#Настройка-учётной-записи-cratesio">Настройка учётной записи Crates.io</a></h3>
<p>Прежде чем вы сможете обнародовать любые библиотеки, вам необходимо создать учётную запись на <a href="https://crates.io/">crates.io</a><!--  --> и получить API токен. Для этого зайдите на домашнюю страницу <a href="https://crates.io/">crates.io</a><!--  --> и войдите в систему через учётную запись GitHub. (В настоящее время требуется наличие учётной записи GitHub, но сайт может поддерживать другие способы создания учётной записи в будущем.) Сразу после входа в систему перейдите в настройки своей учётной записи по адресу <a href="https://crates.io/me/">https://crates.io/me/</a><!--  --> и получите свой ключ API. Затем выполните приказ <code>cargo login</code> с вашим ключом API, например:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Этот приказ сообщит Cargo о вашем API token и сохранит его местно в <em>~/.cargo/credentials</em>. Обратите внимание, что этот токен является <em>тайным</em>: не делитесь им ни с кем другим. Если вы по какой-либо причине поделитесь им с кем-либо, вы должны отозвать его и создать новый токен на <a href="https://crates.io/">crates.io</a>.</p>
<h3 id="Добавление-метаданных-в-новую-библиотеку"><a class="header" href="#Добавление-метаданных-в-новую-библиотеку">Добавление метаданных в новую библиотеку</a></h3>
<p>Допустим, у вас есть ящик, который вы хотите обнародовать. Перед обнародованием вам нужно добавить некоторые метаданные в раздел <code>[package]</code> файла <em>Cargo.toml</em> ящика.</p>
<p>Вашему ящику понадобится не повторяющееся имя. Пока вы работаете над ящиком местно, вы можете назвать его как угодно. Однако названия ящиков на <a href="https://crates.io/">crates.io</a><!-- ignore --> определятся в мгновение первой обнародования. Как только ящику присвоено название, никто другой не сможет обнародовать ящик с таким же именем. Перед тем как обнародовать ящик, поищите название, которое вы хотите использовать. Если такое имя уже используется, вам придётся подобрать другое и отредактировать поле <code>name</code> в файле <em>Cargo.toml</em> в разделе <code>[package]</code>, чтобы использовать новое имя в качестве размещаяемого, например, так:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Даже если вы выбрали не повторяющееся имя, когда вы запустите <code>cargo publish</code> чтобы обнародовать ящик, вы получите предупреждение, а затем ошибку:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Это ошибка, потому что вам не хватает важной сведений: необходимы описание и лицензия, чтобы люди знали, что делает ваш ящик и на каких условиях они могут его использовать. В поле <em>Cargo.toml</em> добавьте описание, состоящее из одного-двух предложений, поскольку оно будет появляться вместе с вашим ящиком в итогах поиска. Для поля <code>license</code> нужно указать значение <em>определителя лицензии</em>. В <a href="http://spdx.org/licenses/">Linux Foundation's Software Package Data Exchange (SPDX)</a> перечислены определители, которые можно использовать для этого значения. Например, чтобы указать, что вы лицензировали свой crate, используя лицензию MIT, добавьте определитель <code>MIT</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>Если вы хотите использовать лицензию, которая отсутствует в SPDX, вам нужно поместить текст этой лицензии в файл, включите файл в свой дело, а затем используйте <code>license-file</code>, чтобы указать имя этого файла вместо использования ключа <code>license</code>.</p>
<p>Руководство по выбору лицензии для вашего дела выходит за рамки этой книги. Многие люди в сообществе Ржавчина лицензируют свои дела так же, как и Rust, используя двойную лицензию <code>MIT OR Apache 2.0</code>. Эта применение отображает, что вы также можете указать несколько определителей лицензий, разделённых <code>OR</code>, чтобы иметь несколько лицензий для вашего дела.</p>
<p>С добавлением единственного имени, исполнения, вашего описания и лицензии, файл <em>Cargo.toml</em> для дела, который готов к обнародования может выглядеть следующим образом:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Документация Cargo</a> описывает другие метаданные, которые вы можете указать, чтобы другие могли легче находить и использовать ваш ящик.</p>
<h3 id="Обнародование-на-cratesio"><a class="header" href="#Обнародование-на-cratesio">Обнародование на Crates.io</a></h3>
<p>Теперь, когда вы создали учётную запись, сохранили свой токен API, выбрали имя для своего ящика и указали необходимые метаданные, вы готовы к обнародования! Обнародование библиотеки загружает определённую исполнение в <a href="https://crates.io/">crates.io</a><!--  --> для использования другими.</p>
<p>Будьте осторожны, потому что обнародование является <em>перманентной</em> действием. Исполнение никогда не сможет быть перезаписана, а код не подлежит удалению. Одна из основных целей <a href="https://crates.io/">crates.io</a><!-- ignore --> - служить постоянным архивом кода, чтобы сборки всех дел, зависящих от crates из <a href="https://crates.io/">crates.io</a><!-- ignore --> продолжали работать. Предоставление возможности удаления исполнений сделало бы выполнение этой цели невозможным. При этом количество исполнений ящиков, которые вы можете обнародовать, не ограничено.</p>
<p>Запустите приказ <code>cargo publish</code> ещё раз. Сейчас эта приказ должна выполниться успешно:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Поздравляем! Теперь вы поделились своим кодом с сообществом Ржавчина и любой может легко добавить вашу библиотеку в качестве зависимости их дела.</p>
<h3 id="Обнародование-новой-исполнения-существующей-библиотеки"><a class="header" href="#Обнародование-новой-исполнения-существующей-библиотеки">Обнародование новой исполнения существующей библиотеки</a></h3>
<p>Когда вы внесли изменения в свой ящик и готовы выпустить новую исполнение, измените значение <code>version</code>, указанное в вашем файле <em>Cargo.toml</em> и повторите размещение. Воспользуйтесь <a href="http://semver.org/">Semantic Versioning rules</a>, чтобы решить, какой номер следующей исполнения подходит для ваших изменений. Затем запустите <code>cargo publish</code>, чтобы загрузить новую исполнение.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="Устранение-устаревших-исполнений-с-cratesio-с-помощью-cargo-yank"><a class="header" href="#Устранение-устаревших-исполнений-с-cratesio-с-помощью-cargo-yank">Устранение устаревших исполнений с Crates.io с помощью <code>cargo yank</code></a></h3>
<p>Хотя вы не можете удалить предыдущие исполнения ящика, вы можете помешать любым будущим делам добавлять его в качестве новой зависимости. Это полезно, когда исполнение ящика сломана по той или иной причине. В таких случаейх Cargo поддерживает <em>выламывание</em> (yanking) исполнения ящика.</p>
<p>Вычёркивание исполнения не позволяет новым делам зависеть от этой исполнения, но при этом позволяет всем существующим делам, зависящим от неё, продолжать работу. По сути, исключение означает, что все дела с <em>Cargo.lock</em> не сломаются, а любые файлы <em>Cargo.lock</em>, которые будут порождаться в будущем, не смогут использовать исключённую исполнение.</p>
<p>Чтобы вычеркнуть исполнение ящика, в папки ящика, который вы обнародовали ранее, выполните приказ <code>cargo yank</code> и укажите, какую исполнение вы хотите вычеркнуть. Например, если мы обнародовали ящик под названием <code>guessing_game</code> исполнения 1.0.1 и хотим вычеркнуть её, в папке дела для <code>guessing_game</code> мы выполним:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Добавив в приказ <code>--undo</code>, вы также можете отменить выламывание и разрешить делам начать зависеть от исполнения снова:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Вычёркивание <em>не удаляет</em> код. Оно не может, например, удалить случайно загруженные пароли. Если это произойдёт, вы должны немедленно сбросить эти пароли.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Рабочие-пространства-cargo"><a class="header" href="#Рабочие-пространства-cargo">Рабочие пространства Cargo</a></h2>
<p>В главе 12 мы создали дополнение, который включал в себя двоичный и библиотечный ящики. По мере развития вашего дела может возникнуть случаей, когда библиотечный ящик будет становиться все больше, и вы захотите разделить ваш дополнение на несколько библиотечных ящиков. Cargo предоставляет возможность под названием <em>workspaces</em>, которая помогает управлять несколькими взаимосвязанными дополнениями, которые разрабатываются в тандеме.</p>
<h3 id="Создание-рабочего-пространства"><a class="header" href="#Создание-рабочего-пространства">Создание рабочего пространства</a></h3>
<p><em>Workspace</em> - это набор дополнений, которые используют один и тот же <em>Cargo.lock</em> и папку для хранения итогов сборки. Давайте создадим дело с использованием <em>workspace</em> - мы будем использовать обыкновенный код, чтобы сосредоточиться на устройстве рабочего пространства. Существует несколько способов внутренне выстроить</p>
<p>рабочую область, но мы покажем только один из них. У нас будет рабочая область, содержащая двоичный файл и две библиотеки. Двоичный файл, который обеспечивает основную возможность, будет зависеть от двух библиотек. Одна библиотека предоставит функцию <code>add_one</code>, а вторая - <code>add_two</code>. Эти три ящика будут частью одного <em>workspace</em>. Начнём с создания папки для рабочего окружения:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Далее в папке <em>add</em> мы создадим файл <em>Cargo.toml</em>, который будет определять настройку всего рабочего окружения. В этом файле не будет разделы <code>[package]</code>. Вместо этого он будет начинаться с разделы <code>[workspace]</code>, которая позволит нам добавить звенья в рабочее пространство, указав путь к дополнению с нашим двоичным ящиком; в данном случае этот путь - <em>adder</em>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    "adder",
]
</code></pre>
<p>Затем мы создадим исполняемый ящик <code>adder</code>, запустив приказ <code>cargo new</code> в папке <em>add</em>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>На этом этапе мы можем создать рабочее пространство, запустив  приказ <code>cargo build</code>. Файлы в папке <em>add</em> должны выглядеть следующим образом:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Рабочая область содержит на верхнем уровне один папка <em>target</em>, в который будут помещены собранные артефакты; дополнение <code>adder</code> не имеет собственного папки <em>target</em>. Даже если мы запустим <code>cargo build</code> из папки <em>adder</em>, собранные артефакты все равно окажутся в <em>add/target</em>, а не в <em>add/adder/target</em>. Cargo так определил папку <em>target</em> в рабочем пространстве, потому что ящики в рабочем пространстве должны зависеть друг от друга. Если бы каждый ящик имел свой собственный папка <em>target</em>, каждому ящику пришлось бы пересобирать каждый из других ящиков в рабочем пространстве, чтобы поместить артефакты в свой собственный папка <em>target</em>. Благодаря совместному использованию единого папки <em>target</em> ящики могут избежать ненужной пересборки.</p>
<h3 id="Добавление-второго-ящика-в-рабочее-пространство"><a class="header" href="#Добавление-второго-ящика-в-рабочее-пространство">Добавление второго ящика в рабочее пространство</a></h3>
<p>Далее давайте создадим ещё одного участника дополнения в рабочей области и назовём его <code>add_one</code>. Внесите изменения в <em>Cargo.toml</em> верхнего уровня так, чтобы указать путь <em>add_one</em> в списке <code>members</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    "adder",
    "add_one",
]
</code></pre>
<p>Затем создайте новый ящик библиотеки с именем <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Ваш папка <em>add</em> должен теперь иметь следующие папки и файлы:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>В файле <em>add_one/src/lib.rs</em> добавим функцию <code>add_one</code>:</p>
<p><span class="filename">Файл: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Теперь мы можем сделать так, чтобы дополнение <code>adder</code> с нашим исполняемым файлом зависел от дополнения <code>add_one</code>, содержащего нашу библиотеку. Сначала нам нужно добавить зависимость пути от <code>add_one</code> в <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Файл: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo не исходит из того, что ящики в рабочем пространстве могут зависеть друг от друга, поэтому нам необходимо явно указать отношения зависимости.</p>
<p>Далее, давайте используем функцию <code>add_one</code> (из ящика <code>add_one</code>) в ящике <code>adder</code>. Откройте файл <em>adder/src/main.rs</em> и добавьте строку <code>use</code> в верхней части, чтобы ввести в область видимости новый библиотечный ящик <code>add_one</code>. Затем измените функцию <code>main</code> для вызова функции <code>add_one</code>, как показано в приложении 14-7.</p>
<p><span class="filename">Файл: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}</code></pre>
<p><span class="caption">Приложение 14-7: Использование возможностей библиотечного ящика <code>add-one</code> в ящике <code>adder</code></span></p>
<p>Давайте соберём  рабочее пространство, запустив приказ <code>cargo build</code> в папке верхнего уровня <em>add</em>!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Чтобы запустить двоичный ящик из папки <em>add</em>, нам нужно указать какой дополнение из рабочей области мы хотим использовать с помощью переменной <code>-p</code> и названия дополнения в приказу <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Запуск кода из <em>adder/src/main.rs</em>, который зависит от <code>add_one</code>.</p>
<h4 id="Зависимость-от-внешних-ящиков-в-рабочем-пространстве"><a class="header" href="#Зависимость-от-внешних-ящиков-в-рабочем-пространстве">Зависимость от внешних ящиков в рабочем пространстве</a></h4>
<p>Обратите внимание, что рабочая область имеет один единственный файл <em>Cargo.lock</em> на верхнем уровне, а не содержит <em>Cargo.lock</em> в папке каждого ящика. Это заверяет, что все ящики используют одну и ту же исполнение всех зависимостей. Если мы добавим дополнение <code>rand</code> в файлы <em>adder/Cargo.toml</em> и <em>add_one/Cargo.toml</em>, Cargo сведёт их оба к одной исполнения <code>rand</code> и запишет её в один <em>Cargo.lock</em>. Если заставить все ящики в рабочей области использовать одни и те же зависимости, то это будет означать, что ящики всегда будут совместимы друг с другом. Давайте добавим ящик <code>rand</code> в раздел <code>[dependencies]</code> в файле <em>add_one/Cargo.toml</em>, чтобы мы могли использовать ящик <code>rand</code> в ящике <code>add_one</code>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Файл: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>Теперь мы можем добавить <code>use rand;</code> в файл  <em>add_one/src/lib.rs</em> и сделать сборку рабочего пространства, запустив <code>cargo build</code> в папке <em>add</em>, что загрузит и собирает <code>rand</code> ящик:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>Файл <em>Cargo.lock</em> верхнего уровня теперь содержит сведения о зависимости <code>add_one</code> к ящику <code>rand</code>. Тем не менее, не смотря на то что <code>rand</code> использован где-то в рабочем пространстве, мы не можем использовать его в других ящиках рабочего пространства, пока не добавим ящик <code>rand</code> в отдельные <em>Cargo.toml</em> файлы. Например, если мы добавим <code>use rand;</code> в файл <em>adder/src/main.rs</em> ящика  <code>adder</code>, то получим ошибку:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Чтобы исправить это, изменените файл <em>Cargo.toml</em> для дополнения <code>adder</code> и укажите, что <code>rand</code> также является его зависимостью. При сборке дополнения <code>adder</code> <code>rand</code> будет добавлен в список зависимостей для <code>adder</code> в <em>Cargo.lock</em>, но никаких дополнительных повторов <code>rand</code> загружено не будет. Cargo позаботился о том, чтобы все ящики во всех дополнениях рабочей области, использующих дополнение <code>rand</code>, использовали одну и ту же исполнение, экономя нам место и обеспечивая, что все ящики в рабочей области будут совместимы друг с другом.</p>
<h4 id="Добавление-проверки-в-рабочее-пространство"><a class="header" href="#Добавление-проверки-в-рабочее-пространство">Добавление проверки в рабочее пространство</a></h4>
<p>В качестве ещё одного улучшения давайте добавим проверка функции <code>add_one::add_one</code> в <code>add_one</code>:</p>
<p><span class="filename">Файл: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>Теперь запустите <code>cargo test</code> в папке верхнего уровня <em>add</em>. Запуск <code>cargo test</code> в рабочем пространстве, внутренне выстроеном</p>
<p>подобно этому, запустит проверки для всех ящиков в рабочем пространстве:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Первая раздел вывода показывает, что проверка <code>it_works</code> в ящике <code>add_one</code> прошёл. Следующая раздел показывает, что в ящике <code>adder</code> не было обнаружено ни одного проверки, а последняя раздел показывает, что в ящике <code>add_one</code> не было найдено ни одного проверки документации.</p>
<p>Мы также можем запустить проверки для одного определенного ящика в рабочем пространстве из папка верхнего уровня с помощью флага <code>-p</code> и указанием имени ящика для которого мы хотим запустить проверки:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Эти выходные данные показывают, что выполнение <code>cargo test</code> запускает только проверки для ящика <code>add-one</code> и не запускает проверки ящика <code>adder</code>.</p>
<p>Если вы соберётесь обнародовать ящики из рабочего пространства на <a href="https://crates.io/">crates.io</a>, каждый ящик будет необходимо будет обнародовать отдельно. Подобно <code>cargo test</code>, мы можем обнародовать определенный ящик из нашей рабочей области, используя флаг <code>-p</code> и указав имя ящика, который мы хотим обнародовать.</p>
<p>Для дополнительной опытов добавьте ящик <code>add_two</code> в данное рабочее пространство подобным способом, как делали с ящик <code>add_one</code> !</p>
<p>По мере роста дела рассмотрите возможность использования рабочих областей: легче понять небольшие, отдельные составляющие, чем один большой кусок кода. Кроме того, хранение ящиков в рабочем пространстве может облегчить согласование между ящиками, если они часто изменяются одновременно.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="Установка-двоичных-файлов-с-помощью-cargo-install"><a class="header" href="#Установка-двоичных-файлов-с-помощью-cargo-install">Установка двоичных файлов с помощью <code>cargo install</code></a></h2>
<p>Приказ <code>cargo install</code> позволяет местно устанавливать и использовать исполняемые ящики. Она не предназначена для замены системных дополнений; она используется как удобный способ Ржавчина разработчикам устанавливать средства, которыми другие разработчики поделились на сайте <a href="https://crates.io/">crates.io</a>. Заметьте, можно устанавливать только дополнения, имеющие исполняемые целевые ящики. <em>Исполняемой целью</em> (binary target) является запускаемая программа, созданная и имеющая в составе ящика файл <em>src/main.rs</em> или другой файл, указанный как исполняемый, в отличии от библиотечных ящиков, которые не могут запускаться сами по себе, но подходят для включения в другие программы. Обычно ящик содержит сведения в файле <em>README</em>, является ли он библиотекой, исполняемым файлом или обоими вместе.</p>
<p>Все исполняемые файлы установленные приказом <code>cargo install</code> сохранены в корневой установочной папке <em>bin</em>. Если вы установили Ржавчина с помощью <em>rustup.rs</em> и у вас его нет в пользовательских настройках, то этим папкой будет <em>$HOME/.cargo/bin</em>. Он заверяет, что папка находится в вашем окружении <code>$PATH</code>, чтобы вы имели возможность запускать программы, которые вы установили приказом <code>cargo install</code>.</p>
<p>Так, например, в главе 12 мы упоминали, что для поиска файлов существует выполнение утилиты <code>grep</code> на Ржавчина под названием <code>ripgrep</code>. Чтобы установить <code>ripgrep</code>, мы можем выполнить следующее:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>Последняя строка вывода показывает местоположение и название установленного исполняемого файла, который в случае <code>ripgrep</code> называется <code>rg</code>. Если вашей установочной папкой является <code>$PATH</code>, как уже упоминалось ранее, вы можете запустить <code>rg --help</code> и начать использовать более быстрый и грубый средство для поиска файлов!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Расширение-cargo-пользовательскими-приказми"><a class="header" href="#Расширение-cargo-пользовательскими-приказми">Расширение Cargo пользовательскими приказми</a></h2>
<p>Cargo расчитан так, что вы можете расширять его новыми субприказми без необходимости изменения самого Cargo. Если исполняемый файл доступен через переменную окружения <code>$PATH</code> и назван по образцу <code>cargo-something</code>, то его можно запускать как субприказ Cargo <code>cargo something</code>. Пользовательские приказы подобные этой также перечисляются в списке доступных через <code>cargo --list</code>. Возможность использовать <code>cargo install</code> для установки расширений и затем запускать их так же, как встроенные в Cargo средства, это очень удобное следствие продуманного внешнего вида Cargo!</p>
<h2 id="Итоги-11"><a class="header" href="#Итоги-11">Итоги</a></h2>
<p>Совместное использование кода с Cargo и <a href="https://crates.io/">crates.io</a><!-- --> является частью того, что делает внутреннее устройство Ржавчина полезной для множества различных задач. Обычная библиотека Ржавчина небольшая и безотказная, но ящики легко распространять, использовать и улучшать независимо от самого языка. Не стесняйтесь делиться кодом, который был вам полезен, через <a href="https://crates.io/">crates.io</a><!-- -->; скорее всего, он будет полезен и кому-то ещё!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Умные-указатели"><a class="header" href="#Умные-указатели">Умные указатели</a></h1>
<p><em>Указатель</em> — это общая подход для переменной, которая содержит адрес участка памяти. Этот адрес «относится к», или «указывает на» некоторые другие данные. Наиболее общая разновидность указателя в Ржавчина — это ссылка, о которой вы узнали из главы 4. Ссылки обозначаются символом <code>&amp;</code> и заимствуют значение, на которое указывают. Они не имеют каких-либо особых возможностей, кроме как ссылаться на данные, и не имеют никаких накладных расходов.</p>
<p><em>Умные указатели</em>, с другой стороны, являются устройствами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности. Подход умных указателей не неповторима для Rust: умные указатели возникли в C++ и существуют в других языках. В Ржавчина есть разные умные указатели, определённые в встроенной библиотеке, которые обеспечивают возможность, выходящую за рамки ссылок. Одним из примеров, который мы рассмотрим в этой главе, является вид умного указателя <em>reference counting</em> (подсчёт ссылок). Этот указатель позволяет иметь несколько владельцев с помощью отслеживания количества владельцев и, когда владельцев не остаётся, очищает данные.</p>
<p>Rust с его подходом владения и заимствования имеет дополнительное различие между ссылками и умными указателями: в то время, как ссылки только заимствуют данные, умные указатели часто <em>владеют</em> данными, на которые указывают.</p>
<p>Ранее мы уже сталкивались с умными указателями в этой книге, хотя и не называли их так, например <code>String</code> и <code>Vec&lt;T&gt;</code> в главе 8. Оба этих вида считаются умными указателями, потому что они владеют некоторой областью памяти и позволяют ею управлять. У них также есть метаданные и дополнительные возможности или заверения. <code>String</code>, например, хранит свой размер в виде метаданных и заверяет, что содержимое строки всегда будет в кодировке UTF-8.</p>
<p>Умные указатели обычно выполняются с помощью устройств. Присущей чертой, которая отличает умный указатель от обычной устройства, является то, что для умных указателей выполнены особенности <code>Deref</code> и <code>Drop</code>. Особенность <code>Deref</code> позволяет образцу умного указателя вести себя как ссылка, так что вы можете написать код, работающий с ним как со ссылкой, так и как с умным указателем. Особенность <code>Drop</code> позволяет написать код, который будет запускаться когда образец умного указателя выйдет из области видимости. В этой главе мы обсудим оба особенности и выясним, почему они важны для умных указателей.</p>
<p>Учитывая, что образец умного указателя является общим образцом разработки, часто используемым в Rust, эта глава не описывает все существующие умные указатели. Множество библиотек имеют свои умные указатели, и вы также можете написать свои. Мы охватим наиболее распространённые умные указатели из встроенной библиотеки:</p>
<ul>
<li><code>Box&lt;T&gt;</code> для распределения значений в куче (памяти)</li>
<li><code>Rc&lt;T&gt;</code> вид счётчика ссылок, который допускает множественное владение</li>
<li>Виды <code>Ref&lt;T&gt;</code> и <code>RefMut&lt;T&gt;</code>, доступ к которым осуществляется через вид <code>RefCell&lt;T&gt;</code>, который обеспечивает правила заимствования во время выполнения вместо времени сборки</li>
</ul>
<p>Дополнительно мы рассмотрим образец <em>внутренней изменчивости (interior mutability)</em>, где неизменяемый вид предоставляет API для изменения своего внутреннего значения. Мы также обсудим <em>ссылочные зацикленности (reference cycles)</em>: как они могут приводить к утечке памяти и как это предотвратить.</p>
<p>Приступим!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-boxt-для-ссылки-на-данные-в-куче"><a class="header" href="#Использование-boxt-для-ссылки-на-данные-в-куче">Использование <code>Box&lt;T&gt;</code> для ссылки на данные в куче</a></h2>
<p>Наиболее простой умный указатель - это <em>box</em>, чей вид записывается как <code>Box&lt;T&gt;</code>. Такие переменные позволяют хранить данные в куче, а не в обойме. То, что остаётся в обойме, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между обоймой и кучей.</p>
<p>У Box нет неполадок с производительностью, кроме хранения данных в куче вместо обоймы. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих случаейх:</p>
<ul>
<li>Когда у вас есть вид, размер которого невозможно определить во время сборки, а вы хотите использовать значение этого вида в среде, требующем точного размера.</li>
<li>Когда у вас есть большой размер данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут воспроизведены</li>
<li>Когда вы хотите получить значение во владение и вас важно только то, что оно относится к виду, выполняющему определённый особенность, а не то, является ли оно значением какого-то определенного вида</li>
</ul>
<p>Мы выясним первую случай в разделе <a href="ch15-01-box.html#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-Boxes">"Выполнение рекурсивных видов с помощью Box"</a><!-- ignore -->. Во втором случае, передача владения на большой размер данных может занять много времени, потому что данные повторяются через обойма. Для повышения производительности в этой случаи, мы можем хранить большое количество данных в куче с помощью Box. Затем только небольшое количество данных указателя воспроизводится в обойме, в то время как данные, на которые он ссылается, остаются в одном месте кучи. Третий случай известен как <em>особенность предмет</em> (trait object) и глава 17 посвящает целый раздел <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование особенность предметов, которые допускают значения разных видов"</a><!-- ignore --> только этой теме. Итак, то, что вы узнаете здесь, вы примените снова в Главе 17!</p>
<h3 id="Использование-boxt-для-хранения-данных-в-куче"><a class="header" href="#Использование-boxt-для-хранения-данных-в-куче">Использование <code>Box&lt;T&gt;</code> для хранения данных в куче</a></h3>
<p>Прежде чем мы обсудим этот исход использования <code>Box&lt;T&gt;</code>, мы рассмотрим правила написания и то, как взаимодействовать со значениями, хранящимися в <code>Box&lt;T&gt;</code>.</p>
<p>В приложении 15-1 показано, как использовать поле для хранения значения <code>i32</code> в куче:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<p><span class="caption">Приложение 15-1: Сохранение значения <code>i32</code> в куче с использованием box</span></p>
<p>Мы объявляем переменную <code>b</code> со значением <code>Box</code>, указывающим на число <code>5</code>, размещённое в куче. Эта программа выведет <code>b = 5</code>; в этом случае мы получаем доступ к данным в box так же, как если бы эти данные находились в обойме. Как и любое другое значение, когда box выйдет из области видимости, как <code>b</code> в конце <code>main</code>, он будет удалён. Деаллокация происходит как для box ( хранящегося в обойме), так и для данных, на которые он указывает (хранящихся в куче).</p>
<p>Размещать одиночные значения в куче не слишком целесообразно, поэтому вряд ли вы будете часто использовать box'ы таким образом. В большинстве случаев более уместно размещать такие значения, как <code>i32</code>, в обойме, где они и сохраняются по умолчанию. Давайте рассмотрим случай, когда box позволяет нам определить виды, которые мы не могли бы иметь, если бы у нас не было box.</p>
<h3 id="Включение-рекурсивных-видов-с-помощью-boxes"><a class="header" href="#Включение-рекурсивных-видов-с-помощью-boxes">Включение рекурсивных видов с помощью Boxes</a></h3>
<p>Значение <em>рекурсивного вида</em> может иметь другое значение такого же вида как свой составляющая. Рекурсивные виды представляют собой неполадку, поскольку во время сборки Ржавчина должен знать, сколько места занимает вид. Однако вложенность значений рекурсивных видов предположительно может продолжаться бесконечно, поэтому Ржавчина не может определить, сколько места потребуется. Поскольку box имеет известный размер, мы можем включить рекурсивные виды, добавив box в определение рекурсивного вида.</p>
<p>В качестве примера рекурсивного вида рассмотрим <em>cons list</em>. Это вид данных, часто встречающийся в полезных языках программирования. Вид cons list, который мы определим, достаточно прост, за исключением наличия рекурсии; поэтому подходы, заложенные в примере, с которым мы будем работать, пригодятся вам в любой более сложной случаи, связанной с рекурсивными видами.</p>
<h4 id="Больше-сведений-о-cons-списке"><a class="header" href="#Больше-сведений-о-cons-списке">Больше сведений о cons списке</a></h4>
<p><em>cons list</em> - это устройства данных из языка программирования Lisp и его диалектов, представляющая собой набор вложенных пар и являющаяся Lisp-исполнением связного списка. Его название происходит от функции <code>cons</code> (сокращение от "construct function") в Lisp, которая создает пару из двух своих переменных. Вызывая <code>cons</code> для пары, которая состоит из некоторого значения и другой пары, мы можем выстраивать списки cons, состоящие из рекурсивных пар.</p>
<p>Вот, пример cons list в виде псевдокода, содержащий список 1, 2, 3, где каждая пара заключена в круглые скобки:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Каждый элемент в cons списке содержит два элемента: значение текущего элемента и следующий элемент. Последний элемент в списке содержит только значение называемое <code>Nil</code> без следующего элемента. Cons список создаётся путём рекурсивного вызова функции <code>cons</code>. Каноничное имя для обозначения основного случая рекурсии - <code>Nil</code>. Обратите внимание, что это не то же самое, что понятие “null” или “nil” из главы 6, которая является недействительным или отсутствующим значением.</p>
<p>Cons list не является часто используемой устройством данных в Rust. В большинстве случаев, когда вам нужен список элементов при использовании Rust, лучше использовать <code>Vec&lt;T&gt;</code>. Другие, более сложные рекурсивные виды данных <em>полезны</em> в определённых случаейх, но благодаря тому, что в этой главе мы начнём с cons list, мы сможем выяснить, как box позволяет нам определить рекурсивный вид данных без особого напряжения.</p>
<p>Приложение 15-2 содержит объявление перечисления cons списка. Обратите внимание, что этот код не будет собираться, потому что вид <code>List</code> не имеет известного размера, что мы и выясним.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Приложение 15-2: Первая попытка определить перечисление в качестве устройства данных cons list, состоящей из <code>i32</code> значений.</span></p>
<blockquote>
<p>Примечание: В данном примере мы выполняем cons list, который содержит только значения <code>i32</code>. Мы могли бы выполнить его с помощью generics, о которых мы говорили в главе 10, чтобы определить вид cons list, который мог бы хранить значения любого вида.</p>
</blockquote>
<p>Использование вида <code>List</code> для хранения списка <code>1, 2, 3</code> будет выглядеть как код в приложении 15-3:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<p><span class="caption">Приложение 15-3: Использование перечисления <code>List</code> для хранения списка <code>1, 2, 3</code></span></p>
<p>Первое значение <code>Cons</code> содержит <code>1</code> и другой <code>List</code>. Это значение <code>List</code> является следующим значением <code>Cons</code>, которое содержит <code>2</code> и другой <code>List</code>. Это значение <code>List</code> является ещё один значением <code>Cons</code>, которое содержит <code>3</code> и значение <code>List</code>, которое наконец является <code>Nil</code>, не рекурсивным исходом, сигнализирующим об окончании списка.</p>
<p>Если мы попытаемся собрать код в приложении 15-3, мы получим ошибку, показанную в приложении 15-4:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<p><span class="caption">Приложение 15-4: Ошибка, которую мы получаем при попытке определить рекурсивное перечисление</span></p>
<p>Ошибка говорит о том, что этот вид "имеет бесконечный размер". Причина в том, что мы определили <code>List</code> в виде, которая является рекурсивной: она непосредственно хранит другое значение своего собственного вида. В итоге Ржавчина не может определить, сколько места ему нужно для хранения значения <code>List</code>. Давайте разберёмся, почему мы получаем эту ошибку. Сначала мы рассмотрим, как Ржавчина решает, сколько места ему нужно для хранения значения нерекурсивного вида.</p>
<h4 id="Вычисление-размера-нерекурсивного-вида"><a class="header" href="#Вычисление-размера-нерекурсивного-вида">Вычисление размера нерекурсивного вида</a></h4>
<p>Вспомните перечисление <code>Message</code> определённое в приложении 6-2, когда обсуждали объявление enum  в главе 6:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Чтобы определить, сколько памяти выделять под значение <code>Message</code>, Ржавчина проходит каждый из исходов, чтобы увидеть, какой исход требует наибольшее количество памяти. Ржавчина видит, что для <code>Message::Quit</code> не требуется места, <code>Message::Move</code> хватает места для хранения двух значений <code>i32</code> и т.д. Так как будет использоваться только один исход, то наибольшее пространство, которое потребуется для значения <code>Message</code>, это пространство, которое потребуется для хранения самого большого из исходов перечисления.</p>
<p>Сравните это с тем, что происходит, когда Ржавчина пытается определить, сколько места необходимо рекурсивному виду, такому как перечисление <code>List</code> в приложении 15-2. Сборщик смотрит на исход <code>Cons</code>, который содержит значение вида <code>i32</code> и значение вида <code>List</code>. Следовательно, <code>Cons</code> нужно пространство, равное размеру <code>i32</code> плюс размер <code>List</code>. Чтобы выяснить, сколько памяти необходимо виду <code>List</code>, сборщик смотрит на исходы, начиная с <code>Cons</code>. Исход <code>Cons</code> содержит значение вида <code>i32</code> и значение вида <code>List</code>, и этот этап продолжается бесконечно, как показано на рисунке 15-1.</p>
 <img alt="Бесконечный список Cons" src="img/trpl15-01.svg" class="center" style="width: 50%;">
<p><span class="caption">Рисунок 15-1: Бесконечный <code>List</code>, состоящий из нескончаемого числа исходов <code>Cons</code></span></p>
<h4 id="Использование-boxt-для-получения-рекурсивного-вида-с-известным-размером"><a class="header" href="#Использование-boxt-для-получения-рекурсивного-вида-с-известным-размером">Использование <code>Box&lt;T&gt;</code> для получения рекурсивного вида с известным размером</a></h4>
<p>Поскольку Ржавчина не может определить, сколько места нужно выделить для видов с рекурсивным определением, сборщик выдаёт ошибку с этим полезным предложением:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>В данном предложении "перенаправление" означает, что вместо того, чтобы непосредственно хранить само значение, мы должны изменить устройство данных, так чтобы хранить его косвенно - хранить указатель на это значение.</p>
<p>Поскольку <code>Box&lt;T&gt;</code> является указателем, Ржавчина всегда знает, сколько места нужно <code>Box&lt;T&gt;</code>: размер указателя не меняется в зависимости от объёма данных, на которые он указывает. Это означает, что мы можем поместить <code>Box&lt;T&gt;</code> внутрь образца <code>Cons</code> вместо значения <code>List</code> напрямую. <code>Box&lt;T&gt;</code> будет указывать на значение очередного <code>List</code>, который будет находиться в куче, а не внутри образца <code>Cons</code>. Мировозренческо у нас все ещё есть список, созданный из списков, содержащих другие списки, но эта выполнение теперь больше похожа на размещение элементов рядом друг с другом, а не внутри друг друга.</p>
<p>Мы можем изменить определение перечисления <code>List</code> в приложении 15-2 и использование <code>List</code> в приложении 15-3 на код из приложения 15-5, который будет собираться:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Приложение 15-5: Определение <code>List</code>, которое использует <code>Box&lt;T&gt;</code> для того, чтобы иметь вычисляемый размер</span></p>
<p><code>Cons</code> требуется объём <code>i32</code> плюс место для хранения данных указателя box. <code>Nil</code> не хранит никаких значений, поэтому ему нужно меньше места, чем <code>Cons</code>. Теперь мы знаем, что любое значение <code>List</code> займёт размер <code>i32</code> плюс размер данных указателя box. Используя box, мы разорвали бесконечную рекурсивную цепочку, поэтому сборщик может определить размер, необходимый для хранения значения <code>List</code>. На рисунке 15-2 показано, как теперь выглядит <code>Cons</code>.</p>
 <img alt="Бесконечный список Cons" src="img/trpl15-02.svg" class="center" style="width: 50%;">
<p><span class="caption">Рисунок 15-2: <code>List</code>, который не является бесконечно большим, потому что <code>Cons</code> хранит <code>Box</code>.</span></p>
<p>Box-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других особых возможностей, подобных тем, которые мы увидим у других видов умных указателей. У них также нет накладных расходов на производительность, которые несут эти особые возможности, поэтому они могут быть полезны в таких случаях, как cons list, где перенаправление - единственная функция, которая нам нужна. В главе 17 мы также рассмотрим другие случаи использования box.</p>
<p>Вид <code>Box&lt;T&gt;</code> является умным указателем, поскольку он выполняет особенность <code>Deref</code>, который позволяет обрабатывать значения <code>Box&lt;T&gt;</code> как ссылки. Когда значение <code>Box&lt;T&gt;</code> выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря выполнения особенности <code>Drop</code>. Эти два особенности будут ещё более значимыми для возможности, предоставляемой другими видами умных указателей, которые мы обсудим в оставшейся части этой главы. Давайте рассмотрим эти два особенности более подробно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обращение-с-умными-указателями-как-с-обычными-ссылками-с-помощью-deref-особенности"><a class="header" href="#Обращение-с-умными-указателями-как-с-обычными-ссылками-с-помощью-deref-особенности">Обращение с умными указателями как с обычными ссылками с помощью <code>Deref</code> особенности</a></h2>
<p>Используя особенность <code>Deref</code>, вы можете изменить поведение <em>оператора разыменования</em> <code>*</code> (не путать с операторами умножения или вездесущего подключения). Выполнив <code>Deref</code> таким образом, что умный указатель может рассматриваться как обычная ссылка, вы можете писать код, оперирующий ссылками, а также использовать этот код с умными указателями.</p>
<p>Давайте сначала посмотрим, как работает оператор разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский вид, который ведёт себя как <code>Box&lt;T&gt;</code> и посмотрим, почему оператор разыменования не работает как ссылка для нового объявленного вида. Мы рассмотрим, как выполнение особенности <code>Deref</code> делает возможным работу умных указателей подобно ссылкам. Затем посмотрим на <em>разыменованное приведение</em> (deref coercion) в Ржавчина и как оно позволяет работать с любыми ссылками или умными указателями.</p>
<blockquote>
<p>Примечание: есть одна большая разница между видом <code>MyBox&lt;T&gt;</code>, который мы собираемся создать и существующим <code>Box&lt;T&gt;</code>: наша исполнение не будет хранить свои данные в куче. В примере мы сосредоточимся на особенности <code>Deref</code>, поэтому менее важно то, где данные хранятся, чем поведение подобное указателю.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="Следуя-за-указателем-на-значение"><a class="header" href="#Следуя-за-указателем-на-значение">Следуя за указателем на значение</a></h3>
<p>Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте. В приложении 15-6 мы создаём ссылку на значение <code>i32</code>, а затем используем оператор разыменования для перехода от ссылки к значению:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Приложение 15-6: Использование оператора разыменования для следования по ссылке к значению <code>i32</code></span></p>
<p>Переменной <code>x</code> присвоено значение<code>5</code> вида <code>i32</code>. Мы установили в качестве значения <code>y</code> ссылку на <code>x</code>. Мы можем утверждать, что значение <code>x</code> равно <code>5</code>. Однако, если мы хотим сделать утверждение о значении в <code>y</code>, мы должны использовать <code>*y</code>, чтобы перейти по ссылке к значению, на которое она указывает (таким образом, происходит <em>разыменование</em>), для того чтобы сборщик при сравнении мог использовать действительное значение. Как только мы разыменуем <code>y</code>, мы получим доступ к целочисленному значению, на которое указывает <code>y</code>, которое и будем сравнивать с <code>5</code>.</p>
<p>Если бы мы попытались написать <code>assert_eq!(5, y);</code>, то получили ошибку сборки:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Сравнение числа и ссылки на число не допускается, потому что они различных видов. Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.</p>
<h3 id="Использование-boxt-как-ссылку"><a class="header" href="#Использование-boxt-как-ссылку">Использование <code>Box&lt;T&gt;</code> как ссылку</a></h3>
<p>Мы можем переписать код в приложении 15-6, чтобы использовать <code>Box&lt;T&gt;</code> вместо ссылки; оператор разыменования, используемый для <code>Box&lt;T&gt;</code> в приложении 15-7, работает так же, как оператор разыменования, используемый для ссылки в приложении 15-6:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Приложение 15-7: Использование оператора разыменования с видом <code>Box&lt;i32&gt;</code></span></p>
<p>Основное различие между приложением 15-7 и приложением 15-6 заключается в том, что здесь мы устанавливаем <code>y</code> как образец <code>Box&lt;T&gt;</code>, указывающий на воспроизведенное значение <code>x</code>, а не как ссылку, указывающую на значение <code>x</code>. В последнем утверждении мы можем использовать оператор разыменования, чтобы проследовать за указателем <code>Box&lt;T&gt;</code> так же, как мы это делали, когда <code>y</code> был ссылкой. Далее мы рассмотрим, что особенного в <code>Box&lt;T&gt;</code>, что позволяет нам использовать оператор разыменования, определяя наш собственный вид.</p>
<h3 id="Определение-собственного-умного-указателя"><a class="header" href="#Определение-собственного-умного-указателя">Определение собственного умного указателя</a></h3>
<p>Давайте создадим умный указатель, похожий на вид <code>Box&lt;T&gt;</code> предоставляемый встроенной библиотекой, чтобы понять как поведение умных указателей отличается от поведения обычной ссылки. Затем мы рассмотрим вопрос, как добавить возможность использовать оператор разыменования.</p>
<p>Вид <code>Box&lt;T&gt;</code> в конечном итоге определяется как устройства упорядоченного ряда с одним элементом, поэтому в приложении 15-8 подобным образом определяется <code>MyBox&lt;T&gt;</code>. Мы также определим функцию <code>new</code>, чтобы она соответствовала функции <code>new</code>, определённой в <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 15-8: Определение вида <code>MyBox&lt;T&gt;</code></span></p>
<p>Мы определяем устройство с именем <code>MyBox</code> и объявляем обобщённый свойство <code>T</code>, потому что мы хотим, чтобы наш вид хранил значения любого вида. Вид <code>MyBox</code> является устройством упорядоченного ряда с одним элементом вида <code>T</code>. Функция <code>MyBox::new</code> принимает один свойство вида <code>T</code> и возвращает образец <code>MyBox</code>, который содержит переданное значение.</p>
<p>Давайте попробуем добавить функцию <code>main</code> из приложения 15-7 в приложение 15-8 и изменим её на использование вида <code>MyBox&lt;T&gt;</code>, который мы определили вместо <code>Box&lt;T&gt;</code>. Код в приложении 15-9 не будет собираться, потому что Ржавчина не знает, как разыменовывать <code>MyBox</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<p><span class="caption">Приложение 15-9. Попытка использовать <code>MyBox&lt;T&gt;</code> таким же образом, как мы использовали ссылки и <code>Box&lt;T&gt;</code></span></p>
<p>Вот итог ошибки сборки:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Наш вид <code>MyBox&lt;T&gt;</code> не может быть разыменован, потому что мы не выполнили эту возможность. Чтобы включить разыменование с помощью оператора <code>*</code>, мы выполняем особенность <code>Deref</code>.</p>
<h3 id="Трактование-вида-как-ссылки-выполняя-особенность-deref"><a class="header" href="#Трактование-вида-как-ссылки-выполняя-особенность-deref">Трактование вида как ссылки выполняя особенность <code>Deref</code></a></h3>
<p>Как обсуждалось в разделе <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“Выполнение особенности для типа”</a><!--  --> Главы 10, для выполнения особенности нужно предоставить выполнения требуемых способов особенности. Особенность <code>Deref</code>, предоставляемый встроенной библиотекой требует от нас выполнения одного способа с именем <code>deref</code>, который заимствует <code>self</code> и возвращает ссылку на внутренние данные. Приложение 15-10 содержит выполнение <code>Deref</code> добавленную к определению <code>MyBox</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-10: Выполнение <code>Deref</code> для вида <code>MyBox&lt;T&gt;</code></span></p>
<p>правила написания <code>type Target = T;</code> определяет связанный вид для использования у особенности <code>Deref</code>. Связанные виды - это немного другой способ объявления обобщённого свойства, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.</p>
<p>Мы заполним тело способа <code>deref</code> оператором <code>&amp;self.0 </code>, чтобы <code>deref</code> вернул ссылку на значение, к которому мы хотим получить доступ с помощью оператора <code>*</code>; вспомним из раздела <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">"Using Tuple Structs without Named Fields to Create Different Types"</a><!-- ignore --> главы 5, что <code>.0</code> получает доступ к первому значению в упорядоченной в ряд устройстве. Функция <code>main</code> в приложении 15-9, которая вызывает <code>*</code> для значения <code>MyBox&lt;T&gt;</code>, теперь собирается, и проверки проходят!</p>
<p>Без особенности <code>Deref</code> сборщик может только разыменовывать <code>&amp;</code> ссылки. Способ <code>deref</code> даёт сборщику возможность принимать значение любого вида, выполняющего <code>Deref</code> и вызывать способ <code>deref</code> чтобы получить ссылку <code>&amp;</code>, которую он знает, как разыменовывать.</p>
<p>Когда мы ввели <code>*y</code> в приложении 15-9, Ржавчина в действительности выполнил за кулисами такой код:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust заменяет оператор <code>*</code> вызовом способа <code>deref</code> и затем простое разыменование, поэтому нам не нужно думать о том, нужно ли нам вызывать способ <code>deref</code>. Эта функция Ржавчина позволяет писать код, который исполняется одинаково, независимо от того, есть ли у нас обычная ссылка или вид, выполняющий особенность <code>Deref</code>.</p>
<p>Причина, по которой способ <code>deref</code> возвращает ссылку на значение, и что простое разыменование вне круглых скобок в <code>*(y.deref())</code> все ещё необходимо, связана с системой владения. Если бы способ <code>deref</code> возвращал значение напрямую, а не ссылку на него, значение переместилось бы из <code>self</code>. Мы не хотим передавать владение внутренним значением внутри <code>MyBox&lt;T&gt;</code> в этом случае и в большинстве случаев, когда мы используем оператор разыменования.</p>
<p>Обратите внимание, что оператор <code>*</code> заменён вызовом способа <code>deref</code>, а затем вызовом оператора <code>*</code> только один раз, каждый раз, когда мы используем <code>*</code> в коде. Поскольку замена оператора <code>*</code> не повторяется бесконечно, мы получаем данные вида <code>i32</code>, которые соответствуют <code>5</code> в <code>assert_eq!</code> приложения 15-9.</p>
<h3 id="Неявные-разыменованные-приведения-с-функциями-и-способами"><a class="header" href="#Неявные-разыменованные-приведения-с-функциями-и-способами">Неявные разыменованные приведения с функциями и способами<a id="implicit-deref-coercions-with-functions-and-methods"></a></a></h3>
<p><em>Разыменованное приведение</em> преобразует ссылку на вид, который выполняет признак <code>Deref</code>, в ссылку на другой вид. Например, deref coercion может преобразовать <code>&amp;String</code> в <code>&amp;str</code>, потому что <code>String</code> выполняет признак <code>Deref</code>, который возвращает <code>&amp;str</code>. Deref coercion - это удобный рычаг, который Ржавчина использует для переменных функций и способов, и работает только для видов, выполняющих признак <code>Deref</code>. Это происходит самостоятельно , когда мы передаём в качестве переменной функции или способа ссылку на значение определённого вида, которое не соответствует виду свойства в определении функции или способа. В итоге серии вызовов способа <code>deref</code> вид, который мы передали, преобразуется в вид, необходимый для свойства.</p>
<p>Разыменованное приведение было добавлено в Rust, так что программистам, пишущим вызовы функций и способов, не нужно добавлять множество явных ссылок и разыменований с помощью использования <code>&amp;</code> и <code>*</code>. Возможность разыменованного приведения также позволяет писать больше кода, который может работать как с ссылками, так и с умными указателями.</p>
<p>Чтобы увидеть разыменованное приведение в действии, давайте воспользуемся видом <code>MyBox&lt;T&gt;</code> определённым в приложении 15-8, а также выполнение <code>Deref</code> добавленную в приложении 15-10. Приложение 15-11 показывает определение функции, у которой есть свойство вида срез строки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 15-11: Функция <code>hello</code> имеющая свойство  <code>name</code> вида <code>&amp;str</code></span></p>
<p>Можно вызвать функцию <code>hello</code> со срезом строки в качестве переменной, например <code>hello("Rust");</code>. Разыменованное приведение делает возможным вызов <code>hello</code> со ссылкой на значение вида <code>MyBox&lt;String&gt;</code>, как показано в приложении 15-12.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
<p><span class="caption">Приложение 15-12: Вызов <code>hello</code> со ссылкой на значение <code>MyBox&lt;String&gt;</code>, которое работает из-за разыменованного приведения</span></p>
<p>Здесь мы вызываем функцию <code>hello</code> с переменнаяом <code>&amp;m</code>, который является ссылкой на значение <code>MyBox&lt;String&gt;</code>. Поскольку мы выполнили особенность <code>Deref</code> для <code>MyBox&lt;T&gt;</code> в приложении 15-10, то Ржавчина может преобразовать <code>&amp;MyBox&lt;String&gt;</code> в <code>&amp;String</code> вызывая <code>deref</code>. Обычная библиотека предоставляет выполнение особенности <code>Deref</code> для вида <code>String</code>, которая возвращает срез строки, это описано в документации API особенности <code>Deref</code>. Ржавчина снова вызывает <code>deref</code>, чтобы превратить <code>&amp;String</code> в <code>&amp;str</code>, что соответствует определению функции <code>hello</code>.</p>
<p>Если бы Ржавчина не выполнил разыменованное приведение, мы должны были бы написать код в приложении 15-13 вместо кода в приложении 15-12 для вызова способа <code>hello</code> со значением вида <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Приложение 15-13: Код, который нам пришлось бы написать, если бы в Ржавчина не было разыменованного приведения ссылок</span></p>
<p>Код <code>(*m)</code> разыменовывает <code>MyBox&lt;String&gt;</code> в <code>String</code>. Затем <code>&amp;</code> и <code>[..]</code> принимают строковый срез <code>String</code>, равный всей строке, чтобы соответствовать ярлыке <code>hello</code>. Код без разыменованного приведения сложнее читать, писать и понимать со всеми этими символами. Разыменованное приведение позволяет Ржавчина обрабатывать эти преобразования для нас самостоятельно .</p>
<p>Когда особенность <code>Deref</code> определён для задействованных видов, Ржавчина проанализирует виды и будет использовать <code>Deref::deref</code> столько раз, сколько необходимо, чтобы получить ссылку, соответствующую виду свойства. Количество раз, которое нужно вставить <code>Deref::deref</code> определяется во время сборки, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!</p>
<h3 id="Как-разыменованное-приведение-взаимодействует-с-изменяемостью"><a class="header" href="#Как-разыменованное-приведение-взаимодействует-с-изменяемостью">Как разыменованное приведение взаимодействует с изменяемостью</a></h3>
<p>Подобно тому, как вы используете особенность <code>Deref</code> для переопределения оператора <code>*</code> у неизменяемых ссылок, вы можете использовать особенность <code>DerefMut</code> для переопределения оператора <code>*</code> у изменяемых ссылок.</p>
<p>Rust выполняет разыменованное приведение, когда находит виды и выполнения особенностей в трёх случаях:</p>
<ul>
<li>Из вида <code>&amp;T</code> в вид <code>&amp;U</code> когда верно <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Из вида <code>&amp;mut T</code> в вид <code>&amp;mut U</code> когда верно <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Из вида <code>&amp;mut T</code> в вид <code>&amp;U</code> когда верно <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Первые два случая равноценны друг другу, за исключением того, что второй выполняет изменяемость. В первом случае говорится, что если у вас есть <code>&amp;T</code>, а <code>T</code> выполняет <code>Deref</code> для некоторого вида <code>U</code>, вы сможете прозрачно получить <code>&amp;U</code>. Во втором случае говорится, что такое же разыменованное приведение происходит и для изменяемых ссылок.</p>
<p>Третий случай хитрее: Ржавчина также приводит изменяемую ссылку к неизменяемой. Но обратное <em>не</em> представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на данные (в противном случае программа не будет собираться). Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, и правила заимствования не заверяют этого. Следовательно, Ржавчина не может сделать предположение, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Запуск-кода-при-очистке-с-помощью-особенности-drop"><a class="header" href="#Запуск-кода-при-очистке-с-помощью-особенности-drop">Запуск кода при очистке с помощью особенности <code>Drop</code></a></h2>
<p>Вторым важным особенностью умного указателя является Drop, который позволяет управлять, что происходит, когда значение вот-вот выйдет из области видимости. Вы можете выполнить особенность Drop для любого вида, а также использовать этот код для высвобождения ресурсов, таких как файлы или сетевые соединения.</p>
<p>Мы рассматриваем <code>Drop</code> в среде умных указателей, потому что возможность свойства <code>Drop</code> по сути всегда используется при выполнения умного указателя. Например, при сбросе <code>Box&lt;T&gt;</code> происходит деаллокация пространства на куче, на которое указывает box.</p>
<p>В некоторых языках для некоторых видов программист должен вызывать код для освобождения памяти или ресурсов каждый раз, когда он завершает использование образцов этих видов. Примерами могут служить указатели файлов, сокеты или блокировки. Если забыть об этом, система окажется перегруженной и может упасть. В Ржавчина вы можете указать, что определённый отрывок кода должен выполняться всякий раз, когда значение выходит из области видимости, и сборщик самостоятельно будет его вставлять. Как следствие, вам не нужно заботиться о размещении кода очистки везде в программе, где завершается работа образца определённого вида - утечки ресурсов все равно не будет!</p>
<p>Вы можете задать определённую логику, которая будет выполняться, когда значение выходит за пределы области видимости, выполнив признак <code>Drop</code>. Особенность <code>Drop</code> требует от вас выполнения одного способа <code>drop</code>, который принимает изменяемую ссылку на <code>self</code>. Чтобы увидеть, когда Ржавчина вызывает <code>drop</code>, давайте выполняем <code>drop</code> с помощью указаний <code>println!</code>.</p>
<p>В приложении 15-14 показана устройства <code>CustomSmartPointer</code>, единственной не имеющей себе подобных возможностью которой является печать <code>Dropping CustomSmartPointer!</code>, когда образец выходит из области видимости, чтобы показать, когда Ржавчина выполняет функцию <code>drop</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre></pre>
<p><span class="caption">Приложение 15-14: Устройства <code>CustomSmartPointer</code>, выполняющая особенность <code>Drop</code>, куда мы поместим наш код очистки</span></p>
<p>Особенность <code>Drop</code> включён в прелюдию, поэтому нам не нужно вводить его в область видимости. Мы выполняем особенность <code>Drop</code> для <code>CustomSmartPointer</code> и выполняем способ <code>drop</code>, который будет вызывать <code>println!</code>. Тело функции <code>drop</code> - это место, где должна располагаться вся логика, которую вы захотите выполнять, когда образец вашего вида выйдет из области видимости. Мы печатаем здесь текст, чтобы наглядно отобразить, когда Ржавчина вызовет <code>drop</code>.</p>
<p>В <code>main</code> мы создаём два образца <code>CustomSmartPointer</code> и затем печатаем <code>CustomSmartPointers created</code> . В конце <code>main</code> наши образцы <code>CustomSmartPointer</code> выйдут из области видимости и Ржавчина вызовет код, который мы добавили в способ <code>drop</code>, который и напечатает наше окончательное сообщение. Обратите внимание, что нам не нужно вызывать способ <code>drop</code> явно.</p>
<p>Когда мы запустим эту программу, мы увидим следующий вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust самостоятельно вызывал <code>drop</code> в мгновение выхода наших образцов из области видимости, тем самым выполнив заданный нами код. Переменные удаляются в обратном порядке их создания, поэтому <code>d</code> была удалена до <code>c</code>. Цель этого примера — дать вам наглядное представление о том, как работает способ <code>drop</code>; в типичных случаях вы будете задавать код очистки, который должен выполнить ваш вид, а не печатать сообщение.</p>
<h3 id="Раннее-удаление-значения-с-помощью-stdmemdrop"><a class="header" href="#Раннее-удаление-значения-с-помощью-stdmemdrop">Раннее удаление значения с помощью <code>std::mem::drop</code></a></h3>
<p>К сожалению, отключение функции самостоятельного удаления с помощью <code>drop</code> является не простым. Отключение <code>drop</code> обычно не требуется; весь смысл особенности <code>Drop</code> в том, чтобы о функции позаботились самостоятельно . Иногда, однако, вы можете захотеть очистить значение рано. Одним из примеров является использование умных указателей, которые управляют блокировками: вы могли бы потребовать принудительный вызов способа <code>drop</code> который снимает блокировку, чтобы другой код в той же области видимости мог получить блокировку. Ржавчина не позволяет вызвать способ особенности <code>Drop</code> вручную; вместо этого вы должны вызвать функцию <code>std::mem::drop</code> предоставляемую встроенной библиотекой, если хотите принудительно удалить значение до конца области видимости.</p>
<p>Если попытаться вызвать способ <code>drop</code> особенности <code>Drop</code> вручную, изменяя функцию <code>main</code> приложения 15-14 так, как показано в приложении 15-15, мы получим ошибку сборщика:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre>
<p><span class="caption">Приложение 15-15: Попытка вызвать способ <code>drop</code> из особенности <code>Drop</code> вручную для досрочной очистки</span></p>
<p>Когда мы попытаемся собрать этот код, мы получим ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>Это сообщение об ошибке говорит, что мы не можем явно вызывать <code>drop</code>. В сообщении об ошибке используется понятие <em>деструктор (destructor)</em>, который является общим понятием программирования для функции, которая очищает образец. <em>Деструктор</em> подобен <em>строителю</em>, который создаёт образец. Функция <code>drop</code> в Ржавчина является определённым деструктором.</p>
<p>Rust не позволяет обращаться к <code>drop</code> напрямую, потому что он все равно самостоятельно вызовет <code>drop</code> в конце <code>main</code>. Это вызвало бы ошибку <em>double free</em>, потому что в этом случае Ржавчина попытался бы дважды очистить одно и то же значение.</p>
<p>Невозможно отключить самостоятельную подстановку вызова <code>drop</code>, когда значение выходит из области видимости, и нельзя вызвать способ <code>drop</code> напрямую. Поэтому, если нам нужно принудительно избавиться от значения раньше времени, следует использовать функцию <code>std::mem::drop</code>.</p>
<p>Функция <code>std::mem::drop</code> отличается от способа <code>drop</code> особенности <code>Drop</code>. Мы вызываем её, передавая в качестве переменной значение, которое хотим принудительно уничтожить. Функция находится в прелюдии, поэтому мы можем изменить <code>main</code> в приложении 15-15 так, чтобы вызвать функцию <code>drop</code>, как показано в приложении 15-16:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre></pre>
<p><span class="caption">Приложение 15-16: Вызов <code>std::mem::drop</code> для принудительного удаления значения до того, как оно выйдет из области видимости</span></p>
<p>Выполнение данного кода выведет следующий итог::</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>Текст <code>Dropping CustomSmartPointer with data </code>some data<code>!</code>, напечатанный между <code>CustomSmartPointer created.</code> и текстом <code>CustomSmartPointer dropped before the end of main.</code>, показывает, что код способа <code>drop</code> вызывается для удаления <code>c</code> в этой точке.</p>
<p>Вы можете использовать код, указанный в выполнения особенности <code>Drop</code>, чтобы сделать очистку удобной и безопасной: например, вы можете использовать её для создания своего собственного управленца памяти! С помощью особенности <code>Drop</code> и системы владения Ржавчина не нужно целенаправленно заботиться о том, чтобы освобождать ресурсы, потому что Ржавчина делает это самостоятельно .</p>
<p>Также не нужно беспокоиться о неполадках, возникающих в итоге случайной очистки значений, которые всё ещё используются: система владения, которая заверяет, что ссылки всегда действительны, также заверяет, что <code>drop</code> вызывается только один раз, когда значение больше не используется.</p>
<p>После того, как мы познакомились с <code>Box&lt;T&gt;</code> и свойствами умных указателей, познакомимся с другими умными указателями, определёнными в встроенной библиотеке.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-умный-указатель-с-подсчётом-ссылок"><a class="header" href="#rct-умный-указатель-с-подсчётом-ссылок"><code>Rc&lt;T&gt;</code>, умный указатель с подсчётом ссылок</a></h2>
<p>В большинстве случаев владение является однозначным: вы точно знаете, какая переменная владеет данным значением. Однако бывают случаи, когда у одного значения может быть несколько владельцев. Например, в Графовых устройствах может быть несколько рёбер, указывающих на один и тот же узел — таким образом, этот узел становится в действительности собственностью всех этих рёбер. Узел не подлежит удалению, за исключением тех случаев, когда на него не указывает ни одно ребро и, соответственно, у него нет владельцев.</p>
<p>Вы должны включить множественное владение явно, используя вид Ржавчина <code>Rc&lt;T&gt;</code>, который является аббревиатурой для <em>подсчёта ссылок</em>. Вид <code>Rc&lt;T&gt;</code> отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё. Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет недействительной.</p>
<p>Представьте себе <code>Rc&lt;T&gt;</code> как телевизор в гостиной. Когда один человек входит, чтобы смотреть телевизор, он включает его. Другие могут войти в комнату и посмотреть телевизор. Когда последний человек покидает комнату, он выключает телевизор, потому что он больше не используется. Если кто-то выключит телевизор во время его просмотра другими, то оставшиеся телезрители устроят шум!</p>
<p>Вид <code>Rc&lt;T&gt;</code> используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время сборки, какая из частей завершит использование данных последней. Если бы мы знали, какая часть завершит использование последней то, мы могли бы сделать эту часть владельцем данных и вступили бы в силу обычные правила владения, применяемые во время сборки.</p>
<p>Обратите внимание, что <code>Rc&lt;T&gt;</code> используется только в однопоточных сценариях. Когда мы обсудим состязательность в главе 16, мы рассмотрим, как выполнять подсчёт ссылок во многопоточных программах.</p>
<h3 id="Использование-rct-для-совместного-использования-данных"><a class="header" href="#Использование-rct-для-совместного-использования-данных">Использование <code>Rc&lt;T&gt;</code> для совместного использования данных</a></h3>
<p>Давайте вернёмся к нашему примеру с cons списком в приложении 15-5. Напомним, что мы определили его с помощью вида <code>Box&lt;T&gt;</code>. В этот раз мы создадим два списка, оба из которых будут владеть третьим списком. Мировозренческо это похоже на рисунок 15-3:</p>
 <img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg">
<p><span class="caption">Рисунок 15-3: Два списка, <code>b</code> и <code>c</code>, делят владение над третьим списком, <code>a</code></span></p>
<p>Мы создадим список <code>a</code>, содержащий 5 и затем 10. Затем мы создадим ещё два списка: <code>b</code> начинающийся с 3 и <code>c</code> начинающийся с 4. Оба списка <code>b</code> и <code>c</code> затем продолжать первый список <code>a</code>, содержащий 5 и 10. Другими словами, оба списка будут разделять первый список, содержащий 5 и 10.</p>
<p>Попытка выполнить этот сценарий, используя определение <code>List</code> с видом <code>Box&lt;T&gt;</code> не будет работать, как показано в приложении 15-17:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<p><span class="caption">Приложение 15-17: Отображение того, что нельзя иметь два списка, использующих <code>Box&lt;T&gt;</code>, которые пытаются совместно владеть третьим списком</span></p>
<p>При сборки этого кода, мы получаем эту ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>Исходы <code>Cons</code> владеют данными, которые они содержат, поэтому, когда мы создаём список <code>b</code>, то <code>a</code> перемещается в <code>b</code>, а <code>b</code> становится владельцем <code>a</code>. Затем, мы пытаемся использовать <code>a</code> снова при создании <code>c</code>, но нам не разрешают, потому что <code>a</code> был перемещён.</p>
<p>Мы могли бы изменить определение <code>Cons</code>, чтобы вместо этого хранить ссылки, но тогда нам пришлось бы указывать свойства времени жизни. Указывая свойства времени жизни, мы бы указали, что каждый элемент в списке будет жить как самое меньшее столько же, сколько и весь список. Это относится к элементам и спискам в приложении 15.17, но не во всех сценариях.</p>
<p>Вместо этого мы изменим наше определение вида <code>List</code> так, чтобы использовать <code>Rc&lt;T&gt;</code> вместо <code>Box&lt;T&gt;</code>, как показано в приложении 15-18. Каждый исход <code>Cons</code> теперь будет содержать значение и вид <code>Rc&lt;T&gt;</code>, указывающий на <code>List</code>. Когда мы создадим <code>b</code> то, вместо того чтобы стал владельцем <code>a</code>, мы будем клонировать <code>Rc&lt;List&gt;</code> который содержит <code>a</code>, тем самым увеличивая количество ссылок с единицы до двойки и позволяя переменным <code>a</code> и <code>b</code> разделять владение на данные в виде <code>Rc&lt;List&gt;</code>. Мы также клонируем <code>a</code> при создании <code>c</code>, увеличивая количество ссылок с двух до трёх. Каждый раз, когда мы вызываем <code>Rc::clone</code>, счётчик ссылок на данные внутри <code>Rc&lt;List&gt;</code> будет увеличиваться и данные не будут очищены, если на них нет нулевых ссылок.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Приложение 15-18: Определение <code>List</code>, использующее <code>Rc&lt;T&gt;</code></span></p>
<p>Нам нужно добавить указанию <code>use</code>, чтобы подключить вид <code>Rc&lt;T&gt;</code> в область видимости, потому что он не входит в список самостоятельного подключения прелюдии. В <code>main</code>, мы создаём список владеющий 5 и 10, сохраняем его в новом <code>Rc&lt;List&gt;</code> переменной <code>a</code>. Затем при создании <code>b</code> и <code>c</code>, мы называем функцию <code>Rc::clone</code> и передаём ей ссылку на <code>Rc&lt;List&gt;</code> как переменная <code>a</code>.</p>
<p>Мы могли бы вызвать <code>a.clone()</code>, а не <code>Rc::clone(&amp;a)</code>, но в Ржавчина принято использовать <code>Rc::clone</code> в таком случае. Внутренняя выполнение <code>Rc::clone</code> не делает глубокого повторения всех данных, как это происходит в видах большинства выполнений <code>clone</code>. Вызов <code>Rc::clone</code> только увеличивает счётчик ссылок, что не занимает много времени. Глубокое повторение данных может занимать много времени. Используя <code>Rc::clone</code> для подсчёта ссылок, можно визуально различать виды клонирования с глубоким повторением и клонирования, которые увеличивают количество ссылок. При поиске  в коде неполадок с производительностью нужно рассмотреть только  клонирование с глубоким повторением и пренебрегать вызовы <code>Rc::clone</code> .</p>
<h3 id="Клонирование-rct-увеличивает-количество-ссылок"><a class="header" href="#Клонирование-rct-увеличивает-количество-ссылок">Клонирование <code>Rc&lt;T&gt;</code> увеличивает количество ссылок</a></h3>
<p>Давайте изменим рабочий пример в приложении 15-18, чтобы увидеть как изменяется число ссылок при создании и удалении ссылок на <code>Rc&lt;List&gt;</code> внутри переменной <code>a</code>.</p>
<p>В приложении 15-19 мы изменим <code>main</code> так, чтобы она имела внутреннюю область видимости вокруг списка <code>c</code>; тогда мы сможем увидеть, как меняется счётчик ссылок при выходе <code>c</code> из внутренней области видимости.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">Приложение 15-19: Печать количества ссылок</span></p>
<p>В каждой части программы, где количество ссылок меняется, мы выводим количество ссылок, которое получаем, вызывая функцию <code>Rc::strong_count</code>. Эта функция названа <code>strong_count</code>, а не <code>count</code>, потому что вид <code>Rc&lt;T&gt;</code> также имеет <code>weak_count</code>; мы увидим, для чего используется <code>weak_count</code> в разделе <a data-md-type="raw_html" href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">"Предотвращение замкнутых ссылок: Превращение <code>Rc&lt;T&gt;</code> в <code data-md-type="raw_html">Weak&lt;T&gt;</code>"</a><!-- ignore -->.</p>
<p>Код выводит в окно вывода:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Можно увидеть, что <code>Rc&lt;List&gt;</code> в переменной <code>a</code> имеет начальный счётчик ссылок равный 1; затем каждый раз при вызове <code>clone</code> счётчик увеличивается на 1. Когда <code>c</code> выходит из области видимости, счётчик уменьшается на 1. Нам не нужно вызывать функцию уменьшения счётчика ссылок, как при вызове <code>Rc::clone</code> для увеличения счётчика ссылок: выполнение <code>Drop</code> самостоятельно уменьшает счётчик ссылок, когда значение <code>Rc&lt;T&gt;</code> выходит из области видимости.</p>
<p>В этом примере мы не наблюдаем того, что когда <code>b</code>, а затем <code>a</code> выходят из области видимости в конце <code>main</code>, счётчик становится равным 0, и <code>Rc&lt;List&gt;</code> полностью очищается. Использование <code>Rc&lt;T&gt;</code> позволяет одному значению иметь несколько владельцев, а счётчик заверяет, что значение остаётся действительным до тех пор, пока любой из владельцев ещё существует.</p>
<p>С помощью неизменяемых ссылок, вид <code>Rc&lt;T&gt;</code> позволяет обмениваться данными между несколькими частями вашей программы только для чтения данных. Если вид <code>Rc&lt;T&gt;</code> позволял бы иметь несколько изменяемых ссылок, вы могли бы нарушить одно из правил заимствования, описанных в главе 4: множественные изменяемые заимствования в одном и том же месте могут вызвать гонки данных (data races) и несогласованность данных. Но возможность изменять данные очень полезна! В следующем разделе мы обсудим образец внутренней изменчивости и вид <code>RefCell&lt;T&gt;</code>, который можно использовать вместе с <code>Rc&lt;T&gt;</code> для работы с этим ограничением.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-и-образец-внутренней-изменяемости"><a class="header" href="#refcellt-и-образец-внутренней-изменяемости"><code>RefCell&lt;T&gt;</code> и образец внутренней изменяемости</a></h2>
<p><em>Внутренняя изменяемость</em> - это образец разработки Rust, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования. Для изменения данных образец использует <code>unsafe</code> код внутри устройства данных, чтобы обойти обычные правила Rust, управляющие изменяемость и заимствование. Небезопасный (unsafe) код даёт понять сборщику, что мы самостоятельно следим за соблюдением этих правил, а не полагаемся на то, что сборщик будет делать это для нас; подробнее о небезопасном коде мы поговорим в главе 19.</p>
<p>Мы можем использовать виды, в которых применяется образец внутренней изменяемости, только если мы можем обеспечить, что правила заимствования будут соблюдаться во время выполнения, несмотря на то, что сборщик не сможет этого обеспечить. В этом случае <code>небезопасный</code> код оборачивается безопасным API, и внешне вид остаётся неизменяемым.</p>
<p>Давайте изучим данную подход с помощью вида данных <code>RefCell&lt;T&gt;</code>, который выполняет этот образец.</p>
<h3 id="Применение-правил-заимствования-во-время-выполнения-с-помощью-refcellt"><a class="header" href="#Применение-правил-заимствования-во-время-выполнения-с-помощью-refcellt">Применение правил заимствования во время выполнения с помощью <code>RefCell&lt;T&gt;</code></a></h3>
<p>В отличие от <code>Rc&lt;T&gt;</code> вид <code>RefCell&lt;T&gt;</code> предоставляет единоличное владение данными, которые он содержит. В чем же отличие вида <code>RefCell&lt;T&gt;</code> от <code>Box&lt;T&gt;</code>? Давайте вспомним правила заимствования из Главы 4:</p>
<ul>
<li>В любой мгновение времени вы можете иметь <em>либо</em> одну изменяемую ссылку либо сколько угодно неизменяемых ссылок (но не оба вида ссылок одновременно).</li>
<li>Ссылки всегда должны быть действительными.</li>
</ul>
<p>С помощью ссылок и вида <code>Box&lt;T&gt;</code> неизменные величины правил заимствования применяются на этапе сборки. С помощью <code>RefCell&lt;T&gt;</code> они применяются <em>во время работы программы</em>. Если вы нарушите эти правила, работая с ссылками, то будет ошибка сборки. Если вы работаете с <code>RefCell&lt;T&gt;</code> и нарушите эти правила, то программа вызовет панику и завершится.</p>
<p>Преимущества проверки правил заимствования во время сборки заключаются в том, что ошибки будут обнаруживаться раньше - ещё в этапе разработки, а производительность во время выполнения не пострадает, поскольку весь анализ завершён заранее. По этим причинам проверка правил заимствования во время сборки является лучшим выбором в большинстве случаев, и именно поэтому она используется в Ржавчина по умолчанию.</p>
<p>Преимущество проверки правил заимствования во время выполнения заключается в том, что определённые сценарии, безопасные для памяти, разрешаются там, где они были бы запрещены проверкой во время сборки. Постоянной анализ, как и сборщик Rust, по своей сути устоявшийся. Некоторые свойства кода невозможно обнаружить, анализируя код: самый известный пример - неполадка остановки, которая выходит за рамки этой книги, но является важной темой для исследования.</p>
<p>Поскольку некоторый анализ невозможен, то если сборщик Ржавчина не может быть уверен, что код соответствует правилам владения, он может отклонить правильную программу; таким образом он является консервативным. Если Ржавчина принял неправильную программу, то пользователи не смогут доверять заверениям, которые даёт Rust. Однако, если Ржавчина отклонит правильную программу, то программист будет испытывать неудобства, но ничего катастрофического не произойдёт. Вид <code>RefCell&lt;T&gt;</code> полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но сборщик не может понять и обеспечить этого.</p>
<p>Подобно виду <code>Rc&lt;T&gt;</code>, вид <code>RefCell&lt;T&gt;</code> предназначен только для использования в однопоточных сценариях и выдаст ошибку времени сборки, если вы попытаетесь использовать его в многопоточном среде. Мы поговорим о том, как получить возможность <code>RefCell&lt;T&gt;</code> во многопоточной программе в главе 16.</p>
<p>Вот список причин выбора видов <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> или <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>Вид <code>Rc&lt;T&gt;</code> разрешает множественное владение одними и теми же данными; виды <code>Box&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code> разрешают иметь единственных владельцев.</li>
<li>Вид <code>Box&lt;T&gt;</code> разрешает неизменяемые или изменяемые владения, проверенные при сборки; вид <code>Rc&lt;T&gt;</code> разрешает только неизменяемые владения, проверенные при сборки; вид <code>RefCell&lt;T&gt;</code> разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.</li>
<li>Поскольку <code>RefCell&lt;T&gt;</code> разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри <code>RefCell&lt;T&gt;</code> даже если <code>RefCell&lt;T&gt;</code> является неизменным.</li>
</ul>
<p>Изменение значения внутри неизменного значения является образцом <em>внутренней изменяемости</em> (interior mutability). Давайте посмотрим на случай, в которой внутренняя изменяемость полезна и рассмотрим, как это возможно.</p>
<h3 id="Внутренняя-изменяемость-изменяемое-заимствование-неизменяемого-значения"><a class="header" href="#Внутренняя-изменяемость-изменяемое-заимствование-неизменяемого-значения">Внутренняя изменяемость: изменяемое заимствование неизменяемого значения</a></h3>
<p>Следствием правил заимствования является то, что когда у вас есть неизменяемое значение, вы не можете заимствовать его с изменением. Например, этот код не будет собираться:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>Если вы попытаетесь собрать этот код, вы получите следующую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>Однако бывают случаи, в которых было бы полезно, чтобы предмет мог изменять себя при помощи своих способов, но казался неизменным для прочего кода. Код вне способов этого предмета не должен иметь возможности изменять его содержимое. Использование <code>RefCell&lt;T&gt;</code> - один из способов получить возможность внутренней изменяемости, но при этом <code>RefCell&lt;T&gt;</code> не позволяет полностью обойти правила заимствования: средство проверки правил заимствования в сборщике позволяет эту внутреннюю изменяемость, однако правила заимствования проверяются во время выполнения. Если вы нарушите правила, то вместо ошибки сборки вы получите <code>panic!</code>.</p>
<p>Давайте разберём опытный пример, в котором мы можем использовать <code>RefCell&lt;T&gt;</code> для изменения неизменяемого значения и посмотрим, почему это полезно.</p>
<h4 id="Исход-использования-внутренней-изменяемости-мок-предметы"><a class="header" href="#Исход-использования-внутренней-изменяемости-мок-предметы">Исход использования внутренней изменяемости: мок предметы</a></h4>
<p>Иногда во время проверки программист использует один вид вместо другого для того, чтобы проверить определённое поведение и убедиться, что оно выполнено правильно. Такой вид-заместитель называется <em>проверочным повторителем</em>. Воспринимайте его как «каскадёра» в кинематографе, когда повторитель  заменяет актёра для выполнения определённой сложной сцены. Проверочные повторители заменяют другие виды при выполнении проверок. <em>Инсценировочные (mock) предметы</em> — это особый вид проверочных повторителей, которые сохраняют данные происходящих во время проверки действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.</p>
<p>В Ржавчина нет предметов в том же смысле, в каком они есть в других языках и в Ржавчина нет возможности мок предметов, встроенных в обычную библиотеку, как в некоторых других языках. Однако вы определённо можете создать устройство, которая будет служить тем же целям, что и мок предмет.</p>
<p>Вот сценарий, который мы будем проверять: мы создадим библиотеку, которая отслеживает значение по отношению к заранее определённому наивысшему значению и отправляет сообщения в зависимости от того, насколько текущее значение находится близко к такому наивысшему значению. Эта библиотека может использоваться, например, для отслеживания квоты количества вызовов API пользователя, которые ему разрешено делать.</p>
<p>Наша библиотека будет предоставлять только функции отслеживания того, насколько близко к наивысшему значению находится значение и какие сообщения должны быть внутри в этот мгновение. Ожидается, что приложения, использующие нашу библиотеку, предоставят рычаг для отправки сообщений: приложение может поместить сообщение в приложение, отправить электронное письмо, отправить текстовое сообщение или что-то ещё. Библиотеке не нужно знать эту подробность. Все что ему нужно - это что-то, что выполняет особенность, который мы предоставим с названием <code>Messenger</code>. Приложение 15-20 показывает код библиотеки:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<p><span class="caption">Приложение 15-20: Библиотека для отслеживания степени приближения того или иного значения к наиболее допустимой величине и предупреждения, в случае если значение достигает определённого уровня</span></p>
<p>Одна важная часть этого кода состоит в том, что особенность <code>Messenger</code> имеет один способ <code>send</code>, принимающий переменнойми неизменяемую ссылку на <code>self</code> и текст сообщения. Он является внешней оболочкой, который должен иметь наш мок предмет. Другой важной частью является то, что мы хотим проверить поведение способа <code>set_value</code> у вида <code>LimitTracker</code>. Мы можем изменить значение, которое передаём свойствоом <code>value</code>, но <code>set_value</code> ничего не возвращает и нет основания, чтобы мы могли бы проверить утверждения о выполнении способа. Мы хотим иметь возможность  сказать, что если мы создаём <code>LimitTracker</code> с чем-то, что выполняет особенность <code>Messenger</code> и с определённым значением для <code>max</code>, то когда мы передаём разные числа в переменной <code>value</code> образец self.messenger отправляет соответствующие сообщения.</p>
<p>Нам нужен мок предмет, который вместо отправки электронного письма или текстового сообщения будет отслеживать сообщения, которые были ему поручены для отправки через <code>send</code>. Мы можем создать новый образец мок предмета. создать <code>LimitTracker</code> с использованием мок предмет для него, вызвать способ <code>set_value</code> у образца <code>LimitTracker</code>, а затем проверить, что мок предмет имеет ожидаемое сообщение. В приложении 15-21 показана попытка выполнить мок предмет, чтобы сделать именно то что хотим, но анализатор заимствований не разрешит такой код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<p><span class="caption">Приложение 15-21: Попытка выполнить <code>MockMessenger</code>, которая не была принята рычагом проверки заимствований</span></p>
<p>Этот проверочный код определяет устройство <code>MockMessenger</code>, в которой есть поле <code>sent_messages</code> со значениями вида <code>Vec</code> из <code>String</code> для отслеживания сообщений, которые поручены устройстве для отправки. Мы также определяем сопряженную функцию <code>new</code>, чтобы было удобно создавать новые образцы <code>MockMessenger</code>, которые создаются с пустым списком сообщений. Затем мы выполняем особенность <code>Messenger</code> для вида <code>MockMessenger</code>, чтобы передать <code>MockMessenger</code> в <code>LimitTracker</code>. В ярлыке способа <code>send</code> мы принимаем сообщение для передачи в качестве свойства и сохраняем его в <code>MockMessenger</code> внутри списка <code>sent_messages</code>.</p>
<p>В этом проверке мы проверяем, что происходит, когда <code>LimitTracker</code> сказано установить <code>value</code> в значение, превышающее 75 процентов от значения <code>max</code>. Сначала мы создаём новый <code>MockMessenger</code>, который будет иметь пустой список сообщений. Затем мы создаём новый <code>LimitTracker</code> и передаём ему ссылку на новый <code>MockMessenger</code> и <code>max</code> значение равное 100. Мы вызываем способ <code>set_value</code> у <code>LimitTracker</code> со значением 80, что составляет более 75 процентов от 100. Затем мы с помощью утверждения проверяем, что <code>MockMessenger</code> должен содержать одно сообщение из списка внутренних сообщений.</p>
<p>Однако с этим проверкой есть одна неполадка, показанная ниже:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
 ...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>Мы не можем изменять <code>MockMessenger</code> для отслеживания сообщений, потому что способ <code>send</code> принимает неизменяемую ссылку на <code>self</code>. Мы также не можем принять предложение из текста ошибки, чтобы использовать <code>&amp;mut self</code>, потому что тогда ярлык <code>send</code> не будет соответствовать ярлыке в определении особенности <code>Messenger</code> (не стесняйтесь попробовать и посмотреть, какое сообщение об ошибке получите вы).</p>
<p>Это случаей, в которой внутренняя изменяемость может помочь! Мы сохраним <code>sent_messages</code> внутри вида <code>RefCell&lt;T&gt;</code>, а затем в способе <code>send</code> сообщение сможет изменить список <code>sent_messages</code> для хранения сообщений, которые мы видели. Приложение 15-22 показывает, как это выглядит:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">Приложение 15-22: Использование <code>RefCell&lt;T&gt;</code> для изменения внутреннего значения, в то время как внешнее значение считается неизменяемым</span></p>
<p>Поле <code>sent_messages</code> теперь имеет вид <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> вместо <code>Vec&lt;String&gt;</code>. В функции <code>new</code> мы создаём новый образец <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> для пустого вектора.</p>
<p>Для выполнения способа <code>send</code> первый свойство по-прежнему является неизменяемым для заимствования <code>self</code>, которое соответствует определению особенности. Мы вызываем <code>borrow_mut</code> для <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> в <code>self.sent_messages</code>, чтобы получить изменяемую ссылку на значение внутри <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, которое является вектором. Затем мы можем вызвать <code>push</code> у изменяемой ссылки на вектор, чтобы отслеживать сообщения, отправленные во время проверки.</p>
<p>Последнее изменение, которое мы должны сделать, заключается в утверждении для проверки: чтобы увидеть, сколько элементов находится во внутреннем векторе, мы вызываем способ <code>borrow</code> у <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, чтобы получить неизменяемую ссылку на внутренний вектор сообщений.</p>
<p>Теперь, когда вы увидели как использовать <code>RefCell&lt;T&gt;</code>, давайте изучим как он работает!</p>
<h4 id="Отслеживание-заимствований-во-время-выполнения-с-помощью-refcellt"><a class="header" href="#Отслеживание-заимствований-во-время-выполнения-с-помощью-refcellt">Отслеживание заимствований во время выполнения с помощью <code>RefCell&lt;T&gt;</code></a></h4>
<p>При создании неизменных и изменяемых ссылок мы используем правила написания <code>&amp;</code> и <code>&amp;mut</code> соответственно. У вида <code>RefCell&lt;T&gt;</code>, мы используем способы <code>borrow</code> и <code>borrow_mut</code>, которые являются частью безопасного API, который принадлежит <code>RefCell&lt;T&gt;</code>. Способ <code>borrow</code> возвращает вид умного указателя <code>Ref&lt;T&gt;</code>, способ <code>borrow_mut</code> возвращает вид умного указателя <code>RefMut&lt;T&gt;</code>. Оба вида выполняют особенность <code>Deref</code>, поэтому мы можем рассматривать их как обычные ссылки.</p>
<p>Вид <code>RefCell&lt;T&gt;</code> отслеживает сколько умных указателей <code>Ref&lt;T&gt;</code> и <code>RefMut&lt;T&gt;</code> активны в данное время. Каждый раз, когда мы вызываем <code>borrow</code>, вид <code>RefCell&lt;T&gt;</code> увеличивает количество активных заимствований. Когда значение <code>Ref&lt;T&gt;</code> выходит из области видимости, то количество неизменяемых заимствований уменьшается на единицу. Как и с правилами заимствования во время сборки, <code>RefCell&lt;T&gt;</code> позволяет иметь много неизменяемых заимствований или одно изменяемое заимствование в любой мгновение времени.</p>
<p>Если попытаться нарушить эти правила, то вместо получения ошибки сборщика, как это было бы со ссылками, выполнение <code>RefCell&lt;T&gt;</code> будет вызывать панику во время выполнения. В приложении 15-23 показана изменение выполнения <code>send</code> из приложения 15-22. Мы намеренно пытаемся создать два изменяемых заимствования активных для одной и той же области видимости, чтобы показать как <code>RefCell&lt;T&gt;</code> не позволяет нам делать так во время выполнения.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 15-23: Создание двух изменяемых ссылок в одной области видимости, чтобы убедиться, что <code>RefCell&lt;T&gt;</code> вызовет панику</span></p>
<p>Мы создаём переменную <code>one_borrow</code> для умного указателя <code>RefMut&lt;T&gt;</code> возвращаемого из способа <code>borrow_mut</code>. Затем мы создаём другое изменяемое заимствование таким же образом в переменной <code>two_borrow</code>. Это создаёт две изменяемые ссылки в одной области видимости, что недопустимо. Когда мы запускаем проверки для нашей библиотеки, код в приложении 15-23 собирается без ошибок, но проверка завершится неудачно:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Обратите внимание, что код вызвал панику с сообщением <code>already borrowed: BorrowMutError</code>. Вот так вид <code>RefCell&lt;T&gt;</code> обрабатывает нарушения правил заимствования во время выполнения.</p>
<p>Решение отлавливать ошибки заимствования во время выполнения, а не во время сборки, как мы сделали здесь, означает, что вы возможно будете находить ошибки в своём коде на более поздних этапах разработки: возможно, не раньше, чем ваш код будет развернут в рабочем окружении. Кроме того, ваш код будет иметь небольшие потери производительности в этапе работы, поскольку заимствования будут отслеживаться во время выполнения, а не во время сборки. Однако использование <code>RefCell&lt;T&gt;</code> позволяет написать предмет-имитатор, который способен изменять себя, чтобы сохранять сведения о тех значениях, которые он получал, пока вы использовали его в среде, где разрешены только неизменяемые значения. Вы можете использовать <code>RefCell&lt;T&gt;</code>, несмотря на его недостатки, чтобы получить больше возможности, чем дают обычные ссылки.</p>
<h3 id="Наличие-нескольких-владельцев-изменяемых-данных-путём-объединения-видов-rct-и-refcellt"><a class="header" href="#Наличие-нескольких-владельцев-изменяемых-данных-путём-объединения-видов-rct-и-refcellt">Наличие нескольких владельцев изменяемых данных путём объединения видов <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code></a></h3>
<p>Обычный способ использования <code>RefCell&lt;T&gt;</code> заключается в его сочетании с видом <code>Rc&lt;T&gt;</code>. Напомним, что вид <code>Rc&lt;T&gt;</code> позволяет иметь нескольких владельцев некоторых данных, но даёт только неизменяемый доступ к этим данным. Если у вас есть <code>Rc&lt;T&gt;</code>, который внутри содержит вид <code>RefCell&lt;T&gt;</code>, вы можете получить значение, которое может иметь несколько владельцев <em>и</em> которое можно изменять!</p>
<p>Например, вспомните пример cons списка приложения 15-18, где мы использовали <code>Rc&lt;T&gt;</code>, чтобы несколько списков могли совместно владеть другим списком. Поскольку <code>Rc&lt;T&gt;</code> содержит только неизменяемые значения, мы не можем изменить ни одно из значений в списке после того, как мы их создали. Давайте добавим вид <code>RefCell&lt;T&gt;</code>, чтобы получить возможность изменять значения в списках. В приложении 15-24 показано использование <code>RefCell&lt;T&gt;</code> в определении <code>Cons</code> так, что мы можем изменить значение хранящееся во всех списках:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
<p><span class="caption">Приложение 15-24: Использование <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> для создания <code>List</code>, который мы можем изменять</span></p>
<p>Мы создаём значение, которое является образцом <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> и сохраняем его в переменной с именем <code>value</code>, чтобы получить к ней прямой доступ позже. Затем мы создаём <code>List</code> в переменной <code>a</code> с исходом <code>Cons</code>, который содержит <code>value</code>. Нам нужно вызвать клонирование <code>value</code>, так как обе переменные <code>a</code> и <code>value</code> владеют внутренним значением <code>5</code>, а не передают владение из <code>value</code> в переменную <code>a</code> или не выполняют заимствование с помощью <code>a</code> переменной <code>value</code>.</p>
<p>Мы оборачиваем список у переменной <code>a</code> в вид <code>Rc&lt;T&gt;</code>, поэтому при создании списков в переменные <code>b</code> и <code>c</code> они оба могут ссылаться на <code>a</code>, что мы и сделали в приложении 15-18.</p>
<p>После создания списков <code>a</code>, <code>b</code> и <code>c</code> мы хотим добавить 10 к значению в <code>value</code>. Для этого вызовем <code>borrow_mut</code> у <code>value</code>, который использует функцию самостоятельного разыменования, о которой мы говорили в главе 5 (см. раздел <a href="ch05-03-method-syntax.html#wheres-the---operator">"Где находится оператор <code>-&gt;</code>?"</a><!-- ignore -->) во внутреннее значение <code>RefCell&lt;T&gt;</code>. Способ <code>borrow_mut</code> возвращает умный указатель <code>RefMut&lt;T&gt;</code>, и мы используя оператор разыменования, изменяем внутреннее значение.</p>
<p>Когда мы печатаем <code>a</code>, <code>b</code> и <code>c</code> то видим, что все они имеют изменённое значение равное 15, а не 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Эта техника довольно изящна! Используя <code>RefCell&lt;T&gt;</code>, мы получаем внешне неизменяемое значение <code>List</code>. Но мы можем использовать способы <code>RefCell&lt;T&gt;</code>, которые предоставляют доступ к его внутренностям, чтобы мы могли изменять наши данные, когда это необходимо. Проверка правил заимствования во время выполнения защищает нас от гонок данных, и иногда стоит немного пожертвовать производительностью ради такой гибкости наших устройств данных. Обратите внимание, что <code>RefCell&lt;T&gt;</code> не работает для многопоточного кода! <code>Mutex&lt;T&gt;</code> - это thread-safe исполнение <code>RefCell&lt;T&gt;</code>, а <code>Mutex&lt;T&gt;</code> мы обсудим в главе 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Ссылочные-замыкания-могут-приводить-к-утечке-памяти"><a class="header" href="#Ссылочные-замыкания-могут-приводить-к-утечке-памяти">Ссылочные замыкания могут приводить к утечке памяти</a></h2>
<p>Заверения безопасности памяти в Ржавчина затрудняют, но не делают невозможным случайное выделение памяти, которое никогда не очищается (известное как <em>утечка памяти</em> ). Полное предотвращение утечек памяти не является одной из заверений Rust, а это означает, что утечки памяти безопасны в Rust. Мы видим, что Ржавчина допускает утечку памяти с помощью <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code>: можно создавать ссылки, в которых элементы ссылаются друг на друга в цикле. Это создаёт утечки памяти, потому что счётчик ссылок каждого элемента в цикле никогда не достигнет 0, а значения никогда не будут удалены.</p>
<h3 id="Создание-ссылочного-замыкания"><a class="header" href="#Создание-ссылочного-замыкания">Создание ссылочного замыкания</a></h3>
<p>Давайте посмотрим, как может произойти случаей ссылочного замыкания и как её предотвратить, начиная с определения перечисления <code>List</code> и способа <code>tail</code> в приложении 15-25:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">Приложение 15-25: Объявление cons list, который содержит <code>RefCell&lt;T&gt;</code>, чтобы мы могли изменять то, на что ссылается образец <code>Cons</code></span></p>
<p>Мы используем другую вариацию определения <code>List</code> из приложения 15-5. Второй элемент в  исходе <code>Cons</code> теперь <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, что означает, что вместо возможности менять значение <code>i32</code>, как мы делали в приложении 15-24, мы хотим менять значение <code>List</code>, на которое указывает исход <code>Cons</code>. Мы также добавляем способ <code>tail</code>, чтобы нам было удобно обращаться ко второму элементу, если у нас есть исход <code>Cons</code>.</p>
<p>В приложении 15-26 мы добавляем <code>main</code> функцию, которая использует определения приложения 15-25. Этот код создаёт список в переменной <code>a</code> и список <code>b</code>, который указывает на список <code>a</code>. Затем он изменяет список внутри <code>a</code> так, чтобы он указывал на <code>b</code>, создавая ссылочное замыкание. В коде есть  указания <code>println!</code>, чтобы показать значения счётчиков ссылок в различных точках этого этапа.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
<p><span class="caption">Приложение 15-26: Создание ссылочного цикла из двух значений <code>List</code>, указывающих друг на друга</span></p>
<p>Мы создаём образец <code>Rc&lt;List&gt;</code> содержащий значение <code>List</code> в переменной <code>a</code> с начальным списком <code>5, Nil</code>. Затем мы создаём образец <code>Rc&lt;List&gt;</code> содержащий другое значение <code>List</code> в переменной <code>b</code>, которое содержит значение 10 и указывает на список в <code>a</code>.</p>
<p>Мы меняем <code>a</code> так, чтобы он указывал на <code>b</code> вместо <code>Nil</code>, создавая зацикленность. Мы делаем это с помощью способа <code>tail</code>, чтобы получить ссылку на <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> из переменной <code>a</code>, которую мы помещаем в переменную <code>link</code>. Затем мы используем способ <code>borrow_mut</code> из вида <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, чтобы изменить внутреннее значение вида <code>Rc&lt;List&gt;</code>, содержащего начальное значение <code>Nil</code> на значение вида <code>Rc&lt;List&gt;</code> взятое из переменной <code>b</code>.</p>
<p>Когда мы запускаем этот код, оставив последний <code>println!</code> с примечаниями в данный мгновение, мы получим вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>Количество ссылок на образцы <code>Rc&lt;List&gt;</code> как в <code>a</code>, так и в <code>b</code> равно 2 после того, как мы заменили список в <code>a</code> на ссылку на <code>b</code>. В конце <code>main</code> Ржавчина уничтожает переменную <code>b</code>, что уменьшает количество ссылок на <code>Rc&lt;List&gt;</code> из <code>b</code> с 2 до 1. Память, которую <code>Rc&lt;List&gt;</code> занимает в куче, не будет освобождена в этот мгновение, потому что количество ссылок на неё равно 1, а не 0. Затем Ржавчина удаляет <code>a</code>, что уменьшает количество ссылок образца <code>Rc&lt;List&gt;</code> в <code>a</code> с 2 до 1. Память этого образца также не может быть освобождена, поскольку другой образец <code>Rc&lt;List&gt;</code> по-прежнему ссылается на него. Таким образом, память, выделенная для списка не будет освобождена никогда. Чтобы наглядно представить этот цикл ссылок, мы создали диаграмму на рисунке 15-4.</p>
<img src="img/trpl15-04.svg" class="center" alt="Reference cycle of lists">
<p><span class="caption">Рисунок 15-4: Ссылочный цикл списков <code>a</code> и <code>b</code>, указывающих друг на друга</span></p>
<p>Если вы удалите последний примечание с <code>println!</code> и запустите программу, Ржавчина будет пытаться печатать зацикленность в <code>a</code>, указывающей на <code>b</code>, указывающей на <code>a</code> и так далее, пока не переполниться обойма.</p>
<p>По сравнению с существующей программой, последствия создания цикла ссылок в этом примере не так страшны: сразу после создания цикла ссылок программа завершается. Однако если более сложная программа выделит много памяти в цикле и будет удерживать её в течение длительного времени, программа будет потреблять больше памяти, чем ей нужно, и может перенапрячь систему, что приведёт к исчерпанию доступной памяти.</p>
<p>Вызвать образование ссылочной зацикленности не просто, но и не невозможно. Если у вас есть значения <code>RefCell&lt;T&gt;</code> которые содержат значения <code>Rc&lt;T&gt;</code> или подобные вложенные сочетания видов с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте зацикленность; Вы не можете полагаться на то, что Ржавчина их обнаружит. Создание ссылочной зацикленности являлось бы логической ошибкой в программе, для которой вы должны использовать самостоятельно е проверки, проверку кода и другие опытов разработки программного обеспечения для её уменьшения.</p>
<p>Другое решение для избежания ссылочной зацикленности - это ресоздание ваших устройств данных, чтобы некоторые ссылки выражали владение, а другие - отсутствие владения. В итоге можно иметь циклы, построенные на некоторых отношениях владения и некоторые не основанные на отношениях владения, тогда только отношения владения влияют на то, можно ли удалить значение. В приложении 15-25 мы всегда хотим, чтобы исходы <code>Cons</code> владели своим списком, поэтому ресоздание устройства данных невозможна. Давайте рассмотрим пример с использованием графов, состоящих из родительских и дочерних узлов, чтобы увидеть, когда отношения владения не являются подходящим способом предотвращения ссылочной зацикленности.</p>
<h3 id="Предотвращение-ссылочной-зацикленности-замена-умного-указателя-rct-на-weakt"><a class="header" href="#Предотвращение-ссылочной-зацикленности-замена-умного-указателя-rct-на-weakt">Предотвращение ссылочной зацикленности: замена умного указателя <code>Rc&lt;T&gt;</code> на <code>Weak&lt;T&gt;</code></a></h3>
<p>До сих пор мы выясняли, что вызов <code>Rc::clone</code> увеличивает <code>strong_count</code> образца <code>Rc&lt;T&gt;</code>, а образец <code>Rc&lt;T&gt;</code> удаляется, только если его <code>strong_count</code> равен 0. Вы также можете создать <em>слабую ссылку</em> на значение внутри образца <code>Rc&lt;T&gt;</code>, вызвав <code>Rc::downgrade</code> и передав ссылку на <code>Rc&lt;T&gt;</code>. Сильные ссылки - это то с помощью чего вы можете поделиться владением образца <code>Rc&lt;T&gt;</code>. Слабые ссылки не отражают связи владения, и их подсчёт не влияет на то, когда образец <code>Rc&lt;T&gt;</code> будет очищен. Они не приведут к ссылочному циклу, потому что любой цикл, включающий несколько слабых ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет равным 0.</p>
<p>Когда вы вызываете <code>Rc::downgrade</code>, вы получаете умный указатель вида <code>Weak&lt;T&gt;</code>. Вместо того чтобы увеличить <code>strong_count</code> в образце <code>Rc&lt;T&gt;</code> на 1, вызов <code>Rc::downgrade</code> увеличивает <code>weak_count</code> на 1. Вид <code>Rc&lt;T&gt;</code> использует <code>weak_count</code> для отслеживания количества существующих ссылок <code>Weak&lt;T&gt;</code>, подобно <code>strong_count</code>. Разница в том, что <code>weak_count</code> не должен быть равен 0, чтобы образец <code>Rc&lt;T&gt;</code> мог быть удалён.</p>
<p>Поскольку значение, на которое ссылается <code>Weak&lt;T&gt;</code> могло быть удалено, то необходимо убедиться, что это значение все ещё существует, чтобы сделать что-либо со значением на которое указывает <code>Weak&lt;T&gt;</code>. Делайте это вызывая способ <code>upgrade</code> у образца вида <code>Weak&lt;T&gt;</code>, который вернёт <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Вы получите итог <code>Some</code>, если значение <code>Rc&lt;T&gt;</code> ещё не было удалено и итог <code>None</code>, если значение <code>Rc&lt;T&gt;</code> было удалено. Поскольку <code>upgrade</code> возвращает вид <code>Option&lt;T&gt;</code>, Ржавчина обеспечит обработку обоих случаев <code>Some</code> и <code>None</code> и не будет неправильного указателя.</p>
<p>В качестве примера, вместо того чтобы использовать список чей элемент знает только о следующем элементе, мы создадим дерево, чьи элементы знают о своих дочерних элементах <em>и</em> о своих родительских элементах.</p>
<h4 id="Создание-древовидной-устройства-данных-node-с-дочерними-узлами"><a class="header" href="#Создание-древовидной-устройства-данных-node-с-дочерними-узлами">Создание древовидной устройства данных: <code>Node</code> с дочерними узлами</a></h4>
<p>Для начала мы построим дерево с узлами, которые знают о своих дочерних узлах. Мы создадим устройство с именем <code>Node</code>, которая будет содержать собственное значение <code>i32</code>, а также ссылки на его дочерние значения <code>Node</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Мы хотим, чтобы <code>Node</code> владел своими дочерними узлами и мы хотим поделиться этим владением с переменными так, чтобы мы могли напрямую обращаться к каждому <code>Node</code> в дереве. Для этого мы определяем внутренние элементы вида <code>Vec&lt;T&gt;</code> как значения вида <code>Rc&lt;Node&gt;</code>. Мы также хотим изменять те узлы, которые являются дочерними по отношению к другому узлу, поэтому у нас есть вид <code>RefCell&lt;T&gt;</code> в поле <code>children</code> оборачивающий вид <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Далее мы будем использовать наше определение устройства и создадим один образец <code>Node</code> с именем <code>leaf</code> со значением 3 и без дочерних элементов, а другой образец с именем <code>branch</code> со значением 5 и <code>leaf</code> в качестве одного из его дочерних элементов, как показано в приложении 15-27:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Приложение 15-27: Создание узла <code>leaf</code> без дочерних элементов и узла <code>branch</code> с <code>leaf</code> в качестве одного из дочерних элементов</span></p>
<p>Мы клонируем  содержимое <code>Rc&lt;Node&gt;</code> из переменной  <code>leaf</code> и сохраняем его в переменной <code>branch</code>, что означает, что <code>Node</code> в  <code>leaf</code> теперь имеет двух владельцев: <code>leaf</code> и <code>branch</code>. Мы можем получить доступ из <code>branch</code> к <code>leaf</code> через обращение <code>branch.children</code>, но нет способа добраться из  <code>leaf</code> к <code>branch</code>. Причина в том, что <code>leaf</code> не имеет ссылки на <code>branch</code> и не знает, что они связаны. Мы хотим, чтобы <code>leaf</code> знал, что <code>branch</code> является его родителем. Мы сделаем это далее.</p>
<h4 id="Добавление-ссылки-от-ребёнка-к-его-родителю"><a class="header" href="#Добавление-ссылки-от-ребёнка-к-его-родителю">Добавление ссылки от ребёнка к его родителю</a></h4>
<p>Для того, чтобы дочерний узел знал о своём родительском узле нужно добавить поле <code>parent</code> в наше определение устройства <code>Node</code>. Неполадкав том, чтобы решить, каким должен быть вид <code>parent</code>. Мы знаем, что он не может содержать <code>Rc&lt;T&gt;</code>, потому что это создаст ссылочную зацикленность с <code>leaf.parent</code> указывающей на <code>branch</code> и <code>branch.children</code>, указывающей на <code>leaf</code>, что приведёт к тому, что их значения <code>strong_count</code> никогда не будут равны 0.</p>
<p>Подумаем об этих отношениях по-другому, родительский узел должен владеть своими потомками: если родительский узел удаляется, его дочерние узлы также должны быть удалены. Однако дочерний элемент не должен владеть своим родителем: если мы удаляем дочерний узел то родительский элемент все равно должен существовать. Это случай для использования слабых ссылок!</p>
<p>Поэтому вместо <code>Rc&lt;T&gt;</code> мы сделаем так, чтобы поле <code>parent</code> использовало вид <code>Weak&lt;T&gt;</code>, а именно <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Теперь наше определение устройства <code>Node</code> выглядит так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>Узел сможет ссылаться на свой родительский узел, но не владеет своим родителем. В приложении 15-28 мы обновляем <code>main</code> на использование нового определения так, чтобы у узла <code>leaf</code> был бы способ ссылаться на его родительский узел <code>branch</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Приложение 15-28: Узел <code>leaf</code> со слабой ссылкой на его родительский узел <code>branch</code></span></p>
<p>Создание узла <code>leaf</code> выглядит подобно примеру из Приложения 15-27, за исключением поля <code>parent</code>: <code>leaf</code> изначально не имеет родителя, поэтому мы создаём новый, пустой образец ссылки <code>Weak&lt;Node&gt;</code>.</p>
<p>На этом этапе, когда мы пытаемся получить ссылку на родительский узел у узла <code>leaf</code> с помощью способа <code>upgrade</code>, мы получаем значение <code>None</code>. Мы видим это в выводе первой указания <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Когда мы создаём узел <code>branch</code> у него также будет новая ссылка вида <code>Weak&lt;Node&gt;</code> в поле <code>parent</code>, потому что узел <code>branch</code> не имеет своего родительского узла. У нас все ещё есть <code>leaf</code> как один из потомков узла <code>branch</code>. Когда мы получили образец <code>Node</code> в переменной <code>branch</code>, мы можем изменить переменную <code>leaf</code> чтобы дать ей <code>Weak&lt;Node&gt;</code> ссылку на её родителя. Мы используем способ <code>borrow_mut</code> у вида <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> поля <code>parent</code> у <code>leaf</code>, а затем используем функцию <code>Rc::downgrade</code> для создания <code>Weak&lt;Node&gt;</code> ссылки на <code>branch</code> из <code>Rc&lt;Node&gt;</code> в <code>branch</code>.</p>
<p>Когда мы снова напечатаем родителя <code>leaf</code> то в этот раз мы получим исход <code>Some</code> содержащий <code>branch</code>, теперь <code>leaf</code> может получить доступ к своему родителю! Когда мы печатаем <code>leaf</code>, мы также избегаем цикла, который в конечном итоге заканчивался переполнением обоймы, как в приложении 15-26; ссылки вида <code>Weak&lt;Node&gt;</code>  печатаются как <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Отсутствие бесконечного вывода означает, что этот код не создал ссылочной зацикленности. Мы также можем сказать это, посмотрев на значения, которые мы получаем при вызове <code>Rc::strong_count</code> и <code>Rc::weak_count</code>.</p>
<h4 id="Визуализация-изменений-в-strong_count-и-weak_count"><a class="header" href="#Визуализация-изменений-в-strong_count-и-weak_count">Визуализация изменений в <code>strong_count</code> и <code>weak_count</code></a></h4>
<p>Давайте посмотрим, как изменяются значения <code>strong_count</code> и <code>weak_count</code> образцов вида <code>Rc&lt;Node&gt;</code> с помощью создания новой внутренней области видимости и перемещая создания образца <code>branch</code> в эту область. Таким образом можно увидеть, что происходит, когда <code>branch</code> создаётся и затем удаляется при выходе из области видимости. Изменения показаны в приложении 15-29:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Приложение 15-29: Создание <code>branch</code> во внутренней области видимости и подсчёт сильных и слабых ссылок</span></p>
<p>После того, как <code>leaf</code> создан его <code>Rc&lt;Node&gt;</code> имеет значения strong count равное 1 и weak count равное 0. Во внутренней области мы создаём <code>branch</code> и связываем её с <code>leaf</code>, после чего при печати значений счётчиков <code>Rc&lt;Node&gt;</code> в <code>branch</code> они будет иметь strong count 1 и weak count 1 (для <code>leaf.parent</code> указывающего на <code>branch</code> с <code>Weak&lt;Node&gt;</code> ). Когда мы распечатаем счётчики из <code>leaf</code>, мы увидим, что они будут иметь strong count 2, потому что <code>branch</code> теперь имеет клон <code>Rc&lt;Node&gt;</code> переменной <code>leaf</code> хранящийся в <code>branch.children</code>, но все равно будет иметь weak count 0.</p>
<p>Когда заканчивается внутренняя область видимости,  <code>branch</code> выходит из области видимости и strong count <code>Rc&lt;Node&gt;</code> уменьшается до 0, поэтому его <code>Node</code> удаляется. Weak count 1 из <code>leaf.parent</code> не имеет никакого отношения к тому, был ли <code>Node</code> удалён, поэтому не будет никаких утечек памяти!</p>
<p>Если мы попытаемся получить доступ к родителю переменной <code>leaf</code> после окончания области видимости, мы снова получим значение <code>None</code>. В конце программы <code>Rc&lt;Node&gt;</code> внутри <code>leaf</code> имеет strong count 1 и weak count 0 потому что переменная <code>leaf</code> снова является единственной ссылкой на <code>Rc&lt;Node&gt;</code>.</p>
<p>Вся логика, которая управляет счётчиками и сбросом их значений, встроена внутри <code>Rc&lt;T&gt;</code> и <code>Weak&lt;T&gt;</code> и их выполнений особенности <code>Drop</code>. Указав, что отношение из дочернего к родительскому элементу должно быть ссылкой вида  <code>Weak&lt;T&gt;</code> в определении <code>Node</code>, делает возможным иметь родительские узлы, указывающие на дочерние узлы и наоборот, не создавая ссылочной зацикленности и утечек памяти.</p>
<h2 id="Итоги-12"><a class="header" href="#Итоги-12">Итоги</a></h2>
<p>В этой главе рассказано как использовать умные указатели для обеспечения различных заверений и соглашений по сравнению с обычными ссылками, которые Ржавчина использует по умолчанию. Вид <code>Box&lt;T&gt;</code> имеет известный размер и указывает на данные размещённые в куче. Вид <code>Rc&lt;T&gt;</code> отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев. Вид <code>RefCell&lt;T&gt;</code> с его внутренней изменяемостью предоставляет вид, который можно использовать при необходимости неизменного вида, но необходимости изменить внутреннее значение этого типа; он также обеспечивает соблюдение правил заимствования во время выполнения, а не во время сборки.</p>
<p>Мы обсудили также особенности <code>Deref</code> и <code>Drop</code>, которые обеспечивают большую возможность умных указателей. Мы исследовали ссылочную зацикленность, которая может вызывать утечки памяти и как это предотвратить с помощью вида <code>Weak&lt;T&gt;</code>.</p>
<p>Если эта глава вызвала у вас влечение и вы хотите выполнить свои собственные умные указатели, обратитесь к <a href="https://doc.rust-lang.org/nomicon/index.html">"The Rustonomicon"</a> за более полезной сведениями.</p>
<p>Далее мы поговорим о одновременности в Rust. Вы даже узнаете о нескольких новых умных указателях.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Многопоточность-без-страха"><a class="header" href="#Многопоточность-без-страха">Многопоточность без страха</a></h1>
<p>Безопасное и эффективное управление многопоточным программированием — ещё одна из основных целей Rust. <em>Многопоточное программирование</em>, когда разные части программы выполняются независимо, и <em>одновременное программирование</em>, когда разные части программы выполняются одновременно, становятся всё более важными, поскольку всё больше компьютеров используют преимущества нескольких процессоров. Исторически программирование в этих условиях было сложным и подверженным ошибкам: Ржавчина надеется изменить это.</p>
<p>Первоначально приказ Ржавчина считала, что обеспечение безопасности памяти и предотвращение неполадок многопоточности — это две отдельные сбоев, которые необходимо решать различными способами. Со временем приказ обнаружила, что системы владения и система видов являются мощным набором средств, помогающих управлять безопасностью памяти <em>и</em> неполадками многопоточного одновременности! Используя владение и проверку видов, многие ошибки многопоточности являются ошибками времени сборки в Rust, а не ошибками времени выполнения. Поэтому вместо того, чтобы тратить много времени на попытки воспроизвести точные обстоятельства, при которых возникает ошибка многопоточности во время выполнения, неправильный код будет отклонён с ошибкой. В итоге вы можете исправить свой код во время работы над ним, а не после развёртывания на рабочем сервере. Мы назвали этот особенность Ржавчина <em>бесстрашной</em> <em>многопоточностью</em>. Бесстрашная многопоточность позволяет вам писать код, который не содержит скрытых ошибок и легко ресогласуется без внесения новых.</p>
<blockquote>
<p>Примечание: для простоты мы будем называть многие сбоев <em>многопоточными</em>, хотя более точный понятие здесь <em> — многопоточные и/или одновременные</em>. Если бы эта книга была о многопоточности и/или одновременности, мы были бы более определены. В этой главе, пожалуйста, всякий раз, когда мы используем понятие <em>«многопоточный»</em>, мысленно замените на понятие <em>«многопоточный и/или одновременный»</em>.</p>
</blockquote>
<p>Многие языки предлагают довольно устоявшиеся решения неполадок многопоточности. Например, Erlang обладает элегантной возможностью для многопоточности при передаче сообщений, но не определяет ясных способов совместного использования состояния между потоками. Поддержка только подмножества возможных решений является разумной подходом для языков более высокого уровня, поскольку язык более высокого уровня обещает выгоду при отказе от некоторого управления над получением абстракций. Однако ожидается, что языки низкого уровня обеспечат решение с наилучшей производительностью в любой именно случаи и будут иметь меньше абстракций по сравнению с аппаратным обеспечением. Поэтому Ржавчина предлагает множество средств для расчетов неполадок любым способом, который подходит для вашей случаи и требований.</p>
<p>Вот темы, которые мы рассмотрим в этой главе:</p>
<ul>
<li>Как создать потоки для одновременного запуска нескольких отрывков кода</li>
<li>Многопоточность <em>передачи сообщений</em>, где потоки передают сообщения между потоками</li>
<li>Многопоточность для <em>совместно используемого состояния</em>, когда несколько потоков имеют доступ к некоторому отрывку данных</li>
<li>Особенности <code>Sync</code> и <code>Send</code>, которые расширяют заверения многопоточности в Ржавчина для пользовательских видов, а также видов, предоставляемых встроенной библиотекой</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-потоков-для-одновременного-выполнения-кода"><a class="header" href="#Использование-потоков-для-одновременного-выполнения-кода">Использование потоков для одновременного выполнения кода</a></h2>
<p>В большинстве современных операционных систем программный код выполняется в виде <em>этапа</em>, причём операционная система способна управлять несколькими этапами сразу. Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно. Устройство, благодаря которой эти независимые части выполняются, называется <em>потоком</em>. Например, веб-сервер может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.</p>
<p>Разбиение вычислений на несколько потоков может повысить производительность программы, поскольку программа выполняет несколько задач одновременно, но такое разбиение также добавляет сложности. Поскольку потоки могут работать одновременно, нет чёткой заверения, определяющей порядок выполнения частей вашего кода в разных потоках. Это может привести к таким неполадкам, как:</p>
<ul>
<li>Состояния гонки, когда потоки обращаются к данным, либо ресурсам, несогласованно.</li>
<li>Взаимные блокировки, когда два потока ожидают друг друга, не позволяя тем самым продолжить работу каждому из потоков.</li>
<li>Ошибки, которые случаются только в определённых случаейх, которые трудно воспроизвести и, соответственно, трудно надёжно исправить.</li>
</ul>
<p>Rust пытается смягчить отрицательные последствия использования потоков, но программирование в многопоточном среде все ещё требует тщательного обдумывания устройства кода, которая отличается от устройства кода программ, работающих в одном потоке.</p>
<p>Языки программирования выполняют потоки несколькими различными способами, и многие операционные системы предоставляют API, который язык может вызывать для создания новых потоков. Обычная библиотека Ржавчина использует прообраз выполнения потоков <em>1:1</em>, при которой одному потоку операционной системы соответствует ровно один "языковой" поток. Существуют ящики, в которых выполнены другие подходы многопоточности, отличающиеся от подходы 1:1.</p>
<h3 id="Создание-нового-потока-с-помощью--spawn"><a class="header" href="#Создание-нового-потока-с-помощью--spawn">Создание нового потока с помощью  <code>spawn</code></a></h3>
<p>Чтобы создать новый поток, мы вызываем функцию <code>thread::spawn</code> и передаём ей замыкание (мы говорили о замыканиях в главе 13), содержащее код, который мы хотим запустить в новом потоке. Пример в приложении 16-1 печатает некоторый текст из основного потока, а также другой текст из нового потока:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p><span class="caption">Приложение 16-1: Создание нового потока для печати определённого текста, в то время как основной поток печатает что-то другое</span></p>
<p>Обратите внимание, что когда основной поток программы на Ржавчина завершается, все порождённые потоки закрываются, независимо от того, завершили они работу или нет. Вывод этой программы может каждый раз немного отличаться, но он будет выглядеть примерно так:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Вызовы <code>thread::sleep</code> заставляют поток на короткое время останавливать своё выполнение, позволяя выполняться другим потокам. Очерёдность выполнения потоков вероятно будет меняться, но это не обязательно: это зависит от того, как ваша операционная система расчитывает потоки. В этом цикле основной поток печатает первым, несмотря на то, что указание печати из порождённого потока появляется раньше в коде. И даже несмотря на то, что мы указали порождённый поток печатать до тех пор, пока значение <code>i</code> не достигнет числа 9, оно успело дойти только до 5, когда основной поток завершился.</p>
<p>Если вы запустите этот код и увидите вывод только из основного потока или не увидите печати из других потоков, попробуйте увеличить числа в рядах, чтобы дать операционной системе больше возможностей для переключения между потоками.</p>
<h3 id="Ожидание-завершения-работы-всех-потоков-используя-join"><a class="header" href="#Ожидание-завершения-работы-всех-потоков-используя-join">Ожидание завершения работы всех потоков используя <code>join</code></a></h3>
<p>Код в приложении 16-1 преждевременно останавливает порождённый поток в большинстве случаев, из-за завершения основного потока. Более того, так как порядок выполнения потоков чётко не определён, этот код не даёт заверения, что порождённый поток вообще начнёт исполняться!</p>
<p>Мы можем исправить неполадку, когда созданный поток не запускается или завершается преждевременно, сохранив возвращаемое значение <code>thread::spawn</code> в какой-либо переменной. Вид возвращаемого значения <code>thread::spawn</code> — <code>JoinHandle</code> . <code>JoinHandle</code> — это владеющее значение, которое, при вызове способа <code>join</code> , будет ждать завершения своего потока. Приложение 16-2 отображает, как использовать <code>JoinHandle</code> потока, созданного в приложении 16-1, и вызывать функцию <code>join</code> , для того, чтобы убедиться, что порождённый поток завершится раньше, чем поток <code>main</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 16-2. Сохранение значения <code>JoinHandle</code> потока <code>thread::spawn</code> , обеспечивающее, что поток выполнит всю необходимую работу, перед тем, как завершится</span></p>
<p>Вызов <code>join</code> у указателя блокирует текущий поток, пока поток, представленный указателем не завершится. <em>Блокировка</em> потока означает, что потоку запрещено выполнять работу или выходить из него. Поскольку мы помеисполнения вызов <code>join</code> после цикла <code>for</code> основного потока, выполнение приложения 16-2 должно привести к выводу, подобному следующему:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Два потока продолжают чередоваться, но основной поток находится в ожидании из-за вызова <code>handle.join()</code> и не завершается до тех пор, пока не завершится запущенный поток.</p>
<p>Но давайте посмотрим, что произойдёт, если мы вместо этого переместим <code>handle.join()</code> перед циклом <code>for</code> в <code>main</code>, например так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p>Основной поток будет ждать завершения порождённого потока, а затем запустит свой цикл <code>for</code> , поэтому выходные данные больше не будут чередоваться, как показано ниже:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Небольшие подробности, такие как место вызова <code>join</code>, могут повлиять на то, выполняются ли ваши потоки одновременно.</p>
<h3 id="Использование-move-замыканий-в-потоках"><a class="header" href="#Использование-move-замыканий-в-потоках">Использование <code>move</code>-замыканий в потоках</a></h3>
<p>Мы часто используем ключевое слово <code>move</code> с замыканиями, переданными в <code>thread::spawn</code>, потому что в этом случае замыкание получает из окружения права владения на используемые им значения, таким образом передавая права владения этими значениями от одного потока к другому. В разделе <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">"Захват ссылок или перемещение прав владения"</a> главы 13 мы обсудили <code>move</code> в среде замыканий. Теперь мы сосредоточимся на взаимодействии между <code>move</code> и <code>thread::spawn</code>.</p>
<p>Обратите внимание, что в приложении 16-1 замыкание, которое мы передаём в <code>thread::spawn</code> не принимает переменных: мы не используем никаких данных из основного потока в коде порождённого потока. Чтобы использовать данные из основного потока в порождённом потоке, замыкание порождённого потока должно захватывать значения, которые ему необходимы. Приложение 16-3 показывает попытку создать вектор в главном потоке и использовать его в порождённом потоке. Тем не менее, это не будет работать, как вы увидите через мгновение.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Приложение 16-3: Попытка использовать вектор, созданный основным потоком, в другом потоке</span></p>
<p>Замыкание использует переменную <code>v</code>, поэтому оно захватит <code>v</code> и сделает его частью окружения замыкания. Поскольку <code>thread::spawn</code> запускает это замыкание в новом потоке, мы должны иметь доступ к <code>v</code> внутри этого нового потока. Но при сборки этого примера, мы получаем следующую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust <em>выводит</em> как захватить <code>v</code> и так как в <code>println!</code> нужна только ссылка на <code>v</code>, то замыкание пытается заимствовать <code>v</code>. Однако есть неполадка: Ржавчина не может определить, как долго будет работать порождённый поток, поэтому он не знает, будет ли всегда действительной ссылка на <code>v</code>.</p>
<p>В приложении 16-4 приведён сценарий, который с большей вероятностью будет иметь ссылку на <code>v</code>, что будет недопустимо:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Приложение 16-4. Поток с замыканием, который пытается захватить ссылку на <code>v</code> из основного потока, удаляющего <code>v</code></span></p>
<p>Если бы Ржавчина позволил нам запустить этот код, есть вероятность, что порождённый поток был бы немедленно переведён в фоновый режим, не выполнив ничего. Порождённый поток имеет ссылку на <code>v</code>, но основной поток немедленно удаляет <code>v</code> , используя функцию <code>drop</code> , которую мы обсуждали в главе 15. Затем, когда порождённый поток начинает выполняться, <code>v</code> уже не существует, поэтому ссылка на него также будет недействительной. О, нет!</p>
<p>Чтобы исправить ошибку сборщика в приложении 16-3, мы можем использовать совет из сообщения об ошибке:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Добавляя ключевое слово <code>move</code> перед замыканием, мы заставляем замыкание забирать используемые значения во владение, вместо того, чтобы позволить Ржавчина вывести необходимость заимствования значения. Изменение Приложения 16-3, показанная в Приложении 16-5, будет собрана и запущена так, как мы ожидаем:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 16-5. Использование ключевого слова <code>move</code> , чтобы замыкание стало владельцем используемых им значений.</span></p>
<p>У нас может возникнуть соблазн попробовать то же самое, чтобы исправить код в приложении 16.4, где основной поток вызывал <code>drop</code> с помощью замыкания <code>move</code> . Однако это исправление не сработает, потому что то, что пытается сделать приложение 16.4, запрещено по другой причине. Если мы добавим <code>move</code> к замыканию, мы переместим <code>v</code> в окружение замыкания и больше не сможем вызывать для него <code>drop</code> в основном потоке. Вместо этого мы получим эту ошибку сборщика:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Правила владения Ржавчина снова нас спасли! Мы получили ошибку кода из приложения 16-3, потому что Ржавчина был устоявшийся и заимствовал <code>v</code> только для потока, что означало, что основной поток предположительно может сделать недействительной ссылку на порождённый поток. Сообщив Ржавчина о передаче владения <code>v</code> в порождаемый поток, мы заверяем Rust, что основной поток больше не будет использовать <code>v</code>. Если мы изменим Приложение 16-4 таким же образом, то мы нарушаем правила владения при попытке использовать <code>v</code> в главном потоке. Ключевое слово <code>move</code> отменяет основное устоявшееся поведение Ржавчина по заимствованию, что не позволяет нам нарушать правила владения.</p>
<p>Имея достаточное понимание потоков и API потоков, давайте посмотрим, что мы можем <em>делать</em> с помощью потоков.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Передача-данных-с-помощью-сообщений-между-потоками"><a class="header" href="#Передача-данных-с-помощью-сообщений-между-потоками">Передача данных с помощью сообщений между потоками</a></h2>
<p>Всё большую распространенность для обеспечения безопасной многопоточности набирает способ, называемый <em>передача сообщений</em>. В этом случае потоки или акторы взаимодействуют друг с другом путём отправки сообщений с данными. Мысль этого подхода выражена в слогане из <a href="https://golang.org/doc/effective_go.html#concurrency">документации языка Go</a> таким образом: «Не стоит передавать сведения с помощью разделяемой памяти; лучше делитесь памятью, передавая сведения».</p>
<p>Для обеспечения отправки многопоточных сообщений в встроенной библиотеке языка Ржавчина выполнены <em>потоки</em>. Поток в программировании - это общепринятый рычаг, с помощью которого данные из одного потока отправляются другому потоку.</p>
<p>Вы можете представить поток в программировании как направленное движение воды, например как ручей или реку. Если вы поместите какую-нибудь вещь на воду, например резиновую уточку, она будет плыть вниз по течению до тех пор, пока это течение не кончится.</p>
<p>Поток состоит из двух половин: передатчика и приёмника. Передатчик — это место вверх по течению, где вы опускаете резиновых уточек в реку, а приёмник — это место, где резиновые уточки оказываются в конце пути. Одна часть вашего кода вызывает способы передатчика с данными, которые вы хотите отправить, а другая часть проверяет принимающую сторону на наличие поступающих сообщений. Поток считается <em>закрытым</em> , если либо передающая, либо принимающая его половина уничтожена.</p>
<p>Давайте создадим программу, в которой один поток будет порождать значения и отправлять их в поток, а другой поток будет получать значения и распечатывать их. Мы будем отправлять между потоками простые значения, используя поток, чтобы изобразить эту функцию. После того, как вы ознакомитесь с этим способом, вы сможете использовать потоки с любыми потоками, которым необходимо взаимодействовать друг с другом. Это может быть например система чата или система, в которой несколько вычислительных потоков выполняют свою часть расчёта, а затем отправляют эту часть в отдельный поток, который уже агрегирует полученные итоги.</p>
<p>Сначала в приложении 16-6 мы создадим поток, но не будем ничего с ним делать. Обратите внимание, что этот код ещё не собирается, потому что Ржавчина не может сказать, какой вид значений мы хотим отправить через поток.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">Приложение 16-6: Создание потока и присваивание двух значений переменным <code>tx</code> и <code>rx</code></span></p>
<p>Мы создаём новый поток, используя функцию <code>mpsc::channel</code>; <code>mpsc</code> означает <em>несколько производителей, один потребитель</em> (multiple producer, single consumer). Коротко, способ которым обычная библиотека Ржавчина выполняет потоки, означает, что поток может иметь несколько <em>отправляющих</em> источников порождающих значения, но только одну <em>принимающую</em> сторону, которая потребляет эти значения. Представьте, что несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке. Сейчас мы пока начнём с одного производителя, а когда пример заработает,  добавим ещё несколько.</p>
<p>Функция <code>mpsc::channel</code> возвращает упорядоченный ряд, первый элемент которого является отправляющей стороной (передатчиком), а вторым элементом является принимающая сторона (получатель). Аббревиатуры <code>tx</code> и <code>rx</code> привычно используются во многих полях для <em>передатчика</em> и <em>приёмника</em> соответственно, поэтому мы называем соответствующие переменные именно так. Мы используем указанию <code>let</code> с образцом, который разъединяет упорядоченные ряды; мы обсудим использование образцов в указаниях <code>let</code> и разъединение в главе 18. А пока знайте, что описанное использование указания <code>let</code> является удобным способом извлечения частей упорядоченного ряда, возвращаемых <code>mpsc::channel</code> .</p>
<p>Давайте переместим передающую часть в порождённый поток так, чтобы он отправлял одну строку и чтобы таким образом, порождённый поток связывался с основным потоком, как показано в приложении 16-7. Это похоже на то, как если бы вы помеисполнения резиновую утку в реку вверх по течению или отправили сообщение чата из одного потока в другой.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Приложение 16-7: Перемещение <code>tx</code> в созданный поток и отправка сообщения «привет»</span></p>
<p>Опять же, мы используем <code>thread::spawn</code> для создания нового потока, а затем используем <code>move</code> для перемещения <code>tx</code> в замыкание, чтобы порождённый поток владел <code>tx</code> . Порождённый поток должен владеть передатчиком, чтобы иметь возможность отправлять сообщения через поток. Передатчик имеет способ <code>send</code> , который принимает значение, которое мы хотим отправить. Способ <code>send</code> возвращает вид <code>Result&lt;T, E&gt;</code> , поэтому, если получатель уже удалён и отправить значение некуда, действие отправки вернёт ошибку. В этом примере мы вызываем <code>unwrap</code> для паники в случае ошибки. В существующем приложении мы обработали бы эту случай более правильно: вернитесь к главе 9, если хотите ещё раз разобрать стратегии правильной обработки ошибок.</p>
<p>В приложении 16-8 мы получим значение от приёмника в основном потоке. Это похоже на извлечение резиновой уточки из воды в конце реки или получение сообщения в чате.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre></pre>
<p><span class="caption">Приложение 16-8: В основном потоке получаем сообщение "hi" и печатаем его</span></p>
<p>Получатель имеет два важных способа: <code>recv</code> и <code>try_recv</code>. Мы используем <code>recv</code>, что является сокращением от <em>receive</em>, который блокирует выполнение основного потока и ждёт, пока данные не будут переданы по потоку. Как только значение будет получено, <code>recv</code> вернёт его в виде <code>Result&lt;T, E&gt;</code>. Когда поток закроется, <code>recv</code> вернёт ошибку, чтобы дать понять, что больше никаких сообщений не поступит.</p>
<p>В свою очередь, способ try_recv не блокирует, а сразу возвращает итог <code>Result&lt;T, E&gt;</code>: значение Ok, содержащее сообщение, если оно доступно или значение Err, если никаких сообщений не поступило. Использование try_recv полезно, если у этого потока есть и другая работа в то время, пока происходит ожидание сообщений: так, мы можем написать цикл, который вызывает try_recv время от времени, обрабатывает сообщение, если оно доступно, а в промежутке выполняет другую работу до того особенности, как вновь будет произведена проверка.</p>
<p>Мы использовали <code>recv</code> в этом примере для простоты; у нас нет никакой другой работы для основного потока, кроме как ждать сообщений, поэтому блокировка основного потока уместна.</p>
<p>При запуске кода приложения 16-8, мы увидим значение, напечатанное из основного потока:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Отлично!</p>
<h3 id="потоки-и-передача-владения"><a class="header" href="#потоки-и-передача-владения">потоки и передача владения</a></h3>
<p>Правила владения играют жизненно важную значение в отправке сообщений, потому что они помогают писать безопасный многопоточный код. Предотвращение ошибок в многопоточном программировании является преимуществом для размышлений о владении во всех ваших Ржавчина программах. Давайте проведём эксперимент, чтобы показать как потоки и владение действуют совместно для предотвращения неполадок. мы попытаемся использовать значение <code>val</code> в порождённом потоке <em>после</em> того как отправим его в поток. Попробуйте собрать код в приложении 16-9, чтобы понять, почему этот код не разрешён:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
<p><span class="caption">Приложение 16-9: Попытка использовать <code>val</code> после того, как мы отправили его по потоку</span></p>
<p>Здесь мы пытаемся напечатать значение <code>val</code> после того, как отправили его в поток вызвав <code>tx.send</code>. Разрешить это было бы плохой мыслью: после того, как значение было отправлено в другой поток, текущий поток мог бы изменить или удалить значение, прежде чем мы попытались бы использовать значение снова. Вероятно изменения в другом потоке могут привести к ошибкам или не ожидаемым итогам из-за противоречивых или несуществующих данных. Однако Ржавчина выдаёт нам ошибку, если мы пытаемся собрать код в приложении 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Наша ошибка для многопоточности привела к ошибке сборки. Функция <code>send</code> вступает во владение своим свойствоом и когда значение перемещается, получатель становится владельцем этого свойства. Это останавливает нас от случайного использования значения снова после его отправки; анализатор заимствования проверяет, что все в порядке.</p>
<h3 id="Отправка-нескольких-значений-и-ожидание-получателем"><a class="header" href="#Отправка-нескольких-значений-и-ожидание-получателем">Отправка нескольких значений и ожидание получателем</a></h3>
<p>Код в приложении 16-8 собирается и выполняется, но в нем неясно показано то, что два отдельных потока общаются друг с другом через поток. В приложении 16-10 мы внесли некоторые изменения, которые докажут, что код в приложении 16-8 работает одновременно: порождённый поток теперь будет отправлять несколько сообщений и делать паузу на секунду между каждым сообщением.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
<p><span class="caption">Приложение 16-10: Отправка нескольких сообщений и пауза между ними</span></p>
<p>На этот раз порождённый поток имеет вектор строк, которые мы хотим отправить основному потоку. Мы перебираем их, отправляя каждую строку по отдельности и делаем паузу между ними, вызывая функцию <code>thread::sleep</code> со значением <code>Duration</code> равным 1 секунде.</p>
<p>В основном потоке мы больше не вызываем функцию <code>recv</code> явно: вместо этого мы используем <code>rx</code> как повторитель . Для каждого полученного значения мы печатаем его. Когда поток будет закрыт, повторение закончится.</p>
<p>При выполнении кода в приложении 16-10 вы должны увидеть следующий вывод с паузой в 1 секунду между каждой строкой:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Поскольку у нас нет кода, который приостанавливает или задерживает цикл <code>for</code> в основном потоке, мы можем сказать, что основной поток ожидает получения значений из порождённого потока.</p>
<h3 id="Создание-нескольких-отправителей-путём-клонирования-передатчика"><a class="header" href="#Создание-нескольких-отправителей-путём-клонирования-передатчика">Создание нескольких отправителей путём клонирования передатчика</a></h3>
<p>Ранее мы упоминали, что <code>mpsc</code> — это аббревиатура от <em>множество поставщиков, один потребитель</em> . Давайте используем <code>mpsc</code> в полной мере и расширим код в приложении 16.10, создав несколько потоков, которые отправляют значения одному и тому же получателю. Мы можем сделать это, клонировав передатчик, как показано в приложении 16.11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 16-11: Отправка нескольких сообщений от нескольких производителей</span></p>
<p>На этот раз, прежде чем мы создадим первый порождённый поток, мы вызовем функцию <code>clone</code> на передатчике. В итоге мы получим новый передатчик, который мы сможем передать первому порождённому потоку. Исходный передатчик мы передадим второму порождённому потоку. Это даст нам два потока, каждый из которых отправляет разные сообщения одному получателю.</p>
<p>Когда вы запустите код, вывод должен выглядеть примерно так:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Вы можете увидеть значения в другом порядке, в зависимости от вашей системы. Именно такое поведение делает одновременность как важным, так и  сложным. Если вы поэкспериментируете с <code>thread::sleep</code> , задавая различные значения переменной в разных потоках, каждый запуск будет более неопределенным и каждый раз будут выводиться разные данные.</p>
<p>Теперь, когда мы посмотрели, как работают потоки, давайте рассмотрим другой способ многопоточности.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Многопоточное-разделяемое-состояние"><a class="header" href="#Многопоточное-разделяемое-состояние">Многопоточное разделяемое состояние</a></h2>
<p>Передача сообщений — прекрасный способ обработки одновременности, но не единственный. Другим способом может быть доступ нескольких потоков к одним и тем же общим данным. Рассмотрим ещё раз часть слогана из документации по языку Go: «Не стоит передавать сведения с помощью разделяемой памяти».</p>
<p>Как бы выглядело общение, используя разделяемую память? Кроме того, почему энтузиасты передачи сообщений предостерегают от его использования?</p>
<p>В каком-то смысле потоки в любом языке программирования похожи на единоличное владение, потому что после передачи значения по потоку вам больше не следует использовать отправленное значение. Многопоточная, совместно используемая память подобна множественному владению: несколько потоков могут одновременно обращаться к одной и той же области памяти. Как вы видели в главе 15, где умные указатели сделали возможным множественное владение, множественное владение может добавить сложность, потому что нужно управлять этими разными владельцами. Система видов Ржавчина и правила владения очень помогают в их правильном управлении. Для примера давайте рассмотрим мьютексы, один из наиболее распространённых многопоточных простейших для разделяемой памяти.</p>
<h3 id="Мьютексы-предоставляют-доступ-к-данным-из-одного-потока-за-раз"><a class="header" href="#Мьютексы-предоставляют-доступ-к-данным-из-одного-потока-за-раз">Мьютексы предоставляют доступ к данным из одного потока (за раз)</a></h3>
<p><em>Mutex</em> - это сокращение от <em>взаимное исключение</em> (mutual exclusion), так как мьютекс позволяет только одному потоку получать доступ к некоторым данным в любой мгновение времени. Для того, чтобы получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить доступ запрашивая <em>блокировку</em> (lock) мьютекса. Блокировка - это устройства данных, являющаяся частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным. Поэтому мьютекс описывается как предмет <em>защищающий</em> данные, которые он хранит через систему блокировки.</p>
<p>Мьютексы имеют репутацию трудных в использовании, потому что вы должны помнить два правила:</p>
<ul>
<li>Перед тем как попытаться получить доступ к данным необходимо получить блокировку.</li>
<li>Когда вы закончили работу с данными, которые защищает мьютекс, вы должны разблокировать данные, чтобы другие потоки могли получить блокировку.</li>
</ul>
<p>Для понимания мьютекса, представьте пример из жизни как объединениевое обсуждение на конференции с одним микрофоном. Прежде чем участник дискуссии сможет говорить, он должен спросить или дать сигнал, что он хочет использовать микрофон. Когда он получает микрофон, то может говорить столько, сколько хочет, а затем передаёт микрофон следующему участнику, который попросит дать ему выступить. Если участник дискуссии забудет освободить микрофон, когда закончит с ним, то никто больше не сможет говорить. Если управление общим микрофоном идёт не правильно, то конференция не будет работать как было расчитано наперед!</p>
<p>Правильное управление мьютексами может быть невероятно сложным и именно поэтому многие люди с энтузиазмом относятся к потокам. Однако, благодаря системе видов и правилам владения в Rust, вы не можете использовать блокировку и разблокировку неправильным образом.</p>
<h4 id="mutext-api"><a class="header" href="#mutext-api"><code>Mutex&lt;T&gt;</code> API</a></h4>
<p>Давайте рассмотрим пример использования мьютекса в приложении 16-12 без использования нескольких потоков:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<p><span class="caption">Приложение 16-12: Изучение API <code>Mutex&lt;T&gt;</code> для простоты в однопоточном среде</span></p>
<p>Как и во многих других видах, мы создаём <code>Mutex&lt;T&gt;</code> с помощью сопутствующей функции <code>new</code>. Чтобы получить доступ к данным внутри мьютекса, мы используем способ <code>lock</code> для получения блокировки. Этот вызов блокирует выполнение текущего потока, так что он не сможет выполнять никакие действия, до тех пор пока не наступит наша очередь получить блокировку.</p>
<p>Вызов <code>lock</code> потерпит неудачу, если другой поток, удерживающий блокировку, запаникует. В таком случае никто не сможет получить блокировку, поэтому мы предпочли использовать <code>unwrap</code> и заставить этот поток паниковать, если мы окажемся в такой случаи.</p>
<p>После получения блокировки мы можем воспринимать возвращённое значение, названное в данном случае <code>num</code>, как изменяемую ссылку на содержащиеся внутри данные. Система видов заверяет, что мы получим блокировку перед использованием значения в <code>m</code>. Вид <code>m</code> - <code>Mutex&lt;i32&gt;</code>, а не <code>i32</code>, поэтому мы <em>должны</em> вызвать <code>lock</code>, чтобы иметь возможность использовать значение <code>i32</code>. Мы не должны об этом забывать, тем более что в иных случаях система видов и не даст нам доступ к внутреннему значению <code>i32</code>.</p>
<p>Как вы наверное подозреваете, <code>Mutex&lt;T&gt;</code> является умным указателем. Точнее, вызов <code>lock</code> <em>возвращает</em> умный указатель, называемый <code>MutexGuard</code>, обёрнутый в <code>LockResult</code>, который мы обработали с помощью вызова <code>unwrap</code>. Умный указатель вида <code>MutexGuard</code> выполняет особенность <code>Deref</code> для указания на внутренние данные; умный указатель также имеет выполнение особенности <code>Drop</code>, самостоятельно снимающего блокировку, когда <code>MutexGuard</code> выходит из области видимости, что происходит в конце внутренней области видимости. В итоге у нас нет риска забыть снять блокировку и оставить мьютекс в заблокированном состоянии, препятствуя  его использованию другими потоками (снятие блокировки происходит самостоятельно ).</p>
<p>После снятия блокировки можно напечатать значение мьютекса и увидеть, что мы смогли изменить внутреннее <code>i32</code> на 6.</p>
<h4 id="Разделение-mutext-между-множеством-потоков"><a class="header" href="#Разделение-mutext-между-множеством-потоков">Разделение <code>Mutex&lt;T&gt;</code> между множеством потоков</a></h4>
<p>Теперь давайте попробуем с помощью <code>Mutex&lt;T&gt;</code> совместно использовать значение между несколькими потоками. Мы стартуем 10 потоков и каждый из них увеличивает значение счётчика на 1, поэтому счётчик изменяется от 0 до 10. Обратите внимание, что в следующих нескольких примерах будут ошибки сборщика и мы будем использовать эти ошибки, чтобы узнать больше об использовании вида <code>Mutex&lt;T&gt;</code> и как Ржавчина помогает нам правильно его использовать. Приложение 16-13 содержит наш начальный пример:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Приложение 16-13. Десять потоков, увеличивающих счётчик, защищённый <code>Mutex&lt;T&gt;</code></span></p>
<p>Мы создаём переменную-счётчик <code>counter</code> для хранения <code>i32</code> значения внутри <code>Mutex&lt;T&gt;</code>, как мы это делали в приложении 16-12. Затем мы создаём 10 потоков, перебирая рядчисел. Мы используем <code>thread::spawn</code> и передаём всем этим потокам одинаковое замыкание, которое перемещает счётчик в поток, запрашивает блокировку на <code>Mutex&lt;T&gt;</code>, вызывая способ <code>lock</code>, а затем добавляет 1 к значению в мьютексе. Когда поток завершит выполнение своего замыкания, <code>num</code> выйдет из области видимости и освободит блокировку, чтобы её мог получить другой поток.</p>
<p>В основном потоке мы собираем все указатели в переменную handles. Затем, как мы это делали в приложении 16-2, вызываем <code>join</code> для каждого указателя, чтобы убедиться в завершении всех потоков. В этот мгновение основной поток получит доступ к блокировке и тоже напечатает итог программы.</p>
<p>Сборщик намекнул, что этот пример не собирается. Давайте выясним почему!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Сообщение об ошибке указывает, что значение <code>counter</code> было перемещёно в замыкание на предыдущей повторения цикла. Ржавчина говорит нам, что мы не можем передать <code>counter</code> во владение  нескольким потокам. Давайте исправим ошибку сборщика с помощью способа множественного владения, который мы обсуждали в главе 15.</p>
<h4 id="Множественное-владение-между-множеством-потоков"><a class="header" href="#Множественное-владение-между-множеством-потоков">Множественное владение между множеством потоков</a></h4>
<p>В главе 15 мы давали значение нескольким владельцам, используя умный указатель <code>Rc&lt;T&gt;</code> для создания значения подсчитанных ссылок. Давайте сделаем то же самое здесь и посмотрим, что произойдёт. Мы завернём <code>Mutex&lt;T&gt;</code> в <code>Rc&lt;T&gt;</code> в приложении 16-14 и клонируем <code>Rc&lt;T&gt;</code> перед передачей владения в поток. Теперь, когда мы увидели ошибки, мы также вернёмся к использованию цикла <code>for</code> и сохраним ключевое слово <code>move</code> у замыкания.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Приложение 16-14: Попытка использования <code>Rc&lt;T&gt;</code>, чтобы позволить нескольким потокам владеть <code>Mutex&lt;T&gt;</code></span></p>
<p>Ещё раз, мы собираем и получаем ... другие ошибки! Сборщик  учит нас.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/thread/mod.rs:691:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Ничего себе, это сообщение об ошибке очень многословно! Вот важная часть, на которой следует сосредоточиться: ``Rc&lt;Mutex<i32>&gt;<code> cannot be sent between threads safely</code>. Сборщик также сообщает нам причину: <code>the trait </code>Send<code>is not implemented for</code>Rc&lt;Mutex<i32>&gt;<code> </code>. Мы поговорим о <code>Send</code> в следующем разделе: это один из особенностей, который заверяет, что виды которые мы используем с потоками, предназначены для использования в многопоточном коде.</p>
<p>К сожалению, <code>Rc&lt;T&gt;</code> небезопасен для совместного использования между потоками. Когда <code>Rc&lt;T&gt;</code> управляет счётчиком ссылок, он добавляется значение к счётчику для каждого вызова <code>clone</code> и вычитается значение из счётчика, когда каждое клонированное значение удаляется при выходе из области видимости. Но он не использует простейшие многопоточности, чтобы обеспечить, что изменения в подсчёте не могут быть прерваны другим потоком. Это может привести к неправильным подсчётам - незначительным ошибкам, которые в свою очередь, могут привести к утечкам памяти или удалению значения до того, как мы отработали с ним. Нам нужен вид точно такой же как <code>Rc&lt;T&gt;</code>, но который позволяет изменять счётчик ссылок безопасно из разных потоков.</p>
<h4 id="Атомарный-счётчик-ссылок-arct"><a class="header" href="#Атомарный-счётчик-ссылок-arct">Атомарный счётчик ссылок <code>Arc&lt;T&gt;</code></a></h4>
<p>К счастью, <code>Arc&lt;T&gt;</code> <em>является</em> видом подобным виду <code>Rc&lt;T&gt;</code>, который безопасен для использования в случаейх многопоточности. Буква <em>А</em> означает <em>атомарное</em>, что означает вид <em>ссылка подсчитываемая атомарно</em>. Atomics - это дополнительный вид простейших для многопоточности, который мы не будем здесь подробно описывать: дополнительную сведения смотрите в документации встроенной библиотеки для <code>std::sync::atomic</code>. На данный мгновение вам просто нужно знать, что atomics работают как простые виды, но безопасны для совместного использования между потоками.</p>
<p>Вы можете спросить, почему все простые виды не являются атомарными и почему обычные виды библиотек не выполнены для использования вместе с видом <code>Arc&lt;T&gt;</code> по умолчанию. Причина в том, что безопасность потоков сопровождается снижением производительности, которое вы хотите платить только тогда, когда вам это действительно нужно. Если вы просто выполняете действия со значениями в одном потоке, то ваш код может работать быстрее, если он не должен обеспечивать заверения предоставляемые atomics.</p>
<p>Давайте вернёмся к нашему примеру: виды <code>Arc&lt;T&gt;</code> и <code>Rc&lt;T&gt;</code> имеют одинаковый API, поэтому мы исправляем нашу программу, заменяя вид в строках <code>use</code>, вызове <code>new</code> и вызове <code>clone</code>. Код в приложении 16-15, наконец собирается и запустится:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Приложение 16-15: Использование вида <code>Arc&lt;T&gt;</code> для обёртывания <code>Mutex&lt;T&gt;</code>, теперь несколько потоков могут совместно владеть мьютексом</span></p>
<p>Код напечатает следующее:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>Мы сделали это! Мы посчитали от 0 до 10, что может показаться не очень впечатляющим, но это позволило больше узнать про <code>Mutex&lt;T&gt;</code> и безопасность потоков. Вы также можете использовать устройство этой программы для выполнения более сложных действий, чем просто увеличение счётчика. Используя эту стратегию, вы можете разделить вычисления на независимые части, разделить эти части на потоки, а затем использовать <code>Mutex&lt;T&gt;</code>, чтобы каждый поток обновлял конечный итог своей частью кода.</p>
<p>Обратите внимание, что если вы выполняете простые числовые действия, то существуют виды более простые, чем <code>Mutex&lt;T&gt;</code>, которые предоставляет звено <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code> встроенной библиотеки</a><!-- ignore -->. Эти виды обеспечивают безопасный, одновременный, атомарный доступ к простым видам. Мы решили использовать <code>Mutex&lt;T&gt;</code> с простым видом в этом примере, чтобы подробнее рассмотреть, как работает <code>Mutex&lt;T&gt;</code>.</p>
<h3 id="Сходства-refcellt--rct-и-mutext--arct"><a class="header" href="#Сходства-refcellt--rct-и-mutext--arct">Сходства <code>RefCell&lt;T&gt;</code> / <code>Rc&lt;T&gt;</code> и <code>Mutex&lt;T&gt;</code> / <code>Arc&lt;T&gt;</code></a></h3>
<p>Вы могли заметить, что <code>counter</code> сам по себе не изменяемый (immutable), но мы можем получить изменяемую ссылку на значение внутри него; это означает, что <code>Mutex&lt;T&gt;</code> обеспечивает внутреннюю изменяемость, также как и семейство <code>Cell</code> видов. Мы использовали <code>RefCell&lt;T&gt;</code> в главе 15, чтобы получить возможность изменять содержимое внутри <code>Rc&lt;T&gt;</code>, теперь подобным образом мы используем <code>Mutex&lt;T&gt;</code> для изменения содержимого внутри <code>Arc&lt;T&gt;</code> .</p>
<p>Ещё одна подробность, на которую стоит обратить внимание: Ржавчина не может защитить вас от всевозможных логических ошибок при использовании <code>Mutex&lt;T&gt;</code>. Вспомните в главе 15, что использование <code>Rc&lt;T&gt;</code> сопряжено с риском создания ссылочной зацикленности, где два значения <code>Rc&lt;T&gt;</code> ссылаются друг на друга, что приводит к утечкам памяти. Подобным образом, <code>Mutex&lt;T&gt;</code> сопряжён с риском создания <em>взаимных блокировок</em> (deadlocks). Это происходит, когда действия необходимо заблокировать два ресурса и каждый из двух потоков получил одну из блокировок, заставляя оба потока ждать друг друга вечно. Если вам важна направление взаимных блокировок, попробуйте создать программу Rust, которая её содержит; затем исследуйте стратегии устранения взаимных блокировок для мьютексов на любом языке и попробуйте выполнить их в Rust. Документация встроенной библиотеки для <code>Mutex&lt;T&gt;</code> и <code>MutexGuard</code> предлагает полезную сведения.</p>
<p>Мы завершим эту главу, рассказав о особенностях <code>Send</code> и <code>Sync</code> и о том, как мы можем использовать их с пользовательскими видами.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Расширенная-многопоточность-с-помощью-особенностей-sync-и-send"><a class="header" href="#Расширенная-многопоточность-с-помощью-особенностей-sync-и-send">Расширенная многопоточность с помощью особенностей <code>Sync</code> и <code>Send</code></a></h2>
<p>Важно, что сам язык Ржавчина имеет <em>очень</em> мало возможностей для многопоточности. Почти все функции многопоточности о которых мы говорили в этой главе, были частью встроенной библиотеки, а не языка. Ваши исходы работы с многопоточностью не ограничиваются языком или встроенной библиотекой; Вы можете написать свой собственный многопоточный возможности или использовать возможности написанные другими.</p>
<p>Тем не менее, в язык встроены две подходы многопоточности: <code>std::marker</code> особенности <code>Sync</code> и <code>Send</code>.</p>
<h3 id="Разрешение-передачи-во-владение-между-потоками-с-помощью-send"><a class="header" href="#Разрешение-передачи-во-владение-между-потоками-с-помощью-send">Разрешение передачи во владение между потоками с помощью <code>Send</code></a></h3>
<p>Маркерный особенность <code>Send</code> указывает, что владение видом выполняющим <code>Send</code>, может передаваться между потоками. Почти каждый вид Ржавчина является видом <code>Send</code>, но есть некоторые исключения, вроде <code>Rc&lt;T&gt;</code>: он не может быть <code>Send</code>, потому что если вы клонировали значение <code>Rc&lt;T&gt;</code> и попытались передать владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно. По этой причине <code>Rc&lt;T&gt;</code> выполнен для использования в однопоточных случаейх, когда вы не хотите платить за снижение производительности.</p>
<p>Следовательно, система видов Ржавчина и ограничений особенности заверяют, что вы никогда не сможете случайно небезопасно отправлять значение <code>Rc&lt;T&gt;</code> между потоками. Когда мы попытались сделать это в приложении 16-14, мы получили ошибку, <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Когда мы переключились на <code>Arc&lt;T&gt;</code>, который является видом <code>Send</code>, то код собрался.</p>
<p>Любой вид полностью состоящий из видов <code>Send</code> самостоятельно помечается как <code>Send</code>. Почти все простые виды являются <code>Send</code>, кроме сырых указателей, которые мы обсудим в главе 19.</p>
<h3 id="Разрешение-доступа-из-нескольких-потоков-с-sync"><a class="header" href="#Разрешение-доступа-из-нескольких-потоков-с-sync">Разрешение доступа из нескольких потоков с <code>Sync</code></a></h3>
<p>Маркерный особенность <code>Sync</code> указывает, что на вид выполняющий <code>Sync</code> можно безопасно ссылаться из нескольких потоков. Другими словами, любой вид <code>T</code> является видом <code>Sync</code>, если <code>&amp;T</code> (ссылка на <code>T</code> ) является видом <code>Send</code>, что означает что ссылку можно безопасно отправить в другой поток. Подобно <code>Send</code>, простые виды являются видом <code>Sync</code>, а виды полностью объединенные из видов <code>Sync</code>, также являются <code>Sync</code> видом.</p>
<p>Умный указатель <code>Rc&lt;T&gt;</code> не является <code>Sync</code> видом по тем же причинам, по которым он не является <code>Send</code>. Вид <code>RefCell&lt;T&gt;</code> (о котором мы говорили в главе 15) и семейство связанных видов <code>Cell&lt;T&gt;</code> не являются <code>Sync</code>. Выполнение проверки заимствования, которую делает вид <code>RefCell&lt;T&gt;</code> во время выполнения программы не является поточно-безопасной. Умный указатель <code>Mutex&lt;T&gt;</code> является видом <code>Sync</code> и может использоваться для совместного доступа из нескольких потоков, как вы уже видели в разделе <a data-md-type="raw_html" href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">«Совместное использование <code>Mutex&lt;T&gt;</code> между несколькими потоками»</a> <!-- ignore -->.</p>
<h3 id="Выполнение-send-и-sync-вручную-небезопасна"><a class="header" href="#Выполнение-send-и-sync-вручную-небезопасна">Выполнение <code>Send</code> и <code>Sync</code> вручную небезопасна</a></h3>
<p>Поскольку виды созданные из особенностей <code>Send</code> и <code>Sync</code> самостоятельно также являются видами <code>Send</code> и <code>Sync</code>, мы не должны выполнить эти особенности вручную. Являясь маркерными особенностями у них нет никаких способов для выполнения. Они просто полезны для выполнения неизменных величин, связанных с многопоточностью.</p>
<p>Ручная выполнение этих особенностей включает в себя выполнение небезопасного кода Rust. Мы поговорим об использовании небезопасного кода Ржавчина в главе 19; на данный мгновение важная сведения заключается в том, что для создания новых многопоточных видов, не состоящих из частей <code>Send</code> и <code>Sync</code> необходимо тщательно продумать заверения безопасности. В <a href="../nomicon/index.html">Rustonomicon</a> есть больше сведений об этих заверениях и о том как их соблюдать.</p>
<h2 id="Итоги-13"><a class="header" href="#Итоги-13">Итоги</a></h2>
<p>Это не последний случай, когда вы увидите многопоточность в этой книге: дело в главе 20 будет использовать подходы этой главы для более существующегостичного случая, чем небольшие примеры обсуждаемые здесь.</p>
<p>Как упоминалось ранее, поскольку в языке Ржавчина очень мало того, с помощью чего можно управлять многопоточностью, многие решения  выполнены в виде ящиков. Они развиваются быстрее, чем обычная библиотека, поэтому обязательно поищите в Интернете текущие современные ящики.</p>
<p>Обычная библиотека Ржавчина предоставляет потоки для передачи сообщений и виды умных указателей, такие как <code>Mutex&lt;T&gt;</code> и <code>Arc&lt;T&gt;</code>, которые можно безопасно использовать в многопоточных средах. Система видов и анализатор заимствований заверяют, что код использующий эти решения не будет содержать гонки данных или недействительные ссылки. Получив собирающийся код, вы можете быть уверены, что он будет успешно работать в нескольких потоках без ошибок, которые трудно обнаружить в других языках. Многопоточное программирование больше не является подходом, которую стоит опасаться: иди вперёд и сделай свои программы многопоточными безбоязненно!</p>
<p>Далее мы поговорим об идиоматичных способах расчетов неполадок и внутреннего выстраивания
решений по мере усложнения ваших программ на Rust. Кроме того, мы обсудим как идиомы Ржавчина связаны с теми, с которыми вы, возможно, знакомы по предметно-направленному программированию.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Возможности-предметно-направленного-программирования-в-rust"><a class="header" href="#Возможности-предметно-направленного-программирования-в-rust">Возможности предметно-направленного программирования в Rust</a></h1>
<p>Предметно-направленное программирование (ООП) — это способ построения программ. Предметы, как программная подход, были введены в язык программирования Simula в 1960-х годах. Эти предметы повлияли на архитектуру программирования Алана Кея, в которой предметы передают сообщения друг другу. Чтобы описать эту архитектуру, он ввёл понятие <em>предметно-направленное программирование</em> в 1967 году. Есть много состязающихся определений ООП, и по некоторым из этих определений Ржавчина является предметно-направленным, а по другим — нет. В этой главе мы рассмотрим некоторые свойства, которые обычно считаются предметно-направленными, и то, как эти свойства транслируются в идиомы языка Rust. Затем мы покажем, как выполнить образец предметно-направленного разработки в Rust, и обсудим соглашения между этим исходом и решением, использующим вместо этого некоторые сильные стороны Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Свойства-предметно-направленных-языков"><a class="header" href="#Свойства-предметно-направленных-языков">Свойства предметно-направленных языков</a></h2>
<p>В сообществе программистов нет единого мнения о том, какими свойствами должен обладать язык, чтобы считаться предметно-направленным. На Ржавчина повлияли многие парадигмы программирования, включая ООП - например, в главе 13 мы изучали особенности, пришедшие из функционального программирования. Однозначно можно утверждать, что ООП-языкам присущи следующие присущие особенности: предметы, инкапсуляция и наследование. Давайте рассмотрим, что каждая из них означает и поддерживает ли их Rust.</p>
<h3 id="Предметы-содержат-данные-и-поведение"><a class="header" href="#Предметы-содержат-данные-и-поведение">Предметы содержат данные и поведение</a></h3>
<p>Книга <em>Приёмы предметно-направленного разработки. Образцы разработки</em> Erich Gamma, Richard Helm, Ralph Johnson, и John Vlissides (Addison-Wesley Professional, 1994), в просторечии называемая <em>Книга банды четырёх</em>, представляет собой сборник примеров предметно-направленного разработки. В ней даётся следующее определение ООП:</p>
<blockquote>
<p>Предметно-направленные программы состоят из предметов. <em>Предмет</em> представляет собой сущность, своего рода дополнение, с данными и процедурами, которые работают с этими данными. Процедуры обычно называются <em>способами</em> или <em>действиеми</em>.</p>
</blockquote>
<p>В соответствии с этим определением, Ржавчина является предметно-направленным языком - в устройствах и перечислениях содержатся данные, а в х <code>impl</code> определяются способы для них. Хотя устройства и перечисления, имеющие способы, не <em>называются</em> предметами, они обеспечивают  возможность, соответствующую определению предметов в книге банды четырёх.</p>
<h3 id="Инкапсуляция-скрывающая-подробности-выполнения"><a class="header" href="#Инкапсуляция-скрывающая-подробности-выполнения">Инкапсуляция, скрывающая подробности выполнения</a></h3>
<p>Другим особенностью, обычно связанным с предметно-направленным программированием, является мысль <em>инкапсуляции</em>: подробности выполнения предмета недоступны для кода, использующего этот предмет. Единственный способ взаимодействия с предметом — через его открытый внешняя оболочка; код, использующий этот предмет, не должен иметь возможности взаимодействовать с внутренними свойствами предметами напрямую изменять его данные или поведение. Инкапсуляция позволяет изменять и ресоздавать внутренние свойства предмета без необходимости изменять код, который использует предмет.</p>
<p>В главе 7 мы уже говорили о том, как управлять инкапсуляцией: мы можем использовать ключевое слово <code>pub</code>, чтобы определить, какие звенья, виды, функции и способы в нашем коде будут открытыми, а всё остальное по умолчанию будет закрытыми. Например, мы можем определить устройство <code>AveragedCollection</code>, в которой есть поле, содержащее вектор значений <code>i32</code>. Также, устройства будет иметь поле, содержащее среднее арифметическое чисел этого вектора, таким образом, среднее не нужно будет вычислять каждый раз, когда оно кому-то понадобится. Другими словами, <code>AveragedCollection</code> будет кэшировать вычисленное среднее для нас. В приложении 17-1 приведено определение устройства <code>AveragedCollection</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<p><span class="caption">Приложение 17-1: устройства <code>AveragedCollection</code> содержит список целых чисел и их среднее арифметическое.</span></p>
<p>Обратите внимание, что устройства помечена ключевым словом <code>pub</code>, что позволяет другому коду её использовать, однако, поля устройства остаются недоступными. Это важно, потому что мы хотим обеспечить обновление среднего значения при добавлении или удалении элемента из списка. Мы можем получить нужное поведение, определив в устройстве способы <code>add</code>, <code>remove</code> и <code>average</code>, как показано в примере 17-2:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<p><span class="caption">Приложение 17-2: Выполнение открытых способов <code>add</code>,<code>remove</code>, и <code>average</code> для <code>AveragedCollection</code></span></p>
<p>Открытые способы <code>add</code>, <code>remove</code> и <code>average</code> являются единственным способом получить или изменить данные в образце <code>AveragedCollection</code>. Когда элемент добавляется в <code>list</code> способом <code>add</code>, или удаляется с помощью способа <code>remove</code>, код выполнения каждого из этих способов вызывает закрытый способ <code>update_average</code>, который позаботится об обновлении поля <code>average</code>.</p>
<p>Мы оставляем поля <code>list</code> и <code>average</code> закрытыми, чтобы внешний код не мог добавлять или удалять элементы непосредственно в поле <code>list</code>; в противном случае поле <code>average</code> может оказаться не согласовано при подобном вмешательстве. Способ <code>average</code> возвращает значение в поле <code>average</code>, что позволяет внешнему коду читать значение <code>average</code>, но не изменять его.</p>
<p>Поскольку мы инкапсулировали подробности выполнения устройства <code>AveragedCollection</code>, мы можем легко изменить такие особенности, как устройства данных, в будущем. Например, мы могли бы использовать <code>HashSet&lt;i32&gt;</code> вместо <code>Vec&lt;i32&gt;</code> для поля <code>list</code>. Благодаря тому, что ярлыки открытых способов <code>add</code>, <code>remove</code> и <code>average</code> остаются неизменными, код, использующий <code>AveragedCollection</code>, также не будет нуждаться в изменении. У нас бы не получилось этого достичь, если бы мы сделали поле <code>list</code> доступным внешнему коду: <code>HashSet&lt;i32&gt;</code> и<code>Vec&lt;i32&gt;</code> имеют разные способы для добавления и удаления элементов, поэтому внешний код, вероятно, должен измениться, если он изменяет <code>list</code> напрямую.</p>
<p>Если инкапсуляция является обязательным особенностью для определения языка как предметно-направленного, то Ржавчина соответствует этому требованию. Возможность использовать или не использовать изменитель доступа <code>pub</code> для различных частей кода позволяет скрыть подробности выполнения.</p>
<h3 id="Наследование-как-система-видов-и-способ-совместного-использования-кода"><a class="header" href="#Наследование-как-система-видов-и-способ-совместного-использования-кода">Наследование как система видов и способ совместного использования кода</a></h3>
<p><em>Наследование</em> — это рычаг, с помощью которого предмет может унаследовать элементы из определения другого предмета. то есть получить данные и поведение родительского предмета без необходимости повторно их определять.</p>
<p>Если язык должен иметь наследование, чтобы быть предметно-направленным, то Ржавчина таким не является. Здесь нет способа определить устройство, наследующую поля и выполнения способов родительской устройства, без использования макроса.</p>
<p>Однако, если вы привыкли иметь наследование в своём наборе средств для программирования, вы можете использовать другие решения в Rust, в зависимости от того, по какой причине вы изначально хотите использовать наследование.</p>
<p>Вы могли бы выбрать наследование по двум основным причинам. Одна из них - возможность повторного использования кода: вы можете выполнить определённое поведение для одного вида, а наследование позволит вам повторно использовать эту выполнение для другого вида. В Ржавчина для этого есть ограниченный способ, использующий выполнение способа особенности по умолчанию, который вы видели в приложении 10-14, когда мы добавили выполнение по умолчанию в способе <code>summarize</code> особенности <code>Summary</code>. Любой вид, выполняющий свойство <code>Summary</code> будет иметь доступный способ <code>summarize</code> без дополнительного кода. Это похоже на то, как родительский класс имеет выполнение способа, и класс-наследник тоже имеет выполнение способа. Мы также можем переопределить выполнение по умолчанию для способа <code>summarize</code>, когда выполняем особенность <code>Summary</code>, что похоже на дочерний класс, переопределяющий выполнение способа, унаследованного от родительского класса.</p>
<p>Вторая причина использования наследования относится к системе видов: чтобы иметь возможность использовать дочерний вид в тех же места, что и родительский. Эта возможность также называется <em>полиморфизм</em> и означает возможность подменять предметы во время исполнения, если они имеют одинаковые свойства.</p>
<blockquote>
<h3 id="Полиморфизм"><a class="header" href="#Полиморфизм">Полиморфизм</a></h3>
<p>Для многих людей полиморфизм является родственным наследования. Но на самом деле это более общая подход, относящаяся к коду, который может работать с данными нескольких видов. Обычно такими видами выступают подклассы при наследовании.</p>
<p>Вместо этого Ржавчина использует обобщённые виды для абстрагирования от видов, и ограничения особенностей (trait bounds) для указания того, какие возможности эти виды должны предоставлять. Это иногда называют <em>ограниченным свойствоическим полиморфизмом</em>.</p>
</blockquote>
<p>Наследование, как подход к разработке, в последнее время утратило распространенность во многих языках программирования, поскольку часто существует риск, что мы будем наследовать код чаще, чем это необходимо. Подклассы не всегда должны обладать всеми свойствами родительского класса, но при использовании наследования другого исхода нет. Это может сделать внешний вид программы менее гибким. Кроме этого, появляется возможность вызова у подклассов способов, которые не имеют смысла или вызывают ошибки, потому что эти способы неприменимы к подклассу. Кроме того, в некоторых языках разрешается только одиночное наследование (т.е. подкласс может наследоваться только от одного класса), что ещё больше ограничивает гибкость разработки программы.</p>
<p>По этим причинам в Ржавчина применяется иной подход, с использованием особенностей-предметов вместо наследования. Давайте посмотрим как особенности-предметы выполняют полиморфизм в Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-особенность-предметов-допускающих-значения-разных-видов"><a class="header" href="#Использование-особенность-предметов-допускающих-значения-разных-видов">Использование особенность-предметов, допускающих значения разных видов</a></h2>
<p>В главе 8 мы упоминали, что одним из ограничений векторов является то, что они могут хранить элементы только одного вида. Мы создали обходное решение в приложении 8-9, где мы определили перечисление <code>SpreadsheetCell</code> в котором были исходы для хранения целых чисел, чисел с плавающей точкой и текста. Это означало, что мы могли хранить разные виды данных в каждой ячейке и при этом иметь вектор, представляющий строку из ячеек. Это очень хорошее решение, когда наши взаимозаменяемые элементы вектора являются видами с конечным набором, известным при сборки кода.</p>
<p>Однако иногда мы хотим, чтобы пользователь нашей библиотеки мог расширить набор видов, которые допустимы в именно случаи. Чтобы показать как этого добиться, мы создадим пример средства с графическим внешней оболочкой пользователя (GUI), который просматривает список элементов, вызывает способ <code>draw</code> для каждого из них, чтобы нарисовать его на экране - это обычная техника для средств GUI. Мы создадим библиотечный ящик с именем <code>gui</code>, содержащий устройство библиотеки GUI. Этот ящик мог бы включать некоторые готовые виды для использования, такие как <code>Button</code> или <code>TextField</code>. Кроме того, пользователи такого ящика <code>gui</code> захотят создавать свои собственные виды, которые могут быть нарисованы: например, кто-то мог бы добавить вид <code>Image</code>, а кто-то другой добавить вид <code>SelectBox</code>.</p>
<p>Мы не будем выполнить полноценную библиотеку GUI для этого примера, но покажем, как её части будут подходить друг к другу. На мгновение написания библиотеки мы не можем знать и определить все виды, которые могут захотеть создать другие программисты. Но мы знаем, что <code>gui</code> должен отслеживать множество значений различных видов и ему нужно вызывать способ <code>draw</code> для каждого из этих значений различного вида. Ему не нужно точно знать, что произойдёт, когда вызывается способ <code>draw</code>, просто у значения будет доступен такой способ для вызова.</p>
<p>Чтобы сделать это на языке с наследованием, можно определить класс с именем <code>Component</code> у которого есть способ с названием <code>draw</code>. Другие классы, такие как <code>Button</code>, <code>Image</code> и <code>SelectBox</code> наследуются от <code>Component</code> и следовательно, наследуют способ <code>draw</code>. Каждый из них может переопределить выполнение способа <code>draw</code>, чтобы определить своё пользовательское поведение, но площадка может обрабатывать все виды, как если бы они были образцами <code>Component</code> и вызывать <code>draw</code> у них. Но поскольку в Ржавчина нет наследования, нам нужен другой способ внутренне выстроить</p>
<p><code>gui</code> библиотеку, чтобы позволить пользователям расширять её новыми видами.</p>
<h3 id="Определение-особенности-для-общего-поведения"><a class="header" href="#Определение-особенности-для-общего-поведения">Определение особенности для общего поведения</a></h3>
<p>Чтобы выполнить поведение, которое мы хотим иметь в <code>gui</code>, определим особенность с именем <code>Draw</code>, который будет содержать один способ с названием <code>draw</code>. Затем мы можем определить вектор, который принимает <em>особенность-предмет</em>. Особенность-предмет указывает как на образец вида, выполняющего указанный особенность, так и на внутреннюю таблицу, используемую для поиска способов особенности указанного вида во время выполнения. Мы создаём особенность-предмет в таком порядке: используем какой-нибудь вид указателя, например ссылку <code>&amp;</code> или умный указатель <code>Box&lt;T&gt;</code>, затем ключевое слово <code>dyn</code>, а затем указываем соответствующий особенность. (Мы будем говорить о причине того, что особенность-предметы должны использовать указатель в разделе <a href="ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">"Виды изменяемого размера и особенность <code>Sized</code> "</a><!-- ignore --> главы 19). Мы можем использовать особенность-предметы вместо гибкого или определенного вида. Везде, где мы используем особенность-предмет, система видов Ржавчина проверит во время сборки, что любое значение, используемое в этом среде, будет выполнить нужный особенность у особенность-предмета. Следовательно, нам не нужно знать все возможные виды во время сборки.</p>
<p>Мы упоминали, что в Ржавчина мы воздерживаемся называть устройства и перечисления «предметами», чтобы отличать их от предметов в других языках. В устройстве или перечислении данные в полях устройства и поведение в разделах <code>impl</code> разделены, тогда как в других языках данные и поведение объединены в одну подход, часто обозначающуюся как предмет. Тем не менее, особенность-предметы <em>являются</em> более похожими на предметы на других языках, в том смысле, что они сочетают в себе данные и поведение. Но особенность-предметы отличаются от привычных предметов тем, что не позволяют добавлять данные к особенность-предмету. Особенность-предметы обычно не настолько полезны, как предметы в других языках: их определенная цель - обеспечить абстракцию через общее поведение.</p>
<p>В приложении 17.3 показано, как определить особенность с именем <code>Draw</code> с помощью одного способа с именем <code>draw</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<p><span class="caption">Приложение 17-3: Определение особенности <code>Draw</code></span></p>
<p>Этот правила написания должен выглядеть знакомым из наших дискуссий о том, как определять особенности в главе 10. Далее следует новый правила написания: в приложении 17.4 определена устройства с именем <code>Screen</code>, которая содержит вектор с именем <code>components</code>. Этот вектор имеет вид <code>Box&lt;dyn Draw&gt;</code>, который и является особенность-предметом; это замена для любого вида внутри <code>Box</code> который выполняет особенность <code>Draw</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<p><span class="caption">Приложение 17-4: Определение устройства <code>Screen</code> с полем <code>components</code>, которое является вектором особенность-предметов, которые выполняют особенность <code>Draw</code></span></p>
<p>В устройстве <code>Screen</code>, мы определим способ <code>run</code>, который будет вызывать способ <code>draw</code> каждого элемента вектора <code>components</code>, как показано в приложении 17-5:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Приложение 17-5: Выполнение способа <code>run</code> у устройства  <code>Screen</code>, который вызывает способ <code>draw</code> каждого составляющих из вектора</span></p>
<p>Это работает иначе, чем определение устройства, которая использует свойство общего вида с ограничениями особенности. Обобщённый свойство вида может быть заменён только одним определенным видом, тогда как особенность-предметы позволяют нескольким определенным видам замещать особенность-предмет во время выполнения. Например, мы могли бы определить устройство <code>Screen</code> используя общий вид и ограничение особенности, как показано в приложении 17-6:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Приложение 17-6: Иная выполнение устройства <code>Screen</code> и способа <code>run</code>, используя обобщённый вид и ограничения особенности</span></p>
<p>Это исход ограничивает нас образцом <code>Screen</code>, который имеет список составляющих всех видов <code>Button</code> или всех видов <code>TextField</code>. Если у вас когда-либо будут только однородные собрания, использование обобщений и ограничений особенности является предпочтительным, поскольку определения будут мономорфизированы во время сборки для использования с определенными видами.</p>
<p>С другой стороны, с помощью способа, использующего особенность-предметы, один образец <code>Screen</code> может содержать <code>Vec&lt;T&gt;</code> который содержит <code>Box&lt;Button&gt;</code>, также как и <code>Box&lt;TextField&gt;</code>. Давайте посмотрим как это работает, а затем поговорим о влиянии на производительность во время выполнения.</p>
<h3 id="Выполнения-особенности"><a class="header" href="#Выполнения-особенности">Выполнения особенности</a></h3>
<p>Теперь мы добавим несколько видов, выполняющих особенность <code>Draw</code>. Мы объявим вид <code>Button</code>. Опять же, действительная выполнение библиотеки GUI выходит за рамки этой книги, поэтому тело способа <code>draw</code> не будет иметь никакой полезной выполнения. Чтобы представить, как может выглядеть такая выполнение, устройства <code>Button</code> может иметь поля для <code>width</code>, <code>height</code> и <code>label</code>, как показано в приложении 17-7:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<p><span class="caption">Приложение 17-7: Устройства <code>Button</code> выполняет особенность <code>Draw</code></span></p>
<p>Поля <code>width</code>, <code>height</code> и <code>label</code> устройства <code>Button</code> будут отличаться от, например, полей других составляющих вроде вида <code>TextField</code>, которая могла бы иметь те же поля плюс поле <code>placeholder</code>. Каждый из видов, который мы хотим нарисовать на экране будет выполнить особенность <code>Draw</code>, но будет использовать отличающийся код способа <code>draw</code> для определения как именно рисовать определенный вид, например <code>Button</code> в этом примере (без действительного кода GUI, который выходит за рамки этой главы). Например, вид <code>Button</code> может иметь дополнительный раздел<code>impl</code>, содержащий способы, относящиеся к тому, что происходит, когда пользователь нажимает кнопку. Эти исходы способов не будут применяться к видам вроде <code>TextField</code>.</p>
<p>Если кто-то использующий нашу библиотеку решает выполнить устройство <code>SelectBox</code>, которая имеет <code>width</code>, <code>height</code> и поля <code>options</code>, он выполняет также и особенность <code>Draw</code> для вида <code>SelectBox</code>, как показано в приложении 17-8:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Приложение 17-8: Другой ящик, использующий <code>gui</code> и выполняющий особенность <code>Draw</code> у устройства <code>SelectBox</code></span></p>
<p>Пользователь нашей библиотеки теперь может написать свою функцию <code>main</code> для создания образца <code>Screen</code>. К образцу <code>Screen</code> он может добавить <code>SelectBox</code> и <code>Button</code>, поместив каждый из них в <code>Box&lt;T&gt;</code>, чтобы он стал особенность-предметом. Затем он может вызвать способ <code>run</code> у образца <code>Screen</code>, который вызовет <code>draw</code> для каждого из составляющих. Приложение 17-9 показывает эту выполнение:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Приложение 17-9: Использование особенность-предметов для хранения значений разных видов, выполняющих один и тот же особенность</span></p>
<p>Когда мы писали библиотеку, мы не знали, что кто-то может добавить вид <code>SelectBox</code>, но наша выполнение <code>Screen</code> могла работать с новым видом и рисовать его, потому что <code>SelectBox</code> выполняет особенность <code>Draw</code>, что означает, что он выполняет способ <code>draw</code>.</p>
<p>Эта подход, касающаяся только сообщений, на которые значение отвечает, в отличие от определенного вида у значения, подобна подходы <em>duck typing</em> в изменяемых строго определенных языках: если что-то ходит как утка и крякает как утка, то она должна быть утка! В выполнения способа <code>run</code> у <code>Screen</code> в приложении 17-5, <code>run</code> не нужно знать каким будет определенный вид каждого составляющих. Он не проверяет, является ли составляющая образцом <code>Button</code> или <code>SelectBox</code>, он просто вызывает способ <code>draw</code> составляющих. Указав <code>Box&lt;dyn Draw&gt;</code> в качестве вида значений в векторе <code>components</code>, мы определили <code>Screen</code> для значений у которых мы можем вызвать способ <code>draw</code>.</p>
<p>Преимущество использования особенность-предметов и системы видов Ржавчина для написания кода, похожего на код с использованием подходы duck typing состоит в том, что нам не нужно во время выполнения  проверять выполняет ли значение в векторе определенный способ или беспокоиться о получении ошибок, если значение не выполняет способ, мы все равно вызываем способ. Ржавчина не собирает наш код, если значения не выполняют особенность, который нужен особенность-предмета..</p>
<p>Например, в приложении 17-10 показано, что произойдёт, если мы попытаемся создать <code>Screen</code> с <code>String</code> в качестве его составляющих:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Приложение 17-10: Попытка использования вида, который не выполняет особенность для особенность-предмета</span></p>
<p>Мы получим ошибку, потому что <code>String</code> не выполняет особенность <code>Draw</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
</code></pre>
<p>Эта ошибка даёт понять, что либо мы передаём в составляющая <code>Screen</code> что-то, что мы не собирались передавать и мы тогда должны передать другой вид, либо мы должны выполнить особенность <code>Draw</code> у вида <code>String</code>, чтобы <code>Screen</code> мог вызывать <code>draw</code> у него.</p>
<h3 id="Особенность-предметы-выполняют-изменяемую-управление-связывание"><a class="header" href="#Особенность-предметы-выполняют-изменяемую-управление-связывание">Особенность-предметы выполняют изменяемую управление (связывание)</a></h3>
<p>Вспомните, в разделе <a href="ch10-01-syntax.html#performance-of-code-using-generics">«Производительность кода, использующего обобщённые виды»</a><!-- ignore --> в главе 10 наше обсуждение этапа мономорфизации, выполняемого сборщиком, когда мы используем ограничения особенностей для обобщённых видов: сборщик порождает частные выполнения функций и способов для каждого определенного вида, который мы применяем для свойства обобщённого вида. Код, который получается в итоге мономорфизации, выполняет <em>постоянную управление</em> , то есть когда сборщик знает, какой способ вы вызываете во время сборки. Это противоположно <em>изменяемой управления</em>, когда сборщик не может определить во время сборки, какой способ вы вызываете. В случае изменяемой управления сборщик создает код, который во время выполнения определит, какой способ нужно вызвать.</p>
<p>Когда мы используем особенность-предметы, Ржавчина должен использовать изменяемую управление. Сборщик не знает всех видов, которые могут быть использованы с кодом, использующим особенность-предметы, поэтому он не знает, какой способ выполнен для какого вида при вызове. Вместо этого, во время выполнения, Ржавчина использует указатели внутри особенность-предмета. чтобы узнать какой способ вызвать. Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при постоянной управления. Изменяемая управление также не позволяет сборщику выбрать встраивание кода способа, что в свою очередь делает невозможными некоторые переработки. Однако мы получили дополнительную гибкость в коде, который мы написали в приложении 17-5, и которую смогли поддержать в приложении 17-9, поэтому все "за" и "против" нужно рассматривать в совокупности.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Выполнение-предметно-направленного-образца-разработки"><a class="header" href="#Выполнение-предметно-направленного-образца-разработки">Выполнение предметно-направленного образца разработки</a></h2>
<p><em>Образец "Состояние"</em> — это предметно-направленный образец разработки. Суть образца заключается в том, что мы определяем набор состояний, которые может иметь внутреннее значение. Состояния представлены набором <em>предметов состояния</em>, а поведение элемента изменяется в зависимости от его состояния. Мы рассмотрим пример устройства записи в блоге, в которой есть поле для хранения состояния, которое будет предметом состояния из набора «черновик», «обзор» или «обнародовано».</p>
<p>Предметы состояния имеют общую возможность: конечно в Ржавчина мы используем устройства и особенности, а не предметы и наследование. Каждый предмет состояния отвечает за своё поведение и сам определяет, когда он должен перейти в другое состояние. Элемент, который содержит предмет состояния, ничего не знает о различиях в поведении состояний или о том, когда одно состояние должно перейти в другое.</p>
<p>Преимуществом образца "Состояние" является то, что при изменении требований заказчика программы не требуется изменять код элемента, содержащего состояние, или код, использующий такой элемент. Нам нужно только обновить код внутри одного из предметов состояния, чтобы изменить его порядок действий, либо, возможно, добавить больше предметов состояния.</p>
<p>Для начала выполняем образец "Состояние" более привычным предметно-направленным способом, а затем воспользуемся подходом, более естественным для Rust. Давайте шаг за шагом выполняем поток действий для записи в блоге, использующий образец "Состояние".</p>
<p>Окончательный возможности будет выглядеть так:</p>
<ol>
<li>Запись в блоге создаётся как пустой черновик.</li>
<li>Когда черновик готов, запрашивается его проверка.</li>
<li>После проверки происходит обнародование записи.</li>
<li>Только обнародованные записи блога возвращают содержимое записи на печать, поэтому сообщения, не прошедшие проверку, не могут быть обнародованы случайно.</li>
</ol>
<p>Любые другие изменения, сделанные в записи, не должны иметь никакого эффекта. Например, если мы попытаемся подтвердить черновик записи в блоге до того, как запросим проверку, запись должна остаться необнародованным черновиком.</p>
<p>В приложении 17-11 показан этот поток действий в виде кода: это пример использования API, который мы собираемся выполнить в библиотеке (ящике) с именем <code>blog</code>. Он пока не собирается, потому что ящик <code>blog</code> ещё не создан.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<p><span class="caption">Приложение 17-11: Код, отображающий желаемое поведение, которое мы хотим получить в ящике <code>blog</code></span></p>
<p>Мы хотим, чтобы пользователь мог создать новый черновик записи в блоге с помощью <code>Post::new</code>. Затем мы хотим разрешить добавление текста в запись блога. Если мы попытаемся получить содержимое записи сразу, до её проверки, мы не должны получить никакого текста на выходе, потому что запись все ещё является черновиком. Мы добавили утверждение (<code>assert_eq!</code>) в коде для опытных целей. Утверждение (assertion), что черновик записи блога должен возвращать пустую строку из способа <code>content</code> было бы отличным состоящим из звеньев проверкой, но мы не собираемся писать проверки для этого примера.</p>
<p>Далее мы хотим разрешить сделать запрос на проверку записи и хотим, чтобы <code>content</code> возвращал пустую строку, пока проверки не завершена. Когда запись пройдёт проверку, она должна быть обнародована, то есть при вызове <code>content</code> будет возвращён текст записи.</p>
<p>Обратите внимание, что единственный вид из ящика, с которым мы взаимодействуем - это вид <code>Post</code>. Этот вид будет использовать образец "Состояние" и будет содержать значение, которое будет являться одним из трёх предметов состояний, представляющих различные состояния, в которых может находиться запись: "черновик", "ожидание проверки" или "обнародовано". Управление переходом из одного состояния в другое будет осуществляться внутренней логикой вида <code>Post</code>. Состояния будут переключаться в итоге реакции на вызов способов образца <code>Post</code> пользователями нашей библиотеки, но пользователи не должны управлять изменениями состояния напрямую. Кроме того, пользователи не должны иметь возможность ошибиться с состояниями, например, обнародовать сообщение до его проверки.</p>
<h3 id="Определение-post-и-создание-нового-образца-в-состоянии-черновика"><a class="header" href="#Определение-post-и-создание-нового-образца-в-состоянии-черновика">Определение <code>Post</code> и создание нового образца в состоянии черновика</a></h3>
<p>Приступим к выполнения библиотеки! Мы знаем, что нам нужна открытая устройства <code>Post</code>, хранящая некоторое содержимое, поэтому мы начнём с определения устройства и связанной с ней открытой функцией <code>new</code> для создания образца <code>Post</code>, как показано в приложении 17-12. Мы также сделаем закрытый особенность <code>State</code>, который будет определять поведение, которое должны будут иметь все предметы состояний устройства <code>Post</code>.</p>
<p>Затем <code>Post</code> будет содержать особенность-предмет <code>Box&lt;dyn State&gt;</code> внутри <code>Option&lt;T&gt;</code> в закрытом поле <code>state</code> для хранения предмета состояния. Чуть позже вы поймёте, зачем нужно использовать <code>Option&lt;T&gt;</code> .</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<p><span class="caption">Приложение 17-12. Определение устройства <code>Post</code> и функции <code>new</code>, которая создаёт новый образец <code>Post</code>, особенности <code>State</code> и устройства <code>Draft</code></span></p>
<p>Особенность <code>State</code> определяет поведение, совместно используемое различными состояниями поста. Все предметы состояний (<code>Draft</code> - "черновик", <code>PendingReview</code>  - "ожидание проверки" и <code>Published</code> - "обнародовано") будут выполнить особенность <code>State</code>. Пока у этого особенности нет никаких способов, и мы начнём с определения состояния <code>Draft</code>, просто потому, что это первое состояние, с которого, как мы хотим, обнародование будет начинать свой путь.</p>
<p>Когда мы создаём новый образец <code>Post</code>, мы устанавливаем его поле <code>state</code> в значение <code>Some</code>, содержащее <code>Box</code>. Этот <code>Box</code> указывает на новый образец устройства <code>Draft</code>. Это заверяет, что всякий раз, когда мы создаём новый образец <code>Post</code>, он появляется как черновик. Поскольку поле <code>state</code> в устройстве <code>Post</code> является закрытым, нет никакого способа создать <code>Post</code> в каком-либо другом состоянии! В функции <code>Post::new</code> мы объявим поле <code>content</code> новой пустой строкой вида <code>String</code>.</p>
<h3 id="Хранение-текста-содержимого-записи"><a class="header" href="#Хранение-текста-содержимого-записи">Хранение текста содержимого записи</a></h3>
<p>В приложении 17-11 показано, что мы хотим иметь возможность вызывать способ <code>add_text</code> и передать ему <code>&amp;str</code>, которое добавляется к текстовому содержимому записи блога. Мы выполняем эту возможность как способ, а не делаем поле <code>content</code> открыто доступным, используя <code>pub</code>. Это означает, что позже мы сможем написать способ, который будет управлять, как именно читаются данные из поля <code>content</code>. Способ <code>add_text</code> довольно прост, поэтому давайте добавим его выполнение в раздел<code>impl Post</code>приложения 17-13:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Приложение 17-13. Выполнение <code>add_text</code> для добавления текста к <code>content</code> (содержимому записи)</span></p>
<p>Способ <code>add_text</code> принимает изменяемую ссылку на <code>self</code>, потому что мы меняем образец <code>Post</code>, для которого вызываем <code>add_text</code>. Затем мы вызываем <code>push_str</code> для <code>String</code> у поля <code>content</code> и передаём <code>text</code> переменнаяом для добавления к сохранённому <code>content</code>. Это поведение не зависит от состояния, в котором находится запись, таким образом оно не является частью образца "Состояние". Способ <code>add_text</code> вообще не взаимодействует с полем <code>state</code>, но это часть поведения, которое мы хотим поддерживать.</p>
<h3 id="Убедимся-что-содержание-черновика-будет-пустым"><a class="header" href="#Убедимся-что-содержание-черновика-будет-пустым">Убедимся, что содержание черновика будет пустым</a></h3>
<p>Даже после того, как мы вызвали <code>add_text</code> и добавили некоторый содержание в нашу запись, мы хотим, чтобы способ <code>content</code> возвращал пустой отрывок строки, так как запись всё ещё находится в черновом состоянии, как это показано в строке 7 приложения 17-11. А пока давайте выполняем способ <code>content</code> наиболее простым способом, который будет удовлетворять этому требованию: будем всегда возвращать пустой отрывок строки. Мы изменим код позже, как только выполняем возможность изменить состояние записи, чтобы она могла бы быть обнародована. Пока что записи могут находиться только в черновом состоянии, поэтому содержимое записи всегда должно быть пустым. Приложение 17-14 показывает такую выполнение-заглушку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Приложение 17-14. Добавление выполнения-заглушки для способа <code>content</code> в <code>Post</code>, которая всегда возвращает пустой отрывок строки.</span></p>
<p>С добавленным таким образом способом <code>content</code> всё в приложении 17-11 работает, как задумано, вплоть до строки 7.</p>
<h3 id="Запрос-на-проверку-записи-меняет-её-состояние"><a class="header" href="#Запрос-на-проверку-записи-меняет-её-состояние">Запрос на проверку записи меняет её состояние</a></h3>
<p>Далее нам нужно добавить возможность для запроса проверки записи, который должен изменить её состояние с <code>Draft</code> на <code>PendingReview</code>. Приложение 17-15 показывает такой код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Приложение 17-15. Выполнение способов <code>request_review</code> в устройстве <code>Post</code> и особенности <code>State</code></span></p>
<p>Мы добавляем в <code>Post</code> открытый способ с именем <code>request_review</code> ("запросить проверку"), который будет принимать изменяемую ссылку на <code>self</code>. Затем мы вызываем внутренний способ <code>request_review</code> для текущего состояния <code>Post</code>, и этот второй способ <code>request_review</code> поглощает текущее состояние и возвращает новое состояние.</p>
<p>Мы добавляем способ <code>request_review</code> в особенность <code>State</code>; все виды, выполняющие этот особенность, теперь должны будут выполнить способ <code>request_review</code>. Обратите внимание, что вместо <code>self</code>, <code>&amp;self</code> или <code>&amp;mut self</code> в качестве первого свойства способа у нас указан <code>self: Box&lt;Self&gt;</code>. Этот правила написания означает, что способ действителен только при его вызове с обёрткой <code>Box</code>, содержащей наш вид. Этот правила написания становится владельцем <code>Box&lt;Self&gt;</code>, делая старое состояние недействительным, поэтому значение состояния <code>Post</code> может быть преобразовано в новое состояние.</p>
<p>Чтобы поглотить старое состояние, способ <code>request_review</code> должен стать владельцем значения состояния. Это место, где приходит на помощь вид <code>Option</code> поля <code>state</code> записи <code>Post</code>: мы вызываем способ <code>take</code>, чтобы забрать значение <code>Some</code> из поля <code>state</code> и оставить вместо него значение <code>None</code>, потому что Ржавчина не позволяет иметь необъявленные поля в устройствах. Это позволяет перемещать значение <code>state</code> из <code>Post</code>, а не заимствовать его. Затем мы установим новое значение <code>state</code> как итог этой действия.</p>
<p>Нам нужно временно установить <code>state</code> в <code>None</code>, вместо того, чтобы установить его напрямую с помощью кода вроде <code>self.state = self.state.request_review();</code>. Нам нужно завладеть значением поля <code>state</code>. Это даст нам заверение, что <code>Post</code> не сможет использовать старое значение <code>state</code> после того, как мы преобразовали его в новое состояние.</p>
<p>Способ <code>request_review</code> в <code>Draft</code> должен вернуть новый образец новой устройства <code>PendingReview</code>, обёрнутый в Box. Эта устройства будет представлять состояние, в котором запись ожидает проверки. Устройства <code>PendingReview</code> также выполняет способ <code>request_review</code>, но не выполняет никаких преобразований. Она возвращает сама себя, потому что, когда мы запрашиваем проверку записи, уже находящейся в состоянии <code>PendingReview</code>, она всё так же должна продолжать оставаться в состоянии <code>PendingReview</code>.</p>
<p>Теперь мы начинаем видеть преимущества образца "Состояние": способ <code>request_review</code> для <code>Post</code> одинаков, он не зависит от значения <code>state</code>. Каждое состояние само несёт ответственность за свои действия.</p>
<p>Оставим способ <code>content</code> у <code>Post</code> таким как есть, возвращающим пустой отрывок строки. Теперь мы можем иметь <code>Post</code> как в состоянии <code>PendingReview</code>, так и в состоянии <code>Draft</code>, но мы хотим получить такое же поведение в состоянии <code>PendingReview</code>. Приложение 17-11 теперь работает до строки 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="Добавление-approve-для-изменения-поведения-content"><a class="header" href="#Добавление-approve-для-изменения-поведения-content">Добавление <code>approve</code> для изменения поведения <code>content</code></a></h3>
<p>Способ <code>approve</code> ("одобрить") будет подобен способу <code>request_review</code>: он будет устанавливать у <code>state</code> значение, которое должна иметь запись при её одобрении, как показано в приложении 17-16:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Приложение 17-16. Выполнение способа <code>approve</code> для вида <code>Post</code> и особенности <code>State</code></span></p>
<p>Мы добавляем способ <code>approve</code> в особенность <code>State</code>, добавляем новую устройство, которая выполняет этот особенность <code>State</code> и устройство для состояния <code>Published</code>.</p>
<p>Подобно тому, как работает <code>request_review</code> для <code>PendingReview</code>, если мы вызовем способ <code>approve</code> для <code>Draft</code>, он не будет иметь никакого эффекта, потому что <code>approve</code> вернёт <code>self</code>. Когда мы вызываем для <code>PendingReview</code> способ <code>approve</code>, то он возвращает новый упакованный образец устройства <code>Published</code>. Устройства <code>Published</code> выполняет особенность <code>State</code>, и как для способа <code>request_review</code>, так и для способа <code>approve</code> она возвращает себя, потому что в этих случаях запись должна оставаться в состоянии <code>Published</code>.</p>
<p>Теперь нам нужно обновить способ <code>content</code> для <code>Post</code>. Мы хотим, чтобы значение, возвращаемое из <code>content</code>, зависело от текущего состояния <code>Post</code>, поэтому мы собираемся перенести часть возможности <code>Post</code> в способ <code>content</code>, заданный для <code>state</code>, как показано в приложении 17.17:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 17-17: Обновление способа <code>content</code> в устройстве <code>Post</code> для делегирования части возможности способу <code>content</code> устройства <code>State</code></span></p>
<p>Поскольку наша цель состоит в том, чтобы сохранить все эти действия внутри устройств, выполняющих особенность <code>State</code>, мы вызываем способ <code>content</code> у значения в поле <code>state</code> и передаём образец обнародования (то есть <code>self</code> ) в качестве переменной. Затем мы возвращаем значение, которое нам выдаёт вызов способа <code>content</code> поля <code>state</code>.</p>
<p>Мы вызываем способ <code>as_ref</code> у <code>Option</code>, потому что нам нужна ссылка на значение внутри <code>Option</code>, а не владение значением. Поскольку <code>state</code> является видом <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, то при вызове способа <code>as_ref</code> возвращается <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. Если бы мы не вызывали <code>as_ref</code>, мы бы получили ошибку, потому что мы не можем переместить <code>state</code> из заимствованного свойства <code>&amp;self</code> функции.</p>
<p>Затем мы вызываем способ <code>unwrap</code>. Мы знаем, что этот способ здесь никогда не приведёт к со сбоемму завершению программы, так все способы <code>Post</code> устроены таким образом, что после их выполнения, в поле <code>state</code> всегда содержится значение <code>Some</code>. Это один из случаев, про которых мы говорили в разделе <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">"Случаи, когда у вас больше сведений, чем у сборщика"</a><!--  --> главы 9 - случай, когда мы знаем, что значение <code>None</code> никогда не встретится, даже если сборщик не может этого понять.</p>
<p>Теперь, когда мы вызываем <code>content</code> у вида <code>&amp;Box&lt;dyn State&gt;</code>, в действие вступает принудительное приведение (deref coercion) для <code>&amp;</code> и <code>Box</code>, поэтому в конечном итоге способ <code>content</code> будет вызван для вида, который выполняет особенность <code>State</code>. Это означает, что нам нужно добавить способ <code>content</code> в определение особенности <code>State</code>, и именно там мы поместим логику для определения того, какое содержимое возвращать, в зависимости от текущего состояния, как показано в приложении 17-18:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<p><span class="caption">Приложение 17-18. Добавление способа <code>content</code> в особенность <code>State</code></span></p>
<p>Мы добавляем выполнение по умолчанию способа <code>content</code>, который возвращает пустой отрывок строки. Это означает, что нам не придётся выполнить <code>content</code> в устройствах <code>Draft</code> и <code>PendingReview</code>.  Устройства <code>Published</code> будет переопределять способ <code>content</code> и вернёт значение из <code>post.content</code>.</p>
<p>Обратите внимание, что для этого способа нам нужны изложении времени жизни, как мы обсуждали в главе 10. Мы берём ссылку на <code>post</code> в качестве переменной и возвращаем ссылку на часть этого <code>post</code>, поэтому время жизни возвращённой ссылки связано с временем жизни переменной <code>post</code>.</p>
<p>И вот, мы закончили - теперь всё из приложения 17-11 работает! Мы выполнили образец "Состояние", определяющий правила этапа работы с записью в блоге. Логика, связанная с этими правилами, находится в предмета. состояний, а не разбросана по всей устройстве <code>Post</code>.</p>
<blockquote>
<h4 id="Почему-не-перечисление"><a class="header" href="#Почему-не-перечисление">Почему не перечисление?</a></h4>
<p>Возможно, вам было важно, почему мы не использовали <code>enum</code> с различными возможными состояниями записи в качестве исходов. Это, безусловно, одно из возможных решений. Попробуйте его выполнить и сравните конечные итоги, чтобы выбрать, какой из исходов вам больше нравится! Одним из недостатков использования перечисления является то, что в каждом месте, где проверяется значение перечисления, потребуется выражение <code>match</code> или что-то подобное для обработки всех возможных исходов. Возможно в этом случае нам придётся повторять больше кода, чем это было в решении с особенность-предметом.</p>
</blockquote>
<h3 id="Соглашенияы-образца-Состояние"><a class="header" href="#Соглашенияы-образца-Состояние">Соглашенияы образца "Состояние"</a></h3>
<p>Мы показали, что Ржавчина способен выполнить предметно-направленный образец "Состояние" для инкапсуляции различных видов поведения, которые должна иметь запись в каждом состоянии. Способы в <code>Post</code> ничего не знают о различных видах поведения. При такой согласования кода, нам достаточно взглянуть только на один его участок, чтобы узнать отличия в поведении обнародованной обнародования: в выполнение особенности <code>State</code> у устройства <code>Published</code>.</p>
<p>Если бы мы захотели создать иную выполнение, не использующую образец состояния, мы могли бы вместо этого использовать выражения <code>match</code> в способах <code>Post</code> или даже в <code>main</code>, которые бы проверяли состояние записи и изменяли поведение в этих местах. Это приведёт к тому, что нам придётся в нескольких местах исследовать все следствия того, что пост перешёл в состояние "обнародовано"! И эта нагрузка будет только увеличиваться по мере добавления новых состояний: для каждого из этих выражений <code>match</code> потребуются дополнительные ответвления.</p>
<p>С помощью образца "Состояние" способы <code>Post</code> и участки, где мы используем <code>Post</code>, не требуют использования выражений <code>match</code>, а для добавления нового состояния нужно только добавить новую устройство и выполнить способы особенности у одной этой устройства.</p>
<p>Выполнение с использованием образца "Состояние" легко расширить для добавления новой возможности. Чтобы увидеть, как легко поддерживать код, использующий данный образец, попробуйте выполнить некоторые из предложений ниже:</p>
<ul>
<li>Добавьте способ <code>reject</code>, который изменяет состояние обнародования с <code>PendingReview</code> обратно на <code>Draft</code>.</li>
<li>Потребуйте два вызова способа <code>approve</code>, прежде чем переводить состояние в <code>Published</code>.</li>
<li>Разрешите пользователям добавлять текстовое содержимое только тогда, когда обнародование находится в состоянии <code>Draft</code>. Подсказка: пусть предмет состояния решает, можно ли менять содержимое, но не отвечает за изменение <code>Post</code>.</li>
</ul>
<p>Одним из недостатков образца "Состояние" является то, что поскольку состояния сами выполняют переходы между собой, некоторые из состояний получаются связанными друг с другом. Если мы добавим другое состояние между <code>PendingReview</code> и <code>Published</code>,  например <code>Scheduled</code> ("расчитано наперед"), то придётся изменить код в <code>PendingReview</code>, чтобы оно теперь переходило в <code>Scheduled</code>. Если бы не нужно было менять <code>PendingReview</code> при добавлении нового состояния, было бы меньше работы, но это означало бы, что мы переходим на другой образец разработки.</p>
<p>Другим недостатком является то, что мы сделали повторение некоторую логику. Чтобы устранить некоторое повторение, мы могли бы попытаться сделать выполнения по умолчанию для способов <code>request_review</code> и <code>approve</code> особенности <code>State</code>, которые возвращают <code>self</code>; однако это нарушило бы безопасность предмета. потому что особенность не знает, каким определенно будет <code>self</code>. Мы хотим иметь возможность использовать <code>State</code> в качестве особенность-предмета. поэтому нам нужно, чтобы его способы были предметно-безопасными.</p>
<p>Другое повторение включает в себя схожие выполнения способов <code>request_review</code> и <code>approve</code> у  <code>Post</code>. Оба способа делегируют выполнения одного и того же способа значению поля <code>state</code> вида <code>Option</code> и устанавливают итогом новое значение поля <code>state</code>. Если бы у <code>Post</code> было много способов, которые следовали этому образцу, мы могли бы рассмотреть определение макроса для устранения повторения (смотри раздел <a href="ch19-06-macros.html#macros">"Макросы"</a><!--  --> в главе 19).</p>
<p>Выполняя образец "Состояние" точно так, как он определён для предметно-направленных языков, мы не настолько полно используем преимущества Rust, как могли бы. Давайте посмотрим на некоторые изменения, которые мы можем внести в ящик <code>blog</code>, чтобы недопустимые состояния и переходы превратить в ошибки времени сборки.</p>
<h4 id="Кодирование-состояний-и-поведения-в-виде-видов"><a class="header" href="#Кодирование-состояний-и-поведения-в-виде-видов">Кодирование состояний и поведения в виде видов</a></h4>
<p>Мы покажем вам, как переосмыслить образец "Состояние", чтобы получить другой набор соглашений. Вместо того, чтобы полностью инкапсулировать состояния и переходы, так, чтобы внешний код не знал о них, мы будем кодировать состояния с помощью разных видов. Следовательно, система проверки видов Ржавчина предотвратит попытки использовать черновые обнародования, там где разрешены только обнародованные обнародования, вызывая ошибки сборки.</p>
<p>Давайте рассмотрим первую часть <code>main</code> в приложении 17-11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
<p>Мы по-прежнему поддерживаем создание новых сообщений в состоянии "черновика" с помощью способа <code>Post::new</code> и возможность добавлять текст к содержимому обнародования. Но вместо способа <code>content</code> у чернового сообщения, возвращающего пустую строку, мы сделаем так, что у черновых сообщений вообще не будет способа <code>content</code>. Таким образом, если мы попытаемся получить содержимое черновика, мы получим ошибку сборщика, сообщающую, что способ не существует. В итоге мы не сможем случайно отобразить черновик содержимого записи в работающей программе, потому что этот код даже не собирается. В приложении 17-19 показано определение устройств <code>Post</code> и <code>DraftPost</code>, а также способов для каждой из них:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<p><span class="caption">Приложение 17-19: Устройства <code>Post</code> с способом <code>content</code> и устройства <code>DraftPost</code> без способа <code>content</code></span></p>
<p>Обе устройства, <code>Post</code> и <code>DraftPost</code>, имеют закрытое поле <code>content</code>, в котором хранится текст сообщения блога. Устройства больше не содержат поле <code>state</code>, потому что мы перемещаем кодирование состояния в виды устройств. Устройства <code>Post</code> будет представлять обнародованную размещение, и у неё есть способ <code>content</code>, который возвращает <code>content</code>.</p>
<p>У нас все ещё есть функция <code>Post::new</code>, но вместо возврата образца <code>Post</code> она возвращает образец <code>DraftPost</code>. Поскольку поле <code>content</code> является закрытым и нет никаких функций, которые возвращают <code>Post</code>, просто так создать образец <code>Post</code> уже невозможно.</p>
<p>Устройства <code>DraftPost</code> имеет способ <code>add_text</code>, поэтому мы можем добавлять текст к <code>content</code> как и раньше, но учтите, что в <code>DraftPost</code> не определён способ <code>content</code>! Так что теперь программа заверяет, что все записи начинаются как черновики, а черновики размещений не имеют своего содержания для отображения. Любая попытка обойти эти ограничения приведёт к ошибке сборщика.</p>
<h4 id="Выполнение-переходов-в-виде-преобразований-в-другие-виды"><a class="header" href="#Выполнение-переходов-в-виде-преобразований-в-другие-виды">Выполнение переходов в виде преобразований в другие виды</a></h4>
<p>Так как же получить обнародованный пост? Мы хотим обеспечить соблюдение правила, согласно которому черновик записи должен быть рассмотрен и утверждён до того, как он будет обнародован. Запись, находящаяся в состоянии проверки, по-прежнему не должна отображать содержимое. Давайте выполняем эти ограничения, добавив ещё одну устройство, <code>PendingReviewPost</code>, определив способ <code>request_review</code> у <code>DraftPost</code>, возвращающий <code>PendingReviewPost</code>, и определив способ <code>approve</code> у <code>PendingReviewPost</code>, возвращающий <code>Post</code>, как показано в приложении 17-20:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<p><span class="caption">Приложение 17-20: Вид <code>PendingReviewPost</code>, который создаётся путём вызова <code>request_review</code> образца <code>DraftPost</code> и способ <code>approve</code>, который превращает <code>PendingReviewPost</code> в обнародованный <code>Post</code>.</span></p>
<p>Способы <code>request_review</code> и <code>approve</code> забирают во владение <code>self</code>, таким образом поглощая образцы <code>DraftPost</code> и <code>PendingReviewPost</code>, которые потом преобразуются в <code>PendingReviewPost</code> и обнародованную <code>Post</code>, соответственно. Таким образом, у нас не будет никаких долгоживущих образцов <code>DraftPost</code>, после того, как мы вызвали у них <code>request_review</code> и так далее. В устройстве <code>PendingReviewPost</code> не определён способ <code>content</code>, поэтому попытка прочитать его содержимое приводит к ошибке сборщика, также как и в случае с <code>DraftPost</code>. Так как единственным способом получить обнародованный образец <code>Post</code>, у которого действительно есть объявленный способ <code>content</code>, является вызов способа <code>approve</code> у образца <code>PendingReviewPost</code>, а единственный способ получить <code>PendingReviewPost</code> - это вызвать способ <code>request_review</code> у образца <code>DraftPost</code>, теперь мы закодировали этап смены состояний записи блога с помощью системы видов.</p>
<p>Кроме этого, нужно внести небольшие изменения в <code>main</code>. Так как способы <code>request_review</code> и <code>approve</code> теперь возвращают предметы, а не преобразуют устройство от которой были вызваны, нам нужно добавить больше затеняющих присваиваний <code>let post =</code>, чтобы сохранять возвращаемые предметы. Также, теперь мы не можем использовать утверждения (assertions) для проверки того является ли содержимое черновиков и записей, находящихся на рассмотрении, пустыми строками, да они нам и не нужны - теперь стало невозможным собрать код, который бы пытался использовать содержимое записей, находящихся в этих состояниях. Обновлённый код в <code>main</code> показан в приложении 17-21:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<p><span class="caption">Приложение 17-21: Изменения в <code>main</code>, использующие новую выполнение этапа подготовки записи блога</span></p>
<p>Изменения, которые нам нужно было внести в <code>main</code>, чтобы переназначить <code>post</code> означают, что эта выполнение теперь не совсем соответствует предметно-направленному образцу "Состояние": преобразования между состояниями больше не инкапсулированы внутри выполнения <code>Post</code> полностью. Тем не менее, мы получили большую выгоду в том, что недопустимые состояния теперь невозможны из-за системы видов и проверки видов, которая происходит во время сборки! У нас есть заверенияия, что некоторые ошибки, такие как отображение содержимого необнародованной обнародования, будут обнаружены до того, как они дойдут до пользователей.</p>
<p>Попробуйте выполнить задачи, предложенные в начале этого раздела, в исполнения ящика <code>blog</code>, каким он стал после приложения 17-20, чтобы создать своё мнение о внешнем виде этой исполнения кода. Обратите внимание, что некоторые задачи в этом исходе могут быть уже выполнены.</p>
<p>Мы увидели, что хотя Ржавчина и способен выполнить предметно-направленные образцы разработки, в нём также доступны и другие образцы, такие как кодирование состояния с помощью системы видов. Эти подходы имеют различные соглашения. Хотя вы, возможно, очень хорошо знакомы с предметно-направленными образцами, переосмысление неполадок для использования преимуществ и возможностей Ржавчина может дать такие выгоды, как предотвращение некоторых ошибок во время сборки. Предметно-направленные образцы не всегда будут лучшим решением в Ржавчина из-за наличия определённых возможностей, таких как владение, которого нет у предметно-направленных языков.</p>
<h2 id="Итоги-14"><a class="header" href="#Итоги-14">Итоги</a></h2>
<p>Независимо от того, что вы думаете о принадлежности Ржавчина к предметно-направленным языкам после прочтения этой главы, теперь вы знаете, что можете использовать особенность-предметы, чтобы выполнить некоторые предметно-направленные свойства в Rust. Изменяемая управление может дать вашему коду некоторую гибкость в обмен на небольшое ухудшение производительности во время выполнения. Вы можете использовать эту гибкость для выполнения предметно-направленных образцов, которые могут улучшить сопровождаемость вашего кода. В Ржавчина также есть другие особенности, такие как владение, которых нет у предметно-направленных языков. Предметно-направленный образец не всегда будет лучшим способом использовать преимущества Rust, но является доступной возможностью.</p>
<p>Далее мы рассмотрим образцы, которые являются ещё одной особенностью Rust, обеспечивающей высокую гибкость. Мы бегло рассказывали о них на протяжении всей книги, но ещё не видели всех их возможностей. Вперёд!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Образцы-и-сопоставление"><a class="header" href="#Образцы-и-сопоставление">Образцы и сопоставление</a></h1>
<p><em>Образцы</em> - это особый правила написания в Ржавчина для сопоставления со устройством видов, как сложных, так и простых. Использование образцов в сочетании с выражениями <code>match</code> и другими устройствоми даёт вам больший управление над потоком управления программы. Образец состоит из некоторой сочетания следующего:</p>
<ul>
<li>Записи</li>
<li>Деупорядоченные массивы, перечисления, устройства или упорядоченные ряды</li>
<li>Переменные</li>
<li>Особые символы</li>
<li>Заполнители</li>
</ul>
<p>Некоторые примеры образцов включают <code>x</code> , <code>(a, 3)</code> и <code>Some(Color::Red)</code> . В средах, в которых допустимы образцы, эти составляющие описывают разновидность данных. Затем наша программа сопоставляет значения с образцами, чтобы определить, имеет ли значение правильную разновидность данных для продолжения выполнения определённого отрывка кода.</p>
<p>Чтобы использовать образец, мы сравниваем его с некоторым значением. Если образец соответствует значению, мы используем части значения в нашем дальнейшем коде. Вспомните выражения <code>match</code> главы 6, в которых использовались образцы, например, описание машины для сортировки монет. Если значение в памяти соответствует виде образца, мы можем использовать именованные части образца. Если этого не произойдёт, то не выполнится код, связанный с образцом.</p>
<p>Эта глава - справочник по всем особенностим, связанным с образцами. Мы расскажем о допустимых местах использования образцов, разнице между опровержимыми и неопровержимыми образцами и про различные виды правил написания образцов, которые вы можете увидеть. К концу главы вы узнаете, как использовать образцы для ясного выражения многих понятий.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Все-случаи-где-могут-быть-использованы-образцы"><a class="header" href="#Все-случаи-где-могут-быть-использованы-образцы">Все случаи, где могут быть использованы образцы</a></h2>
<p>В этапе использования языка Ржавчина вы часто используете образцы, даже не осознавая этого! В этом разделе обсуждаются все случаи, где использование образцов является правильным.</p>
<h3 id="Ветки-match"><a class="header" href="#Ветки-match">Ветки <code>match</code></a></h3>
<p>Как обсуждалось в главе 6, мы используем образцы в ветках выражений <code>match</code>. Условновыражения <code>match</code> определяется как ключевое слово <code>match</code>, значение используемое для сопоставления, одна или несколько веток, которые состоят из образца и выражения для выполнения, если значение соответствует образцу этой ветки, как здесь:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Например, вот выражение <code>match</code> из приложения 6-5, которое соответствует значению <code>Option&lt;i32&gt;</code> в переменной <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Образцами в этом выражении <code>match</code> являются <code>None</code> и <code>Some(i)</code> слева от каждой стрелки.</p>
<p>Одно из требований к выражениям <code>match</code> состоит в том, что они должны быть <em>исчерпывающими</em> (exhaustive) в том смысле, что они должны учитывать все возможности для значения в выражении <code>match</code>. Один из способов убедиться, что вы рассмотрели каждую возможность - это иметь образец перехвата всех исходов в последней ветке выражения: например, имя переменной, совпадающее с любым значением, никогда не может потерпеть неудачу и таким образом, охватывает каждый оставшийся случай.</p>
<p>Особый образец <code>_</code> будет соответствовать чему угодно, но он никогда не привязывается к переменной, поэтому он часто используется в последней ветке. Образец <code>_</code> может быть полезен, если вы, например, хотите пренебрегать любое не указанное значение. Мы рассмотрим образец <code>_</code> более подробно в разделе <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">"Пренебрежение значений в образце</a><!--  --> позже в этой главе.</p>
<h3 id="Условные-выражения-if-let"><a class="header" href="#Условные-выражения-if-let">Условные выражения <code>if let</code></a></h3>
<p>В главе 6 мы обсуждали, как использовать выражения <code>if let</code> как правило в качестве более короткого способа записи эквивалента <code>match</code>, которое обрабатывает только один случай. Дополнительно <code>if let</code> может иметь соответствующий <code>else</code>, содержащий код для выполнения, если образец выражения <code>if let</code> не совпадает.</p>
<p>В приложении 18-1 показано, что можно также смешивать и сопоставлять выражения <code>if let</code>, <code>else if</code> и <code>else if let</code>. Это даёт больше гибкости, чем <code>match</code> выражение, в котором можно выразить только одно значение для сравнения с образцами. Кроме того, условия в серии <code>if let</code>, <code>else if</code>, <code>else if let</code> не обязаны соотноситься друг с другом.</p>
<p>Код в приложении 18-1 показывает последовательность проверок нескольких условий, определяющих каким должен быть цвет фона. В данном примере мы создали переменные с предопределёнными значениями, которые в существующей программе могли бы быть получены из пользовательского ввода.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-1: Использование условных устройств <code>if let</code>, <code>else if</code>, <code>else if let</code>, и <code>else</code></span></p>
<p>Если пользователь указывает любимый цвет, то этот цвет используется в качестве цвета фона. Если любимый цвет не указан, и сегодня вторник, то цвет фона - зелёный. Иначе, если пользователь указывает свой возраст в виде строки, и мы можем успешно проанализировать её и представить в виде числа, то цвет будет либо фиолетовым, либо оранжевым, в зависимости от значения числа. Если ни одно из этих условий не выполняется, то цвет фона будет синим.</p>
<p>Эта условная устройства позволяет поддерживать сложные требования. С жёстко закодированными значениями, которые у нас здесь есть, этот пример напечатает <code>Using purple as the background color</code>.</p>
<p>Можно увидеть, что <code>if let</code> может также вводить затенённые переменные, как это можно сделать в <code>match</code> ветках: строка <code>if let Ok(age) = age</code> вводит новую затенённую переменную <code>age</code>, которая содержит значение внутри исхода <code>Ok</code>. Это означает, что нам нужно поместить условие <code>if age &gt; 30</code> внутри этого блок: мы не можем объединить эти два условия в <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. Затенённый <code>age</code>, который мы хотим сравнить с 30, не является действительным, пока не начнётся новая область видимости с фигурной скобки.</p>
<p>Недостатком использования <code>if let</code> выражений является то, что сборщик не проверяет полноту (exhaustiveness) всех исходов, в то время как с помощью выражения <code>match</code> это происходит. Если мы не напишем последний раздел<code>else</code> и, благодаря этому, пропустим обработку некоторых случаев, сборщик не предупредит нас о возможной логической ошибке.</p>
<h3 id="Условные-циклы-while-let"><a class="header" href="#Условные-циклы-while-let">Условные циклы <code>while let</code></a></h3>
<p>Подобно устройства <code>if let</code>, устройство условного цикла <code>while let</code> позволяет повторять цикл <code>while</code> до тех пор, пока образец продолжает совпадать. Пример в приложении 18-2 отображает цикл <code>while let</code>, который использует вектор в качестве обоймы и печатает значения вектора в порядке, обратном тому, в котором они были помещены.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{top}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-2: Использование цикла <code>while let</code> для печати значений до тех пор, пока <code>stack.pop()</code> возвращает <code>Some</code></span></p>
<p>В этом примере выводится 3, 2, а затем 1. Способ <code>pop</code> извлекает последний элемент из вектора и возвращает <code>Some(value)</code>. Если вектор пуст, то <code>pop</code> возвращает <code>None</code>. Цикл <code>while</code> продолжает выполнение кода в своём разделе, пока <code>pop</code> возвращает <code>Some</code>. Когда <code>pop</code> возвращает <code>None</code>, цикл останавливается. Мы можем использовать <code>while let</code> для удаления каждого элемента из обоймы.</p>
<h3 id="Цикл-for"><a class="header" href="#Цикл-for">Цикл <code>for</code></a></h3>
<p>В цикле <code>for</code> значение, которое следует непосредственно за ключевым словом <code>for</code> , является образцом. Например, в <code>for x in y</code>  выражение <code>x</code> является образцом. В приложении 18-3 показано, как использовать образец в цикле <code>for</code> , чтобы разъединять или разбить упорядоченный ряд как часть цикла <code>for</code> .</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-3: Использование образца в цикле <code>for</code> для разъединения упорядоченного ряда</span></p>
<p>Код в приложении 18-3 выведет следующее:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>Мы приспособимтируем повторитель с помощью способа <code>enumerate</code>, чтобы он порождал упорядоченный ряд, состоящий из значения и порядкового указателя этого значения. Первым созданным значением будет упорядоченный ряд <code>(0, 'a')</code>. Когда это значение сопоставляется с образцом <code>(index, value)</code>, <code>index</code> будет равен <code>0</code>, а <code>value</code> будет равно <code>'a'</code> и будет напечатана первая строка выходных данных.</p>
<h3 id="Указание-let"><a class="header" href="#Указание-let">Указание <code>let</code></a></h3>
<p>До этой главы мы подробно обсуждали только использование образцов с <code>match</code> и <code>if let</code>, но на самом деле, мы использовали образцы и в других местах, в том числе в указаниях <code>let</code>. Например, рассмотрим следующее простое назначение переменной с помощью <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Каждый раз, когда вы использовали подобным образом указанию <code>let</code>, вы использовали образцы, хотя могли и не осознавать этого! Более условноуказание <code>let</code> выглядит так:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>В указаниях вида <code>let x = 5;</code> с именем переменной в слоте <code>PATTERN</code>, имя переменной является просто отдельной, простой способом образца. Ржавчина сравнивает выражение с образцом и присваивает любые имена, которые он находит. Так что в примере <code>let x = 5;</code>, <code>x</code> - это образец, который означает "привязать то, что соответствует здесь, переменной <code>x</code>". Поскольку имя <code>x</code> является полностью образцом, этот образец в действительности означает "привязать все к переменной <code>x</code> независимо от значения".</p>
<p>Чтобы более чётко увидеть особенность сопоставления с образцом <code>let</code>, рассмотрим приложение 18-4, в котором используется образец с <code>let</code> для разъединения упорядоченного ряда.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-4. Использование образца для разъединения упорядоченного ряда и создания трёх переменных одновременно</span></p>
<p>Здесь мы сопоставляем упорядоченный ряд с образцом. Ржавчина сравнивает значение <code>(1, 2, 3)</code> с образцом <code>(x, y, z)</code> и видит, что значение соответствует образцу, поэтому Ржавчина связывает <code>1</code> с <code>x</code>, <code>2</code> с <code>y</code> и <code>3</code> с <code>z</code>. Вы можете думать об этом образце упорядоченного ряда как о вложении в него трёх отдельных образцов переменных.</p>
<p>Если количество элементов в образце не совпадает с количеством элементов в упорядоченном ряде, то весь вид не будет совпадать и мы получим ошибку сборщика. Например, в приложении 18-5 показана попытка разъединять упорядоченный ряд с тремя элементами в две переменные, что не будет работать.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 18-5: Неправильное построение образца, переменные не соответствуют количеству элементов в упорядоченном ряде</span></p>
<p>Попытка собрать этот код приводит к ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Чтобы исправить ошибку, мы могли бы пренебрегать одно или несколько значений в упорядоченном ряде, используя <code>_</code> или <code>..</code>, как вы увидите в разделе <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Пренебрежение значений в Образце”</a> <!-- ignore -->. Если образец содержит слишком много переменных в образце, можно решить неполадку, сделав виды совпадающими, удалив некоторые переменные таким образом, чтобы число переменных равнялось числу элементов в упорядоченном ряде.</p>
<h3 id="Свойства-функции-1"><a class="header" href="#Свойства-функции-1">Свойства функции</a></h3>
<p>Свойства функции также могут быть образцами. Код в приложении 18-6 объявляет функцию с именем <code>foo</code>, которая принимает один свойство с именем <code>x</code> вида <code>i32</code>, к настоящему времени это должно выглядеть знакомым.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 18-6: Ярлык функции использует образцы в свойствах</span></p>
<p><code>x</code> это часть образца! Как и в случае с <code>let</code>, мы можем сопоставить упорядоченный ряд в переменных функции с образцом. Приложение 18-7 разделяет значения в упорядоченном ряде при его передачи в функцию.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<p><span class="caption">Приложение 18-7: Функция с свойствами, которая разрушает упорядоченный ряд</span></p>
<p>Этот код печатает <code>Current location: (3, 5)</code>. Значения <code>&amp;(3, 5)</code> соответствуют образцу <code>&amp;(x, y)</code>, поэтому <code>x</code> - это значение <code>3</code>, а <code>y</code> - это значение <code>5</code>.</p>
<p>Добавляя к вышесказанному, мы можем использовать образцы в списках свойств замыкания таким же образом, как и в списках свойств функции, потому что, как обсуждалось в главе 13, замыкания похожи на функции.</p>
<p>На данный мгновение вы видели несколько способов использования образцов, но образцы работают не одинаково во всех местах, где их можно использовать. В некоторых местах образцы должны быть неопровержимыми; в других обстоятельствах они могут быть опровергнуты. Мы обсудим эти две подходы далее.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Возможность-опровержения-может-ли-образец-не-совпадать"><a class="header" href="#Возможность-опровержения-может-ли-образец-не-совпадать">Возможность опровержения: может ли образец не совпадать</a></h2>
<p>Образцы бывают двух видов: опровержимые и неопровержимые. Образцы, которые будут соответствовать любому возможному переданному значению, являются <em>неопровержимыми</em> (irrefutable). Примером может быть <code>x</code> в указания <code>let x = 5;</code>, потому что <code>x</code> соответствует чему-либо и, следовательно, не может не совпадать. Образцы, которые могут не соответствовать некоторому возможному значению, являются <em>опровержимыми</em> (refutable). Примером может быть <code>Some(x)</code> в выражении <code>if let Some(x) = a_value</code>, потому что если значение в переменной <code>a_value</code> равно <code>None</code>, а не <code>Some</code>, то образец <code>Some(x)</code> не будет совпадать.</p>
<p>Свойства функций, указания <code>let</code> и циклы <code>for</code> могут принимать только неопровержимые образцы, поскольку программа не может сделать ничего значимого, если значения не совпадают. А выражения <code>if let</code> и <code>while let</code> принимают опровержимые и неопровержимые образцы, но сборщик предостерегает от неопровержимых образцов, поскольку по определению они предназначены для обработки возможного сбоя: возможность условного выражения заключается в его способности выполнять разный код в зависимости от успеха или неудачи.</p>
<p>В общем случае, вам не нужно беспокоиться о разнице между опровержимыми (refutable) и неопровержимыми (irrefutable) образцами; тем не менее, вам необходимо ознакомиться с подходом возможности опровержения, чтобы вы могли отреагировать на неё, увидев в сообщении об ошибке. В таких случаях вам потребуется изменить либо образец, либо устройство, с которой вы используете образец, в зависимости от предполагаемого поведения кода.</p>
<p>Давайте посмотрим на пример того, что происходит, когда мы пытаемся использовать опровержимый образец, где Ржавчина требует неопровержимый образец, и наоборот. В приложении 18-8 показана указание <code>let</code>, но для образца мы указали <code>Some(x)</code>, являющийся образцом, который можно опровергнуть. Как и следовало ожидать, этот код не будет собираться.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 18-8: Попытка использовать опровержимый образец вместе с <code>let</code></span></p>
<p>Если <code>some_option_value</code> было бы значением <code>None</code>, то оно не соответствовало бы образцу <code>Some(x)</code>, что означает, что образец является опровержимым. Тем не менее, указание <code>let</code> может принимать только неопровержимый образец, потому что нет правильного кода, который может что-то сделать со значением <code>None</code>. Во время сборки Ржавчина будет жаловаться на то, что мы пытались использовать опровержимый образец, для которого требуется неопровержимый образец:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Поскольку мы не покрыли (и не могли покрыть!) каждое допустимое значение с помощью образца <code>Some(x)</code>, то Ржавчина выдаёт ошибку сборки.</p>
<p>Чтобы исправить неполадку наличия опровержимого образца, там, где нужен неопровержимый образец, можно изменить код, использующий образец: вместо использования <code>let</code>, можно использовать <code>if let</code>. Затем, если образец не совпадает, выполнение кода внутри фигурных скобок будет пропущено, что даст возможность продолжить правильное выполнение. В приложении 18-9 показано, как исправить код из приложения 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!("{x}");
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-9. Использование <code>if let</code> и раздела с опровергнутыми образцами вместо <code>let</code></span></p>
<p>Код исправлен! Этот код совершенно правильный, хотя это означает, что мы не можем использовать неопровержимый образец без получения ошибки. Если мы используем образец <code>if let</code>, который всегда будет совпадать, то для примера <code>x</code>, показанного в приложении 18-10, сборщик выдаст предупреждение.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!("{x}");
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-10. Попытка использовать неопровержимый образец с <code>if let</code></span></p>
<p>Rust жалуется, что не имеет смысла использовать <code>if let</code> с неопровержимым образцом:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>По этой причине совпадающие ветки выражений должны использовать опровержимые образцы, за исключением последнего, который должен сопоставлять любые оставшиеся значения с неопровержимым образцом. Ржавчина позволяет нам использовать неопровержимый образец в <code>match</code> только с одной веткой, но этот правила написания не особенно полезен и может быть заменён более простой указанием <code>let</code>.</p>
<p>Теперь, когда вы знаете, где использовать образцы и разницу между опровержимыми и неопровержимыми образцами, давайте рассмотрим весь правила написания, который мы можем использовать для создания образцов.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="правила-написания-образцов"><a class="header" href="#правила-написания-образцов">правила написания образцов</a></h2>
<p>В этом разделе мы рассмотрим все виды допустимого правил написания в образцах и расскажем, когда и для чего вам может понадобиться каждый из них.</p>
<h3 id="Сопоставление-с-записью"><a class="header" href="#Сопоставление-с-записью">Сопоставление с записью</a></h3>
<p>Как мы уже видели в главе 6, можно сопоставлять образцы с записями напрямую. В следующем коде есть несколько примеров:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Этот код печатает <code>one</code>, потому что значение в <code>x</code> равно 1. Данный правила написания полезен, когда вы хотите, чтобы ваш код предпринял действие, если он получает определенное значение.</p>
<h3 id="Сопоставление-именованных-переменных"><a class="header" href="#Сопоставление-именованных-переменных">Сопоставление именованных переменных</a></h3>
<p>Именованные переменные - это неопровержимые (irrefutable) образцы, которые соответствуют любому значению и мы использовали их много раз в книге. Однако при использовании именованных переменных в выражениях <code>match</code> возникает сложность. Поскольку <code>match</code> начинает новую область видимости, то переменные, объявленные как часть образца внутри выражения <code>match</code>, будут затенять переменные с тем же именем вне устройства <code>match</code> как и в случае со всеми переменными. В приложении 18-11 мы объявляем переменную с именем <code>x</code> со значением <code>Some(5)</code> и переменную <code>y</code> со значением <code>10</code>. Затем мы создаём выражение <code>match</code> для значения <code>x</code>. Посмотрите на образцы в ветках, <code>println!</code> в конце и попытайтесь выяснить, какой код будет напечатан прежде чем запускать его или читать дальше.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-11: Выражение <code>match</code> с веткой, которая добавляет затенённую переменную <code>y</code></span></p>
<p>Давайте рассмотрим, что происходит, когда выполняется выражение <code>match</code>. Образец в первой ветке не соответствует определённому значению <code>x</code>, поэтому выполнение продолжается.</p>
<p>Образец во второй ветке вводит новую переменную с именем <code>y</code>, которая будет соответствовать любому значению в <code>Some</code>. Поскольку мы находимся в новой области видимости внутри выражения <code>match</code>, это новая переменная <code>y</code>, а не <code>y</code> которую мы объявили в начале со значением 10. Эта новая привязка <code>y</code> будет соответствовать любому значению из <code>Some</code>, которое находится в <code>x</code>. Следовательно, эта новая <code>y</code> связывается с внутренним значением <code>Some</code> из переменной <code>x</code>. Этим значением является <code>5</code>, поэтому выражение для этой ветки выполняется и печатает <code>Matched, y = 5</code>.</p>
<p>Если бы <code>x</code> было значением <code>None</code> вместо <code>Some(5)</code>, то образцы в первых двух ветках не совпали бы, поэтому значение соответствовало бы подчёркиванию. Мы не ввели переменную <code>x</code> в образце ветки со знаком подчёркивания, поэтому <code>x</code> в выражении все ещё является внешней переменной <code>x</code>, которая не была затенена. В этом гипотетическом случае совпадение <code>match</code> выведет <code>Default case, x = None</code>.</p>
<p>Когда выражение <code>match</code> завершается, заканчивается его область видимости как и область действия внутренней переменной <code>y</code>. Последний <code>println!</code> печатает <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Чтобы создать выражение <code>match</code>, которое сравнивает значения внешних <code>x</code> и <code>y</code>, вместо введения затенённой переменной нужно использовать условие в сопоставлении образца. Мы поговорим про условие в сопоставлении образца позже в разделе <a href="ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">“Дополнительные условия в сопоставлении образца”</a><!--  -->.</p>
<h3 id="объединение-образцов"><a class="header" href="#объединение-образцов">объединение образцов</a></h3>
<p>В выражениях <code>match</code> можно сравнивать сразу с несколькими образцами, используя правила написания <code>|</code>, который является оператором образца <em>or</em>. Например, в следующем примере мы сопоставляем значение <code>x</code> с ветвями match, первая из которых содержит оператор <em>or</em>, так что если значение <code>x</code> совпадёт с любым из значений в этой ветви, то будет выполнен её код:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Будет напечатано <code>one or two</code>.</p>
<h3 id="Сопоставление-рядов-с-помощью-"><a class="header" href="#Сопоставление-рядов-с-помощью-">Сопоставление рядов с помощью <code>..=</code></a></h3>
<p>правила написания <code>..=</code> позволяет нам выполнять сравнение с рядом значений. В следующем коде, когда в образце найдётся совпадение с любым из значений заданного ряда, будет выполнена эта ветка:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Если <code>x</code> равен 1, 2, 3, 4 или 5, то совпадение будет достигнуто в первой ветке. Этот правила написания более удобен при указании нескольких значений для сравнения, чем использование оператора <code>|</code> для определения этой же мысли; если бы мы решили использовать <code>|</code>, нам пришлось бы написать <code>1 | 2 | 3 | 4 | 5</code>. Указание ряда намного короче, особенно если мы хотим подобрать, скажем, любое число от 1 до 1 000!</p>
<p>Сборщик проверяет, что рядне является пустым во время сборки, и поскольку единственными видами, для которых Ржавчина может определить, пуст рядили нет, являются <code>char</code> и числовые значения, ряды допускаются только с числовыми или <code>char</code> значениями.</p>
<p>Вот пример использования рядов значений <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust может сообщить, что <code>'c'</code> находится в ряде первого образца и напечатать <code>early ASCII letter</code>.</p>
<h3 id="Разъединение-для-получения-значений"><a class="header" href="#Разъединение-для-получения-значений">Разъединение для получения значений</a></h3>
<p>Мы также можем использовать образцы для разъединения устройств, перечислений и упорядоченных рядов, чтобы использовать разные части этих значений. Давайте пройдёмся по каждому исходу.</p>
<h4 id="Разъединение-устройства"><a class="header" href="#Разъединение-устройства">Разъединение устройства</a></h4>
<p>В приложении 18-12 показана устройства <code>Point</code> с двумя полями <code>x</code> и <code>y</code>, которые мы можем разделить, используя образец с указанием <code>let</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Приложение 18-12: Разбиение полей устройства в отдельные переменные</span></p>
<p>Этот код создаёт переменные <code>a</code> и <code>b</code> , которые сопоставляются значениям полей <code>x</code> и <code>y</code> устройства <code>p</code> . Этот пример показывает, что имена переменных в образце не обязательно должны совпадать с именами полей устройства. Однако обычно имена переменных сопоставляются с именами полей, чтобы было легче запомнить, какие переменные взяты из каких полей. Из-за этого, а также из-за того, что строчка <code>let Point { x: x, y: y } = p;</code> содержит много повторения, в Ржавчина ввели особое сокращение для образцов, соответствующих полям устройства: вам нужно только указать имя поля устройства, и тогда переменные, созданные из образца, будут иметь те же имена. Код в приложении 18-13 подобен коду в Приложении 18-12, но в образце <code>let</code> создаются переменные <code>x</code> и <code>y</code>, вместо <code>a</code> и <code>b</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Приложение 18-13: Разъединение полей устройства с использованием сокращённой записи</span></p>
<p>Этот код создаёт переменные <code>x</code> и <code>y</code>, которые соответствуют полям <code>x</code> и <code>y</code> из переменной <code>p</code>. В итоге переменные <code>x</code> и <code>y</code> содержат значения из устройства <code>p</code>.</p>
<p>А ещё, используя записанные значения в образце, мы можем разъединять, не создавая переменные для всех полей. Это даёт возможность, проверяя одни поля на соответствие определенным значениям, создавать переменные для разъединения других.</p>
<p>В приложении 18-14 показано выражение <code>match</code>, которое разделяет значения <code>Point</code> на три случая: точки, которые лежат непосредственно на оси <code>x</code> (что верно, когда <code>y = 0</code>), на оси <code>y</code> (<code>x = 0</code>) или ни то, ни другое.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-14: Разъединение и сопоставление с записями в одном образце</span></p>
<p>Первая ветвь будет соответствовать любой точке, лежащей на оси <code>x</code>, если значение поля <code>y</code> будет соответствовать записи <code>0</code>. Образец по-прежнему создаёт переменную <code>x</code>, которую мы сможем использовать в коде этой ветви.</p>
<p>Подобно, вторая ветвь совпадёт с любой точкой на оси <code>y</code>, в случае, если значение поля <code>x</code> будет равно <code>0</code>, а для значения поля <code>y</code> будет создана переменная <code>y</code>. Третья ветвь не содержит никаких записей, поэтому она соответствует любому другому <code>Point</code> и создаёт переменные как для поля <code>x</code>, так и для поля <code>y</code>.</p>
<p>В этом примере значение <code>p</code> совпадает по второй ветке, так как <code>x</code> содержит значение 0, поэтому этот код будет печатать <code>On the y axis at 7</code>.</p>
<p>Помните, что выражение <code>match</code> перестаёт проверять следующие ветви, как только оно находит первый совпадающий образец, поэтому, даже если <code>Point { x: 0, y: 0}</code> находится на оси <code>x</code> и оси <code>y</code>, этот код будет печатать только <code>On the x axis at 0</code> .</p>
<h4 id="Разъединение-перечислений"><a class="header" href="#Разъединение-перечислений">Разъединение перечислений</a></h4>
<p>Мы уже разъединили перечисления в книге (см., например, приложение 6-5 главы 6), но<br>не обсуждали явно, что образец для разъединения перечисления должен соответствовать способу объявления данных, хранящихся в перечислении. Например, в приложении 18-15 мы используем перечисление <code>Message</code> из приложения 6-2 и пишем <code>match</code> с образцами, которые будут разъединять каждое внутреннее значение.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}")
        }
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-15: Разъединение исходов перечисления, содержащих разные виды значений</span></p>
<p>Этот код напечатает <code>Change the color to red 0, green 160, and blue 255</code>. Попробуйте изменить значение переменной <code>msg</code>, чтобы увидеть выполнение кода в других ветках.</p>
<p>Для исходов перечисления без каких-либо данных, вроде <code>Message::Quit</code>, мы не можем разъединять значение, которого нет. Мы можем сопоставить только буквальное значение <code>Message::Quit</code> в этом образце, но без переменных.</p>
<p>Для исходов перечисления похожих на устройства, таких как <code>Message::Move</code>, можно использовать образец, подобный образцу, который мы указываем для сопоставления устройств. После имени исхода мы помещаем фигурные скобки и затем перечисляем поля именами переменных. Таким образом мы разделяем отрывки, которые будут использоваться в коде этой ветки. Здесь мы используем сокращённую разновидность, как в приложении 18-13.</p>
<p>Для исходов перечисления, подобных упорядоченному ряду, вроде <code>Message::Write</code>, который содержит упорядоченный ряд с одним элементом и <code>Message::ChangeColor</code>, содержащему упорядоченный ряд с тремя элементами, образец подобен тому, который мы указываем для сопоставления упорядоченных рядов. Количество переменных в образце должно соответствовать количеству элементов в исходе, который мы сопоставляем.</p>
<h4 id="Разъединение-вложенных-устройств-и-перечислений"><a class="header" href="#Разъединение-вложенных-устройств-и-перечислений">Разъединение вложенных устройств и перечислений</a></h4>
<p>До сих пор все наши примеры сопоставляли устройства или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами! Например, мы можем ресогласовать код в приложении 18-15 для поддержки цветов RGB и HSV в сообщении <code>ChangeColor</code> , как показано в приложении 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}")
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-16: Сопоставление со вложенными перечислениями</span></p>
<p>Образец первой ветки в выражении <code>match</code> соответствует исходу перечисления <code>Message::ChangeColor</code>, который содержит исход <code>Color::Rgb</code>; затем образец привязывается к трём внутренними значениями <code>i32</code>. Образец второй ветки также соответствует исходу перечисления <code>Message::ChangeColor</code>, но внутреннее перечисление соответствует исходу <code>Color::Hsv</code>. Мы можем указать эти сложные условия в одном выражении <code>match</code>, даже если задействованы два перечисления.</p>
<h4 id="Разъединение-устройств-и-упорядоченных-рядов"><a class="header" href="#Разъединение-устройств-и-упорядоченных-рядов">Разъединение устройств и упорядоченных рядов</a></h4>
<p>Можно смешивать, сопоставлять и вкладывать образцы разъединения ещё более сложными способами. В следующем примере показана сложная разъединение, где мы вкладываем устройства и упорядоченные ряды внутрь упорядоченного ряда и разъединим из него все простые значения:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>Этот код позволяет нам разбивать сложные виды на составные части, чтобы мы могли использовать нужным нас значения по отдельности.</p>
<p>Разъединение с помощью образцов - это удобный способ использования отрывков значений, таких как как значение из каждого поля в устройстве, по отдельности друг от друга.</p>
<h3 id="Пренебрежение-значений-в-образце"><a class="header" href="#Пренебрежение-значений-в-образце">Пренебрежение значений в образце</a></h3>
<p>Вы видели, что иногда полезно пренебрегать значения в образце, например в последней ветке <code>match</code>, чтобы получить ветку, обрабатывающую любые значения, которая на самом деле ничего не делает, но учитывает все оставшиеся возможные значения. Есть несколько способов пренебрегать целые значения или части значений в образце: используя образец <code>_</code> (который вы видели), используя образец <code>_</code> внутри другого образца, используя имя, начинающееся с подчёркивания, либо используя <code>..</code>, чтобы пренебрегать оставшиеся части значения. Давайте рассмотрим, как и зачем использовать каждый из этих образцов.</p>
<h4 id="Пренебрежение-всего-значения-с-помощью-образца-_"><a class="header" href="#Пренебрежение-всего-значения-с-помощью-образца-_">Пренебрежение всего значения с помощью образца <code>_</code></a></h4>
<p>Мы использовали подчёркивание (<code>_</code>) в качестве образца подстановочного знака (wildcard), который будет сопоставляться с любом значением, но не будет привязываться к этому значению. Это особенно удобно в последней ветке выражения <code>match</code>, но мы также можем использовать его в любом образце, в том числе в свойствах функции, как показано в приложении 18-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Приложение 18-15: Использование <code>_</code> в ярлыке функции</span></p>
<p>Этот код полностью пренебрегает значение <code>3</code>, переданное в качестве первого переменной, и выведет на печать <code>This code only uses the y parameter: 4</code>.</p>
<p>В большинстве случаев, когда вам больше не нужен какой-то из свойств функции, вы можете изменить её ярлык, убрав неиспользуемый свойство. Пренебрежение свойства функции может быть особенно полезно в случаях когда, например, вы выполняете особенность с определённой ярлыком, но тело функции в вашей выполнения не нуждается в одном из свойств. В таком случае сборщик не будет выдавать предупреждения о неиспользуемых свойствах функции, как это было бы, если бы вы указали имя свойства.</p>
<h4 id="Пренебрежение-частей-значения-с-помощью-вложенного-_"><a class="header" href="#Пренебрежение-частей-значения-с-помощью-вложенного-_">Пренебрежение частей значения с помощью вложенного <code>_</code></a></h4>
<p>Также, <code>_</code> можно использовать внутри образцов, чтобы пренебрегать какую-то часть значения, например, когда мы хотим проверить только определённую подробность, а остальные свойства нам не понадобятся в коде, который нужно выполнить. В приложении 18-18 показан код, ответственный за управление значениями настроек. Согласно бизнес-требованиям, пользователь не может изменить установленное значение свойства, но может удалить его и задать ему новое значение, если на данный мгновение оно отсутствует.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-18: Использование подчёркивания в образцах, соответствующих исходам <code>Some</code>, когда нам не нужно использовать значение внутри <code>Some</code></span></p>
<p>Этот код будет печатать <code>Can't overwrite an existing customized value</code>, а затем <code>setting is Some(5)</code>. В первой ветке нам не нужно сопоставлять или использовать значения внутри исхода <code>Some</code>, но нам нужно проверить случай, когда <code>setting_value</code> и <code>new_setting_value</code> являются исходом <code>Some</code>. В этом случае мы печатаем причину, почему мы не меняем значение <code>setting_value</code> и оно не меняется.</p>
<p>Во всех других случаях (если либо <code>setting_value</code>, либо <code>new_setting_value</code> являются исходом <code>None</code>), выраженных образцом <code>_</code> во второй ветке, мы хотим, чтобы <code>new_setting_value</code> стало равно <code>setting_value</code>.</p>
<p>Мы также можем использовать подчёркивание в нескольких местах в одном образце, чтобы пренебрегать определенные значения. Приложение 18-19 показывает пример пренебрежения второго и четвёртого значения в упорядоченном ряде из пяти элементов.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-19: Пренебрежение нескольких частей упорядоченного ряда</span></p>
<p>Этот код напечатает <code>Some numbers: 2, 8, 32</code>, а значения 4 и 16 будут пренебрежены.</p>
<h4 id="Пренебрежение-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени"><a class="header" href="#Пренебрежение-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени">Пренебрежение неиспользуемой переменной, начинающейся с символа <code>_</code> в имени</a></h4>
<p>Если вы создаёте переменную, но нигде её не используете, Ржавчина обычно выдаёт предупреждение, потому что неиспользуемая переменная может быть ошибкой. Но иногда полезно создать переменную, которую вы пока не используете, например, когда вы создаёте протовид или только начинаете дело. В этой случаи вы можете сказать Ржавчина не предупреждать вас о неиспользуемой переменной, начав имя переменной с подчёркивания. В приложении 18-20 мы создаём две неиспользуемые переменные, но когда мы собираем такой код, мы должны получить предупреждение только об одной из них.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Приложение 18-20: Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных</span></p>
<p>Здесь мы получаем предупреждение о том, что не используем переменную <code>y</code>, но мы не получаем предупреждения о неиспользовании переменной<code>_x</code>.</p>
<p>Обратите внимание, что есть небольшая разница между использованием только <code>_</code> и использованием имени, начинающегося с подчёркивания. правила написания <code>_x </code> по-прежнему привязывает значение к переменной, тогда как <code>_</code> не привязывает ничего. В приложении 18-21 представлена ошибка, показывающая, в каком случае это различие имеет значение.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 18-21: Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения</span></p>
<p>Мы получим ошибку, поскольку значение <code>s</code> все равно будет перемещено в <code>_s</code>, что не позволит нам больше воспользоваться <code>s</code>. Однако использование подчёркивания само по себе никогда не приводит к привязке к значению. Приложение 18-22 собирается без ошибок, поскольку <code>s</code> не будет перемещён в <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-22. Использование подчёркивания не привязывает значение</span></p>
<p>Этот код работает правильно, потому что мы никогда не привязываем <code>s</code> к чему либо; оно не перемещается.</p>
<h4 id="Пренебрежение-оставшихся-частей-значения-с-помощью-"><a class="header" href="#Пренебрежение-оставшихся-частей-значения-с-помощью-">Пренебрежение оставшихся частей значения с помощью <code>..</code></a></h4>
<p>Со значениями, которые имеют много частей, можно использовать правила написания <code>..</code>, чтобы использовать только некоторые части и пренебрегать остальные, избегая необходимости перечислять подчёркивания для каждого пренебрегаемого значения. Образец <code>..</code> пренебрегает любые части значения, которые мы явно не сопоставили в остальной частью образца. В приложении 18-23 мы имеем устройство <code>Point</code>, которая содержит координату в трёхмерном пространстве. В выражении <code>match</code> мы хотим работать только с координатой <code>x</code> и пренебрегать значения полей <code>y</code> и <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-21: Пренебрежение полей устройства <code>Point</code> кроме поля <code>x</code> с помощью <code>..</code></span></p>
<p>Мы перечисляем значение <code>x</code> и затем просто включаем образец <code>..</code>. Это быстрее, чем перечислять <code>y: _</code> и <code>z: _</code>, особенно когда мы работаем со устройствами, которые имеют много полей, в случаейх, когда только одно или два поля представляют для нас влечение.</p>
<p>правила написания <code>..</code> раскроется до необходимого количества значений. В приложении 18-24 показано, как использовать <code>..</code> с упорядоченным рядом.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-24: Сопоставление только первого и последнего значений в упорядоченном ряде и пренебрежение всех других значений</span></p>
<p>В этом коде первое и последнее значение соответствуют <code>first</code> и <code>last</code>. Устройство <code>..</code> будет соответствовать и пренебрегать всё, что находится между ними.</p>
<p>Однако использование <code>..</code> должно быть однозначным. Если неясно, какие значения предназначены для сопоставления, а какие следует пренебрегать, Ржавчина выдаст ошибку. В приложении 18-25 показан пример неоднозначного использования <code>..</code>, поэтому он не будет собираться.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<p><span class="caption">Приложение 18-25: Попытка использовать <code>..</code> неоднозначным способом</span></p>
<p>При сборки примера, мы получаем эту ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Rust не может определить, сколько значений в упорядоченном ряде нужно пренебрегать, прежде чем сопоставить значение с <code>second</code>, и сколько следующих значений пренебрегать после этого. Этот код может означать, что мы хотим пренебрегать <code>2</code>, связать <code>second</code> с <code>4</code>, а затем пренебрегать <code>8</code>, <code>16</code> и <code>32</code>; или что мы хотим пренебрегать <code>2</code> и <code>4</code>, связать <code>second</code> с <code>8</code>, а затем пренебрегать <code>16</code> и <code>32</code>; и так далее. Имя переменной <code>second</code> не означает ничего особенного для Rust, поэтому мы получаем ошибку сборщика, так как использование <code>..</code> в двух местах как здесь, является неоднозначным.</p>
<h3 id="Дополнительные-условия-оператора-сопоставления-match-guards"><a class="header" href="#Дополнительные-условия-оператора-сопоставления-match-guards">Дополнительные условия оператора сопоставления (Match Guards)</a></h3>
<p><em>Условие сопоставления</em> (match guard) является дополнительным условием <code>if</code>, указанным после образца в ветке <code>match</code>, которое также должно быть выполнено, чтобы ветка была выбрана. Условия сопоставления полезны для выражения более сложных мыслей, чем позволяет только образец.</p>
<p>Условие может использовать переменные, созданные в образце. В приложении 18-26 показан <code>match</code>, в котором первая ветка имеет образец <code>Some(x)</code>, а также имеет условие сопоставления, <code>if x % 2 == 0</code> (которое будет истинным, если число чётное).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-26: Добавление условия сопоставления в образец</span></p>
<p>В этом примере будет напечатано <code>The number 4 is even</code>. Когда <code>num</code> сравнивается с образцом в первой ветке, он совпадает, потому что <code>Some(4)</code> соответствует <code>Some(x)</code>. Затем условие сопоставления проверяет, равен ли 0 остаток от деления <code>x</code> на 2 и если это так, то выбирается первая ветка.</p>
<p>Если бы <code>num</code> вместо этого было <code>Some(5)</code>, условие в сопоставлении первой ветки было бы ложным, потому что остаток от 5 делённый на 2, равен 1, что не равно 0. Ржавчина тогда перешёл бы ко второй ветке, которое совпадает, потому что вторая ветка не имеет условия сопоставления и, следовательно, соответствует любому исходу <code>Some</code>.</p>
<p>Невозможно выразить условие <code>if x % 2 == 0</code> внутри образца, поэтому условие в сопоставлении даёт нам возможность выразить эту логику. Недостатком этой дополнительной выразительности является то, что сборщик не пытается проверять полноту, когда задействованы выражения с условием в сопоставлении.</p>
<p>В приложении 18-11 мы упомянули, что можно использовать условия сопоставления для решения нашей сбоев затенения образца. Напомним, что внутри образца в выражении <code>match</code> была создана новая переменная, вместо использования внешней к <code>match</code> переменной. Эта новая переменная означала, что мы не могли выполнить сравнение с помощью значения внешней переменной. В приложении 18-27 показано, как мы можем использовать условие сопоставления для решения этой сбоев.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<p><span class="caption">Приложение 18-27. Использование условия сопоставления для проверки на равенство со значением внешней переменной</span></p>
<p>Этот код теперь напечатает <code>Default case, x = Some(5)</code>. Образец во второй ветке не вводит новую переменную <code>y</code>, которая будет затенять внешнюю <code>y</code>, это означает, что теперь можно использовать внешнюю переменную <code>y</code> в условии сопоставления. Вместо указания образца как <code>Some(y)</code>, который бы затенял бы внешнюю <code>y</code>, мы указываем <code>Some(n)</code>. Это создаёт новую переменную <code>n</code>, которая ничего не затеняет, так как переменной <code>n</code> нет вне устройства <code>match</code>.</p>
<p>Условие сопоставления <code>if n == y</code> не является образцом и следовательно, не вводит новые переменные. Переменная <code>y</code> <em>и есть</em> внешняя <code>y</code>, а не новая затенённая <code>y</code>, и теперь мы можем искать элемент, который будет иметь то же значение, что и внешняя <code>y</code>, путём сравнения <code>n</code> и <code>y</code>.</p>
<p>Вы также можете использовать оператор <em>или</em> <code>|</code> в условии сопоставления, чтобы указать несколько образцов; условие сопоставления будет применяться ко всем образцам. В приложении 18-28 показан приоритет соединения условия сопоставления с образцом, который использует <code>|</code>. Важной частью этого примера является то, что условие сопоставления <code>if y</code> применяется к <code>4</code>, <code>5</code>, <em>и</em> к <code>6</code>, хотя это может выглядеть как будто <code>if y</code> относится только к <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-28: Соединение нескольких образцов с условием сопоставления</span></p>
<p>Условие сопоставления гласит, что ветка совпадает, только если значение <code>x</code> равно <code>4</code>, <code>5</code> или <code>6</code>, <em>и</em> если <code>y</code> равно <code>true</code>. Когда этот код выполняется, образец первой ветки совпадает, потому что <code>x</code> равно <code>4</code>, но условие сопоставления <code>if y</code> равно false, поэтому первая ветка не выбрана. Код переходит ко второй ветке, которая совпадает, и эта программа печатает <code>no</code>. Причина в том, что условие <code>if</code> применяется ко всему образцу <code>4 | 5 | 6</code>, а не только к последнему значению <code>6</code>. Другими словами, приоритет условия сопоставления по отношению к образцу ведёт себя так:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>а не так:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>После запуска кода, старшинство в поведении становится очевидным: если условие сопоставления применялось бы только к конечному значению в списке, указанном с помощью оператора <code>|</code>, то ветка бы совпала и программа напечатала бы <code>yes</code>.</p>
<h3 id="Связывание-"><a class="header" href="#Связывание-">Связывание <code>@</code></a></h3>
<p>Оператор <em>at</em> (<code>@</code>) позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение образцу. В приложении 18-29 показан пример, в котором мы хотим проверить, что перечисление <code>Message::Hello</code> со значением поля <code>id</code> находится в ряде <code>3..=7</code>. Но мы также хотим привязать такое значение к переменной <code>id_variable</code>, чтобы использовать его внутри кода данной ветки. Мы могли бы назвать эту переменную <code>id</code>, так же как поле, но для этого примера мы будем использовать другое имя.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-29: Использование <code>@</code> для привязывания значения в образце, с одновременной его проверкой</span></p>
<p>В этом примере будет напечатано <code>Found an id in range: 5</code>. Указывая <code>id_variable @</code> перед рядом <code>3..=7</code>, мы захватываем любое значение, попадающее в ряд, одновременно проверяя, что это значение соответствует ряду в образце.</p>
<p>Во второй ветке, где у нас в образце указан только ряд, код этой ветки не имеет переменной, которая содержит действительное значение поля <code>id</code>. Значение поля <code>id</code> могло бы быть 10, 11 или 12, но код, соответствующий этому образцу, не знает, чему оно равно. Код образца не может использовать значение из поля <code>id</code>, потому что мы не сохранили значение <code>id</code> в переменной.</p>
<p>В последней ветке, где мы указали переменную без ряда, у нас есть значение, доступное для использования в коде ветки, в переменной с именем <code>id</code>. Причина в том, что мы использовали упрощённый правила написания полей устройства. Но мы не применяли никакого сравнения со значением в поле <code>id</code> в этой ветке, как мы это делали в первых двух ветках: любое значение будет соответствовать этому образцу.</p>
<p>Использование <code>@</code> позволяет проверять значение и сохранять его в переменной в пределах одного образца.</p>
<h2 id="Итоги-15"><a class="header" href="#Итоги-15">Итоги</a></h2>
<p>Образцы Ржавчина очень помогают различать разные виды данных. При использовании их в выражениях <code>match</code>, Ржавчина заверяет, что ваши образцы охватывают все возможные значения, потому что иначе ваша программа не собирается. Образцы в указаниях <code>let</code> и свойствах функций делают такие устройства более полезными, позволяя разбивать элементы на более мелкие части, одновременно присваивая их значения переменным. Мы можем создавать простые или сложные образцы в соответствии с нашими потребностями.</p>
<p>Далее, в предпоследней главе книги, мы рассмотрим некоторые продвинутые особенности различных возможностей Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Расширенные-возможности"><a class="header" href="#Расширенные-возможности">Расширенные возможности</a></h1>
<p>На данный мгновение вы изучили все наиболее используемые части языка программирования Rust. Прежде чем мы выполним ещё один дело в главе 20, мы рассмотрим несколько особенностей языка, с которыми вы можете сталкиваться время от времени, но не использовать каждый день. Вы можете использовать эту главу в качестве справочника, когда столкнётесь с какими-либо незнакомыми вещами. Рассмотренные здесь функции будут полезны в очень отличительных случаейх. Хотя вы, возможно, не будете часто пользоваться ими, мы хотим убедиться, что вы знаете все возможности языка Rust.</p>
<p>В этой главе мы рассмотрим:</p>
<ul>
<li>Небезопасный Rust: как отказаться от некоторых заверений Ржавчина и взять на себя ответственность за их ручное соблюдение</li>
<li>Продвинутые особенности: сопряженные виды, свойства вида по умолчанию, полностью квалифицированный правила написания, супер-особенности и образец создания (newtype) по отношению к особенностям</li>
<li>Расширенные виды: больше о образце newtype, псевдонимах вида, вид never и виды изменяемыхх размеров</li>
<li>Расширенные функции и замыкания: указатели функций и возврат замыканий</li>
<li>Макросы: способы определения кода, который определяет большую часть кода во время сборки</li>
</ul>
<p>Это набор возможностей Ржавчина для всех! Давайте погрузимся в него!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>Во всех предыдущих главах этой книги мы обсуждали код на Rust, безопасность памяти в котором обеспечивается во время сборки. Однако внутри Ржавчина скрывается другой язык - небезопасный Rust, который не обеспечивает безопасной работы с памятью. Этот язык называется <em>unsafe Rust</em> и работает также как и первый, но предоставляет вам дополнительные возможности.</p>
<p>Небезопасный Ржавчина существует потому что по своей природе постоянной анализ довольно устоявшийся. Когда сборщик пытается определить, соответствует ли код заверениям, то он скорее отвергнет несколько допустимых программ, чем пропустит несколько недопустимых. Не смотря на то, что код <em>может</em> быть в порядке, если сборщик Ржавчина не будет располагать достаточной сведениями, чтобы убедиться в этом, он отвергнет код. В таких случаях вы можете использовать небезопасный код, чтобы сказать сборщику: "Поверь мне, я знаю, что делаю". Однако имейте в виду, что вы используете небезопасный Ржавчина на свой страх и риск: если вы неправильно используете небезопасный код, могут возникнуть сбоев, связанные с нарушением безопасности памяти, например, разыменование нулевого указателя.</p>
<p>Другая причина, по которой у Ржавчина есть небезопасное альтер эго, заключается в том, что по существу аппаратное обеспечение компьютера небезопасно. Если Ржавчина не позволял бы вам выполнять небезопасные действия, вы не могли бы выполнять определённые задачи. Ржавчина должен позволить вам использовать системное, низкоуровневое программирование, такое как прямое взаимодействие с операционной системой, или даже написание вашей собственной операционной системы. Возможность написания низкоуровневого, системного кода является одной из целей языка. Давайте рассмотрим, что и как можно делать с небезопасным Rust.</p>
<h3 id="Небезопасные-сверхспособности"><a class="header" href="#Небезопасные-сверхспособности">Небезопасные сверхспособности</a></h3>
<p>Чтобы переключиться на небезопасный Rust, используйте ключевое слово <code>unsafe</code>, а затем начните новый блок, содержащий небезопасный код. В небезопасном Ржавчина можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем <em>небезопасными супер силами</em>. Эти супер силы включают в себя следующее:</p>
<ul>
<li>Разыменование сырого указателя</li>
<li>Вызов небезопасной функции или небезопасного способа</li>
<li>Доступ или изменение изменяемой постоянной переменной</li>
<li>Выполнение небезопасного особенности</li>
<li>Доступ к полям в <code>union</code></li>
</ul>
<p>Важно понимать, что <code>unsafe</code> не отключает проверку заимствования или любые другие проверки безопасности Rust: если вы используете ссылку в небезопасном коде, она всё равно будет проверена. Единственное, что делает ключевое слово <code>unsafe</code> - даёт вам доступ к этим пяти возможностям, безопасность работы с памятью в которых не проверяет сборщик. Вы по-прежнему получаете некоторую степень безопасности внутри небезопасного раздела.</p>
<p>Кроме того, <code>unsafe</code> не означает, что код внутри этого раздела является неизбежно опасным или он точно будет иметь сбоев с безопасностью памяти: цель состоит в том, что вы, как программист, заверяете, что код внутри раздела <code>unsafe</code> будет обращаться к действительной памяти правильным образом.</p>
<p>Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных действия внутри разделов, помеченных как <code>unsafe</code>, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри <code>unsafe</code> разделов. Делайте <code>unsafe</code> разделы маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.</p>
<p>Чтобы наиболее изолировать небезопасный код, советуется заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже, когда будем обсуждать небезопасные функции и способы. Части встроенной библиотеки выполнены как проверенные, безопасные абстракции над небезопасным кодом. Оборачивание небезопасного кода в безопасную абстракцию предотвращает возможную утечку использования <code>unsafe</code> кода во всех местах, где вы или ваши пользователи могли бы захотеть напрямую использовать возможность, выполненную <code>unsafe</code> кодом, потому что использование безопасной абстракции само безопасно.</p>
<p>Давайте поговорим о каждой из четырёх небезопасных сверх способностей, и по ходу дела рассмотрим некоторые абстракции, которые обеспечивают безопасный внешняя оболочка для небезопасного кода.</p>
<h3 id="Разыменование-сырых-указателей"><a class="header" href="#Разыменование-сырых-указателей">Разыменование сырых указателей</a></h3>
<p>В главе 4 раздела <a href="ch04-02-references-and-borrowing.html#dangling-references">"Недействительные ссылки"</a><!--  --> мы упоминали, что сборщик заверяет, что ссылки всегда действительны. Небезопасный Ржавчина имеет два новых вида, называемых <em>сырыми указателями</em> (raw pointers), которые похожи на ссылки. Как и в случае ссылок, сырые указатели могут быть неизменяемыми или изменяемыми и записываться как <code>*const T</code> и <code>*mut T</code> соответственно. Звёздочка не является оператором разыменования; это часть имени вида. В среде сырых указателей <em>неизменяемый</em> (immutable) означает, что указателю нельзя напрямую присвоить что-то после того как он разыменован.</p>
<p>В отличие от ссылок и умных указателей, сырые указатели:</p>
<ul>
<li>могут пренебрегать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти</li>
<li>не заверяют что ссылаются на действительную память</li>
<li>могут быть null</li>
<li>не выполняют самостоятельную очистку памяти</li>
</ul>
<p>Отказавшись от этих заверений, вы можете обменять безопасность  на большую производительность или возможность взаимодействия с другим языком или оборудованием, где заверения Ржавчина не применяются.</p>
<p>В приложении 19-1 показано, как создать неизменяемый и изменяемый сырой указатель из ссылок.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-1: Создание необработанных указателей из ссылок</span></p>
<p>Обратите внимание, что мы не используем ключевое слово <code>unsafe</code> в этом коде. Можно создавать сырые указатели в безопасном коде; мы просто не можем разыменовывать сырые указатели за пределами небезопасного раздела, как вы увидите чуть позже.</p>
<p>Мы создали сырые указатели, используя <code>as</code> для приведения неизменяемой и изменяемой ссылки к соответствующим им видам сырых указателей. Поскольку мы создали их непосредственно из ссылок, которые обязательно являются действительными, мы знаем, что эти определенные сырые указатели являются действительными, но мы не можем делать такое же предположение о любом сыром указателе.</p>
<p>Чтобы отобразить это, создадим сырой указатель, в достоверности которого мы не можем быть так уверены. В приложении 19-2 показано, как создать необработанный указатель на произвольное место в памяти. Попытка использовать произвольную память является непредсказуемой: по этому адресу могут быть данные, а могут и не быть, сборщик может перерабатывать код так, что доступа к памяти не будет, или программа может завершиться с ошибкой сегментации. Обычно нет веских причин писать такой код, но это возможно.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-2: Создание сырого указателя на произвольный адрес памяти</span></p>
<p>Напомним, что можно создавать сырые указатели в безопасном коде, но нельзя <em>разыменовывать</em> сырые указатели и читать данные, на которые они указывают. В приложении 19-3 мы используем оператор разыменования <code>*</code> для сырого указателя, который требует <code>unsafe</code> раздела.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-3: Разыменование сырых указателей в разделе <code>unsafe</code></span></p>
<p>Создание указателей безопасно. Только при попытке доступа к предмету по адресу в указателе мы можем получить недопустимое значение.</p>
<p>Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали <code>*const i32</code> и <code>*mut i32</code>, которые ссылаются на одну и ту же область памяти, где хранится <code>num</code>. Если мы попытаемся создать неизменяемую и изменяемую ссылку на <code>num</code> вместо сырых указателей, такой код не собирается, т.к. будут нарушены правила заимствования, запрещающие наличие изменяемой ссылки одновременно с неизменяемыми ссылками. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый указатель на одну и ту же область памяти и изменять данные с помощью изменяемого указателя, возможно создавая эффект гонки данных. Будьте осторожны!</p>
<p>С учётом всех этих опасностей, зачем тогда использовать сырые указатели? Одним из основных применений является взаимодействие с кодом C, как вы увидите в следующем разделе <a href="ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">"Вызов небезопасной функции или способа"</a><!--  -->. Другой случай это создание безопасных абстракций, которые не понимает анализатор заимствований. Мы введём понятие небезопасных функций и затем рассмотрим пример безопасной абстракции, которая использует небезопасный код.</p>
<h3 id="Вызов-небезопасной-функции-или-способа"><a class="header" href="#Вызов-небезопасной-функции-или-способа">Вызов небезопасной функции или способа</a></h3>
<p>Второй вид действий, которые можно выполнять в небезопасном разделе - это вызов небезопасных функций. Небезопасные функции и способы выглядят точно так же, как обычные функции и способы, но перед остальным определением у них есть дополнительное <code>unsafe</code>. Ключевое слово <code>unsafe</code> в данном среде указывает на то, что к функции предъявляются требования, которые мы должны соблюдать при вызове этой функции, поскольку Ржавчина не может обеспечить, что мы их выполняем. Вызывая небезопасную функцию внутри раздела <code>unsafe</code>, мы говорим, что прочитали документацию к этой функции и берём на себя ответственность за соблюдение её условий.</p>
<p>Вот небезопасная функция с именем <code>dangerous</code> которая ничего не делает в своём теле:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>Мы должны вызвать функцию <code>dangerous</code> в отдельном <code>unsafe</code> разделе. Если мы попробуем вызвать <code>dangerous</code> без <code>unsafe</code> раздела, мы получим ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>С помощью раздела <code>unsafe</code> мы сообщаем Rust, что прочитали документацию к функции, поняли, как правильно её использовать, и убедились, что выполняем договор функции.</p>
<p>Тела небезопасных функций являются в действительности <code>unsafe</code> разделами, поэтому для выполнения других небезопасных действий внутри небезопасной функции не нужно добавлять ещё один <code>unsafe</code> блок.</p>
<h4 id="Создание-безопасных-абстракций-вокруг-небезопасного-кода"><a class="header" href="#Создание-безопасных-абстракций-вокруг-небезопасного-кода">Создание безопасных абстракций вокруг небезопасного кода</a></h4>
<p>То, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. На самом деле, обёртывание небезопасного кода в безопасную функцию - это обычная абстракция. В качестве примера рассмотрим функцию <code>split_at_mut</code> из встроенной библиотеки, которая требует некоторого небезопасного кода. Рассмотрим, как мы могли бы её выполнить. Этот безопасный способ определён для изменяемых срезов: он берет один срез и превращает его в два, разделяя срез по порядковому указателю, указанному в качестве переменной. В приложении 19-4 показано, как использовать <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-4: Использование безопасной функции <code>split_at_mut</code></span></p>
<p>Эту функцию нельзя выполнить, используя только безопасный Rust. Попытка выполнения могла бы выглядеть примерно как в приложении 19-5, который не собирается. Для простоты мы выполняем <code>split_at_mut</code> как функцию, а не как способ, и только для значений вида <code>i32</code>, а не обобщённого вида <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 19-5: Попытка выполнения <code>split_at_mut</code> с использованием только безопасного Rust</span></p>
<p>Эта функция сначала получает общую длину среза. Затем она проверяет (assert), что порядковый указатель, переданный в качестве свойства, находится в границах среза, сравнивая его с длиной. Assert означает, что если мы передадим порядковый указатель, который больше, чем длина среза, функция запаникует ещё до попытки использования этого порядкового указателя.</p>
<p>Затем мы возвращаем два изменяемых отрывка в упорядоченном ряде: один от начала исходного отрывка до <code>mid</code> порядкового указателя (не включая сам mid), а другой - от <code>mid</code> (включая сам mid) до конца отрывка.</p>
<p>При попытке собрать код в приложении 19-5, мы получим ошибку.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Анализатор заимствований Ржавчина не может понять, что мы заимствуем различные части среза, он понимает лишь, что мы хотим осуществить заимствование частей одного среза дважды. Заимствование различных частей среза в принципе в порядке вещей, потому что они не перекрываются, но Ржавчина недостаточно умён, чтобы это понять. Когда мы знаем, что код верный, но Ржавчина этого не понимает, значит пришло время прибегнуть к небезопасному коду.</p>
<p>Приложение 19-6 отображает, как можно использовать <code>unsafe</code> блок, сырой указатель и вызовы небезопасных функций чтобы <code>split_at_mut</code> заработала:</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-6. Использование небезопасного кода в выполнения функции <code>split_at_mut</code></span></p>
<p>Напомним, из раздела <a href="ch04-03-slices.html#the-slice-type">"Вид срез"</a><!-- ignore --> главы 4, что срезы состоят из указателя на некоторые данные и длины. Мы используем способ <code>len</code> для получения длины среза и способ <code>as_mut_ptr</code> для доступа к сырому указателю среза. Поскольку у нас есть изменяемый срез на значения вида <code>i32</code>, функция <code>as_mut_ptr</code> возвращает сырой указатель вида <code>*mut i32</code>, который мы сохранили в переменной <code>ptr</code>.</p>
<p>Далее проверяем, что порядковый указатель<code>mid</code> находится в границах среза. Затем мы обращаемся к небезопасному коду: функция <code>slice::from_raw_parts_mut</code> принимает сырой указатель, длину и создаёт срез. Мы используем эту функцию для создания среза, начинающегося с <code>ptr</code> и имеющего длину в <code>mid</code> элементов. Затем мы вызываем способ <code>add</code> у <code>ptr</code> с <code>mid</code> в качестве переменной, чтобы получить сырой указатель, который начинается с <code>mid</code>, и создаём срез, используя этот указатель и оставшееся количество элементов после <code>mid</code> в качестве длины.</p>
<p>Функция <code>slice::from_raw_parts_mut</code> является небезопасной, потому что она принимает необработанный указатель и должна полагаться на то, что этот указатель действителен. Способ <code>add</code> для необработанных указателей также небезопасен, поскольку он должен считать, что местоположение смещения также является действительным указателем. Поэтому мы были вынуждены разместить <code>unsafe</code> разделвокруг наших вызовов <code>slice::from_raw_parts_mut</code> и <code>add</code>, чтобы иметь возможность вызвать их. Посмотрев на код и добавив утверждение, что <code>mid</code> должен быть меньше или равен <code>len</code>, мы можем сказать, что все необработанные указатели, используемые в разделе <code>unsafe</code>, будут правильными указателями на данные внутри среза. Это приемлемое и уместное использование <code>unsafe</code>.</p>
<p>Обратите внимание, что нам не нужно помечать результирующую функцию <code>split_at_mut</code> как <code>unsafe</code>, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с помощью выполнения функции, которая использует код <code>unsafe</code> раздела безопасным образом, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.</p>
<p>Напротив, использование <code>slice::from_raw_parts_mut</code> в приложении 19-7 приведёт к вероятному сбою при использовании среза. Этот код использует произвольный адрес памяти и создаёт срез из 10000 элементов.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-7: Создание среза из произвольного адреса памяти</span></p>
<p>Мы не владеем памятью в этом произвольном месте, и нет никакой заверения, что созданный этим кодом отрывок содержит допустимые значения <code>i32</code>. Попытка использовать <code>values</code> так, как будто это допустимый срез, приводит к неопределённому поведению.</p>
<h4 id="Использование-extern-функций-для-вызова-внешнего-кода"><a class="header" href="#Использование-extern-функций-для-вызова-внешнего-кода">Использование <code>extern</code> функций для вызова внешнего кода</a></h4>
<p>Иногда вашему коду на языке Ржавчина может потребоваться взаимодействие с кодом, написанным на другом языке. Для этого в Ржавчина есть ключевое слово <code>extern</code>, которое облегчает создание и использование <em>внешней оболочки внешних функций (Foreign Function Interface - FFI)</em>. FFI - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.</p>
<p>Приложение 19-8 отображает, как настроить встраивание с функцией <code>abs</code> из встроенной библиотеки C. Функции, объявленные внутри разделов <code>extern</code>, всегда небезопасны для вызова из кода Rust. Причина в том, что другие языки не обеспечивают соблюдение правил и заверений Rust, Ржавчина также не может проверить заверения, поэтому ответственность за безопасность ложится на программиста.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Приложение 19-8: Объявление и вызов <code>extern</code> функции, написанной на другом языке программирования</span></p>
<p>Внутри раздела <code>extern "C"</code> мы перечисляем имена и ярлыки внешних функций из другого языка, которые мы хотим вызвать. Часть <code>"C"</code> определяет какой <em>application binary interface</em> (ABI - двоичный внешняя оболочка приложений) использует внешняя функция. Внешнюю оболочку ABI определяет как вызвать функцию на уровне ассемблера. Использование ABI <code>"C"</code> является наиболее часто используемым и следует правилам ABI внешней оболочки языка Си.</p>
<blockquote>
<h4 id="Вызов-функций-Ржавчина-из-других-языков"><a class="header" href="#Вызов-функций-Ржавчина-из-других-языков">Вызов функций Ржавчина из других языков</a></h4>
<p>Также можно использовать <code>extern</code> для создания внешней оболочки, позволяющего другим языкам вызывать функции Rust. Вместо того чтобы создавать целый раздел<code>extern</code>, мы добавляем ключевое слово <code>extern</code> и указываем ABI для использования непосредственно перед ключевым словом <code>fn</code> для необходимой функции. Нам также нужно добавить изложение <code>#[no_mangle]</code>, чтобы сказать сборщику Ржавчина не искажать имя этой функции. <em>Искажение</em> - это когда сборщик меняет имя, которое мы дали функции, на другое имя, которое содержит больше сведений для других частей этапа сборки, но менее читабельно для человека. Сборщик каждого языка программирования искажает имена по-разному, поэтому, чтобы функция Ржавчина могла быть использована другими языками, мы должны отключить искажение имён в сборщике Rust.</p>
<p>В следующем примере мы делаем функцию <code>call_from_c</code> доступной из кода на C, после того как она будет собрана в разделяемую библиотеку и прилинкована с C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Ржавчина function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p>Такое использование <code>extern</code> не требует <code>unsafe</code>.</p>
</blockquote>
<h3 id="Получение-доступа-и-внесение-изменений-в-изменяемую-постоянную-переменную"><a class="header" href="#Получение-доступа-и-внесение-изменений-в-изменяемую-постоянную-переменную">Получение доступа и внесение изменений в изменяемую постоянную переменную</a></h3>
<p>В этой книге мы ещё не говорили о <em>вездесущих переменных</em>, которые Ржавчина поддерживает, но с которыми могут возникнуть сбоев из-за действующих в Ржавчина правил владения. Если два потока обращаются к одной и той же изменяемой вездесущей переменной, это может привести к гонке данных.</p>
<p>Вездесущие переменные в Ржавчина называют <em>постоянными</em> (static). Приложение 19-9 отображает пример объявления и использования в качестве значения постоянной переменной, имеющей вид строкового среза:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {HELLO_WORLD}");
}</code></pre></pre>
<p><span class="caption">Приложение 19-9: Определение и использование неизменяемой постоянной переменной</span></p>
<p>Постоянные переменные похожи на постоянные значения, которые мы обсуждали в разделе <a href="ch03-01-variables-and-mutability.html#constants">“Различия между переменными и постоянными значениями”</a><!-- ignore --> главы 3. Имена постоянных переменных по общему соглашению пишутся в наставлении <code>SCREAMING_SNAKE_CASE</code>, и мы <em>должны</em> указывать вид переменной, которым в данном случае является <code>&amp;'static str</code>. Постоянные переменные могут хранить только ссылки со временем жизни <code>'static</code>, это означает что сборщик Ржавчина может вывести время жизни и нам не нужно прописывать его явно. Доступ к неизменяемой постоянной переменной является безопасным.</p>
<p>Тонкое различие между постоянными значениями и неизменяемыми постоянными переменными заключается в том, что значения в постоянной переменной имеют определенный адрес в памяти. При использовании значения всегда будут доступны одни и те же данные. Постоянного значения, с другой стороны, могут повторять свои данные при каждом использовании. Ещё одно отличие заключается в том, что постоянные переменные могут быть изменяемыми. Обращение к изменяемым постоянном переменным и их изменение является <em>небезопасным</em>. В приложении 19-10 показано, как объявить, получить доступ и изменять изменяемую постоянную переменную с именем <code>COUNTER</code>.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {COUNTER}");
    }
}</code></pre></pre>
<p><span class="caption">Приложение 19-10: Чтение из изменяемой постоянной переменной или запись в неё небезопасны</span></p>
<p>Как и с обычными переменными, мы определяем изменяемость с помощью ключевого слова <code>mut</code>. Любой код, который читает из или пишет в переменную <code>COUNTER</code> должен находиться в <code>unsafe</code> разделе. Этот код собирается и печатает <code>COUNTER: 3</code>, как и следовало ожидать, потому что выполняется в одном потоке. Наличие нескольких потоков с доступом к <code>COUNTER</code> приведёт к случаи гонки данных.</p>
<p>Наличие изменяемых данных, которые доступны вездесуще, делает трудным выполнение заверения отсутствия гонок данных, поэтому Ржавчина считает изменяемые постоянные переменные небезопасными. Там, где это возможно, предпочтительно использовать техники многопоточности и умные указатели, направленные на многопоточное исполнение, которые мы обсуждали в главе 16. Таким образом, сборщик сможет проверить, что обращение к данным, доступным из разных потоков, выполняется безопасно.</p>
<h3 id="Выполнение-небезопасных-особенностей"><a class="header" href="#Выполнение-небезопасных-особенностей">Выполнение небезопасных особенностей</a></h3>
<p>Мы можем использовать <code>unsafe</code> для выполнения небезопасного особенности. Особенность является небезопасным, если хотя бы один из его способов имеет некоторый неизменная величина, который сборщик не может проверить. Мы объявляем особенности <code>unsafe</code>, добавляя ключевое слово <code>unsafe</code> перед <code>trait</code> и помечая выполнение особенности как <code>unsafe</code>, как показано в приложении 19-11.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
<p><span class="caption">Приложение 19-11: Определение и выполнение небезопасного особенности</span></p>
<p>Используя <code>unsafe impl</code>, мы даём обещание поддерживать неизменные величины, которые сборщик не может проверить.</p>
<p>Для примера вспомним маркерные особенности <code>Sync</code> и <code>Send</code>, которые мы обсуждали в разделе <a data-md-type="raw_html" href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">"Расширяемый одновременность с помощью особенностей <code>Sync</code> и <code>Send</code>"</a><!-- ignore --> главы 16: сборщик выполняет эти особенности самостоятельно , если наши виды полностью состоят из видов <code>Send</code> и <code>Sync</code>. Если мы создадим вид, который содержит вид, не являющийся <code>Send</code> или <code>Sync</code>, такой, как сырой указатель, и мы хотим пометить этот вид как <code>Send</code> или <code>Sync</code>, мы должны использовать <code>unsafe</code> блок. Ржавчина не может проверить, что наш вид поддерживает заверения того, что он может быть безопасно передан между потоками или доступен из нескольких потоков; поэтому нам нужно добавить эти проверки вручную и указать это с помощью <code>unsafe</code>.</p>
<h3 id="Доступ-к-полям-объединений-union"><a class="header" href="#Доступ-к-полям-объединений-union">Доступ к полям объединений (union)</a></h3>
<p>Последнее действие, которое работает только с <code>unsafe</code> - это доступ к полям <em>union</em>. <code>union</code> похож на <code>struct</code>, но в каждом определенном образце одновременно может использоваться только одно объявленное поле. Объединения в основном используются для взаимодействия с объединениями в коде на языке Си. Доступ к полям объединений небезопасен, поскольку Ржавчина не может обязательно определить вид данных, которые в данный мгновение хранятся в образце объединения. Подробнее об объединениях вы можете узнать в <a href="../reference/items/unions.html">the Ржавчина Reference</a>.</p>
<h3 id="Когда-использовать-небезопасный-код"><a class="header" href="#Когда-использовать-небезопасный-код">Когда использовать небезопасный код</a></h3>
<p>Использование <code>unsafe</code> для выполнения одного из пяти действий (супер способностей), которые только что обсуждались, не является ошибочным или не одобренным. Но получить правильный <code>unsafe</code> код сложнее, потому что сборщик не может помочь в обеспечении безопасности памяти. Если у вас есть причина использовать <code>unsafe</code> код, вы можете делать это, а наличие явной <code>unsafe</code> изложении облегчает отслеживание источника неполадок. если они возникают.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутые-особенности"><a class="header" href="#Продвинутые-особенности">Продвинутые особенности</a></h2>
<p>Мы познакомились с особенностями в разделе <a href="ch10-02-traits.html#traits-defining-shared-behavior">"Особенности: Определение общего поведения"</a><!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Rust, мы можем перейти к более подробному рассмотрению.</p>
<h3 id="Указание-видов-заполнителей-в-определениях-особенностей-с-сопряженными-видами"><a class="header" href="#Указание-видов-заполнителей-в-определениях-особенностей-с-сопряженными-видами">Указание видов-заполнителей в определениях особенностей с сопряженными видами</a></h3>
<p><em>Сопряженные виды</em> связывают вид-заполнитель с особенностью таким образом, что определения способов особенности могут использовать эти виды-заполнители в своих ярлыках. Для именно выполнения особенности вместо типа-заполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить особенности, использующие некоторые виды, без необходимости точно знать, что это за виды, пока особенности не будут выполнены.</p>
<p>Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Сопряженные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.</p>
<p>Одним из примеров особенности с сопряженным видом является особенность <code>Iterator</code> из встроенной библиотеки. Сопряженный вид называется <code>Item</code> и символизирует вид значений, по которым повторяется вид, выполняющий особенность <code>Iterator</code>. Определение особенности <code>Iterator</code> показано в приложении 19-12.</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<p><span class="caption">Приложение 19-12: Определение особенности <code>Iterator</code>, который имеет сопряженный вид <code>Item</code></span></p>
<p>Вид <code>Item</code> является заполнителем и определение способа <code>next</code> показывает, что он будет возвращать значения вида <code>Option&lt;Self::Item&gt;</code>. Разработчики особенности <code>Iterator</code> определят определенный вид для <code>Item</code>, а способ <code>next</code> вернёт <code>Option</code> содержащий значение этого определенного вида.</p>
<p>Сопряженные виды могут показаться подходом похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя подходами, мы рассмотрим выполнение особенности <code>Iterator</code> для вида с именем <code>Counter</code>, который указывает, что вид <code>Item</code> равен <code>u32</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Этот правила написания весьма напоминает обобщённые виды. Так почему же особенность <code>Iterator</code> не определён обобщённым видом, как показано в приложении 19-13?</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<p><span class="caption">Приложение 19-13: Гипотетическое определение особенности <code>Iterator</code> используя обобщённые виды</span></p>
<p>Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны определять виды в каждой выполнения; потому что мы также можем выполнить <code>Iterator&lt;String&gt; for Counter</code> или любого другого вида, мы могли бы иметь несколько выполнения <code>Iterator</code> для <code>Counter</code>. Другими словами, когда особенность имеет обобщённый свойство, он может быть выполнен для вида несколько раз, каждый раз меняя определенные виды свойств обобщённого вида. Когда мы используем способ <code>next</code> у <code>Counter</code>, нам пришлось бы предоставить изложении вида, указывая какую выполнение <code>Iterator</code> мы хотим использовать.</p>
<p>С сопряженными видами не нужно определять виды, потому что мы не можем выполнить особенность у вида несколько раз. В приложении 19-12 с определением, использующим сопряженные виды можно выбрать только один вид <code>Item</code>, потому что может быть только одно объявление <code>impl Iterator for Counter</code>. Нам не нужно указывать, что нужен повторитель значений вида <code>u32</code> везде, где мы вызываем <code>next</code> у <code>Counter</code>.</p>
<p>Сопряженные виды также становятся частью договора особенности: разработчики особенности должны предоставить вид, который заменит сопряженный заполнитель вида. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошей опытом является документирование связанного вида в документации по API.</p>
<h3 id="Свойства-обобщённого-вида-по-умолчанию-и-перегрузка-операторов"><a class="header" href="#Свойства-обобщённого-вида-по-умолчанию-и-перегрузка-операторов">Свойства обобщённого вида по умолчанию и перегрузка операторов</a></h3>
<p>Когда мы используем свойства обобщённого вида, мы можем указать определенный вид по умолчанию для обобщённого вида. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида с помощью правил написания  <code>&lt;PlaceholderType=ConcreteType&gt;</code>.</p>
<p>Отличным примером, когда этот способ полезен, является <em>перегрузка оператора</em> (operator overloading), когда вы настраиваете поведение оператора (например, <code>+</code> ) для определённых случаев.</p>
<p>Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Но можно перегрузить перечисленные действия и соответствующие им особенности из <code>std::ops</code> путём выполнения особенностей, связанных с этими операторами. Например, в приложении 19-14 мы перегружаем оператор <code>+</code>, чтобы складывать два образца <code>Point</code>. Мы делаем это выполняя особенность <code>Add</code> для устройства <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<p><span class="caption">Приложение 19-14: Выполнение особенности <code>Add</code> для перегрузки оператора <code>+</code> для образцов <code>Point</code></span></p>
<p>Способ <code>add</code> складывает значения <code>x</code> двух образцов <code>Point</code> и значения <code>y</code> у <code>Point</code> для создания нового образца <code>Point</code>. Особенность <code>Add</code> имеет сопряженный вид с именем <code>Output</code>, который определяет вид, возвращаемый из способа <code>add</code>.</p>
<p>Обобщённый вид по умолчанию в этом коде находится в особенности <code>Add</code> . Вот его определение:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код должен выглядеть знакомым: особенность с одним способом и сопряженным видом. Новый правила написания это <code>RHS=Self</code>. Такой правила написания называется <em>свойства вида по умолчанию</em> (default type parameters). Свойство обобщённого вида <code>RHS</code> (сокращённо “right hand side”) определяет вид свойства <code>rhs</code> в способе <code>add</code>. Если мы не укажем определенный вид для <code>RHS</code> при выполнения особенности <code>Add</code>, то видом для <code>RHS</code> по умолчанию будет <code>Self</code>, который будет видом для которого выполняется особенность <code>Add</code>.</p>
<p>Когда мы выполнили <code>Add</code> для устройства <code>Point</code>, мы использовали обычное значение для <code>RHS</code>, потому что хотели сложить два образца <code>Point</code>. Давайте посмотрим на пример выполнения особенности <code>Add</code>, где мы хотим пользовательский вид <code>RHS</code> вместо использования вида по умолчанию.</p>
<p>У нас есть две разные устройства <code>Millimeters</code> и <code>Meters</code>, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида в другую устройство известно как образец <em>newtype</em>, который мы более подробно опишем в разделе <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">"Образец Newtype для выполнение внешних особенностей у внешних видов"</a><!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь выполнение особенности <code>Add</code>, которая делает правильное преобразование единиц. Можно выполнить <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве <code>Rhs</code>, как показано в приложении 19-15.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<p><span class="caption">Приложение 19-15: Выполнение особенности <code>Add</code> для устройства  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span></p>
<p>Чтобы сложить <code>Millimeters</code> и <code>Meters</code>, мы указываем <code>impl Add&lt;Meters&gt;</code>, чтобы указать значение свойства вида <code>RHS</code> (Meters) вместо использования значения по умолчанию <code>Self</code> (Millimeters).</p>
<p>Свойства вида по умолчанию используются в двух основных случаях:</p>
<ul>
<li>Чтобы расширить вид без внесения изменений ломающих существующий код</li>
<li>Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей</li>
</ul>
<p>Особенность <code>Add</code> из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида, но особенность <code>Add</code> позволяет сделать больше. Использование свойства вида по умолчанию в объявлении особенности <code>Add</code> означает, что не нужно указывать дополнительный свойство большую часть времени. Другими словами, большая часть кода выполнения не нужна, что делает использование особенности проще.</p>
<p>Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида к существующему особенности, можно дать ему значение по умолчанию, чтобы разрешить расширение возможности особенности без нарушения кода существующей выполнения.</p>
<h3 id="Полностью-квалифицированный-правила-написания-для-устранения-неоднозначности-вызов-способов-с-одинаковым-именем"><a class="header" href="#Полностью-квалифицированный-правила-написания-для-устранения-неоднозначности-вызов-способов-с-одинаковым-именем">Полностью квалифицированный правила написания для устранения неоднозначности: вызов способов с одинаковым именем</a></h3>
<p>В Ржавчина ничего не мешает особенности иметь способ с одинаковым именем, таким же как способ другого особенности и Ржавчина не мешает выполнить оба таких особенности у одного вида. Также возможно выполнить способ с таким же именем непосредственно у вида, такой как и способы у особенностей.</p>
<p>При вызове способов с одинаковыми именами в Ржавчина нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим код в приложении 19-16, где мы определили два особенности: <code>Pilot</code> и <code>Wizard</code>, у обоих есть способ <code>fly</code>. Затем мы выполняем оба особенности у вида <code>Human</code> в котором уже выполнен способ с именем <code>fly</code>. Каждый способ <code>fly</code> делает что-то своё.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 19-16: Два особенности определены с способом <code>fly</code> и выполнены у вида <code>Human</code>, а также способ <code>fly</code> выполнен непосредственно у <code>Human</code></span></p>
<p>Когда мы вызываем <code>fly</code> у образца <code>Human</code>, то сборщик по умолчанию вызывает способ, который непосредственно выполнен для вида, как показано в приложении 19-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<p><span class="caption">Приложение 19-17: Вызов <code>fly</code> у образца <code>Human</code></span></p>
<p>Запуск этого кода напечатает <code>*waving arms furiously*</code> , показывая, что Ржавчина называется способ <code>fly</code> выполненный непосредственно у <code>Human</code>.</p>
<p>Чтобы вызвать способы <code>fly</code> у особенности <code>Pilot</code> или особенности <code>Wizard</code> нужно использовать более явный правила написания, указывая какой способ <code>fly</code> мы имеем в виду. Приложение 19-18 отображает такой правила написания.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<p><span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span></p>
<p>Указание имени особенности перед именем способа проясняет сборщику Rust, какую именно выполнение <code>fly</code> мы хотим вызвать. Мы могли бы также написать <code>Human::fly(&amp;person)</code>, что эквивалентно используемому нами <code>person.fly()</code> в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.</p>
<p>Выполнение этого кода выводит следующее:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Поскольку способ <code>fly</code> принимает свойство <code>self</code>, если у нас было два <em>вида</em> оба выполняющих один <em>особенность</em>, то Ржавчина может понять, какую выполнение особенности использовать в зависимости от вида <code>self</code>.</p>
<p>Однако, сопряженные функции, не являющиеся способами, не имеют свойства <code>self</code>. Когда существует несколько видов или особенностей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Ржавчина не всегда знает, какой вид вы имеете в виду, если только вы не используете <em>полный правила написания</em>. Например, в приложении 19-19 мы создаём особенность для приюта животных, который хочет назвать всех маленьких собак <em>Spot</em>. Мы создаём особенность <code>Animal</code> со связанной с ним функцией <code>baby_name</code>, не являющейся способом. Особенность <code>Animal</code> выполнен для устройства <code>Dog</code>, для которой мы также напрямую предоставляем связанную функцию <code>baby_name</code>, не являющуюся способом.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre></pre>
<p><span class="caption">Приложение 19-19: Особенность с сопряженной функцией и вид с сопряженной функцией с тем же именем, которая тоже выполняет особенность</span></p>
<p>Мы выполнили код для приюта для животных, который хочет назвать всех щенков именем Spot, в сопряженной функции <code>baby_name</code>, которая определена для <code>Dog</code>. Вид <code>Dog</code> также выполняет особенность <code>Animal</code>, который описывает свойства, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в выполнения <code>Animal</code> у <code>Dog</code> в функции <code>baby_name</code> сопряженной с особенностью <code>Animal</code>.</p>
<p>В <code>main</code> мы вызываем функцию <code>Dog::baby_name</code>, которая вызывает сопряженную функцию определённую напрямую у <code>Dog</code>. Этот код печатает следующее:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию <code>baby_name</code>, которая является частью особенности <code>Animal</code> выполненного у <code>Dog</code>, так чтобы код печатал <code>A baby dog is called a puppy</code>. Техника указания имени особенности использованная в приложении 19-18 здесь не помогает; если мы изменим <code>main</code> код как в приложении 19-20, мы получим ошибку сборки.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
<p><span class="caption">Приложение 19-20. Попытка вызвать функцию <code>baby_name</code> из особенности <code>Animal</code>, но Ржавчина не знает какую выполнение использовать</span></p>
<p>Поскольку <code>Animal::baby_name</code> не имеет свойства <code>self</code>, и могут быть другие виды, выполняющие особенность <code>Animal</code>, Ржавчина не может понять, какую выполнение <code>Animal::baby_name</code> мы хотим использовать. Мы получим эту ошибку сборщика:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>Чтобы устранить неоднозначность и сказать Rust, что мы хотим использовать выполнение <code>Animal</code> для <code>Dog</code>, нужно использовать полный правила написания. Приложение 19-21 отображает, как использовать полный правила написания.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<p><span class="caption">Приложение 19-21: Использование полного правил написания для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у особенности <code>Animal</code> выполненную в <code>Dog</code></span></p>
<p>Мы указываем изложение вида в угловых скобках, которая указывает на то что мы хотим вызвать способ <code>baby_name</code> из особенности <code>Animal</code> выполненный в <code>Dog</code>, также указывая что мы хотим рассматривать вид <code>Dog</code> в качестве <code>Animal</code> для вызова этой функции. Этот код теперь напечатает то, что мы хотим:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>В общем, полный правила написания определяется следующим образом:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Для сопряженных функций, которые не являются способами, будет отсутствовать <code>receiver</code> (предмет приёмника): будет только список переменных. Вы можете использовать полный правила написания везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого правил написания, которую Ржавчина может понять из другой сведений в программе. Вам нужно использовать более подробный правила написания только в тех случаях, когда существует несколько выполнений, использующих одно и то же название, и Ржавчина нужно помочь определить, какую выполнение вы хотите вызвать.</p>
<h3 id="Использование-супер-особенностей-для-требования-возможности-одного-особенности-в-рамках-другого-особенности"><a class="header" href="#Использование-супер-особенностей-для-требования-возможности-одного-особенности-в-рамках-другого-особенности">Использование супер особенностей для требования возможности одного особенности в рамках другого особенности</a></h3>
<p>Иногда вы можете написать определение особенности, которое зависит от другого особенности: для вида, выполняющего первый особенность, вы хотите потребовать, чтобы этот вид также выполнил второй особенность. Вы должны сделать это, чтобы ваше определение особенности могло использовать связанные элементы второго особенности. Особенность, на который опирается ваше определение особенности, называется <em>supertrait</em> вашего особенности.</p>
<p>Например, мы хотим создать особенность <code>OutlinePrint</code> с способом <code>outline_print</code>, который будет печатать значение обрамлённое звёздочками. Мы хотим чтобы устройства <code>Point</code>, выполняющая особенность встроенной библиотеки <code>Display</code>, вывела на печать <code>(x, y)</code> при вызове <code>outline_print</code> у образца <code>Point</code>, который имеет значение <code>1</code> для <code>x</code> и значение <code>3</code> для <code>y</code>. Она должна напечатать следующее:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>В выполнения <code>outline_print</code> мы хотим использовать возможность особенности <code>Display</code>. Поэтому нам нужно указать, что особенность <code>OutlinePrint</code> будет работать только для видов, которые также выполняют <code>Display</code> и предоставляют возможность, которая нужна в <code>OutlinePrint</code>. Мы можем сделать это в объявлении особенности, указав <code>OutlinePrint: Display</code>. Этот способ похож на добавление ограничения в особенность. В приложении 19-22 показана выполнение особенности <code>OutlinePrint</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Приложение 19-22: Выполнение особенности <code>OutlinePrint</code> которая требует возможности особенности <code>Display</code></span></p>
<p>Поскольку мы указали, что особенность <code>OutlinePrint</code> требует особенности <code>Display</code>, мы можем использовать функцию <code>to_string</code>, которая самостоятельно выполнена для любого вида выполняющего <code>Display</code>. Если бы мы попытались использовать <code>to_string</code> не добавляя двоеточие и не указывая особенность <code>Display</code> после имени особенности, мы получили бы сообщение о том, что способ с именем <code>to_string</code> не был найден у вида <code>&amp;Self</code> в текущей области видимости.</p>
<p>Давайте посмотрим что происходит, если мы пытаемся выполнить особенность <code>OutlinePrint</code> для вида, который не выполняет <code>Display</code>, например устройства <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
<p>Мы получаем сообщение о том, что требуется выполнение <code>Display</code>, но её нет:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>Чтобы исправить, мы выполняем <code>Display</code> у устройства <code>Point</code> и выполняем требуемое ограничение <code>OutlinePrint</code>, вот так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Тогда выполнение особенности <code>OutlinePrint</code> для устройства <code>Point</code> будет собрана успешно и мы можем вызвать <code>outline_print</code> у образца <code>Point</code> для отображения значения обрамлённое звёздочками.</p>
<h3 id="Образец-newtype-для-выполнение-внешних-особенностей-у-внешних-видов"><a class="header" href="#Образец-newtype-для-выполнение-внешних-особенностей-у-внешних-видов">Образец Newtype для выполнение внешних особенностей у внешних видов</a></h3>
<p>В разделе <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">"Выполнение особенности у типа"</a><!-- ignore --> главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается выполнить особенность у вида, если либо особенность, либо вид являются местными для нашего ящика. Можно обойти это ограничение, используя <em>образец нового вида</em> (newtype pattern), который включает в себя создание нового вида в упорядоченной в ряд устройстве. (Мы рассмотрели упорядоченные в ряд устройства  в разделе <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">"Использование устройств упорядоченных рядов без именованных полей для создания различных видов"</a><!--  --> главы 5.) Устройства упорядоченного ряда будет иметь одно поле и будет тонкой оболочкой для вида которому мы хотим выполнить особенность. Тогда вид оболочки является местным для нашего ящика и мы можем выполнить особенность для местной обёртки. <em>Newtype</em> это понятие, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого образца и вид оболочки исключается во время сборки.</p>
<p>В качестве примера, мы хотим выполнить особенность <code>Display</code> для вида <code>Vec&lt;T&gt;</code>, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что особенность <code>Display</code> и вид <code>Vec&lt;T&gt;</code> объявлены вне нашего ящика. Мы можем сделать устройство <code>Wrapper</code>, которая содержит образец <code>Vec&lt;T&gt;</code>; тогда мы можем выполнить <code>Display</code> у устройства <code>Wrapper</code> и использовать значение <code>Vec&lt;T&gt;</code> как показано в приложении 19-23.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
<p><span class="caption">Приложение 19-23. Создание вида <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для выполнения <code>Display</code></span></p>
<p>Выполнение <code>Display</code> использует <code>self.0</code> для доступа к внутреннему <code>Vec&lt;T&gt;</code>, потому что <code>Wrapper</code> это устройства упорядоченного ряда, а <code>Vec&lt;T&gt;</code> это элемент с порядковым указателем 0 в упорядоченном ряде. Затем мы можем использовать полезные  возможности вида <code>Display</code> у <code>Wrapper</code>.</p>
<p>Недостатком использования этой техники является то, что <code>Wrapper</code> является новым видом, поэтому он не имеет способов для значения, которое он держит в себе. Мы должны были бы выполнить все способы для <code>Vec&lt;T&gt;</code> непосредственно во <code>Wrapper</code>, так чтобы эти способы делегировались внутреннему <code>self.0</code>, что позволило бы нам обращаться с <code>Wrapper</code> точно так же, как с <code>Vec&lt;T&gt;</code>. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида, выполняя особенность <code>Deref</code> (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью <code>Deref</code> особенности"</a><!-- ignore --> главы 15) у <code>Wrapper</code> для возвращения внутреннего вида, то это было бы решением. Если мы не хотим, чтобы вид <code>Wrapper</code> имел все способы внутреннего вида, например, для ограничения поведения вида <code>Wrapper</code>, то пришлось бы вручную выполнить только те способы, которые нам нужны.</p>
<p>Этот образец newtype также полезен, даже когда особенности не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутые-виды"><a class="header" href="#Продвинутые-виды">Продвинутые виды</a></h2>
<p>Система видов Ржавчина имеет некоторые особенности, о которых мы уже упоминали, но ещё не обсуждали. Мы начнём с общего обзора newtypes, а затем разберёмся, чем они могут пригодиться в качестве видов. Далее мы перейдём к псевдонимам видов - возможности, похожей на newtypes, но с несколько иной смыслом. Мы также обсудим вид <code>!</code> и виды с изменяемым размером.</p>
<h3 id="Использование-образца-newtype-для-обеспечения-безопасности-видов-и-создания-абстракций"><a class="header" href="#Использование-образца-newtype-для-обеспечения-безопасности-видов-и-создания-абстракций">Использование образца Newtype для обеспечения безопасности видов и создания абстракций</a></h3>
<blockquote>
<p>Примечание: В этом разделе предполагается, что вы прочитали предыдущий раздел <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">"Использование образца Newtype для выполнения внешних особенностей для внешних видов."</a><!-- ignore --></p>
</blockquote>
<p>Образец newtype полезен и для других задач, помимо тех, которые мы обсуждали до сих пор, в частности, для постоянного обеспечения того, чтобы значения никогда не путались, а также для указания единиц измерения значения. Пример использования newtypes для указания единиц измерения вы видели в приложении 19-15: вспомните, как устройства <code>Millimeters</code> и <code>Meters</code> обернули значения <code>u32</code> в newtype. Если бы мы написали функцию с свойствоом вида <code>Millimeters</code>, мы не смогли бы собрать программу, которая случайно попыталась бы вызвать эту функцию со значением вида <code>Meters</code> или обычным <code>u32</code>.</p>
<p>Мы также можем использовать образец newtype для абстрагирования от некоторых подробностей выполнения вида: новый вид может предоставлять открытый API, который отличается от API скрытого внутри вида.</p>
<p>Newtypes также позволяют скрыть внутреннюю выполнение. Например, мы можем создать вид <code>People</code>, который обернёт <code>HashMap&lt;i32, String&gt;</code>, хранящий ID человека, связанный с его именем. Код, использующий <code>People</code>, будет взаимодействовать только с открытым API, который мы предоставляем, например, способ добавления имени в собрание <code>People</code>; этому коду не нужно будет знать, что внутри мы присваиваем <code>i32</code> ID именам. Образец newtype - это лёгкий способ достижения инкапсуляции для скрытия подробностей выполнения, который мы обсуждали в разделе <a href="ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">"Инкапсуляция, скрывающая подробности выполнения"</a><!-- ignore --> главы 17.</p>
<h3 id="Создание-родственных-вида-с-помощью-псевдонимов-вида"><a class="header" href="#Создание-родственных-вида-с-помощью-псевдонимов-вида">Создание родственных вида с помощью псевдонимов вида</a></h3>
<p>Rust предоставляет возможность объявить <em>псевдоним вида</em> чтобы дать существующему виду другое имя. Для этого мы используем ключевое слово <code>type</code>. Например, мы можем создать псевдоним вида <code>Kilometers</code> для <code>i32</code> следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Теперь псевдоним <code>Kilometers</code> является <em>родственным</em> для <code>i32</code>; в отличие от видов <code>Millimeters</code> и <code>Meters</code>, которые мы создали в приложении 19-15, <code>Kilometers</code> не является отдельным, новым видом. Значения, имеющие вид <code>Kilometers</code>, будут обрабатываться так же, как и значения вида <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>Поскольку <code>Kilometers</code> и <code>i32</code> являются одним и тем же видом, мы можем добавлять значения обоих видов и передавать значения <code>Kilometers</code> функциям, принимающим свойства <code>i32</code>. Однако, используя этот способ, мы не получаем тех преимуществ проверки видов, которые мы получаем от образца newtype, рассмотренного ранее. Другими словами, если мы где-то перепутаем значения <code>Kilometers</code> и <code>i32</code>, сборщик не выдаст нам ошибку.</p>
<p>Родственные в основном используются для сокращения повторений. Например, у нас может быть такой многословный тип:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Написание таких длинных видов в ярлыках функций и в виде наставлений видов по всему коду может быть утомительным и чреватым ошибками. Представьте себе дело, наполненный таким кодом, как в приложении 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-24: Использование длинного вида во многих местах</span></p>
<p>Псевдоним вида делает этот код более удобным для работы, сокращая количество повторений. В приложении 19-25 мы ввели псевдоним <code>Thunk</code> для вида verbose и можем заменить все использования этого вида более коротким псевдонимом <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-25: Представление псевдонима <code>Thunk</code> для уменьшения количества повторений</span></p>
<p>Такой код гораздо легче читать и писать! Выбор осмысленного имени для псевдонима вида также может помочь прояснить ваши намерения (<em>thunk</em> - название для кода, который будет вычисляться позднее, поэтому это подходящее имя для сохраняемого замыкания).</p>
<p>Псевдонимы видов также часто используются с видом <code>Result&lt;T, E&gt;</code> для сокращения повторений. Рассмотрим звено <code>std::io</code> в встроенной библиотеке. Действия ввода-вывода часто возвращают <code>Result&lt;T, E&gt;</code> для обработки случаев, когда эти действия не удаются. В данной библиотеке есть устройства <code>std::io::Error</code>, которая отражает все возможные ошибки ввода/вывода. Многие функции в <code>std::io</code> будут возвращать <code>Result&lt;T, E&gt;</code>, где <code>E</code> - это <code>std::io::Error</code>, например, эти функции в особенности <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code> часто повторяется. Поэтому <code>std::io</code> содержит такое объявление псевдонима вида:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Поскольку это объявление находится в звене <code>std::io</code>, мы можем использовать полный псевдоним <code>std::io::Result&lt;T&gt;</code>; это и есть <code>Result&lt;T, E&gt;</code>, где в качестве <code>E</code> выступает <code>std::io::Error</code>. Ярлыки функций особенности <code>Write</code> в итоге выглядят следующим образом:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>Псевдоним вида помогает двумя способами: он облегчает написание кода <em>и</em> даёт нам согласованный внешняя оболочка для всего из <code>std::io</code>. Поскольку это псевдоним, то это просто ещё один вид <code>Result&lt;T, E&gt;</code>, что означает, что с ним мы можем использовать любые способы, которые работают с <code>Result&lt;T, E&gt;</code>, а также особый правила написания вроде <code>?</code> оператора.</p>
<h3 id="Вид-never-который-никогда-не-возвращается"><a class="header" href="#Вид-never-который-никогда-не-возвращается">Вид Never, который никогда не возвращается</a></h3>
<p>В Ржавчина есть особый вид <code>!</code>, который на жаргоне теории видов известен как <em>empty type</em> (пустой вид), потому что он не содержит никаких значений. Мы предпочитаем называть его <em>never type</em> (никакой вид), потому что он используется в качестве возвращаемого вида, когда функция ничего не возвращает. Вот пример:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Этот код читается как "функция <code>bar</code> ничего не возвращает". Функции, которые ничего не возвращают, называются <em>рассеивающими функциями</em> (diverging functions). Мы не можем производить значения вида <code>!</code>, поэтому <code>bar</code> никогда ничего не вернёт.</p>
<p>Но для чего нужен вид, для которого вы никогда не сможете создать значения? Напомним код из приложения 2-5, отрывка "игры в загадки"; мы воспроизвели его часть здесь в приложении 19-26.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 19-26: Сопоставление <code>match</code> с веткой, которая заканчивается <code>continue</code></span></p>
<p>В то время мы опуисполнения некоторые подробности в этом коде. В главе 6 раздела <a href="ch06-02-match.html#the-match-control-flow-operator">"Оператор управления потоком <code>match</code>"</a><!--  --> мы обсуждали, что все ветви <code>match</code> должны возвращать одинаковый вид. Например, следующий код не работает:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>Вид <code>guess</code> в этом коде должен быть целым <em>и</em> строкой, а Ржавчина требует, чтобы <code>guess</code> имел только один вид. Так что же возвращает <code>continue</code>? Как нам позволили вернуть <code>u32</code> из одной ветви и при этом иметь другую ветвь, которая оканчивается <code>continue</code> в приложении 19-26?</p>
<p>Как вы уже возможно догадались, <code>continue</code> имеет  значение <code>!</code>. То есть, когда Ржавчина вычисляет вид <code>guess</code>, он смотрит на обе сопоставляемые ветки, первая со значением <code>u32</code> и последняя со значением <code>!</code>. Так как <code>!</code> никогда не может иметь значение, то Ржавчина решает что видом <code>guess</code> является вид <code>u32</code>.</p>
<p>Условный подход к описанию такого поведения заключается в том, что выражения вида <code>!</code> могут быть преобразованы в любой другой вид. Нам позволяется завершить этот <code>match</code> с помощью <code>continue</code>, потому что <code>continue</code> не возвращает никакого значения; вместо этого он передаёт управление обратно в начало цикла, поэтому в случае <code>Err</code> мы никогда не присваиваем значение <code>guess</code>.</p>
<p>Вид never полезен также для макроса <code>panic!</code>. Вспомните функцию <code>unwrap</code>, которую мы вызываем для значений <code>Option&lt;T&gt;</code>, чтобы создать значение или вызвать панику с этим определением:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>В этом коде происходит то же самое, что и в <code>match</code> в приложении 19-26: Ржавчина видит, что <code>val</code> имеет вид <code>T</code>, а <code>panic!</code> имеет вид <code>!</code>, поэтому итогом общего выражения <code>match</code> является <code>T</code>. Этот код работает, потому что <code>panic!</code> не производит никакого значения; он завершает программу. В случае <code>None</code> мы не будем возвращать значение из <code>unwrap</code>, поэтому этот код работает.</p>
<p>Последнее выражение, которое имеет вид <code>!</code> это <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>В данном случае цикл никогда не завершится, поэтому <code>!</code> является значением выражения. Но это не будет так, если мы добавим <code>break</code>, так как цикл завершит свою работу, когда дойдёт до <code>break</code>.</p>
<h3 id="Виды-с-изменяемым-размером-и-особенность-sized"><a class="header" href="#Виды-с-изменяемым-размером-и-особенность-sized">Виды с изменяемым размером и особенность <code>Sized</code></a></h3>
<p>Rust необходимо знать некоторые подробности о видах, например, сколько места нужно выделить для значения определённого вида. Из-за этого один из особенностей системы видов поначалу вызывает некоторое недоумение: подход <em>видов с изменяемым размером</em>. Иногда называемые <em>DST</em> или <em>безразмерные виды</em>, эти виды позволяют нам писать код, используя значения, размер которых мы можем узнать только во время выполнения.</p>
<p>Давайте углубимся в подробности изменяемого вида <code>str</code>, который мы использовали на протяжении всей книги. Все верно, не вида <code>&amp;str</code>, а вида <code>str</code> самого по себе, который является DST. Мы не можем знать, какой длины строка до особенности времени выполнения, то есть мы не можем создать переменную вида <code>str</code> и не можем принять переменная вида <code>str</code>. Рассмотрим следующий код, который не работает:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust должен знать, сколько памяти выделить для любого значения определенного вида и все значения вида должны использовать одинаковый размер памяти. Если Ржавчина позволил бы нам написать такой код, то эти два значения <code>str</code> должны были бы занимать одинаковое количество памяти. Но они имеют разную длину: <code>s1</code> нужно 12 байтов памяти, а для <code>s2</code> нужно 15. Вот почему невозможно создать переменную имеющую вид изменяемого размера.</p>
<p>Так что же нам делать? В этом случае вы уже знаете ответ: мы преобразуем виды <code>s1</code> и <code>s2</code> в <code>&amp;str</code>, а не в <code>str</code>. Вспомните из раздела <a href="ch04-03-slices.html#string-slices">"Строковые срезы"</a> главы 4, что устройства данных среза просто хранит начальную положение и длину среза. Так, в отличие от <code>&amp;T</code>, который содержит только одно значение - адрес памяти, где находится <code>T</code>, в <code>&amp;str</code> хранятся <em>два</em> значения - адрес <code>str</code> и его длина. Таким образом, мы можем узнать размер значения <code>&amp;str</code> во время сборки: он вдвое больше длины <code>usize</code>. То есть, мы всегда знаем размер <code>&amp;str</code>, независимо от длины строки, на которую оно ссылается. В целом, именно так в Ржавчина используются виды изменяемого размера: они содержат дополнительный бит метаданных, который хранит размер изменяемой сведений. Золотое правило изменяемых размерных видов заключается в том, что мы всегда должны помещать значения таких видов за каким-либо указателем.</p>
<p>Мы можем соединенять <code>str</code> со всеми видами указателей: например, <code>Box&lt;str&gt;</code> или <code>Rc&lt;str&gt;</code>. На самом деле, вы уже видели это раньше, но с другим изменяемым размерным видом: особенностями. Каждый особенность - это изменяемый размерный вид, на который мы можем ссылаться, используя имя особенности. В главе 17 в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование особенность-предметов, допускающих значения разных видов"</a> мы упоминали, что для использования особенностей в качестве особенность-предметов мы должны поместить их за указателем, например <code>&amp;dyn Trait</code> или <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> тоже подойдёт).</p>
<p>Для работы с DST Ржавчина использует особенность <code>Sized</code> чтобы решить, будет ли размер вида известен на стадии сборки. Этот особенность самостоятельно выполняется для всего, чей размер известен к времени сборки. Кроме того, Ржавчина неявно добавляет ограничение на <code>Sized</code> к каждой гибкой функции. То есть, определение гибкой функции, такое как:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>на самом деле рассматривается как если бы мы написали её в виде:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>По умолчанию обобщённые функции будут работать только с видами чей размер известен во время сборки. Тем не менее, можно использовать следующий особый правила написания, чтобы ослабить это ограничение:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>Ограничение особенности <code>?Sized</code> означает «<code>T</code> может или не может быть <code>Sized</code>», эта наставление отменяет обычное правило, согласно которому гибкие виды должны иметь известный размер во время сборки. Использовать правила написания <code>?Trait</code> в таком качестве можно только для <code>Sized</code>, и ни для каких других особенностей.</p>
<p>Также обратите внимание, что мы поменяли вид свойства <code>t</code> с <code>T</code> на <code>&amp;T</code>. Поскольку вид мог бы не быть <code>Sized</code>, мы должны использовать его за каким-либо указателем. В данном случае мы выбрали ссылку.</p>
<p>Далее мы поговорим о функциях и замыканиях!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутые-функции-и-замыкания"><a class="header" href="#Продвинутые-функции-и-замыкания">Продвинутые функции и замыкания</a></h2>
<p>В этом разделе рассматриваются некоторые продвинутые возможности, относящиеся к функциям и замыканиям, такие как указатели функций и возвращаемые замыкания.</p>
<h3 id="Указатели-функций"><a class="header" href="#Указатели-функций">Указатели функций</a></h3>
<p>Мы уже обсуждали, как передавать замыкания в функции; но также можно передавать обычные функции в функции! Эта техника полезна, когда вы хотите передать ранее созданную функцию, а не определять новое замыкание. Функции соответствуют виду <code>fn</code> (со строчной буквой f), не путать с особенностью замыкания <code>Fn</code>. Вид <code>fn</code> называется <em>указателем функции</em>. Передача функций с помощью указателей функций позволяет использовать функции в качестве переменных других функций.</p>
<p>Для указания того, что свойство является указателем на функцию, используется правила написания, такой же, как и для замыканий, что отображается в приложении 19-27, где мы определили функцию <code>add_one</code>, которая добавляет единицу к переданному ей свойству. Функция <code>do_twice</code> принимает два свойства: указатель на любую функцию, принимающую свойство <code>i32</code> и возвращающую <code>i32</code>, и число вида <code>i32</code>. Функция <code>do_twice</code> дважды вызывает функцию <code>f</code>, передавая ей значение <code>arg</code>, а затем складывает полученные итоги. Функция <code>main</code> вызывает функцию <code>do_twice</code> с переменнойми <code>add_one</code> и <code>5</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
<p><span class="caption">Приложение 19-27: Использование вида <code>fn</code> для получения указателя на функцию в качестве переменной</span></p>
<p>Этот код выводит <code>Ответ: 12</code>. Мы указали, что свойство <code>f</code> в <code>do_twice</code> является <code>fn</code>, которая принимает на вход единственный свойство вида <code>i32</code> и возвращает <code>i32</code>. Затем мы можем вызвать <code>f</code> в теле <code>do_twice</code>. В <code>main</code> мы можем передать имя функции <code>add_one</code> в качестве первого переменной в <code>do_twice</code>.</p>
<p>В отличие от замыканий, <code>fn</code> является видом, а не особенностью, поэтому мы указываем <code>fn</code> непосредственно в качестве вида свойства, а не объявляем свойство гибкого вида с одним из особенностей <code>Fn</code> в качестве связанного.</p>
<p>Указатели функций выполняют все три особенности замыканий (<code>Fn</code>, <code>FnMut</code> и <code>FnOnce</code>), то есть вы всегда можете передать указатель функции в качестве переменной функции, которая ожидает замыкание. Лучше всего для описания функции использовать гибкий вид и один из особенностей замыканий, чтобы ваши функции могли принимать как функции, так и замыкания.</p>
<p>Однако, одним из примеров, когда вы бы хотели принимать только <code>fn</code>, но не замыкания, является взаимодействие с внешним кодом, который не имеет замыканий: функции языка C могут принимать функции в качестве переменных, однако замыканий в языке C нет.</p>
<p>В качестве примера того, где можно использовать либо замыкание, определяемое непосредственно в месте передачи, либо именованную функцию, рассмотрим использование способа <code>map</code>, предоставляемого особенностью <code>Iterator</code> в встроенной библиотеке. Чтобы использовать функцию <code>map</code> для преобразования вектора чисел в вектор строк, мы можем использовать замыкание, например, так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>Или мы можем использовать функцию в качестве переменной <code>map</code> вместо замыкания, например, так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>Обратите внимание, что мы должны использовать полный правила написания, о котором мы говорили ранее в разделе <a href="ch19-03-advanced-traits.html#advanced-traits">"Продвинутые особенности"</a><!--  -->, потому что доступно несколько функций с именем <code>to_string</code>. Здесь мы используем функцию <code>to_string</code> определённую в особенности <code>ToString</code>, который выполнен в встроенной библиотеке для любого вида выполняющего особенность <code>Display</code>.</p>
<p>Вспомните из раздела <a href="ch06-01-defining-an-enum.html#enum-values">"Значения перечислений"</a> главы 6, что имя каждого определённого нами исхода перечисления также становится функцией-объявителем. Мы можем использовать эти объявители в качестве указателей на функции, выполняющих особенности замыканий, что означает, что мы можем использовать объявители в качестве переменных для способов, принимающих замыкания, например, так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы создаём образцы <code>Status::Value</code>, используя каждое значение <code>u32</code> в ряде (0..20), с которым вызывается <code>map</code> с помощью функции объявителя <code>Status::Value</code>. Некоторые люди предпочитают этот исполнение, а некоторые предпочитают использовать замыкания. Оба исхода собирается в один и тот же код, поэтому используйте любой исполнение, который вам понятнее.</p>
<h3 id="Возврат-замыканий"><a class="header" href="#Возврат-замыканий">Возврат замыканий</a></h3>
<p>Замыкания представлены особенностями, что означает, что вы не можете возвращать замыкания из функций. В большинстве случаев, когда вам захочется вернуть особенность, вы можете использовать определенный вид, выполняющий этот особенность, в качестве возвращаемого значения функции. Однако вы не можете сделать подобного с замыканиями, поскольку у них не может быть определенного вида, который можно было бы вернуть; например, вы не можете использовать указатель на функцию <code>fn</code> в качестве возвращаемого вида.</p>
<p>Следующий код пытается напрямую вернуть замыкание, но он не собирается:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>Ошибка сборщика выглядит следующим образом:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~
help: box the return type, and wrap all of the returned values in `Box::new`
  |
1 ~ fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
2 ~     Box::new(|x| x + 1)
  |

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` (lib) due to 1 previous error
</code></pre>
<p>Ошибка снова ссылается на особенность <code>Sized</code> ! Ржавчина не знает, сколько памяти нужно будет выделить для замыкания. Мы видели решение этой сбоев ранее. Мы можем использовать особенность-предмет:</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}</code></pre>
<p>Этот код просто отлично собирается. Для получения дополнительной сведений об особенность-предмета. обратитесь к разделу <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование особенность-предметов которые допускают значения разных видов"</a><!--  --> главы 17.</p>
<p>Далее давайте посмотрим на макросы!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Макросы"><a class="header" href="#Макросы">Макросы</a></h2>
<p>Мы использовали макросы, такие как <code>println!</code> на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Понятие <em>макрос</em> относится к семейству возможностей в Rust. Это <em>декларативные</em> (declarative) макросы с помощью <code>macro_rules!</code> и три вида <em>процедурных</em> (procedural) макросов:</p>
<ul>
<li>Пользовательские (выводимые) <code>#[derive]</code> макросы, которые указывают код, добавленный с помощью свойства <code>derive</code>, используемые для устройств и перечислений</li>
<li>Макросы подобные свойствам (attribute-like), которые определяют настраиваемые свойства, используемые для любого элемента языка</li>
<li>Похожие на функции (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream</li>
</ul>
<p>Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.</p>
<h3 id="Разница-между-макросами-и-функциями"><a class="header" href="#Разница-между-макросами-и-функциями">Разница между макросами и функциями</a></h3>
<p>По сути, макросы являются способом написания кода, который записывает другой код, что известно как <em>мета программирование</em>. В Приложении C мы обсуждаем свойство <code>derive</code>, который порождает за вас выполнение различных особенностей. Мы также использовали макросы <code>println!</code> и <code>vec!</code> на протяжении книги. Все эти макросы <em>раскрываются</em> для создания большего количества кода, чем исходный код написанный вами вручную.</p>
<p>Мета программирование полезно для уменьшения объёма кода, который вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.</p>
<p>Ярлык функции должна объявлять некоторое количество и вид этих свойств имеющихся у функции. Макросы, с другой стороны, могут принимать переменное число свойств: мы можем вызвать <code>println!("hello")</code> с одним переменнаяом или <code>println!("hello {}", name)</code> с двумя переменнойми. Также макросы раскрываются до того как сборщик преобразует смысл кода, поэтому макрос может, например, выполнить особенность заданного вида. Функция этого не может, потому что она вызывается во время выполнения и особенность должен быть выполнен во время сборки.</p>
<p>Обратной стороной выполнения макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте Ржавчина код, который записывает другой Ржавчина код. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.</p>
<p>Другое важное различие между макросами и функциями заключается в том, что вы должны объявить макросы или добавить их в область видимости <em>прежде</em> чем можете вызывать их в файле, в отличии от функций, которые вы можете объявить где угодно и вызывать из любого места.</p>
<h3 id="Декларативные-макросы-с-macro_rules-для-общего-мета-программирования"><a class="header" href="#Декларативные-макросы-с-macro_rules-для-общего-мета-программирования">Декларативные макросы с <code>macro_rules!</code> для общего мета программирования</a></h3>
<p>Наиболее широко используемой способом макросов в Ржавчина являются <em>декларативные макросы</em>. Они также иногда упоминаются как "макросы на примере", "<code>macro_rules!</code> макрос" или просто "макросы". По своей сути декларативные макросы позволяют писать нечто похожее на выражение <code>match</code> в  Rust. Как обсуждалось в главе 6, <code>match</code> выражения являются управляющими устройствами, которые принимают некоторое выражение, итог значения выражения сопоставляют с образцами, а затем запускают код для сопоставляемой ветки. Макросы также сравнивают значение с образцами, которые связаны с определенным кодом: в этой случаи значение является записью исходного кода Rust, переданным в макрос. Образцы сравниваются со устройствами этого исходного кода и при совпадении код, связанный с каждым образцом, заменяет код переданный макросу. Все это происходит во время сборки.</p>
<p>Для определения макроса используется устройство <code>macro_rules!</code>. Давайте рассмотрим, как использовать <code>macro_rules!</code> глядя на то, как объявлен макрос <code>vec!</code>. В главе 8 рассказано, как можно использовать макрос <code>vec!</code> для создания нового вектора с определёнными значениями. Например, следующий макрос создаёт новый вектор, содержащий три целых числа:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>Мы также могли использовать макрос <code>vec!</code> для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не смогли бы использовать функцию, чтобы сделать то же самое, потому что мы не знали бы заранее количество или вид значений.</p>
<p>В приложении 19-28 приведено несколько упрощённое определение макроса <code>vec!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<p><span class="caption">Приложение 19-28: Упрощённая исполнение определения макроса <code>vec!</code></span></p>
<blockquote>
<p>Примечание: действительное определение макроса <code>vec!</code> в встроенной библиотеке содержит код для предварительного выделения правильного объёма памяти. Этот код является переработкой, которую мы здесь не используем, чтобы сделать пример проще.</p>
</blockquote>
<p>Изложение <code>#[macro_export]</code> указывает, что данный макрос должен быть доступен всякий раз, когда ящик с объявленным макросом, добавлен в область видимости. Без этой изложении макрос нельзя добавить в область видимости.</p>
<p>Затем мы начинаем объявление макроса с помощью  <code>macro_rules!</code> и имени макроса, который объявляется <em>без</em> восклицательного знака. Название, в данном случае <code>vec</code>, после которого следуют фигурные скобки, указывающие тело определения макроса.</p>
<p>Устройства в теле макроса <code>vec!</code> похожа на устройство <code>match</code> выражения. Здесь у нас есть одна ветвь с образцом <code>( $( $x:expr ),* )</code>, затем следует ветвь <code>=&gt;</code> и раздел кода, связанный с этим образцом. Если образец сопоставлен успешно, то соответствующий раздел кода будет создан. Учитывая, что данный код является единственным образцом в этом макросе, существует только один действительный способ сопоставления, любой другой образец приведёт к ошибке. Более сложные макросы будут иметь более одной ветви.</p>
<p>Допустимый правила написания образца в определениях макросов отличается от правил написания образца рассмотренного в главе 18, потому что образцы макроса сопоставляются со устройствами кода Rust, а не со значениями. Давайте пройдёмся по тому, какие части образца в приложении 19-28 что означают; полный правила написания образцов макроса можно найти в <a href="../reference/macros-by-example.html">Справочнике по Rust</a>.</p>
<p>Во-первых, мы используем набор скобок, чтобы охватить весь образец. Мы используем знак доллара ( <code>$</code>) для объявления переменной в системе макросов, которая будет содержать код на Rust, соответствующий образцу. Знак доллара показывает, что это макропеременная, а не обычная переменная Rust. Далее следует набор скобок, в котором определятся значения, соответствующие образцу в скобках, для использования в коде замены. Внутри <code>$()</code> находится <code>$x:expr</code>, которое соответствует любому выражению Ржавчина и даёт выражению имя <code>$x</code>.</p>
<p>Запятая, следующая за <code>$()</code> указывает на то, что буквенный символ-разделитель запятая может дополнительно появиться после кода, который соответствует коду в <code>$()</code>. Звёздочка <code>*</code> указывает, что образец соответствует ноль или больше раз тому, что предшествует <code>*</code>.</p>
<p>Когда вызывается этот макрос с помощью <code>vec![1, 2, 3];</code> образец <code>$x</code> соответствует три раза всем трём выражениям <code>1</code>, <code>2</code> и <code>3</code>.</p>
<p>Теперь давайте посмотрим на образец в теле кода, связанного с этой ветвью: <code>temp_vec.push()</code> внутри <code>$()*</code> порождается для каждой части, которая соответствует символу <code>$()</code> в образце ноль или более раз в зависимости от того, сколько раз образец сопоставлен. Символ <code>$x</code> заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с <code>vec![1, 2, 3];</code>, созданный код, заменяющий этот вызов макроса будет следующим:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Мы определили макрос, который может принимать любое количество переменных любого вида и может порождать код для создания вектора, содержащего указанные элементы.</p>
<p>Чтобы узнать больше о том, как писать макросы, обратитесь к онлайн-документации или другим ресурсам, таким как <a href="https://veykril.github.io/tlborm/">«Маленькая книга макросов Rust»</a> , начатая Дэниелом Кипом и продолженная Лукасом Виртом.</p>
<h3 id="Процедурные-макросы-для-создания-кода-из-свойств"><a class="header" href="#Процедурные-макросы-для-создания-кода-из-свойств">Процедурные макросы для создания кода из свойств</a></h3>
<p>Вторая разновидность макросов - это <em>процедурные макросы</em> (procedural macros), которые действуют как функции (и являются видом процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают над этим кодом и создают некоторый код в качестве вывода, а не выполняют сопоставления с образцами и замену кода другим кодом, как это делают декларативные макросы. Процедурные макросы могут быть трёх видов: "пользовательского вывода" (custom-derive), "похожие на свойство" (attribute-like) и "похожие на функцию" (function-like), все они работают схожим образом.</p>
<p>При создании процедурных макросов объявления должны находиться в собственном ящике целенаправленного вида. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. В приложении 19-29 показано, как задать процедурный макрос, где <code>some_attribute</code> является заполнителем для использования целенаправленного макроса.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Приложение 19-29: Пример определения процедурного макроса</span></p>
<p>Функция, которая определяет процедурный макрос, принимает <code>TokenStream</code> в качестве входных данных и создаёт <code>TokenStream</code> в качестве вывода. Вид <code>TokenStream</code> объявлен ящиком <code>proc_macro</code>, включённым в Ржавчина и представляет собой последовательность токенов. Это ядро макроса: исходный код над которым работает макрос, является входным <code>TokenStream</code>, а код создаваемый макросом является выходным <code>TokenStream</code>. К функции имеет также прикреплённый свойство, определяющий какой вид процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же ящике.</p>
<p>Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие разновидности отличающимися.</p>
<h3 id="Как-написать-пользовательский-derive-макрос"><a class="header" href="#Как-написать-пользовательский-derive-макрос">Как написать пользовательский <code>derive</code> макрос</a></h3>
<p>Давайте создадим ящик с именем <code>hello_macro</code>, который определяет особенность с именем <code>HelloMacro</code> и имеет одну с ним сопряженную функцию с именем <code>hello_macro</code>. Вместо того, чтобы пользователи нашего ящика самостоятельно выполнили особенность <code>HelloMacro</code> для каждого из своих видов, мы предоставим им процедурный макрос, чтобы они могли определять свой вид с помощью свойства <code>#[derive(HelloMacro)]</code> и получили выполнение по умолчанию для функции <code>hello_macro</code>. Выполнение по умолчанию выведет <code>Hello, Macro! My name is TypeName!</code>, где <code>TypeName</code> - это имя вида, для которого был определён этот особенность. Другими словами, мы напишем ящик, использование которого позволит другому программисту писать код показанный в приложении 19-30.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Приложение 19-30: Код, который сможет писать пользователь нашего ящика при использовании нашего процедурного макроса</span></p>
<p>Этот код напечатает <code>Hello, Macro! My name is Pancakes!</code>, когда мы закончим. Первый шаг - создать новый, библиотечный ящик так:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Далее, мы определим особенность <code>HelloMacro</code> и сопряженную с ним функцию:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<p>У нас есть особенность и его функция. На этом этапе пользователь ящика может выполнить особенность для достижения желаемой возможности, так:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>Тем не менее, ему придётся написать разделвыполнения для каждого вида, который он хотел использовать вместе с <code>hello_macro</code>; а мы хотим избавить их от необходимости делать эту работу.</p>
<p>Кроме того, мы пока не можем предоставить функцию <code>hello_macro</code> с выполнением по умолчанию, которая будет печатать имя вида, для которого выполнен особенность: Ржавчина не имеет возможностей рефлексии (reflection), поэтому он не может выполнить поиск имени вида во время выполнения кода. Нам нужен макрос для создания кода во время сборки.</p>
<p>Следующим шагом является определение процедурного макроса. На мгновение написания этой статьи процедурные макросы должны быть в собственном ящике. Со временем это ограничение может быть отменено. Соглашение о внутреннем выстраивании</p>
<p>ящиков и макросов является следующим: для ящика с именем <code>foo</code>, его пользовательский, ящик с выводимым процедурным макросом называется <code>foo_derive</code>. Давайте начнём с создания нового ящика с именем <code>hello_macro_derive</code> внутри дела <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Наши два ящика тесно связаны, поэтому мы создаём процедурный макрос-ящик в папке ящика <code>hello_macro</code>. Если мы изменим определение особенности в <code>hello_macro</code>, то нам придётся также изменить выполнение процедурного макроса в <code>hello_macro_derive</code>. Два ящика нужно будет обнародовать отдельно и программисты, использующие эти ящики, должны будут добавить их как зависимости, а затем добавить их в область видимости. Мы могли вместо этого сделать так, что ящик <code>hello_macro</code> использует <code>hello_macro_derive</code> как зависимость и реэкспортирует код процедурного макроса. Однако то, как мы внутренне выстраивали</p>
<p>дело, делает возможным программистам использовать <code>hello_macro</code> даже если они не хотят <code>derive</code> возможность.</p>
<p>Нам нужно объявить ящик <code>hello_macro_derive</code> как процедурный макрос-ящик. Также понадобятся возможности из ящиков <code>syn</code> и <code>quote</code>, как вы увидите через мгновение, поэтому нам нужно добавить их как зависимости. Добавьте следующее в файл <em>Cargo.toml</em> для <code>hello_macro_derive</code>:</p>
<p><span class="filename">Файл: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
<p>Чтобы начать определение процедурного макроса, поместите код приложения 19-31 в ваш файл <em>src/lib.rs</em> ящика <code>hello_macro_derive</code>. Обратите внимание, что этот код не собирается пока мы не добавим определение для функции <code>impl_hello_macro</code>.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Ржавчина code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Приложение 19-31: Код, который потребуется в большинстве процедурных макро ящиков для обработки Ржавчина кода</span></p>
<p>Обратите внимание, что мы разделили код на функцию <code>hello_macro_derive</code>, которая отвечает за синтаксический анализ <code>TokenStream</code> и функцию <code>impl_hello_macro</code>, которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса удобнее. Код во внешней функции ( <code>hello_macro_derive</code> в данном случае) будет одинаковым для почти любого процедурного макрос ящика, который вы видите или создаёте. Код, который вы указываете в теле внутренней функции (в данном случае <code>impl_hello_macro</code> ) будет отличаться в зависимости от цели вашего процедурного макроса.</p>
<p>Мы представили три новых ящика: <code>proc_macro</code> <a href="https://crates.io/crates/syn"><code>syn</code></a> и <a href="https://crates.io/crates/quote"><code>quote</code></a>. Макрос <code>proc_macro</code> поставляется с Rust, поэтому нам не нужно было добавлять его в зависимости внутри <em>Cargo.toml</em>. Макрос <code>proc_macro</code> - это API сборщика, который позволяет нам читать и управлять Ржавчина кодом из нашего кода.</p>
<p>Ящик <code>syn</code> разбирает Ржавчина код из строки в устройство данных над которой мы может выполнять действия. Ящик <code>quote</code> превращает устройства данных <code>syn</code> обратно в код Rust. Эти ящики упрощают разбор любого вида Ржавчина кода, который мы хотели бы обрабатывать: написание полного синтаксического анализатора для кода Ржавчина не является простой задачей.</p>
<p>Функция <code>hello_macro_derive</code> будет вызываться, когда пользователь нашей библиотеки указывает своему виду <code>#[derive(HelloMacro)]</code>. Это возможно, потому что мы определяли функцию <code>hello_macro_derive</code> с помощью <code>proc_macro_derive</code> и указали имя <code>HelloMacro</code>, которое соответствует имени нашего особенности; это соглашение, которому следует большинство процедурных макросов.</p>
<p>Функция <code>hello_macro_derive</code> сначала преобразует <code>input</code> из <code>TokenStream</code> в устройство данных, которую мы можем затем преобразовать и над которой выполнять действия. Здесь ящик <code>syn</code> вступает в игру. Функция <code>parse</code> в <code>syn</code> принимает <code>TokenStream</code> и возвращает устройство <code>DeriveInput</code>, представляющую разобранный код Rust. Приложение 19-32 показывает соответствующие части устройства <code>DeriveInput</code>, которые мы получаем при разборе строки <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Приложение 19-32: Образец <code>DeriveInput</code> получаемый, когда разбирается код имеющий свойство макроса из приложения 19-30</span></p>
<p>Поля этой устройства показывают, что код Rust, который мы разобрали, является разделустройства с <code>ident</code> (определителем, означающим имя) <code>Pancakes</code>. В этой устройстве есть больше полей для описания всех видов кода Rust; проверьте <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">документацию <code>syn</code> о устройстве <code>DeriveInput</code></a> для получения дополнительной сведений.</p>
<p>Вскоре мы определим функцию <code>impl_hello_macro</code>, в которой построим новый, дополнительный код Rust. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является <code>TokenStream</code>. Возвращаемый <code>TokenStream</code> добавляется в код, написанный пользователями макроса, поэтому, когда они соберут свой ящик, они получат дополнительную возможность, которую мы предоставляем в изменённом <code>TokenStream</code>.</p>
<p>Возможно, вы заметили, что мы вызываем <code>unwrap</code> чтобы выполнить панику в функции <code>hello_macro_derive</code>, если вызов функции <code>syn::parse</code> потерпит неудачу. Наш процедурный макрос должен паниковать при ошибках, потому что функции <code>proc_macro_derive</code> должны возвращать <code>TokenStream</code>, а не вид <code>Result</code> для соответствия API процедурного макроса. Мы упроисполнения этот пример с помощью <code>unwrap</code>, но в рабочем коде вы должны предоставить более определенные сообщения об ошибках, если что-то пошло не правильно, используя <code>panic!</code> или <code>expect</code>.</p>
<p>Теперь, когда у нас есть код для преобразования определеного Ржавчина кода из <code>TokenStream</code> в образец <code>DeriveInput</code>, давайте создадим код выполняющий особенность <code>HelloMacro</code> у определеного вида, как показано в приложении 19-33.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Ржавчина code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Приложение 19-33: Выполнение особенности <code>HelloMacro</code> с использованием проанализированного кода Rust.</span></p>
<p>Мы получаем образец устройства <code>Ident</code> содержащий имя (определитель) определеного вида с использованием <code>ast.ident</code>. Устройства в приложении 19-32 показывает, что когда мы запускаем функцию <code>impl_hello_macro</code> для кода из приложения 19-30, то получаемый <code>ident</code> будет иметь поле <code>ident</code> со значением <code>"Pancakes"</code>. Таким образом, переменная <code>name</code> в приложении 19-33 будет содержать образец устройства <code>Ident</code>, что при печати выдаст строку <code>"Pancakes"</code>, что является именем устройства в приложении 19-30.</p>
<p>Макрос <code>quote!</code> позволяет определить код Rust, который мы хотим вернуть. Сборщик ожидает что-то отличное от прямого итога выполнения макроса <code>quote!</code>, поэтому нужно преобразовать его в <code>TokenStream</code>. Мы делаем это путём вызова способа <code>into</code>, который использует промежуточное представление и возвращает значение требуемого вида <code>TokenStream</code>.</p>
<p>Макрос <code>quote!</code> также предоставляет очень полезную механику образцов: мы можем ввести <code>#name</code> и <code>quote!</code> заменит его значением из переменной <code>name</code>. Вы можете даже сделать некоторое повторение, подобное тому, как работают обычные макросы. Проверьте <a href="https://docs.rs/quote">документацию ящика <code>quote</code></a> для подробного введения.</p>
<p>Мы хотим, чтобы наш процедурный макрос порождал выполнение нашего особенности <code>HelloMacro</code> для вида, который определял пользователь, который мы можем получить, используя <code>#name</code>. Выполнение особенности имеет одну функцию <code>hello_macro</code>, тело которой содержит возможность, которую мы хотим предоставить: напечатать <code>Hello, Macro! My name is</code> с именем определеного вида.</p>
<p>Макрос <code>stringify!</code> используемый здесь, встроен в Rust. Он принимает Ржавчина выражение, такое как <code>1 + 2</code> и во время сборки сборщик превращает выражение в строковый запись, такой как <code>"1 + 2"</code>. Он отличается от макросов <code>format!</code> или <code>println!</code>, которые вычисляют выражение, а затем превращают итог в виде вида <code>String</code>. Существует возможность того, что введённый <code>#name</code> может оказаться выражением для печати буквально как есть, поэтому здесь мы используем <code>stringify!</code>. Использование <code>stringify!</code> также уменьшает выделение памяти путём преобразования <code>#name</code> в строковый запись во время сборки.</p>
<p>На этом этапе приказ <code>cargo build</code> должна завершиться успешно для обоих <code>hello_macro</code> и <code>hello_macro_derive</code>. Давайте подключим эти ящики к коду в приложении 19-30, чтобы увидеть процедурный макрос в действии! Создайте новый двоичный дело в папке ваших <em>дел</em> с использованием приказы <code>cargo new pancakes</code>. Нам нужно добавить <code>hello_macro</code> и <code>hello_macro_derive</code> в качестве зависимостей для ящика <code>pancakes</code> в файл <em>Cargo.toml</em>. Если вы размещаете свои исполнения <code>hello_macro</code> и <code>hello_macro_derive</code> на сайт <a href="https://crates.io/">crates.io</a>, они будут обычными зависимостями; если нет, вы можете указать их как <code>path</code> зависимости следующим образом:</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Поместите код в приложении 19-30 в <em>src/main.rs</em> и выполните <code>cargo run</code>: он должен вывести <code>Hello, Macro! My name is Pancakes!</code>. Выполнение особенности <code>HelloMacro</code> из процедурного макроса была включена без необходимости его выполнения ящиком <code>pancakes</code>; <code>#[derive(HelloMacro)]</code> добавил выполнение особенности.</p>
<p>Далее давайте рассмотрим, как другие виды процедурных макросов отличаются от пользовательских выводимых макросов.</p>
<h3 id="Макросы-похожие-на-свойство"><a class="header" href="#Макросы-похожие-на-свойство">Макросы, похожие на свойство</a></h3>
<p>Подобные свойствам макросы похожи на пользовательские выводимые макросы, но вместо создания кода для <code>derive</code> свойства, они позволяют создавать новые свойства. Они являются также более гибкими: <code>derive</code> работает только для устройств и перечислений; свойство-подобные могут применяться и к другим элементам, таким как функции. Вот пример использования  имеющего свойство макроса: допустим, у вас есть свойство именованный <code>route</code> который определяет функции при использовании фреймворка для веб-приложений:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>Данный свойство <code>#[route]</code> будет определён платспособом как процедурный макрос. Ярлык функции определения макроса будет выглядеть так:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Здесь есть два свойства вида <code>TokenStream</code>. Первый для содержимого свойства: часть <code>GET, "/"</code> . Второй это тело элемента, к которому прикреплён свойство: в данном случае <code>fn index() {}</code> и остальная часть тела функции.</p>
<p>Кроме того, имеющие свойства макросы работают так же как и пользовательские выводимые макросы: вы создаёте ящик с видом <code>proc-macro</code> и выполняете функцию, которая порождает код, который хотите!</p>
<h3 id="Макросы-похожие-на-функции"><a class="header" href="#Макросы-похожие-на-функции">Макросы, похожие на функции</a></h3>
<p>Макросы, похожие на функции, выглядят подобно вызову функций. Подобно макросам <code>macro_rules!</code> они являются более гибкими, чем функции; например, они могут принимать неизвестное количество переменных. Тем не менее, макросы <code>macro_rules!</code> можно объявлять только с использованием правил написания подобного сопоставлению, который мы обсуждали ранее в разделе <a data-md-type="raw_html" href="ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">"Декларативные макросы <code>macro_rules!</code> для общего мета программирования"</a>. Макросы, похожие на функции, принимают свойство <code>TokenStream</code> и их определение управляет этим <code>TokenStream</code>, используя код Rust, как это делают два других вида процедурных макроса. Примером подобного возможностей макроса является макрос <code>sql!</code>, который можно вызвать так:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Этот макрос будет разбирать SQL указанию внутри него и проверять, что она синтаксически правильная, что является гораздо более сложной обработкой, чем то что может сделать макрос <code>macro_rules!</code>. Макрос <code>sql!</code> мог бы быть определён так:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Это определение похоже на ярлык пользовательского выводимого макроса: мы получаем токены, которые находятся внутри скобок и возвращаем код, который мы хотели создать.</p>
<h2 id="Итоги-16"><a class="header" href="#Итоги-16">Итоги</a></h2>
<p>Фух! Теперь у вас в распоряжении есть некоторые возможности Rust, которые вы не будете часто использовать, но вы будете знать, что они доступны в особых обстоятельствах. Мы представили несколько сложных тем, чтобы при появлении сообщения с предложением исправить ошибку или в коде других людей, вы могли бы распознать эти подходы и правила написания. Используйте эту главу как справочник, который поможет вам найти решение.</p>
<p>Далее мы применим в действительностивсе, что обсуждали на протяжении всей книги, и выполним ещё один дело!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Конечный-дело-создание-многопоточного-веб-сервера"><a class="header" href="#Конечный-дело-создание-многопоточного-веб-сервера">Конечный дело: создание многопоточного веб-сервера</a></h1>
<p>Это был долгий путь, но мы дошли до конца книги. В этой главе мы сделаем ещё один дело, чтобы закрепить несколько тем из последних глав и резюмировать то, что прошли в самом начале.</p>
<p>В качестве нашего конечного дела мы напишем веб-сервер, который выводит надпись “hello” в веб-браузере, как на рисунке 20-1.</p>
<p><img src="https://github.com/ruRust/book/blob/master/rustbook-en/src/img/trpl20-01.png?raw=true" alt="hello from rust" /></p>
<p><span class="caption">Рисунок 20-1: Наш последний совместный дело</span></p>
<p>Для создания веб-сервера нам понадобится:</p>
<ol>
<li>Узнать немного о протоколах TCP и HTTP.</li>
<li>Сделать прослушивание TCP соединения у сокета.</li>
<li>Создать возможность для парсинга небольшого количества HTTP-запросов.</li>
<li>Научить сервер отдавать правильный HTTP-ответ.</li>
<li>Улучшить пропускную способность нашего сервера с помощью объединения потоков.</li>
</ol>
<p>Прежде чем мы начнём, заметим: способ, который мы будем использовать - не лучшим способ создания веб-сервера на Rust. Члены сообщества уже обнародовали на <a href="https://crates.io/">crates.io</a> несколько готовых к использованию ящиков, которые предоставляют более полные выполнения веб-сервера и объединения потоков, чем те, которые мы создадим. Однако наша цель в этой главе — научиться новому, а не идти по лёгкому пути. Поскольку Ржавчина — это язык системного программирования, мы можем выбирать тот уровень абстракции, который нам подходит, и можем переходить на более низкий уровень, что может быть невозможно или неприменимо в других языках. Поэтому мы напишем основной HTTP-сервер и объединениепотоков вручную, чтобы вы могли изучить общие мысли и способы, лежащие в основе ящиков, которые, возможно, вы будете использовать в будущем.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Создание-однопоточного-веб-сервера"><a class="header" href="#Создание-однопоточного-веб-сервера">Создание однопоточного веб-сервера</a></h2>
<p>Начнём с однопоточного веб-сервера. Перед тем, как начать, давайте сделаем краткий обзор протоколов, задействованных при создании веб-серверов. Детальное описание этих протоколов выходит за рамки этой книги, но краткий обзор даст вам необходимую сведения.</p>
<p>Двумя основными протоколами, используемыми в веб-серверах, являются <em>протокол передачи гипертекста</em> <em>(HTTP - Hypertext Transfer Protocol)</em> и <em>Протокол управления передачей</em> <em>(TCP - Transmission Control Protocol)</em>. Оба протокола являются протоколами вида <em>запрос-ответ</em> (request-response), то есть <em>клиент</em> объявляет запросы, а <em>сервер</em> слушает эти запросы и предоставляет ответ клиенту. Содержимое этих запросов и ответов определяется протоколами.</p>
<p>TCP - это протокол нижнего уровня, который описывает подробности того, как сведения передаётся от одного сервера к другому, но не определяет, что это за сведения. HTTP строится поверх TCP, определяя содержимое запросов и ответов. Технически возможно использовать HTTP с другими протоколами, но в подавляющем большинстве случаев HTTP отправляет свои данные поверх TCP. Мы будем работать с необработанными байтами в TCP и запросами и ответами в HTTP.</p>
<h3 id="Прослушивание-tcp-соединения"><a class="header" href="#Прослушивание-tcp-соединения">Прослушивание TCP соединения</a></h3>
<p>Нашему веб-серверу необходимо прослушивать TCP-соединение, так что это первая часть, над которой мы будем работать. Обычная библиотека предлагает для этого звено <code>std::net</code>. Сделаем новый дело обычным способом:</p>
<pre><code class="language-console">$ cargo new hello
      Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Дл начала добавьте код из приложения 20-1 в файл <em>src/main.rs</em>. Этот код будет прослушивать входящие TCP потоки по адресу <code>127.0.0.1:7878</code>. Когда сервер примет входящий поток, он напечатает <code>Connection established!</code> ("Соединение установлено!").</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre></pre>
<p><span class="caption">Приложение 20-1: Прослушивание входящих потоков и печать сообщения при получении потока</span></p>
<p>Используя <code>TcpListener</code> мы можем слушать TCP соединения к адресу <code>127.0.0.1:7878</code>. В адресе, в его части перед двоеточием, сначала идёт IP-адрес, относящийся к вашему компьютеру (он одинаковый на каждом компьютере и не представляет определенный компьютер автора), а часть <code>7878</code> является портом. Мы выбрали этот порт по двум причинам: HTTP обычно не используется на этом порту, поэтому маловероятно, что наш сервер будет враждовать с каким-нибудь другим сервером, который может выполняться на вашей машине, и ещё 7878 - это слово <em>rust</em>, набранное на телефоне.</p>
<p>Функция <code>bind</code> в этом сценарии работает так же, как функция <code>new</code>, поскольку она возвращает новый образец <code>TcpListener</code> . Причина, по которой функция называется <code>bind</code> заключается в том, что в сетевой совокупности понятий подключение к порту для прослушивания называется «привязка к порту» (“binding to a port”).</p>
<p>Функция <code>bind</code> возвращает <code>Result&lt;T, E&gt;</code>, а это значит, что привязка может не состояться. Так, например, подключение к порту 80 предполагает наличие привилегий администратора (прочие пользователи могут прослушивать порты только от 1023-го и выше), поэтому если мы попытаемся подключиться к порту 80, не будучи администратором, привязка не сработает. Привязка также не выполнится, например, если мы запустим два образца нашей программы, прослушивающие один и тот же порт. Поскольку мы пишем простейший сервер в учебных целях, мы не будем беспокоиться об обработке подобных ошибок; вместо этого мы используем <code>unwrap</code> для прекращения работы программы в случае возникновения ошибок.</p>
<p>Способ <code>incoming</code> в <code>TcpListener</code> возвращает повторитель , который даёт нам последовательность потоков (определеннее, потоков вида <code>TcpStream</code> ). Один <em>поток</em> представляет собой открытое соединение между клиентом и сервером. <em>Соединением</em> называется полный этап запроса и ответа, в котором клиент подключается к серверу, сервер порождает ответ, и сервер закрывает соединение. Таким образом, мы будем читать из потока <code>TcpStream</code> то, что отправил клиент, а затем записывать наш ответ в поток, для отправки его обратно клиенту. В целом, цикл <code>for</code> будет обрабатывать каждое соединение по очереди и создавать серию потоков, которые мы будем обрабатывать.</p>
<p>На текущий мгновение наша обработка потока состоит из вызова <code>unwrap</code> для завершения программы, если в потоке возникли ошибки, если же таковых не обнаружится, программа выведет сообщение. В следующем приложении мы добавим больше возможности для успешного сценария. Причиной того, что мы можем получать ошибки от способа <code>incoming</code>, когда клиент подключается к серверу, является то, что на самом деле мы не перебираем подключения. На самом деле мы перебираем <em>попытки подключения</em>. Подключение может не состояться по ряду причин, многие из которых зависят от операционной системы. Например, многие операционные системы имеют ограничение на количество одновременно открытых соединений, которые они могут поддерживать; при превышении этого предела новые попытки установить соединение будут приводить к ошибке, пока какие-либо из уже открытых соединений не будут закрыты.</p>
<p>Попробуем запустить этот код! Вызовите <code>cargo run</code> в окне вызова, а затем загрузите <em>127.0.0.1:7878</em> в веб-браузере. В браузере должно отображаться сообщение об ошибке, например «Connection reset», поскольку сервер в настоящее время не отправляет обратно никаких данных. Но когда вы посмотрите на свой окно вызова, вы должны увидеть несколько сообщений, которые были напечатаны, когда браузер подключался к серверу!</p>
<pre><code class="language-text">     Running `target/debug/hello`
 Connection established!
 Connection established!
 Connection established!
</code></pre>
<p>Иногда вы видите несколько сообщений, напечатанных для одного запроса браузера; Причина может заключаться в том, что браузер выполняет запрос страницы, а также других ресурсов, таких как значок <em>favicon.ico,</em> который отображается на вкладке браузера.</p>
<p>Также может быть, что браузер пытается подключиться к серверу несколько раз, потому что сервер не отвечает. Когда <code>stream</code> выходит из области видимости и отбрасывается в конце цикла, соединение закрывается как часть выполнения <code>drop</code>. Браузеры иногда обрабатывают закрытые соединения, повторяя попытки, потому что неполадка может быть временной. Важным обстоятельством является то, что мы успешно получили указатель TCP-соединения!</p>
<p>Не забудьте остановить программу, нажав <span class="keystroke">ctrl-c</span>, когда вы закончите выполнение определённой исполнения кода. Затем перезапустите программу, вызвав приказ <code>cargo run</code>, после того, как вы внесли какой-либо набор изменений, чтобы убедиться, что выполняется самая свежая исполнение кода.</p>
<h3 id="Чтение-запросов"><a class="header" href="#Чтение-запросов">Чтение запросов</a></h3>
<p>Выполняем возможности чтения запроса из браузера! Чтобы разделить части, связанные с получением соединения и последующим действием с ним, мы запустим новую функцию для обработки соединения. В этой новой функции <code>handle_connection</code> мы будем читать данные из потока TCP и распечатывать их, чтобы мы могли видеть данные, отправленные из браузера. Измените код, чтобы он выглядел как в приложении 20-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
<p><span class="caption">Приложение 20-2: Чтение из <code>TcpStream</code> и печать данных</span></p>
<p>Мы добавляем <code>std::io::prelude</code> и <code>std::io::BufReader</code> в область видимости, чтобы получить доступ к особенностям и видам, которые позволяют нам читать и писать в поток. В цикле <code>for</code> функции <code>main</code> вместо вывода сообщения о том, что мы установили соединение, мы теперь вызываем новую функцию <code>handle_connection</code> и передаём ей <code>stream</code>.</p>
<p>В функции <code>handle_connection</code> мы создаём новый образец <code>BufReader</code>, который оборачивает изменяемую ссылку на <code>stream</code>. <code>BufReader</code> добавляет буферизацию, управляя вызовами способов особенности <code>std::io::Read</code> за нас.</p>
<p>Мы создаём переменную <code>http_request</code> для сбора строк запроса, который браузер отправляет на наш сервер. Мы указываем, что хотим собрать эти строки в вектор, добавляя изложение вида <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> выполняет особенность <code>std::io::BufRead</code>, который выполняет способ <code>lines</code>. Способ <code>lines</code> возвращает повторитель <code>Result&lt;String, std::io::Error&gt;</code>, разделяющий поток данных на части всякий раз, когда ему попадается байт новой строки. Чтобы получить все строки <code>String</code>, мы с помощью map вызываем <code>unwrap</code> у каждого <code>Result</code>. Значение <code>Result</code> может быть ошибкой, если данные не соответствуют исполнению UTF-8 или если возникли сбоев с чтением из потока. Опять же, программа в промышленном исполнении должна обрабатывать эти ошибки более изящно, но мы для простоты решили прекращать работу программы в случае ошибки.</p>
<p>Браузер указывает об окончании HTTP-запроса, отправляя два символа перевода строки подряд, поэтому, чтобы получить один запрос из потока, мы забираем строки, пока не получим строку, которая является пустой строкой. После того, как мы собрали строки в вектор, мы распечатываем их, используя красивое отладочное изменение
, чтобы мы могли взглянуть на указания, которые веб-браузер отправляет на наш сервер.</p>
<p>Попробуем этот код! Запустите программу и снова сделайте запрос в веб-браузере. Обратите внимание, что мы по-прежнему будем получать в браузере страницу с ошибкой, но вывод нашей программы в окне вызова теперь будет выглядеть примерно так:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>В зависимости от вашего браузера итог может немного отличаться. Теперь, когда мы печатаем данные запроса, мы можем понять, почему мы получаем несколько подключений из одного запроса браузера, посмотрев на путь после <code>GET</code> в первой строке запроса. Если все повторяющиеся соединения запрашивают <em>/</em> , мы знаем, что браузер пытается получить <em>/</em> повторно, потому что он не получает ответа от нашей программы.</p>
<p>Давайте разберём эти данные запроса, чтобы понять, что браузер запрашивает у нашей программы.</p>
<h3 id="Пристальный-взгляд-на-http-запрос"><a class="header" href="#Пристальный-взгляд-на-http-запрос">Пристальный взгляд на HTTP запрос</a></h3>
<p>HTTP - это текстовый протокол и запрос имеет следующий вид:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка - это <em>строка запроса</em> , содержащая сведения о том, что запрашивает клиент. Первая часть строки запроса указывает используемый <em>способ</em> , например <code>GET</code> или <code>POST</code> , который описывает, как клиент выполняет этот запрос. Наш клиент использовал запрос <code>GET</code>, что означает, что он просит нас предоставить сведения.</p>
<p>Следующая часть строки запроса - это <em>/</em>, которая указывает <em>унифицированный определитель</em> <em>ресурса (URI),</em> который запрашивает клиент: URI почти, но не совсем то же самое, что и <em>унифицированный указатель ресурса</em> <em>(URL)</em>. Разница между URI и URL-адресами не важна для наших целей в этой главе, но согласно принятых требований HTTP использует понятие URI, поэтому мы можем просто мысленно заменить URL-адрес здесь.</p>
<p>Последняя часть - это исполнение HTTP, которую использует клиент, а затем строка запроса заканчивается <em>последовательностью CRLF</em> . (CRLF обозначает <em>возврат каретки</em> и <em>перевод строки</em> , что является понятием из дней пишущих машинок!) Последовательность CRLF также может быть записана как <code>\r\n</code> , где <code>\r</code> - возврат каретки, а <code>\n</code> - перевод строки. Последовательность CRLF отделяет строку запроса от остальных данных запроса. Обратите внимание, что при печати CRLF мы видим начало новой строки, а не <code>\r\n</code> .</p>
<p>Глядя на данные строки запроса, которые мы получили от запуска нашей программы, мы видим, что <code>GET</code> - это способ, <em>/</em> - это URI запроса, а <code>HTTP/1.1</code> - это исполнение.</p>
<p>После строки запроса оставшиеся строки, начиная с <code>Host:</code> далее, являются заголовками. <code>GET</code> запросы не имеют тела.</p>
<p>Попробуйте сделать запрос из другого браузера или запросить другой адрес, например <em>127.0.0.1:7878/test</em> , чтобы увидеть, как изменяются данные запроса.</p>
<p>Теперь, когда мы знаем, что запрашивает браузер, давайте отправим обратно в ответ некоторые данные!</p>
<h3 id="Написание-ответа"><a class="header" href="#Написание-ответа">Написание ответа</a></h3>
<p>Теперь выполняем отправку данных в ответ на запрос клиента. Ответы имеют следующий вид:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка - это <em>строка состояния</em>, которая содержит исполнение HTTP, используемую в ответе, числовой код состояния, который суммирует итог запроса, и фразу причины, которая предоставляет текстовое описание кода состояния. После последовательности CRLF идут любые заголовки, другая последовательность CRLF и тело ответа.</p>
<p>Вот пример ответа, который использует HTTP исполнения 1.1, имеет код состояния 200, фразу причины OK, без заголовков и без тела:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Код состояния 200 - это обычный успешный ответ. Текст представляет собой крошечный успешный HTTP-ответ. Давайте запишем это в поток как наш ответ на успешный запрос! Из функции <code>handle_connection</code> удалите <code>println!</code> который печатал данные запроса и заменял их кодом из Приложения 20-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 20-3: Запись крошечного успешного HTTP-ответа в поток</span></p>
<p>Первый перевод строки определяет переменную <code>response</code>, которая содержит данные сообщения об успешном выполнении. Затем мы вызываем <code>as_bytes</code> в нашем <code>response</code>, чтобы преобразовать строковые данные в байты. Способ <code>write_all</code> в <code>stream</code> принимает вид <code>&amp;[u8]</code> и отправляет эти байты непосредственно получателю. Поскольку действие <code>write_all</code> может завершиться с ошибкой, мы, как и ранее, используем <code>unwrap</code> на любом возможно ошибочном итоге. И опять, в существующем приложении здесь вам нужно было бы добавить обработку ошибок.</p>
<p>После этих изменений давайте запустим наш код и сделаем запрос. Мы больше не печатаем никаких данных в окно вызова, поэтому мы не увидим никакого вывода, кроме сообщений от Cargo. Когда вы загрузите <em>127.0.0.1:7878</em> в веб-браузере, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали код получения HTTP-запроса и отправки ответа на него!</p>
<h3 id="Возвращение-существующего-html"><a class="header" href="#Возвращение-существующего-html">Возвращение существующего HTML</a></h3>
<p>Давайте выполняем возможности чего-нибудь большего, чем просто пустой страницы. Создайте новый файл <em>hello.html</em> в корне папки вашего дела, а не в папке <em>src</em> . Вы можете ввести любой HTML-код, который вам заблагорассудится; В приложении 20-4 показан один из исходов.</p>
<p><span class="filename">Файл: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Приложение 20-4: Пример HTML-файла для ответа на запрос</span></p>
<p>Это простейший HTML5-документ с заголовком и каким-то текстом. Чтобы сервер возвращал его в ответ на полученный запрос, мы изменим <code>handle_connection</code>, как показано в приложении 20-5, чтобы считать HTML-файл, добавить его в ответ в качестве тела и отправить.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 20-5. Отправка содержимого <em>hello.html</em> в качестве тела ответа</span></p>
<p>Мы добавили элемент <code>fs</code> в указанию <code>use</code>, чтобы включить в область видимости звено файловой системы встроенной библиотеки. Код для чтения содержимого файла в строку должен выглядеть знакомым для вас; мы использовали его в главе 12, когда читали содержимое файла для нашего дела ввода-вывода в приложении 12-4.</p>
<p>Далее мы используем <code>format!</code> чтобы добавить содержимое файла в качестве тела ответа об успешном завершении. Чтобы обеспечить действительный HTTP-ответ, мы добавляем заголовок <code>Content-Length</code> который имеет размер тела нашего ответа, в данном случае размер <code>hello.html</code> .</p>
<p>Запустите этот код приказом <code>cargo run</code> и загрузите <em>127.0.0.1:7878</em> в браузере; вы должны увидеть выведенный HTML в браузере!</p>
<p>В настоящее время мы пренебрегаем данные запроса в переменной <code>http_request</code> и в любом случае просто отправляем обратно содержимое HTML-файла. Это означает, что если вы попытаетесь запросить адрес <em>127.0.0.1:7878/something-else</em> в своём браузере, вы все равно получите тот же самый HTML-ответ. Пока что наш сервер очень ограничен, и не умеет делать то, что делает большинство веб-серверов. Мы хотим настроить наши ответы в зависимости от запроса и отправлять обратно HTML-файл только для правильно созданного запроса к пути <em>/</em> .</p>
<h3 id="Проверка-запроса-и-выборочное-возвращение-ответа"><a class="header" href="#Проверка-запроса-и-выборочное-возвращение-ответа">Проверка запроса и выборочное возвращение ответа</a></h3>
<p>Сейчас наш веб-сервер возвращает HTML из файла независимо от того, что определенно запросил клиент. Давайте добавим проверку того, что браузер запрашивает <em>/</em>, прежде чем вернуть HTML-файл, и будем возвращать ошибку, если браузер запрашивает что-то постороннее. Для этого нам нужно изменять <code>handle_connection</code>, как показано в приложении 20-6. Новый код проверяет соответствует ли требуемый запросом ресурс с определителем <em>/</em>, и содержит разделы <code>if</code> и <code>else</code>, чтобы иначе обрабатывать другие запросы.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<p><span class="caption">Приложение 20-6: Обрабатываем запросы для корневого ресурса <em>/</em> не так, как запросы для других ресурсов</span></p>
<p>Мы будем рассматривать только первую строку HTTP-запроса, поэтому вместо того, чтобы читать весь запрос в вектор, мы вызываем <code>next</code> , чтобы получить первый элемент из повторителя. Первый вызов <code>unwrap</code> заботится об обработке <code>Option</code> и останавливает программу, если в повторителе нет элементов. Второй <code>unwrap</code> обрабатывает <code>Result</code> и имеет тот же эффект, что и <code>unwrap</code>, который был в <code>map</code>, добавленном в приложении 20-2.</p>
<p>Затем мы проверяем переменную <code>request_line</code>, чтобы увидеть, равна ли она строке запроса, соответствующей запросу GET для пути <em>/</em> . Если это так, раздел<code>if</code> возвращает содержимое нашего HTML-файла.</p>
<p>Если <code>request_line</code> <em>не</em> равна запросу GET для пути <em>/</em>, это означает, что мы получили какой-то другой запрос. Мы скоро добавим код в раздел<code>else</code>, чтобы ответить на все остальные запросы.</p>
<p>Запустите этот код сейчас и запросите <em>127.0.0.1:7878</em> ; вы должны получить HTML в <em>hello.html</em> . Если вы сделаете любой другой запрос, например <em>127.0.0.1:7878/something-else</em> , вы получите ошибку соединения, подобную той, которую вы видели при запуске кода из Приложения 20-1 и Приложения 20-2.</p>
<p>Теперь давайте добавим код из приложения 20-7 в раздел<code>else</code> чтобы вернуть ответ с кодом состояния 404, который указывает о том, что содержание для запроса не найден. Мы также вернём HTML-код для страницы, отображаемой в браузере, с указанием ответа конечному пользователю.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение  20-7: Отвечаем кодом состояния 404 и страницей ошибки, если было запрошено что-то, отличающееся от ресурса <em>/</em></span></p>
<p>Здесь ответ имеет строку состояния с кодом 404 и фразу причины <code>NOT FOUND</code>. Тело ответа будет HTML из файла <em>404.html</em>. Вам нужно создать файл <em>404.html</em> рядом с <em>hello.html</em> для этой страницы ошибки; снова не стесняйтесь использовать любой HTML код или пример HTML кода в приложении 20-8.</p>
<p><span class="filename">Файл: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Приложение 20-8. Пример содержимого страницы для отправки с любым ответом 404</span></p>
<p>С этими изменениями снова запустите сервер. Запрос на <em>127.0.0.1:7878</em> должен возвращать содержимое <em>hello.html</em>, и любой другой запрос, как <em>127.0.0.1:7878/foo</em>, должен возвращать сообщение об ошибке HTML от <em>404.html</em>.</p>
<h3 id="Переработка-кода"><a class="header" href="#Переработка-кода">Переработка кода</a></h3>
<p>На текущий мгновение разделы <code>if</code> и <code>else</code> во многом повторяются: они оба читают файлы и записывают содержимое файлов в поток. Разница лишь в строке состояния и имени файла. Давайте сделаем код более кратким, вынеся эти отличия в отдельные разделы <code>if</code> и <code>else</code>, в которых переменным будут присвоены значения строки состояния и имени файла; далее эти переменные мы сможем использовать в коде для чтения файла и создания ответа. В приложении 20-9 показан код после изменения объёмных разделов <code>if</code> и <code>else</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Приложение 20-9: Переработка кода разделов <code>if</code> и <code>else</code>, чтобы они содержали только код, который отличается для каждого из случаев</span></p>
<p>Теперь разделы <code>if</code> и <code>else</code> возвращают только соответствующие значения для строки состояния и имени файла в упорядоченном ряде. Затем мы используем разъединение, чтобы присвоить эти два значения <code>status_line</code> и <code>filename</code> используя образец в указания <code>let</code>, как обсуждалось в главе 18.</p>
<p>Ранее повторяющийся код теперь находится вне разделов <code>if</code> и <code>else</code> и использует переменные <code>status_line</code> и <code>filename</code>. Это позволяет легче увидеть разницу между этими двумя случаями и означает, что у нас есть только одно место для обновления кода, если захотим изменить работу чтения файлов и записи ответов. Поведение кода в приложении 20-9 будет таким же, как и в 20-8.</p>
<p>Потрясающие! Теперь у нас есть простой веб-сервер примерно на 40 строках кода Rust, который отвечает на один запрос страницей с содержанием и отвечает на все остальные запросы ответом 404.</p>
<p>В настоящее время наш сервер работает в одном потоке, что означает, что он может обслуживать только один запрос за раз. Давайте разберёмся, почему это может быть неполадкой, сымитировав несколько медленных запросов. Затем мы исправим случай так, чтобы наш сервер мог обрабатывать несколько запросов одновременно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Превращение-однопоточного-сервера-в-многопоточный-сервер"><a class="header" href="#Превращение-однопоточного-сервера-в-многопоточный-сервер">Превращение однопоточного сервера в многопоточный сервер</a></h2>
<p>В текущей выполнения сервер обрабатывает каждый запрос по очереди, то есть, он не начнёт обрабатывать второе соединение, пока не завершит обработку первого. При росте числа запросов к серверу, такое последовательное выполнение было бы все менее и менее разумным. Если сервер получает какой-то запрос, обработка которого занимает достаточно много времени, последующим запросам придётся ждать завершения обработки длительного запроса, даже если эти новые запросы сами по себе могут быть обработаны быстро. Нам нужно это исправить, но сначала рассмотрим неполадку в действии.</p>
<h3 id="Подражание-медленного-запроса-в-текущей-выполнения-сервера"><a class="header" href="#Подражание-медленного-запроса-в-текущей-выполнения-сервера">Подражание медленного запроса в текущей выполнения сервера</a></h3>
<p>Мы посмотрим, как запрос с медленной обработкой может повлиять на другие запросы, сделанные к серверу в текущей выполнения. В приложении 20-10 выполнена обработка запроса к ресурсу <em>/sleep</em> с эмуляцией медленного ответа, при которой сервер будет ждать 5 секунд перед тем, как ответить.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<p><span class="caption">Приложение 20-10: Подражание медленного запроса с помощью 5-секундной задержки</span></p>
<p>Мы переключились с <code>if</code> на <code>match</code>, так как теперь у нас есть три случая. Нам придётся явно сопоставить срез от <code>request_line</code> для проверки совпадения образца со строковыми записями; <code>match</code> не делает самостоятельно е ссылки и разыменования, как это делает способ равенства.</p>
<p>Первая ветка совпадает с разделом <code>if</code> из приложения 20-9. Вторая ветка соответствует запросу <em>/sleep</em> . Когда этот запрос получен, сервер заснёт на 5 секунд, прежде чем отдать успешную HTML-страницу. Третья ветка совпадает с разделом <code>else</code> из приложения 20-9.</p>
<p>Можно увидеть, насколько прост наш сервер: в существующих библиотеках распознавание разных запросов осуществлялось бы гораздо менее многословно!</p>
<p>Запустите сервер приказом <code>cargo run</code>. Затем откройте два окна браузера: одно с адресом <em>http://127.0.0.1:7878/</em>, другое с <em>http://127.0.0.1:7878/sleep</em>. Если вы несколько раз обратитесь к URI <em>/</em>, то как и раньше увидите, что сервер быстро ответит. Но если вы введёте URI <em>/sleep</em>, а затем загрузите URI <em>/</em>, то увидите что <em>/</em> ждёт, пока <code>/sleep</code> не отработает полные 5 секунд перед загрузкой страницы.</p>
<p>Есть несколько способов, которые можно использовать, чтобы избавиться от подтормаживания запросов после одного медленного запроса; способ, который мы выполняем, называется объединением потоков.</p>
<h3 id="Улучшение-пропускной-способности-с-помощью-объединения-потоков"><a class="header" href="#Улучшение-пропускной-способности-с-помощью-объединения-потоков">Улучшение пропускной способности с помощью объединения потоков</a></h3>
<p><em>Объединение потоков</em> является объединением заранее порождённых потоков, ожидающих в объединении и готовых выполнить задачу. Когда программа получает новую задачу, она назначает эту задачу одному из потоков в объединении, и тогда задача будет обработана этим потоком. Остальные потоки в объединении доступны для обработки любых других задач, поступающих в то время, пока первый поток занят. Когда первый поток завершает обработку своей задачи, он возвращается в объединениесвободных потоков, готовых приступить к новой задаче. Объединение потоков позволяет обрабатывать соединения одновременно, увеличивая пропускную способность вашего сервера.</p>
<p>Мы ограничим число потоков в объединении небольшим числом, чтобы защитить нас от атак вида «отказ в обслуживании» (DoS - Denial of Service); если бы наша программа создавала новый поток в мгновение поступления каждого запроса, то кто-то сделавший 10 миллионов запросов к серверу, мог бы создать хаос, использовать все ресурсы нашего сервера и остановить обработку запросов.</p>
<p>Вместо порождения неограниченного количества потоков, у нас будет определенное количество потоков, ожидающих в объединении. Поступающие запросы будут отправляться в объединениедля обработки. Объединение будет иметь очередь входящих запросов. Каждый из потоков в объединении будет извлекать запрос из этой очереди, обрабатывать запрос и затем запрашивать в очереди следующий запрос. При таком внешнем виде мы можем обрабатывать <code>N</code> запросов одновременно, где <code>N</code> - количество потоков. Если каждый поток отвечает на длительный запрос, последующие запросы могут по-прежнему задержаться в очереди, но теперь мы увеличили количество "длинных" запросов, которые мы можем обработать, перед тем, как эта случаей снова возникнет.</p>
<p>Этот подход - лишь один из многих способов улучшить пропускную способность веб-сервера. Другими исходами, на которые возможно стоило бы обратить внимание, являются: <em>прообраз fork/join</em>, <em>прообраз однопоточного не согласованного ввода-вывода</em> или <em>прообраз многопоточного не согласованного ввода-вывода</em>. Если вам важна эта тема, вы можете почитать больше сведений о других решениях и попробовать выполнить их самостоятельно. С таким низкоуровневым языком как Rust, любой из этих исходов осуществим.</p>
<p>Прежде чем приступить к выполнения объединения потоков, давайте поговорим о том, как должно выглядеть использование объединения . Когда вы пытаетесь создать код, сначала необходимо написать клиентский внешнюю оболочку. Напишите API кода, чтобы он был внутренне выстроен так, как вы хотите его вызывать, затем выполните возможность данной устройства, вместо подхода выполнить возможности. а затем разрабатывать общедоступный API.</p>
<p>Подобно тому, как мы использовали разработку через проверка (test-driven) в деле главы 12, мы будем использовать здесь разработку, управляемую сборщиком (compiler-driven). Мы напишем код, вызывающий нужные нам функции, а затем посмотрим на ошибки сборщика, чтобы определить, что мы должны изменить дальше, чтобы заставить код работать. Однако перед этим, в качестве отправной точки, мы рассмотрим технику, которую мы не будем применять в дальнейшем.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="Порождение-потока-для-каждого-запроса"><a class="header" href="#Порождение-потока-для-каждого-запроса">Порождение потока для каждого запроса</a></h4>
<p>Сначала давайте рассмотрим, как мог бы выглядеть код, если бы он создавал бы новый поток для каждого соединения. Как упоминалось ранее, мы не собираемся использовать этот способ в окончательной выполнения, из-за возможных неполадок при возможно неограниченном числе порождённых потоков. Это лишь отправная точка, с которой начнёт работу наш многопоточный сервер. Затем мы улучшим код, добавив объединениепотоков, и тогда разницу между этими двумя решениями будет легче заметить. В приложении 20-11 показаны изменения, которые нужно внести в код <code>main</code>, чтобы порождать новый поток для обработки каждого входящего соединения внутри цикла <code>for</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-11: Порождение нового потока для каждого соединения</span></p>
<p>Как вы изучили в главе 16, функция <code>thread::spawn</code> создаст новый поток и затем запустит код замыкания в этом новом потоке. Если вы запустите этот код и загрузите <em>/sleep</em> в своём браузере, а затем загрузите <em>/</em> в двух других вкладках браузера, вы действительно увидите, что запросам к <em>/</em> не приходится ждать завершения <em>/sleep</em>. Но, как мы уже упоминали, это в какой-то мгновение приведёт к сильному снижению производительности системы, так как вы будете создавать новые потоки без каких-либо ограничений.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="Создание-конечного-числа-потоков"><a class="header" href="#Создание-конечного-числа-потоков">Создание конечного числа потоков</a></h4>
<p>Мы хотим, чтобы наш объединениепотоков работал подобным, знакомым образом, чтобы переключение с потоков на объединениепотоков не требовало больших изменений в коде использующем наш API. В приложении 20-12 показан гипотетический внешняя оболочка для устройства <code>ThreadPool</code>, который мы хотим использовать вместо <code>thread::spawn</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 20-12: Наш наилучший внешняя оболочка <code>ThreadPool</code></span></p>
<p>Мы используем <code>ThreadPool::new</code>, чтобы создать новый объединениепотоков с конфигурируемым числом потоков, в данном случае четырьмя. Затем в цикле <code>for</code> функция <code>pool.execute</code> имеет внешнюю оболочку, похожий на <code>thread::spawn</code>, в том смысле, что он так же принимает замыкание, код которого объединениедолжен выполнить для каждого соединения. Нам нужно выполнить <code>pool.execute</code>, чтобы он принимал замыкание и передавал его потоку из объединения для выполнения. Этот код пока не собирается, но мы постараемся, чтобы сборщик помог нам это исправить.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="Создание-threadpool-с-помощью-разработки-управляемой-сборщиком"><a class="header" href="#Создание-threadpool-с-помощью-разработки-управляемой-сборщиком">Создание <code>ThreadPool</code> с помощью разработки, управляемой сборщиком</a></h4>
<p>Внесите изменения приложения 20-12 в файл <em>src/main.rs</em>, а затем давайте воспользуемся ошибками сборщика из приказы <code>cargo check</code> для управления нашей разработкой. Вот первая ошибка, которую мы получаем:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Замечательно! Ошибка говорит о том, что нам нужен вид или звено <code>ThreadPool</code>, поэтому мы сейчас его создадим. Наша выполнение <code>ThreadPool</code> не будет зависеть от того, что делает наш веб-сервер. Итак, давайте переделаем ящик <code>hello</code> из двоичного в библиотечный, чтобы хранить там нашу выполнение <code>ThreadPool</code>. После того, как мы переключимся в библиотечный ящик, мы также сможем использовать отдельную библиотеку объединения потоков для любой подходящей работы, а не только для обслуживания веб-запросов.</p>
<p>Создайте файл <em>src/lib.rs</em>, который содержит следующий код, который является простейшим определением устройства <code>ThreadPool</code>, которое мы можем иметь на данный мгновение:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
<p>Затем изменените файл <em>main.rs</em>, чтобы внести <code>ThreadPool</code>  из библиотечного ящика в текущую область видимости, добавив следующий код в начало <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p>Этот код по-прежнему не будет работать, но давайте проверим его ещё раз, чтобы получить следующую ошибку, которую нам нужно устранить:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Эта ошибка указывает, что далее нам нужно создать сопряженную функцию с именем <code>new</code> для <code>ThreadPool</code>. Мы также знаем, что <code>new</code> должна иметь один свойство, который может принимать <code>4</code> в качестве переменной и должен возвращать образец <code>ThreadPool</code>. Давайте выполняем простейшую функцию <code>new</code>, которая будет иметь эти свойства:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
<p>Мы выбираем <code>usize</code> в качестве вида свойства <code>size</code>, потому что мы знаем, что отрицательное число потоков не имеет никакого смысла. Мы также знаем, что мы будем использовать число 4 в качестве количества элементов в собрания потоков, для чего предназначен вид <code>usize</code>, как обсуждалось в разделе <a href="ch03-02-data-types.html#integer-types">"Целочисленные виды"</a><!--  --> главы 3.</p>
<p>Давайте проверим код ещё раз:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Теперь мы ошибка возникает из-за того, что у нас нет способа <code>execute</code> в устройстве <code>ThreadPool</code>. Вспомните раздел <a href="ch20-02-multithreaded.html#creating-a-finite-number-of-threads">"Создание конечного числа потоков"</a><!-- ignore -->, в котором мы решили, что наш объединениепотоков должен иметь внешнюю оболочку, похожий на <code>thread::spawn</code>. Кроме того, мы выполняем функцию <code>execute</code>, чтобы она принимала замыкание и передавала его свободному потоку из объединения для запуска.</p>
<p>Мы определим способ <code>execute</code> у <code>ThreadPool</code>, принимающий замыкание в качестве свойства. Вспомните из раздела <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">"Перемещение захваченных значений из замыканий и особенности <code>Fn</code>"</a> <!-- ignore --> главы 13 сведения о том, что мы можем принимать замыкания в качестве свойств тремя различными особенностями: <code>Fn</code> , <code>FnMut</code> и <code>FnOnce</code>. Нам нужно решить, какой вид замыкания использовать здесь. Мы знаем, что в конечном счёте мы сделаем что-то похожее на выполнение встроенной библиотеки <code>thread::spawn</code>, поэтому мы можем посмотреть, какие ограничения накладывает на свой свойство ярлык функции <code>thread::spawn</code>. Документация показывает следующее:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Свойство вида <code>F</code> - это как раз то, что нас важно; свойство вида <code>T</code> относится к возвращаемому значению и нам он не важен. Можно увидеть, что <code>spawn</code> использует <code>FnOnce</code> в качестве ограничения особенности у <code>F</code>. Возможно это как раз то, чего мы хотим, так как в конечном итоге мы передадим полученный в <code>execute</code> переменная в функцию <code>spawn</code>. Дополнительную уверенность в том, что <code>FnOnce</code> - это именно тот особенность, который мы хотим использовать, нам даётобстоятельство, что поток для выполнения запроса будет выполнять замыкание этого запроса только один раз, что соответствует части  <code>Once</code> ("единожды") в названии особенности <code>FnOnce</code>.</p>
<p>Свойство вида <code>F</code> также имеет ограничение особенности <code>Send</code> и ограничение времени жизни <code>'static</code>, которые полезны в нашей случаи: нам нужен <code>Send</code> для передачи замыкания из одного потока в другой и <code>'static</code>, потому что мы не знаем, сколько времени поток будет выполняться. Давайте создадим способ <code>execute</code> для <code>ThreadPool</code>, который будет принимать обобщённый свойство вида <code>F</code> со следующими ограничениями:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
<p>Мы по-прежнему используем <code>()</code> после <code>FnOnce</code> потому что особенность <code>FnOnce</code> представляет замыкание, которое не принимает свойств и возвращает единичный вид <code>()</code>. Также как и при определении функций, вид возвращаемого значения в ярлыке может быть опущен, но даже если у нас нет свойств, нам все равно нужны скобки.</p>
<p>Опять же, это самая простая выполнение способа <code>execute</code>: она ничего не делает, мы просто пытаемся сделать код собираемым. Давайте проверим снова:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>Сейчас мы получаем только предупреждения, что означает, что код собирается! Но обратите внимание, если вы попробуете <code>cargo run</code> и сделаете запрос в браузере, вы увидите ошибки в браузере, которые мы видели в начале главы. Наша библиотека на самом деле ещё не вызывает замыкание, переданное в <code>execute</code>!</p>
<blockquote>
<p>Примечание: вы возможно слышали высказывание о языках со строгими сборщиками, таких как Haskell и Rust, которое звучит так: «Если код собирается, то он работает». Но это высказывание не всегда верно. Наш дело собирается, но абсолютно ничего не делает! Если бы мы создавали существующий, законченный дело, это был бы хороший мгновение начать писать состоящие из звеньев проверки, чтобы проверять, что код собирается <em>и</em> имеет желаемое поведение.</p>
</blockquote>
<h4 id="Проверка-количества-потоков-в-new"><a class="header" href="#Проверка-количества-потоков-в-new">Проверка количества потоков в <code>new</code></a></h4>
<p>Мы ничего не делаем с свойствами <code>new</code> и <code>execute</code>. Давайте выполняем тела этих функций с нужным нам поведением. Для начала давайте подумаем о <code>new</code>. Ранее мы выбрали беззнаковый вид для свойства <code>size</code>, потому что объединениес отрицательным числом потоков не имеет смысла. Объединение с нулём потоков также не имеет смысла, однако ноль - это вполне допустимое значение <code>usize</code>. Мы добавим код для проверки того, что <code>size</code> больше нуля, прежде чем вернуть образец <code>ThreadPool</code>, и заставим программу паниковать, если она получит ноль, используя макрос <code>assert!</code>, как показано в приложении 20-13.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Приложение 20-13: Выполнение <code>ThreadPool::new</code> с со сбоем завершениям работы, если <code>size</code> равен нулю</span></p>
<p>Мы добавили немного документации для нашей устройства <code>ThreadPool</code> с помощью примечаниев. Обратите внимание, что мы следовали хорошим применением документирования, добавив раздел, в котором указывается случаей, при которой функция может со сбоем завершаться, как это обсуждалось в главе 14. Попробуйте запустить <code>cargo doc --open</code> и кликнуть на устройство <code>ThreadPool</code>, чтобы увидеть как выглядит созданная документация для <code>new</code>!</p>
<p>Вместо добавления макроса <code>assert!</code>, как мы здесь сделали, мы могли бы преобразовать функцию <code>new</code> в функцию <code>build</code> таким образом, чтобы она возвращала <code>Result</code> , подобно тому, как мы делали в функции <code>Config::new</code> дела ввода/вывода в приложении 12-9. Но в данном случае мы решили, что попытка создания объединения потоков без указания хотя бы одного потока должна быть непоправимой ошибкой. Если вы чувствуете такое стремление, попробуйте написать функцию <code>build</code>  с ярлыком ниже, для сравнения с функцией <code>new</code>:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="Создание-места-для-хранения-потоков"><a class="header" href="#Создание-места-для-хранения-потоков">Создание места для хранения потоков</a></h4>
<p>Теперь, имея возможность удостовериться, что количество потоков для хранения в объединении соответствует требованиям, мы можем создавать эти потоки и сохранять их в устройстве <code>ThreadPool</code> перед тем как возвратить её. Но как мы "сохраним" поток? Давайте ещё раз посмотрим на ярлык <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Функция <code>spawn</code> возвращает вид <code>JoinHandle&lt;T&gt;</code>, где <code>T</code> является видом, который возвращает замыкание. Давайте попробуем использовать <code>JoinHandle</code> и посмотрим, что произойдёт. В нашем случае замыкания, которые мы передаём объединению потоков, будут обрабатывать соединение и не будут возвращать ничего, поэтому <code>T</code> будет единичным (unit) видом <code>()</code>.</p>
<p>Код в приложении 20-14 собирается, но пока не создаст ни одного потока. Мы изменили определение <code>ThreadPool</code> так, чтобы он содержал вектор образцов <code>thread::JoinHandle&lt;()&gt;</code>, объявляли вектор ёмкостью <code>size</code>, установили цикл <code>for</code>, который будет выполнять некоторый код для создания потоков, и вернули образец <code>ThreadPool</code>, содержащий их.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Приложение 20-14: Создание вектора в <code>ThreadPool</code> для хранения потоков</span></p>
<p>Мы включили <code>std::thread</code> в область видимости библиотечного ящика, потому что мы используем <code>thread::JoinHandle</code> в качестве вида элементов вектора в <code>ThreadPool</code>.</p>
<p>После получения правильного значения size, наш <code>ThreadPool</code> создаёт новый вектор, который может содержать <code>size</code> элементов. Функция <code>with_capacity</code> выполняет ту же задачу, что и <code>Vec::new</code>, но с важным отличием: она заранее выделяет необходимый объём памяти в векторе. Поскольку мы знаем, что нам нужно хранить <code>size</code> элементов в векторе, предварительное выделение памяти для этих элементов будет немного более эффективным, чем использование <code>Vec::new</code>, при котором размер вектора будет увеличиваться по мере вставки элементов.</p>
<p>Если вы снова запустите приказ <code>cargo check</code>, она должна завершиться успешно.</p>
<h4 id="Устройства-worker-ответственная-за-отправку-кода-из-threadpool-в-поток"><a class="header" href="#Устройства-worker-ответственная-за-отправку-кода-из-threadpool-в-поток">Устройства <code>Worker</code>, ответственная за отправку кода из <code>ThreadPool</code> в поток</a></h4>
<p>Мы целенаправленно оставили примечание в цикле <code>for</code> в Приложении 20-14 по поводу создания потоков. Сейчас мы разберёмся, как на самом деле создаются потоки. Обычная библиотека предоставляет <code>thread::spawn</code> для создания потоков, причём <code>thread::spawn</code> ожидает получить некоторый код, который поток должен выполнить, как только он будет создан. Однако в нашем случае мы хотим создавать потоки и заставлять их <em>ожидать</em> код, который мы будем передавать им позже. Выполнение потоков в встроенной библиотеке не предоставляет никакого способа сделать это, мы должны выполнить это вручную.</p>
<p>Мы будем выполнить это поведение, добавив новую устройство данных между <code>ThreadPool</code> и потоками, которая будет управлять этим новым поведением. Мы назовём эту устройство <code>Worker</code> ("работник"), это общепринятое имя в выполнения объединений. Работник берёт код, который нужно выполнить, и запускает этот код внутри рабочего потока. Представьте людей, работающих на кухне ресторана: работники ожидают, пока не поступят заказы от клиентов, а затем они несут ответственность за принятие этих заказов и их выполнение.</p>
<p>Вместо того чтобы хранить вектор образцов <code>JoinHandle&lt;()&gt;</code> в объединении потоков, мы будем хранить образцы устройства <code>Worker</code>. Каждый <code>Worker</code> будет хранить один образец <code>JoinHandle&lt;()&gt;</code>. Затем мы выполняем способ у <code>Worker</code>, который будет принимать замыкание и отправлять его в существующий поток для выполнения. Для того чтобы мы могли различать работники в объединении при логировании или отладке, мы также присвоим каждому работнику <code>id</code>.</p>
<p>Вот как выглядит новая последовательность действий, которые будут происходить при создании <code>ThreadPool</code>. Мы выполняем код, который будет отправлять замыкание в поток, после того, как у нас будет <code>Worker</code> , заданный следующим образом:</p>
<ol>
<li>Определим устройство <code>Worker</code>, которая содержит <code>id</code> и <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Изменим <code>ThreadPool</code>, чтобы он содержал вектор образцов <code>Worker</code>.</li>
<li>Определим функцию <code>Worker::new</code>, которая принимает номер <code>id</code> и возвращает образец <code>Worker</code>, который содержит <code>id</code> и поток, порождённый с пустым замыканием.</li>
<li>В <code>ThreadPool::new</code> используем счётчик цикла <code>for</code> для создания <code>id</code>, создаём новый <code>Worker</code> с этим <code>id</code> и сохраняем образец "работника" в вектор.</li>
</ol>
<p>Если вы готовы принять вызов, попробуйте выполнить эти изменения самостоятельно, не глядя на код в приложении 20-15.</p>
<p>Готовы? Вот приложение 20-15 с одним из способов сделать указанные ранее изменения.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Приложение 20-15: Изменение <code>ThreadPool</code> для хранения образцов <code>Worker</code> вместо непосредственного хранения потоков</span></p>
<p>Мы изменили название поля в <code>ThreadPool</code> с <code>threads</code> на <code>workers</code>, поскольку теперь оно содержит образцы <code>Worker</code> вместо образцов <code>JoinHandle&lt;()&gt;</code>. Мы используем счётчик в цикле <code>for</code> для передачи цифрового определителя в качестве переменной <code>Worker::new</code>, и сохраняем каждый новый <code>Worker</code> в векторе с именем <code>workers</code>.</p>
<p>Внешний код (вроде нашего сервера в <em>src/bin/main.rs</em>) не обязательно должен знать подробности выполнения, касающиеся использования устройства <code>Worker</code> внутри <code>ThreadPool</code>, поэтому мы делаем устройство <code>Worker</code> и её функцию <code>new</code> закрытыми. Функция <code>Worker::new</code> использует заданный нами <code>id</code> и сохраняет образец <code>JoinHandle&lt;()&gt;</code>, который создаётся при порождении нового потока с пустым замыканием.</p>
<blockquote>
<p>Примечание: Если операционная система не может создать поток из-за нехватки системных ресурсов, <code>thread::spawn</code> со сбоем завершится. Это приведёт к со сбоемму завершению нашего сервера целиком, даже если некоторые потоки были созданы успешно. Для простоты будем считать, что нас устраивает такое поведение, но в существующей выполнения объединения потоков вы, вероятно, захотите использовать <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> и его способ <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore -->, который вместо этого возвращает <code>Result</code> .</p>
</blockquote>
<p>Этот код собирается и будет хранить количество образцов <code>Worker</code>, которое мы указали в качестве переменной функции <code>ThreadPool::new</code>. Но мы всё <em>ещё</em> не обрабатываем замыкание, которое мы получаем в способе <code>execute</code>. Давайте посмотрим, как это сделать далее.</p>
<h4 id="Отправка-запросов-в-потоки-через-потоки"><a class="header" href="#Отправка-запросов-в-потоки-через-потоки">Отправка запросов в потоки через потоки</a></h4>
<p>Следующая неполадка, с которой мы будем бороться, заключается в том, что замыкания, переданные в <code>thread::spawn</code> абсолютно ничего не делают. Сейчас мы получаем замыкание, которое хотим выполнить, в способе <code>execute</code>. Но мы должны передать какое-то замыкание в способ <code>thread::spawn</code>, при создании каждого <code>Worker</code>  во время создания <code>ThreadPool</code>.</p>
<p>Мы хотим, чтобы вновь созданные устройства <code>Worker</code> извлекали код для запуска из очереди, хранящейся в <code>ThreadPool</code> и отправляли этот код в свой поток для выполнения.</p>
<p>потоки (channels), простой способ связи между двумя потоками, с которыми мы познакомились в главе 16, кажется наилучше подойдут для этого сценария. Мы будем использовать поток в качестве очереди заданий, а приказ <code>execute</code> отправит задание из <code>ThreadPool</code> образцам <code>Worker</code>, которые будут отправлять задание в свой поток. Расчет таков:</p>
<ol>
<li><code>ThreadPool</code> создаст поток и будет хранить отправитель.</li>
<li>Каждый <code>Worker</code> будет хранить приёмник.</li>
<li>Мы создадим новую устройство <code>Job</code>, которая будет хранить замыкания, которые мы хотим отправить в поток.</li>
<li>Способ <code>execute</code> отправит задание, которое он хочет выполнить, в отправляющую сторону потока.</li>
<li>В своём потоке <code>Worker</code> будет замкнуто опрашивать принимающую сторону потока и выполнять замыкание любого задания, которое он получит.</li>
</ol>
<p>Давайте начнём с создания потока в <code>ThreadPool::new</code> и удержания отправляющей стороны в образце <code>ThreadPool</code>, как показано в приложении 20-16. В устройстве <code>Job</code> сейчас ничего не содержится, но это будет вид элемента, который мы отправляем в поток.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 20-16: Изменение <code>ThreadPool</code> для хранения отправляющей части потока, который отправляет образцы <code>Job</code></span></p>
<p>В <code>ThreadPool::new</code> мы создаём наш новый поток и сохраняем в объединении его отправляющую сторону. Код успешно собирается.</p>
<p>Давайте попробуем передавать принимающую сторону потока каждому "работнику" (устройстве Worker), когда объединениепотоков создаёт поток. Мы знаем, что хотим использовать получающую часть потока в потоке, порождаемым "работником", поэтому мы будем ссылаться на свойство <code>receiver</code> в замыкании. Код 20-17 пока не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Приложение 20-17: Передача принимающей части потока "работникам"</span></p>
<p>Мы внесли несколько небольших и простых изменений: мы передаём принимающую часть потока в <code>Worker::new</code>, а затем используем его внутри замыкания.</p>
<p>При попытке проверить код, мы получаем ошибку:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>Код пытается передать <code>receiver</code> нескольким образцам <code>Worker</code>. Это не сработает, поскольку, как вы можете помнить из главы 16: выполнение потока, которую предоставляет Ржавчина - несколько <em>производителей</em>, один <em>потребитель</em>. Это означает, что мы не можем просто клонировать принимающую сторону потока, чтобы исправить этот код. Кроме этого, мы не хотим отправлять одно и то же сообщение нескольким потребителям, поэтому нам нужен единый список сообщений для множества обработчиков, чтобы каждое сообщение обрабатывалось лишь один раз.</p>
<p>Кроме того, удаление задачи из очереди потока включает изменение <code>receiver</code>, поэтому потокам необходим безопасный способ делиться и изменять <code>receiver</code>, в противном случае мы можем получить условия гонки (как описано в главе 16).</p>
<p>Вспомните умные указатели, которые обсуждались в главе 16: чтобы делиться владением между несколькими потоками и разрешать потокам изменять значение, нам нужно использовать вид <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Вид <code>Arc</code> позволит нескольким "работникам" владеть получателем (receiver), а <code>Mutex</code> заверяет что только один "работник" сможет получить задание (job) от получателя за раз. Приложение 20-18 показывает изменения, которые мы должны сделать.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<p><span class="caption">Приложение 20-18. Совместное использование приёмника в "работниках" с применением <code>Arc</code> и <code>Mutex</code></span></p>
<p>В <code>ThreadPool::new</code> мы помещаем принимающую сторону потока внутрь <code>Arc</code> и <code>Mutex</code>. Для каждого нового "работника" мы клонируем <code>Arc</code>, чтобы увеличить счётчик ссылок так, что "работники" могут разделять владение принимающей стороной потока.</p>
<p>С этими изменениями код собирается! Мы подбираемся к цели!</p>
<h4 id="Выполнение-способа-execute"><a class="header" href="#Выполнение-способа-execute">Выполнение способа <code>execute</code></a></h4>
<p>Давайте выполняем наконец способ <code>execute</code> у устройства <code>ThreadPool</code>. Мы также изменим вид <code>Job</code> со устройства на псевдоним вида для особенность-предмета. который будет содержать вид замыкания, принимаемый способом <code>execute</code>. Как описано в разделе <a href="ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">"Создание родственных вида с помощью псевдонимов типа"</a><!-- ignore --> главы 19, псевдонимы видов позволяют делать длинные виды короче, облегчая их использование. Посмотрите на приложение 20-19.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 20-19: Создание псевдонима вида <code>Job</code> для указателя <code>Box</code>, содержащего каждое замыкание и затем отправляющее задание (job) в поток</span></p>
<p>После создания нового образца <code>Job</code> с замыканием, полученным в <code>execute</code>, мы посылаем его через отправляющий конец потока. На тот случай, если отправка не удастся, вызываем <code>unwrap</code> у <code>send</code>. Это может произойти, например, если мы остановим выполнение всех наших потоков, что означает, что принимающая сторона прекратила получать новые сообщения. На данный мгновение мы не можем остановить выполнение наших потоков: наши потоки будут исполняться до тех пор, пока существует объединение Причина, по которой мы используем <code>unwrap</code>, заключается в том, что, хотя мы знаем, что сбой не произойдёт, сборщик этого не знает.</p>
<p>Но мы ещё не закончили! В "работнике" (worker) наше замыкание, переданное в <code>thread::spawn</code> все ещё <em>ссылается</em> только на принимающую сторону потока. Вместо этого нам нужно, чтобы замыкание работало в бесконечном цикле, запрашивая задание у принимающей части потока и выполняя задание, когда оно принято. Давайте внесём изменения, показанные в приложении 20-20 внутри <code>Worker::new</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Приложение 20-20: Получение и выполнение заданий в потоке "работника"</span></p>
<p>Здесь мы сначала вызываем <code>lock</code> у <code>receiver</code>, чтобы получить мьютекс, а затем вызываем <code>unwrap</code>, чтобы со сбоем завершить работу при любых ошибках. Захват блокировки может завершиться неудачей, если мьютекс находится в <em>отравленном</em> состоянии (poisoned state), что может произойти, если какой-то другой поток завершился со сбоем, удерживая блокировку, вместо снятия блокировки. В этой случаи вызвать <code>unwrap</code> для со сбоемго завершения потока вполне оправдано. Не стесняйтесь заменить <code>unwrap</code> на <code>expect</code> с сообщением об ошибке, которое имеет для вас значение.</p>
<p>Если мы получили блокировку мьютекса, мы вызываем <code>recv</code>, чтобы получить <code>Job</code> из потока. Последний вызов <code>unwrap</code> позволяет миновать любые ошибки, которые могут возникнуть, если поток, управляющий отправитель, прекратил исполняться, подобно тому, как способ <code>send</code> возвращает <code>Err</code>, если получатель не принимает сообщение.</p>
<p>Вызов <code>recv</code> - блокирующий, поэтому пока задач нет, текущий поток будет ждать, пока задача не появится. <code>Mutex&lt;T&gt;</code> заверяет, что только один поток <code>Worker</code> за раз попытается запросить задачу.</p>
<p>Наш объединениепотоков теперь находится в рабочем состоянии! Выполните <code>cargo run</code> и сделайте несколько запросов:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Успех! Теперь у нас есть объединениепотоков, который обрабатывает соединения не согласованно. Никогда не создаётся более четырёх потоков, поэтому наша система не будет перегружена, если сервер получит много запросов. Если мы отправим запрос ресурса <em>/sleep</em>, сервер сможет обслуживать другие запросы, обрабатывая их в другом потоке.</p>
<blockquote>
<p>Примечание: если вы запросите <em>/sleep</em> в нескольких окнах браузера одновременно, они могут загружаться по одному, с интервалами в 5 секунд. Некоторые веб-браузеры выполняют несколько образцов одного и того же запроса последовательно из-за кэширования. Такое ограничение не связано с работой нашего веб-сервера.</p>
</blockquote>
<p>После изучения цикла <code>while let</code> в главе 18 вы можете удивиться, почему мы не написали код рабочего потока (worker thread), как показано в приложении 20-22.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Приложение 20-22: Иная выполнение <code>Worker::new</code> с использованием <code>while let</code></span></p>
<p>Этот код собирается и запускается, но не даёт желаемого поведения: медленный запрос всё равно приведёт к тому, что другие запросы будут ждать обработки. Причина здесь несколько тоньше: устройства <code>Mutex</code> не имеет открытого способа <code>unlock</code>, так как владение блокировкой основано на времени жизни <code>MutexGuard&lt;T&gt;</code> внутри <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>, которое возвращает способ <code>lock</code>. Во время сборки анализатор заимствований может проследить за выполнением правила, согласно которому к ресурсу, охраняемому <code>Mutex</code>, нельзя получить доступ пока мы удерживаем блокировку. Однако в этой выполнение мы также можем получить случай, когда блокировка будет удерживаться дольше, чем предполагалось, если мы не будем внимательно учитывать время жизни <code>MutexGuard&lt;T&gt;</code>.</p>
<p>Код в приложении 20-20, использующий <code>let job = receiver.lock().unwrap().recv().unwrap();</code> работает, потому что при использовании <code>let</code> любые промежуточные значения, используемые в выражении справа от знака равенства, немедленно уничтожаются после завершения указания <code>let</code>. Однако <code>while let</code> (и <code>if let</code> и <code>match</code>) не удаляет временные значения до конца связанного раздела. Таким образом, в приложении 20-21 блокировка не снимается в течение всего времени вызова <code>job()</code>, что означает, что другие работники не могут получать задания.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Мягкое-завершение-работы-и-очистка"><a class="header" href="#Мягкое-завершение-работы-и-очистка">Мягкое завершение работы и очистка</a></h2>
<p>Приложение 20-20 не согласованно отвечает на запросы с помощью использования объединения потоков, как мы и хотели. Мы получаем некоторые предупреждения про <code>workers</code>, <code>id</code> и поля <code>thread</code>, которые мы не используем напрямую, что напоминает нам о том, что мы не освобождаем все ресурсы. Когда мы используем менее элегантный способ остановки основного потока клавишной сочетанием <span class="keystroke">ctrl-c</span>, все остальные потоки также немедленно останавливаются, даже если они находятся в середине обработки запроса.</p>
<p>Далее, выполняем особенность  <code>Drop</code> для вызова <code>join</code> у каждого потока в объединении, чтобы они могли завершить запросы, над которыми они работают, перед закрытием. Затем мы выполняем способ сообщить потокам, что они должны перестать принимать новые запросы и завершить работу. Чтобы увидеть этот код в действии, мы изменим наш сервер так, чтобы он принимал только два запроса, после чего правильно завершал работу объединения потоков.</p>
<h3 id="Выполнение-особенности-drop-для-threadpool"><a class="header" href="#Выполнение-особенности-drop-для-threadpool">Выполнение особенности <code>Drop</code> для <code>ThreadPool</code></a></h3>
<p>Давайте начнём с выполнения <code>Drop</code> у нашего объединения потоков. Когда объединениеудаляется, все наши потоки должны объединиться (join), чтобы убедиться, что они завершают свою работу. В приложении 20-22 показана первая попытка выполнения <code>Drop</code>, код пока не будет работать.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 20-22: Присоединение (Joining) каждого потока, когда объединениепотоков выходит из области видимости</span></p>
<p>Сначала мы пройдёмся по каждому <code>worker</code> из объединения потоков. Для этого мы используем <code>&amp;mut</code> с <code>self</code>, потому что нам нужно иметь возможность изменять <code>worker</code>. Для каждого обработчика мы выводим сообщение о том, что он завершает работу, а затем вызываем <code>join</code> у потока этого обработчика. Для случаев, когда вызов <code>join</code> не удался, мы используем <code>unwrap</code>, чтобы заставить Ржавчина запаниковать и перейти в режим грубого завершения работы.</p>
<p>Ошибка получаемая при сборки этого кода:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
  --&gt; /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/thread/mod.rs:1718:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>Ошибка говорит нам, что мы не можем вызвать <code>join</code>, потому что у нас есть только изменяемое заимствование каждого <code>worker</code>, а <code>join</code> забирает во владение свой переменная. Чтобы решить эту неполадку, нам нужно извлечь поток из образца <code>Worker</code>, который владеет <code>thread</code>, чтобы <code>join</code> мог его использовать. Мы сделали это в приложении 17-15: теперь, когда <code>Worker</code> хранит в себе <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, мы можем воспользоваться способом <code>take</code> у <code>Option</code>, чтобы извлечь значение из исхода <code>Some</code>, тем самым оставляя на его месте <code>None</code>. Другими словами, в рабочем состоянии <code>Worker</code> будет использовать исход <code>Some</code> содержащий <code>thread</code>, а когда мы захотим завершить <code>Worker</code>, мы заменим <code>Some</code> на <code>None</code>, чтобы у <code>Worker</code> не было потока для работы.</p>
<p>Итак, мы хотим обновить объявление <code>Worker</code> следующим образом:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!("Shutting down worker {}", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Теперь давайте опираться на сборщик, чтобы найти другие места, которые нужно изменить. Проверяя код, мы получаем две ошибки:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`
   |
note: the method `join` exists on the type `JoinHandle&lt;()&gt;`
  --&gt; /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/thread/mod.rs:1718:5
help: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect("REASON").join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected `Option&lt;JoinHandle&lt;()&gt;&gt;`, found `JoinHandle&lt;_&gt;`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` (lib) due to 2 previous errors
</code></pre>
<p>Давайте обратимся ко второй ошибке, которая указывает на код в конце <code>Worker::new</code>; нам нужно обернуть значение <code>thread</code> в исход <code>Some</code> при создании нового <code>Worker</code>. Внесите следующие изменения, чтобы исправить эту ошибку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!("Shutting down worker {}", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>Первая ошибка находится в нашей выполнения <code>Drop</code>. Ранее мы упоминали, что намеревались вызвать <code>take</code> для свойства <code>Option</code>, чтобы забрать <code>thread</code> из этапа <code>worker</code>. Следующие изменения делают это:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Как уже говорилось в главе 17, способ <code>take</code> у вида <code>Option</code> забирает значение из исхода <code>Some</code> и оставляет исход <code>None</code> в этом месте. Мы используем <code>if let</code>, чтобы разъединять <code>Some</code> и получить поток; затем вызываем <code>join</code> у потока. Если поток "работника" уже <code>None</code>, мы знаем, что этот "работник" уже очистил свой поток, поэтому в этом случае ничего не происходит.</p>
<h3 id="Тревожное-оповещение-потокам-прекратить-прослушивание-получения-задач"><a class="header" href="#Тревожное-оповещение-потокам-прекратить-прослушивание-получения-задач">Тревожное оповещение потокам прекратить прослушивание получения задач</a></h3>
<p>Теперь, после всех внесённых нами изменений, код собирается без каких-либо предупреждений. Но плохая новость в том, что этот код всё ещё не работает так, как мы этого хотим. Причина заключается в логике замыканий, запускаемых потоками образцов Worker: в данный мгновение мы вызываем join, но это не приводит к завершению потоков, так как они находятся в бесконечном цикле, ожидая новую задачу. Если мы попытаемся удалить ThreadPool в текущей выполнения drop, основной поток навсегда заблокируется в ожидании завершения первого потока из объединения .</p>
<p>Чтобы решить эту неполадку, нам нужно будет изменить выполнение <code>drop</code> в <code>ThreadPool</code>, а затем внести изменения в цикл <code>Worker</code> .</p>
<p>Во-первых, изменим выполнение <code>drop</code> <code>ThreadPool</code> таким образом, чтобы явно удалять <code>sender</code> перед тем, как начнём ожидать завершения потоков. В приложении 20-23 показаны изменения в <code>ThreadPool</code> для явного удаления <code>sender</code> . Мы используем ту же технику <code>Option</code> и <code>take</code>, что и с потоком, чтобы переместить <code>sender</code> из <code>ThreadPool</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 20-23. Явное удаление <code>sender</code> перед ожиданием завершения рабочих потоков</span></p>
<p>Удаление <code>sender</code> закрывает поток, что указывает на то, что сообщения больше не будут отправляться. Когда это произойдёт, все вызовы <code>recv</code>, выполняемые рабочими этапами в бесконечном цикле, вернут ошибку. В приложении 20-24 мы меняем цикл <code>Worker</code> для правильного выхода из него в этом случае, что означает, что потоки завершатся, когда выполнение <code>drop</code> <code>ThreadPool</code> вызовет для них <code>join</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!("Shutting down worker {}", worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p><span class="caption">Приложение 20-24: Явный выход из цикла, когда <code>recv</code> возвращает ошибку</span></p>
<p>Чтобы увидеть этот код в действии, давайте изменим <code>main</code>, чтобы принимать только два запроса, прежде чем правильно завершить работу сервера как показано в приложении 20-25.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Код 20-25. Выключение сервера после обслуживания двух запросов с помощью выхода из цикла</span></p>
<p>Вы бы не хотели, чтобы существующий веб-сервер отключался после обслуживания только двух запросов. Этот код всего лишь отображает, что правильное завершение работы и освобождение ресурсов находятся в рабочем состоянии.</p>
<p>Способ <code>take</code> определён в особенности <code>Iterator</code> и ограничивает повторение самое большее первыми двумя элементами. <code>ThreadPool</code> выйдет из области видимости в конце <code>main</code> и будет запущена его выполнение <code>drop</code>.</p>
<p>Запустите сервер с <code>cargo run</code> и сделайте три запроса. Третий запрос должен выдать ошибку и в окне вызова вы должны увидеть вывод, подобный следующему:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Вы возможно увидите другой порядок рабочих потоков и напечатанных сообщений. Мы можем увидеть, как этот код работает по сообщениям: "работники" номер 0 и 3 получили первые два запроса. Сервер прекратил принимать соединения после второго подключения, а выполнение <code>Drop</code> для <code>ThreadPool</code> начинает выполняется ещё тогда, когда как работник 3 даже не приступил к выполнению своей работы. Удаление <code>sender</code> отключает все рабочие потоки от потока и просит их завершить работу. Каждый рабочий поток при отключении печатает сообщение, а затем объединениепотоков вызывает <code>join</code>, чтобы дождаться, пока каждый из рабочих потоков завершится.</p>
<p>Обратите внимание на один важная особенность этого определенного запуска: ThreadPool удалил <code>sender</code>, и прежде чем какой-либо из работников получил ошибку, мы попытались присоединить (join) рабочий поток с номером 0. Рабочий поток 0 ещё не получил ошибку от <code>recv</code>, поэтому основной поток заблокировался, ожидания завершения потока работника 0. Тем временем, работник 3 получил задание, а затем каждый из рабочих потоков получил ошибку. Когда рабочий поток 0 завершился, основной поток ждал окончания завершения выполнения остальных рабочих потоков. В этот мгновение все они вышли из своих циклов и остановились.</p>
<p>Примите поздравления! Теперь мы завершили дело; у нас есть основной веб-сервер, использующий объединениепотоков для не согласованных ответов. Мы можем выполнить правильное завершение работы сервера, очистив все потоки в объединении.</p>
<p>Вот полный код для справки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>Мы могли бы сделать ещё больше! Если вы хотите продолжить совершенствование этого дела, вот несколько мыслей:</p>
<ul>
<li>Добавьте больше документации в <code>ThreadPool</code> и его открытые способы.</li>
<li>Добавьте проверки для возможностей, исполняемого библиотекой.</li>
<li>Замените вызовы <code>unwrap</code> на более устойчивую обработку ошибок.</li>
<li>Используйте <code>ThreadPool</code> для выполнения некоторых других задач, помимо обслуживания веб-запросов.</li>
<li>На <a href="https://crates.io/">crates.io</a> найдите ящик для работы с объединениями потоков и на его основе выполните подобный веб-сервер. Затем сравните его API и надёжность с выполненным нами объединением потоков.</li>
</ul>
<h2 id="Итоги-17"><a class="header" href="#Итоги-17">Итоги</a></h2>
<p>Отличная работа! Вы сделали это к концу книги! Мы хотим поблагодарить вас за то, что присоединились к нам в этом путешествии по языку Rust. Теперь вы готовы выполнить свои собственные дела на Ржавчина и помочь с делами другим людям. Имейте в виду, что сообщество Ржавчина разработчиков довольно гостеприимно, они с удовольствием постараются помочь вам с любыми трудностями, с которыми вы можете столкнуться в своём путешествии по Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Дополнительная-сведения"><a class="header" href="#Дополнительная-сведения">Дополнительная сведения</a></h1>
<p>Следующие разделы содержат справочные источники, которые могут оказаться полезными в вашем путешествии по Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приложение-a-Ключевые-слова"><a class="header" href="#Приложение-a-Ключевые-слова">Приложение A: Ключевые слова</a></h2>
<p>Следующий список содержит ключевые слова, зарезервированные для текущего или будущего использования в языке Rust. Как таковые их нельзя использовать в качестве определителей (за исключением сырых определителей, которые мы обсудим в разделе <a href="appendix-01-keywords.html#raw-identifiers">«Сырые определители</a><!-- ignore -->»). определительы — это имена функций, переменных, свойств, полей устройств, звеньев, ящиков, постоянных значений, макросов, постоянных значений, свойств, видов, свойств или времён жизни.</p>
<h3 id="Используемые-в-настоящее-время-ключевые-слова"><a class="header" href="#Используемые-в-настоящее-время-ключевые-слова">Используемые в настоящее время ключевые слова</a></h3>
<p>Ниже приведён список используемых в настоящее время ключевых слов с их описанием.</p>
<ul>
<li><code>as</code> — выполнить простое преобразование, уточнить определенную свойство, которую содержит предмет, или переименовать элемент в выражении <code>use</code></li>
<li><code>async</code> — возврат <code>Future</code> вместо блокировки текущего потока</li>
<li><code>await</code> — остановка выполнения до готовности итога <code>Future</code></li>
<li><code>break</code> — немедленный выход из цикла</li>
<li><code>const</code> — определение постоянного элемента или неизменяемого сырого указателя</li>
<li><code>continue</code> — досрочный переход к следующей повторения цикла</li>
<li><code>crate</code> — ссылка на корень дополнения в пути к звену</li>
<li><code>dyn</code> — изменяемая отсылка к особенности предмета</li>
<li><code>else</code> — иные  ветви для устройств управления потока <code>if</code> и <code>if let</code></li>
<li><code>enum</code> — определение перечислений</li>
<li><code>extern</code> — связывание внешней функции или переменной</li>
<li><code>false</code> — логический ложный запись</li>
<li><code>fn</code> — определение функции или вида указателя на функцию</li>
<li><code>for</code> — замкнуто перебирать элементы из повторителя, выполнить признак или указывать время жизни с более высоким рейтингом.</li>
<li><code>if</code> — ветвление на основе итога условного выражения</li>
<li><code>impl</code> — выполнение встроенной возможности или возможности особенности</li>
<li><code>in</code> — часть правил написания цикла <code>for</code></li>
<li><code>let</code> — объявление (связывание) переменной</li>
<li><code>loop</code> — безусловный цикл</li>
<li><code>match</code> — сопоставление значения с образцами</li>
<li><code>mod</code> — определение звена</li>
<li><code>move</code> — перекладывание владения на замыкание всеми захваченными элементами</li>
<li><code>mut</code> — обозначение изменчивости в ссылках, сырах указателей и привязках к образцу</li>
<li><code>pub</code> — изменитель открытой доступность полей устройств, разделов <code>impl</code> и звеньев</li>
<li><code>ref</code> — привязка по ссылке</li>
<li><code>return</code> — возвращает итог из функции</li>
<li><code>Self</code> — псевдоним для определяемого или исполняемого вида</li>
<li><code>self</code> — предмет текущего способа или звена</li>
<li><code>static</code> — вездесущая переменная или время жизни, продолжающееся на протяжении всего выполнения программы</li>
<li><code>struct</code> — определение устройства</li>
<li><code>super</code> — родительский звено текущего звена</li>
<li><code>trait</code> — определение особенности</li>
<li><code>true</code> — логический истинный запись</li>
<li><code>type</code> — определение псевдонима вида или связанного вида</li>
<li><code>union</code> - определить <a href="../reference/items/unions.html">объединение</a><!-- ignore -->; является ключевым словом только при использовании в объявлении объединения</li>
<li><code>unsafe</code> — обозначение небезопасного кода, функций, особенностей и их выполнений</li>
<li><code>use</code> — ввод имён в область видимости</li>
<li><code>where</code> — ограничение вида</li>
<li><code>while</code> — условный цикл, основанный на итоге выражения</li>
</ul>
<h3 id="Ключевые-слова-зарезервированные-для-будущего-использования"><a class="header" href="#Ключевые-слова-зарезервированные-для-будущего-использования">Ключевые слова, зарезервированные для будущего использования</a></h3>
<p>Следующие ключевые слова ещё не имеют никакой возможности, но зарезервированы Ржавчина для возможного использования в будущем.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="Сырые-определители"><a class="header" href="#Сырые-определители">Сырые определители</a></h3>
<p><em>Сырые определители</em> — это правила написания, позволяющий использовать ключевые слова там, где обычно они не могут быть. Для создания и использования сырого определителя к ключевому слову добавляется приставка <code>r#</code>.</p>
<p>Например, ключевое слово <code>match</code>. Если вы попытаетесь собрать следующую функцию, использующую в качестве имени <code>match</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>вы получите ошибку:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Ошибка говорит о том, что вы не можете использовать ключевое слово <code>match</code> в качестве определителя функции. Чтобы получить возможность использования слова <code>match</code> в качестве имени функции, нужно использовать правила написания «сырых определителей», например так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>Этот код собирается без ошибок. Обратите внимание, что приставка <code>r#</code> в определении имени функции указан так же, как он указан в месте её вызова в <code>main</code>.</p>
<p>Сырые определители позволяют вам использовать любое слово, которое вы выберете, в качестве определителя, даже если это слово окажется зарезервированным ключевым словом. Это даёт нам больше свободы в выборе имён определителей, а также позволяет нам встраиваться с программами, написанными на языке, где эти слова не являются ключевыми. Кроме того, необработанные определители позволяют вам использовать библиотеки, написанные в исполнения Rust, отличной от используемой в вашем ящике. Например, <code>try</code> не является ключевым словом в выпуске 2015 года, но является в выпуске 2018 года. Если вы зависите от библиотеки, написанной с использованием исполнения 2015 года и имеющей функцию <code>try</code>, вам потребуется использовать правила написания сырого определителя, в данном случае <code>r#try</code>, для вызова этой функции из кода исполнения 2018 года. См. <a href="appendix-05-editions.html">Приложение E</a><!-- ignore --> для получения дополнительной сведений о изданиех Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-Б-Операторы-и-обозначения"><a class="header" href="#Дополнение-Б-Операторы-и-обозначения">Дополнение Б: Операторы и обозначения</a></h2>
<p>Это дополнение содержит глоссарий правил написания Rust, включая операторы и другие обозначения, которые появляются сами по себе или в среде путей, обобщений, особенностей, макросов, свойств, примечаниев, упорядоченных рядов и скобок.</p>
<h3 id="Операторы"><a class="header" href="#Операторы">Операторы</a></h3>
<p>Таблица Б-1 содержит операторы языка Rust, пример появления оператора, короткое объяснение, возможность перегрузки оператора. Если оператор можно перегрузить, то показан особенность, с помощью которого его можно перегрузить.</p>
<p><span class="caption">Таблица Б-1: Операторы</span></p>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Пример</th><th>Объяснение</th><th>Перегружаемость</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Вызов макроса</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Побитовое или логическое отрицание</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Сравнение "не равно"</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Остаток от деления</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Остаток от деления и присваивание</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Заимствование</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Указывает что данный вид заимствуется</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Побитовое И</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Побитовое И и присваивание</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Логическое И</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Арифметическое умножение</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Арифметическое умножение и присваивание</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Разыменование ссылки</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Указывает, что данный вид является сырым указателем</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Соединение ограничений вида</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Арифметическое сложение</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Арифметическое сложение и присваивание</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Разделитель переменных и элементов</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Арифметическое отрицание</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Арифметическое вычитание</td><td><code>Sub</code></td></tr>
<tr><td><code>-</code></td><td><code>var -= expr</code></td><td>Арифметическое вычитание и присваивание</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>&amp;vert;...&amp;vert; -&gt; type</code></td><td>...</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Доступ к элементу</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Указывает на рядчисел, исключая правый</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Указывает на рядчисел, включая правый</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>правила написания обновления устройства</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Привязка «И все остальное»</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Устарело, используйте новый правила написания <code>..=</code>) Используется при определении инклюзивного ряда</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Арифметическое деление</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Арифметическое деление и присваивание</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Ограничения видов</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Объявление поля устройства</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Метка цикла</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Признак конца указания и элемента</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Часть правил написания массива конечного размера</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Битовый сдвиг влево</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Битовый сдвиг влево и присваивание</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Сравнение "меньше чем"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Сравнение "меньше или равно"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Присваивание/эквивалентность</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Сравнение "равно"</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Часть правил написания устройства match</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Сравнение "больше чем"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Сравнение "больше или равно"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Битовый сдвиг вправо</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Битовый сдвиг вправо и присваивание</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Побитовое исключающее ИЛИ</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Побитовое исключающее ИЛИ и присваивание</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>&amp;vert;</code></td><td><code>pat &amp;vert; pat</code></td><td>Иные образцы</td><td></td></tr>
<tr><td><code>&amp;vert;</code></td><td><code>expr &amp;vert; expr</code></td><td>Побитовое ИЛИ</td><td><code>BitOr</code></td></tr>
<tr><td><code>&amp;vert;=</code></td><td><code>var &amp;vert;= expr</code></td><td>Побитовое ИЛИ и присваивание</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>&amp;vert;&amp;vert;</code></td><td><code>expr &amp;vert;&amp;vert; expr</code></td><td>Короткое логическое ИЛИ</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Возврат ошибки</td><td></td></tr>
</tbody></table>
</div>
<h3 id="Обозначения-не-операторы"><a class="header" href="#Обозначения-не-операторы">Обозначения не-операторы</a></h3>
<p>Следующий список содержит все символы, которые не работают как операторы; то есть они не ведут себя как вызов функции или способа.</p>
<p>Таблица Б-2 показывает символы, которые появляются сами по себе и допустимы в различных местах.</p>
<p><span class="caption">Таблица Б-2: Автономный правила написания</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Именованное время жизни или метка цикла</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Числовой запись определённого вида</td></tr>
<tr><td><code>"..."</code></td><td>Строковый запись</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code>, etc.</td><td>Необработанный строковый запись, в котором не обрабатываются escape-символы</td></tr>
<tr><td><code>b"..."</code></td><td>Строковый запись байтов; создаёт массив байтов вместо строки</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>, etc.</td><td>Необработанный строковый байтовый запись, сочетание необработанного и байтового записи</td></tr>
<tr><td><code>'...'</code></td><td>Символьный запись</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII байтовый запись</td></tr>
<tr><td><code>&amp;vert;...&amp;vert; expr</code></td><td>Замыкание</td></tr>
<tr><td><code>!</code></td><td>Всегда пустой вид для расходящихся функций</td></tr>
<tr><td><code>_</code></td><td>«Пренебрегаемое» связывание образцов; также используется для читабельности целочисленных записей</td></tr>
</tbody></table>
</div>
<p>Таблица Б-3 показывает обозначения которые появляются в среде путей упорядочевания звеньев</p>
<p><span class="caption">Таблица Б-3. Правила написания, связанный с путями</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Путь к пространству имён</td></tr>
<tr><td><code>::path</code></td><td>Путь относительно корня ящика (т. е. явный абсолютный путь)</td></tr>
<tr><td><code>self::path</code></td><td>Путь относительно текущего звена (т. е. явный относительный путь).</td></tr>
<tr><td><code>super::path</code></td><td>Путь относительно родительского звена текущего звена</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Сопряженные постоянные значения, функции и виды</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Сопряженный элемент для вида, который не может быть назван прямо (например <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Устранение неоднозначности вызова способа путём именования особенности, который определяет его</td></tr>
<tr><td><code>type::method(...)</code></td><td>Устранение неоднозначности путём вызова способа через имя вида, для которого он определён</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Устранение неоднозначности вызова способа путём именования особенности и вида</td></tr>
</tbody></table>
</div>
<p>Таблица Б-4 показывает обозначения которые появляются в среде использования обобщённых видов свойств</p>
<p><span class="caption">Таблица Б-4: Обобщения</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Определяет свойства для обобщённых свойств в виде (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Определяет свойства для обобщённых свойств, функций, или способов в выражении. Часто называют turbofish (например <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Определение обобщённой функции</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Определение обобщённой устройства</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Объявление обобщённого перечисления</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Определение обобщённой выполнения</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Высокоуровневое связывание времени жизни</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Обобщённый вид где один или более сопряженных видов имеют определённое присваивание (например <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Таблица Б-5 показывает обозначения которые появляются в среде использования обобщённых видов свойств с ограничениями видов</p>
<p><span class="caption">Таблица Б-5: Ограничения видов</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Обобщённый свойство <code>T</code> ограничивается до видов которые выполняют особенность <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Обобщённый вид <code>T</code> должен существовать не меньше чем <code>'a</code> (то есть вид не может иметь ссылки с временем жизни меньше чем <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Обобщённый вид <code>T</code> не имеет заимствованных ссылок кроме имеющих время жизни <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>Обобщённое время жизни <code>'b</code> должно быть не меньше чем <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Позволяет обобщённым видам свойства иметь изменяемый размер</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Соединение ограничений видов</td></tr>
</tbody></table>
</div>
<p>Таблица Б-6 показывает обозначения, которые появляются в среде вызова или определения макросов и указания свойств элемента.</p>
<p><span class="caption">Таблица Б-6: Макросы и свойства</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Внешний свойство</td></tr>
<tr><td><code>#![meta]</code></td><td>Внутренний свойство</td></tr>
<tr><td><code>$ident</code></td><td>Подстановка в макросе</td></tr>
<tr><td><code>$ident:kind</code></td><td>Захват макроса</td></tr>
<tr><td><code>$(…)…</code></td><td>Повторение макроса</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Вызов макроса</td></tr>
</tbody></table>
</div>
<p>Таблица Б-7 показывает обозначения, которые создают примечания.</p>
<p><span class="caption">Таблица Б-7: Примечания</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Однострочный примечание</td></tr>
<tr><td><code>//!</code></td><td>Внутренний однострочный примечание документации</td></tr>
<tr><td><code>///</code></td><td>Внешний однострочный примечание документации</td></tr>
<tr><td><code>/*...*/</code></td><td>Многострочный примечание</td></tr>
<tr><td><code>/*!...*/</code></td><td>Внутренний многострочный примечание документации</td></tr>
<tr><td><code>/**...*/</code></td><td>Внешний многострочный примечание документации</td></tr>
</tbody></table>
</div>
<p>Таблица Б-8 показывает обозначения, которые появляются в среде использования упорядоченных рядов.</p>
<p><span class="caption">Таблица Б-8: Упорядоченные ряды</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Пустой упорядоченный ряд, он же пустой вид. И запись и вид.</td></tr>
<tr><td><code>(expr)</code></td><td>Выражение в скобках</td></tr>
<tr><td><code>(expr,)</code></td><td>Упорядоченный ряд с одним элементом выражения</td></tr>
<tr><td><code>(type,)</code></td><td>Упорядоченный ряд с одним элементом вида</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Выражение упорядоченного ряда</td></tr>
<tr><td><code>(type, ...)</code></td><td>Вид упорядоченного ряда</td></tr>
<tr><td><code>(type, ...)</code></td><td>Выражение вызова функции; также используется для объявления устройств-упорядоченных рядов и исходов-упорядоченных рядов перечисления</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Взятие элемента по порядковому указателю в упорядоченном ряде</td></tr>
</tbody></table>
</div>
<p>Таблица Б-9 показывает среды, в которых используются фигурные скобки.</p>
<p><span class="caption">Таблица Б-9: Фигурные скобки</span></p>
<div class="table-wrapper"><table><thead><tr><th>Среда</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Выражение раздела</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> запись</td></tr>
</tbody></table>
</div>
<p>Таблица Б-10 показывает среды, в которых используются квадратные скобки.</p>
<p><span class="caption">Таблица Б-10: Квадратные скобки</span></p>
<div class="table-wrapper"><table><thead><tr><th>Среда</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Запись массива</td></tr>
<tr><td><code>[expr; len]</code></td><td>Запись массива, содержащий <code>len</code> повторов <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Массив, содержащий <code>len</code> образцов вида <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Взятие по порядковому указателю в собрания. Возможна перегрузка (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Взятие среза собрания по порядковому указателю, используется <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, или <code>RangeFull</code> как "порядковый указатель"</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-В-Выводимые-особенности"><a class="header" href="#Дополнение-В-Выводимые-особенности">Дополнение В: Выводимые особенности</a></h2>
<p>Во многих частях книги мы обсуждали свойство <code>derive</code>, которые Вы могли применить к объявлению устройства или перечисления. Свойство <code>derive</code> порождает код по умолчанию для выполнения особенности, который вы указали в  <code>derive</code>.</p>
<p>В этом дополнении, мы расскажем про все особенности, которые вы можете использовать в свойстве <code>derive</code>. Каждая раздел содержит:</p>
<ul>
<li>Действия и способы, добавляемые особенностью</li>
<li>Как представлена выполнение особенности через <code>derive</code></li>
<li>Что выполнение особенности рассказывает про вид</li>
<li>Условия, в которых разрешено или запрещено выполнить особенность</li>
<li>Примеры случаев, которые требуют наличие особенности</li>
</ul>
<p>Если Вам понадобилось поведение отличное от поведения при выполнения через <code>derive</code>, обратитесь к <a href="../std/index.html">документации по встроенной библиотеке</a><!-- ignore --> чтобы узнать как вручную выполнить особенность.</p>
<p>Перечисленные здесь особенности являются единственными, определёнными встроенной библиотекой, которые могут быть выполнены в ваших видах с помощью <code>derive</code>. Другие особенности, определённые в встроенной библиотеке, не имеют ощутимого поведения по умолчанию, поэтому вам решать, как выполнить их для достижения ваших целей.</p>
<p>Пример особенности, который нельзя выполнить через derive - <code>Display</code>, который обрабатывает изменение
для конечных пользователей. Вы всегда должны сами рассмотреть лучший способ для отображения вида конечному пользователю. Какие части вида должны быть разрешены для просмотра конечному пользователю? Какие части они найдут подходящими? Какой вид вывода для них будет самым подходящим? Сборщик Ржавчина не знает ответы на эти вопросы, поэтому он не может подобрать подходящее обычное поведение.</p>
<p>Список видов, выполняемых через derive, в этом дополнении не является исчерпывающим: библиотеки могут выполнить <code>derive</code> для их собственных особенностей, составляя свои списки особенностей, которые Вы можете использовать с помощью <code>derive</code>. Выполнение <code>derive</code> включает в себя использование процедурных макросов, которые были рассмотрены в разделе <a href="ch19-06-macros.html#macros">"Макросы"</a><!--  --> главы 19.</p>
<h3 id="debug-для-отладочного-вывода"><a class="header" href="#debug-для-отладочного-вывода"><code>Debug</code> для отладочного вывода</a></h3>
<p>Особенность <code>Debug</code> включает отладочное изменение
в изменяемых строках, которые вы можете указать с помощью <code>:?</code> внутри <code>{}</code> фигурных скобок.</p>
<p>Особенность <code>Debug</code> позволяет Вам напечатать предметы вида с целью отладки, поэтому Вы и другие программисты, использующие Ваш вид, смогут проверить предмет в определённой точке выполнения программы.</p>
<p>Особенность <code>Debug</code> обязателен в некоторых случаях. Например, при использовании макроса <code>assert_eq!</code>. Этот макрос печатает значения входных переменных, если они не совпадают. Это позволяет программистам увидеть, почему эти предметы не равны.</p>
<h3 id="partialeq-и-eq-для-сравнения-равенства"><a class="header" href="#partialeq-и-eq-для-сравнения-равенства"><code>PartialEq</code> и <code>Eq</code> для сравнения равенства</a></h3>
<p>Особенность <code>PartialEq</code> позволяет Вам сравнить предметы одного вида на эквивалентность, и включает для них использование операторов <code>==</code> и <code>!=</code>.</p>
<p>Использование <code>PartialEq</code> выполняет способ <code>eq</code>. Когда <code>PartialEq</code> используют для устройства, два предмета равны если равны <em>все</em> поля предметов, и предметы не равны, если хотя бы одно поле отлично. Когда используется для перечислений, каждый исход равен себе, и не равен другим исходам.</p>
<p>Особенность <code>PartialEq</code> обязателен в некоторых случаях. Например для макроса <code>assert_eq!</code>, где необходимо сравнивать два предмета одного вида на эквивалентность.</p>
<p>Особенность <code>Eq</code> не имеет способов. Он указывает что каждое значение определеного вида равно самому себе. Особенность <code>Eq</code> может быть применён только для видов выполняющих особенность <code>PartialEq</code>, хотя не все виды, которые выполняют <code>PartialEq</code> могут выполнить <code>Eq</code>. Примером являются числа с плавающей запятой: выполнение чисел с плавающей запятой говорит, что два образца со значениями не-число (<code>NaN</code>) не равны друг другу.</p>
<p>Особенность <code>Eq</code>необходим в некоторых случаях. Например, для ключей в <code>HashMap&lt;K, V&gt;</code>. Поэтому <code>HashMap&lt;K, V&gt;</code> может сказать, что два ключа являются одним и тем же.</p>
<h3 id="partialord-и-ord-для-сравнения-порядка"><a class="header" href="#partialord-и-ord-для-сравнения-порядка"><code>PartialOrd</code> и <code>Ord</code> для сравнения порядка</a></h3>
<p>Особенность <code>PartialOrd</code> позволяет Вам сравнить предметы одного вида с помощью сортировки. Вид, выполняющий <code>PartialOrd</code> может использоваться с операторами <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, и <code>&gt;=</code>. Вы можете выполнить особенность <code>PartialOrd</code> только для видов, выполняющих <code>PartialEq</code>.</p>
<p>Использование <code>PartialOrd</code> выполняет способ <code>partial_cmp</code>, который возвращает <code>Option&lt;Ordering&gt;</code> который является <code>None</code> когда значения не выстраивают порядок. Примером значения, которое не может быть упорядочено, не являются числом (<code>NaN</code>) значение с плавающей запятой. Вызов <code>partial_cmp</code> с любым числом с плавающей запятой и значением <code>NaN</code> вернёт <code>None</code>.</p>
<p>Когда используется для устройств, <code>PartialOrd</code> сравнивает два предмета путём сравнения значений каждого поля в порядке, в котором поля объявлены в устройстве. Когда используется для перечислений, то исходы перечисления объявленные ранее будут меньше чем исходы объявленные позже.</p>
<p>Например, особенность <code>PartialOrd</code> может потребоваться для способа <code>gen_range</code> из <code>rand</code> ящика который порождает случайные значения в заданном ряде (который определён выражением ряда).</p>
<p>Особенность <code>Ord</code> позволяет знать, для двух значений определеного вида всегда будет существовать валидный порядок. Особенность <code>Ord</code> выполняет способ <code>cmp</code>, который возвращает <code>Ordering</code> а не <code>Option&lt;Ordering&gt;</code> потому что валидный порядок всегда будет существовать. Вы можете применить особенность  <code>Ord</code> только для видов, выполняющих особенность <code>PartialOrd</code> и <code>Eq</code> (<code>Eq</code> также требует <code>PartialEq</code>). При использовании на устройствах или перечислениях, <code>cmp</code> имеет такое же поведение, как и <code>partial_cmp</code> в<code>PartialOrd</code>.</p>
<p>Особенность <code>Ord</code> необходим в некоторых случаях. Например, сохранение значений в <code>BTreeSet&lt;T&gt;</code>, виде данных, который хранит сведения на основе порядка отсортированных данных.</p>
<h3 id="clone-и-copy-для-повторения-значений"><a class="header" href="#clone-и-copy-для-повторения-значений"><code>Clone</code> и <code>Copy</code> для повторения значений</a></h3>
<p>Особенность <code>Clone</code> позволяет вам явно создать глубокую повтор значения, а также этап повторения может вызывать особый код и воспроизводить данные с кучи. Более подробно про <code>Clone</code> смотрите в разделы <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">"Способы взаимодействия переменных и данных: клонирование"</a> в разделе 4.</p>
<p>Использование <code>Clone</code> выполняет способ <code>clone</code>, который в случае выполнения на всем виде, вызывает <code>clone</code>для каждой части данных вида. Это подразумевает, что все поля или значения в виде также должны выполнить <code>Clone</code> для использования <code>Clone</code>.</p>
<p>Особенность <code>Clone</code> необходим в некоторых случаях. Например, для вызова способа <code>to_vec</code> для среза. Срез не владеет данными, содержащимися в нем, но вектор значений, возвращённый из <code>to_vec</code> должен владеть этими предметами, поэтому <code>to_vec</code> вызывает <code>clone</code> для всех данных. Таким образом, вид хранящийся в срезе, должен выполнить <code>Clone</code>.</p>
<p>Особенность <code>Copy</code> позволяет повторять значения повторяя только данные, которые хранятся на обойме, произвольный код не требуется. Смотрите раздел <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">"Из обоймы данные: Повторение"</a><!-- ignore --> в разделе 4 для большей сведений о <code>Copy</code>.</p>
<p>Особенность <code>Copy</code> не содержит способов для предотвращения перегрузки этих способов программистами, иначе бы это нарушило соглашение, что никакой произвольный код не запускается. Таким образом все программисты могут предполагать, что повторение значений будет происходить быстро.</p>
<p>Вы можете вывести <code>Copy</code> для любого вида все части которого выполняют <code>Copy</code>. Вид который выполняет <code>Copy</code> должен также выполнить <code>Clone</code>, потому что вид выполняющий <code>Copy</code> имеет обыкновенную выполнение <code>Clone</code> который выполняет ту же задачу, что и <code>Copy</code>.</p>
<p>Особенность <code>Copy</code> нужен очень редко; виды, выполняющие <code>Copy</code> имеют небольшую переработку, то есть для него не нужно вызывать способ <code>clone</code>, который делает код более кратким.</p>
<p>Все, что вы делаете с <code>Copy</code> можно также делать и с <code>Clone</code>, но код может быть медленнее и требовать вызов способа <code>clone</code> в некоторых местах.</p>
<h3 id="hash-для-превращения-значения-в-значение-конечного-размера"><a class="header" href="#hash-для-превращения-значения-в-значение-конечного-размера"><code>Hash</code> для превращения значения в значение конечного размера</a></h3>
<p>Особенность <code>Hash</code> позволяет превратить значение произвольного размера в значение конечного размера с использованием хеш-функции. Использование <code>Hash</code> выполняет способ <code>hash</code>. При выполнения через derive, способ <code>hash</code> сочетает итоги вызова <code>hash</code> на каждой части данных вида, то есть все поля или значения должны выполнить <code>Hash</code> для использования <code>Hash</code> с помощью derive.</p>
<p>Особенность <code>Hash</code> необходим в некоторых случаях. Например, для хранения ключей в <code>HashMap&lt;K, V&gt;</code>, для их более эффективного хранения.</p>
<h3 id="default-для-значений-по-умолчанию"><a class="header" href="#default-для-значений-по-умолчанию"><code>Default</code> для значений по умолчанию</a></h3>
<p>Особенность <code>Default</code> позволяет создавать значение по умолчанию для вида. Использование <code>Default</code> выполняет функцию <code>default</code>. Обычная выполнение способа <code>default</code> вызовет функцию <code>default</code> на каждой части данных вида, то есть для использования <code>Default</code> через derive, все поля и значения вида данных должны также выполнить <code>Default</code>.</p>
<p>Функция <code>Default::default</code>часто используется в сочетания с правилами написания обновления устройства, который мы обсуждали в разделы <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">"Создание образца устройства из образца другой устройства с помощью правил написания обновления устройства"</a><!-- ignore --> главы 5. Вы можете настроить несколько полей для устройства, а для остальных полей установить значения с помощью <code>..Default::default()</code>.</p>
<p>Особенность <code>Default</code> необходим в некоторых случаях. Например, для способа <code>unwrap_or_default</code> у вида <code>Option&lt;T&gt;</code>. Если значение <code>Option&lt;T&gt;</code> будет <code>None</code>, способ <code>unwrap_or_default</code> вернёт итог вызова функции <code>Default::default</code> для вида <code>T</code>, хранящегося в <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-Г---Средства-разработки"><a class="header" href="#Дополнение-Г---Средства-разработки">Дополнение Г - Средства разработки</a></h2>
<p>В этом дополнении мы расскажем про часто используемые средства разработки, предоставляемые Rust. Мы рассмотрим самостоятельное изменение
, быстрый путь исправления предупреждений, линтер, и встраивание с IDE.</p>
<h3 id="Самостоятельное-изменение"><a class="header" href="#Самостоятельное-изменение">Самостоятельное изменение</a></h3>
<p>с <code>rustfmt</code></p>
<p>Средство <code>rustfmt</code> переделает ваш код в соответствии со исполнением кода сообщества. Многие совместные дела используют <code>rustfmt</code>, чтобы предотвратить споры о том, какой исполнение использовать при написании Rust: все изменяют свой код с помощью этого средства.</p>
<p>Для установки <code>rustfmt</code>, введите следующее:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Этот приказ установит <code>rustfmt</code> и <code>cargo-fmt</code>, также как Ржавчина даёт Вам одновременно <code>rustc</code> и <code>cargo</code>. Для изменения дела, использующего Cargo, введите следующее:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Этот приказ изменит весь код на языке Ржавчина в текущем ящике. Будет изменён только исполнение кода, смысл останется прежней. Для большей сведений о <code>rustfmt</code>, смотрите <a href="https://github.com/rust-lang/rustfmt">документацию</a>.</p>
<h3 id="Исправление-кода-с-rustfix"><a class="header" href="#Исправление-кода-с-rustfix">Исправление кода с <code>rustfix</code></a></h3>
<p>Средство rustfix включён в установку Ржавчина и может самостоятельно исправлять предупреждения сборщика с очевидным способом исправления сбоев, скорее всего, подходящим вам. Вероятно, вы уже видели предупреждения сборщика. Например, рассмотрим этот код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Мы вызываем функцию <code>do_something</code> 100 раз, но никогда не используем переменную <code>i</code> в теле цикла <code>for</code>. Ржавчина предупреждает нас об этом:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Предупреждение предлагает нам использовать <code>_i</code> как имя переменной: нижнее подчёркивание в начале определителя предполагает, что мы его не используем. Мы можем самостоятельно применить это предположение с помощью <code>rustfix</code>, запустив приказ <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Когда посмотрим в <em>src/main.rs</em> снова, мы увидим что <code>cargo fix</code> изменил наш код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Переменная цикла <code>for</code> теперь носит имя <code>_i</code>, и предупреждение больше не появляется.</p>
<p>Также Вы можете использовать приказ <code>cargo fix</code> для перемещения вашего кода между различными изданиеми Rust. Издания будут рассмотрены в дополнении Д.</p>
<h3 id="Больше-проверок-с-clippy"><a class="header" href="#Больше-проверок-с-clippy">Больше проверок с Clippy</a></h3>
<p>Средство Clippy является собранием проверок (lints) для анализа Вашего кода, поэтому Вы можете найти простые ошибки и улучшить ваш Ржавчина код.</p>
<p>Для установки Clippy, введите следующее:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Для запуска проверок Clippy’s для дела Cargo, введите следующее:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Например, скажем что Вы хотите написать программу, в которой будет использоваться приближенная математическая постоянное значение, такая как число Пи, как в следующей программе:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>Запуск <code>cargo clippy</code> для этого дела вызовет следующую ошибку:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Эта ошибка сообщает вам, что в Ржавчина уже определена более точная постоянное значение <code>PI</code>, и что ваша программа будет более правильной, если вы вместо неё будете использовать эту постоянное значение. Затем вы должны изменить свой код, чтобы использовать постоянное значение <code>PI</code>. Следующий код не приводит к ошибкам или предупреждениям от Clippy:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>Для большей сведений о Clippy смотрите <a href="https://github.com/rust-lang/rustfmt">документацию</a>.</p>
<h3 id="Встраивание-с-ide-с-помощью-rust-analyzer"><a class="header" href="#Встраивание-с-ide-с-помощью-rust-analyzer">Встраивание с IDE с помощью <code>rust-analyzer</code></a></h3>
<p>Чтобы облегчить встраивание с IDE, сообщество Ржавчина советует использовать <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->. Этот средство представляет собой набор направленных на сборщик утилит, которые используют <a href="http://langserver.org/">Language Server Protocol</a><!-- ignore -->, который является сводом требований для взаимодействия IDE и языков программирования друг с другом. Разные клиенты могут использовать <code>rust-analyzer</code>, например <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">подключаемый звено анализатора Ржавчина для Visual Studio Code</a>.</p>
<p>Посетите <a>домашнюю страницу</a> дела <code>rust-analyzer</code> для получения указаний по установке, затем установите поддержку языкового сервера в именно среде IDE. Ваша IDE получит такие возможности, как автозаполнение, переход к определению и встроенные ошибки.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приложение-e---Издания-языка"><a class="header" href="#Приложение-e---Издания-языка">Приложение E - Издания языка</a></h2>
<p>В главе 1, можно увидеть, что приказ <code>cargo new</code> добавляет некоторые мета-данные о издания языка в файл <em>Cargo.toml</em>. Данное приложение рассказывает, что они означают.</p>
<p>Язык Ржавчина и его сборщик имеют шестинедельный цикл выпуска, означающий, что пользователи постоянно получают новые функции. В других языках обычно выпускают большие обновления, но редко. Объединение Ржавчина выпускает меньшие обновления, но более часто. Через некоторое время все эти небольшие изменения накапливаются. Между исполнениями обычно сложно оглянуться назад и сказать "Ого, язык сильно изменился между исполнениями Ржавчина 1.10 и Ржавчина 1.31!"</p>
<p>Каждые два или три года, объединение Ржавчина выпускает новую издание языка <em>(Rust edition)</em>. Каждая издание объединяет все новые особенности, которые попали в язык с новыми дополнениями, с полной, обновлённой документацией и набором средств. Новые издания поставляются как часть шестинедельного этапа исполнений.</p>
<p>Для разных людей издания служат разным целям:</p>
<ul>
<li>Для активных пользователей новая издание приносит все инкрементальные изменения в удобный и понятный дополнение.</li>
<li>Для тех, кто языком не пользуется, новая реакция является знаком, что некоторые важные улучшения, на которые возможно надо взглянуть ещё раз, попали в язык.</li>
<li>Для тех кто разрабатывает на Rust, новая издание даёт некоторую точку отсчёта для дела в целом.</li>
</ul>
<p>На мгновение написания доступны две издания Rust: Ржавчина 2015 и Ржавчина 2018. Данная книга написана с использованием идиом издания Ржавчина 2018.</p>
<p>Ключ <code>edition</code> в настроечном файле  <em>Cargo.toml</em> отображает, какую издание сборщик должен использовать для вашего кода. Если ключа нет, то для обратной совместимости сборщик Ржавчина использует издание <code>2015</code>.</p>
<p>Любой дело может выбрать издание отличную от издания по умолчанию, которая равна 2015. Издания могут содержать несовместимые изменения, включая новые ключевые слова, которые могут враждовать с определителями в коде. Однако, пока вы не переключитесь на новую издание, ваш код будет продолжать собираться даже после обновления используемой исполнения сборщика.</p>
<p>Все исполнения сборщика Ржавчина поддерживают любую издание, которая предшествовала выпуску текущей, и они могут линковать дополнения любой поддерживаемой издания. Изменения изданий действуют только на способ начального разбора сборщиком исходного кода. Поэтому, если вы используете 2015 издание, а одна из ваших зависимостей использует 2018, ваш дело будет собран и сможет пользоваться этой зависимостью. Обратная случаей, когда ваш дело использует Ржавчина 2018, а зависимость использует Ржавчина 2015, работает таким же образом.</p>
<p>Внесём ясность: большая часть возможностей будет доступна во всех изданиях. Разработчики, использующие любую издание Rust, будут продолжать получать улучшения по мере выпуска новых исполнений. Однако в некоторых случаях, в основном, когда добавляются новые ключевые слова, некоторые новые возможности могут быть доступны только в последних изданиях. Нужно переключить издание, чтобы воспользоваться новыми возможностями.</p>
<p>Для получения больше подробностей, есть полная книга <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> про издания, в которой перечисляются различия между изданиями и объясняется, как самостоятельно обновить свой код на новую издание с помощью приказы <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приложение-Е-Переводы-книги"><a class="header" href="#Приложение-Е-Переводы-книги">Приложение Е: Переводы книги</a></h2>
<p>Для ресурсов на языках, отличных от английского. Большинство из них все ещё в разработке; см. <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">ярлык «Переводы»</a>, чтобы помочь или сообщить нам о новом переводе!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-Ё---Как-создаётся-Ржавчина-и-nightly-rust"><a class="header" href="#Дополнение-Ё---Как-создаётся-Ржавчина-и-nightly-rust">Дополнение Ё - Как создаётся Ржавчина и “Nightly Rust”</a></h2>
<p>Это дополнение рассказывает как создаётся Rust, и как это влияет на Вас как на разработчика.</p>
<h3 id="Безотказность-без-стагнации"><a class="header" href="#Безотказность-без-стагнации">Безотказность без стагнации</a></h3>
<p>Как язык, Ржавчина <em>много</em> заботиться о безотказности Вашего кода. Мы хотим чтобы Ржавчина был прочным фундаментом, вашей опорой, и если бы все постоянно менялось, это было бы невозможно. В то же время, если мы не можем экспериментировать с различными возможностями, мы не можем обнаружить важные сбоев до исполнения, когда мы не можем их изменить.</p>
<p>Нашим решением сбоев является “безотказность без стагнации”, и наш руководящий принцип: Вы никогда не должны бояться перехода на новую безотказную исполнение Rust. Каждое обновление должно быть безболезненным, но также должно добавлять новые функции, меньше дефектов и более быструю скорость сборки.</p>
<h3 id="Ту-ту-потоки-выпуска-и-поездка-на-поезде"><a class="header" href="#Ту-ту-потоки-выпуска-и-поездка-на-поезде">Ту-ту! потоки выпуска и поездка на поезде</a></h3>
<p>Разработка языка Ржавчина работает по принципу <em>расписания поездов</em>. То есть, вся разработка совершается в ветке <code>master</code> Ржавчина хранилища. Выпуски следуют подходы последовательного выпуска продукта (software release train), которая была использована Cisco IOS и другими программными продуктами. Есть три <em>потока выпуска</em> Rust:</p>
<ul>
<li>Ночной (Nightly)</li>
<li>Бета (Beta)</li>
<li>Безотказный (Stable)</li>
</ul>
<p>Большинство Ржавчина разработчиков используют безотказную исполнение, но те кто хотят попробовать экспериментальные новые функции, должны использовать Nightly или Beta.</p>
<p>Приведём пример, как работает этап разработки и выпуска новых исполнений. Давайте предположим, что объединение Ржавчина работает над исполнением Ржавчина 1.5. Его исполнение состоялся в декабре 2015 года, но это даст существующегостичность номера исполнения. Была добавлена новая возможность в Rust: новые изменения в ветку <code>master</code>. Каждую ночь выпускается новая ночная исполнение Rust. Каждый день является днём выпуска ночной исполнения и эти выпуски создаются нашей устройством самостоятельно . По мере того как идёт время, наши выпуски выглядят так:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Каждые шесть недель наступает время подготовки новой Beta исполнения! Ветка <code>beta</code> Ржавчина хранилища ответвляется от ветки <code>master</code>, используемой исполнением Nightly. Теперь мы имеем два выпуска:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Многие пользователи Ржавчина не используют активно бета-исполнение, но проверяют бета-исполнение в их системе CI для помощи Ржавчина обнаружить сбоев обратной совместимости. В это время каждую ночь выпускается новая исполнение Nightly:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Предположим, что была найдена отступление. Хорошо, что мы можем проверять бета-исполнение перед тем как отступление попала в безотказную исполнение! Исправление отправляется в ветку <code>master</code>, поэтому исполнение nightly исправлена и затем исправление также направляется в ветку <code>beta</code>, и происходит новый выпуск бета-исполнения:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Через шесть недель после выпуска бета-исполнения, наступает время для выпуска безотказной исполнения! Ветка <code>stable</code> создаётся из ветки <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Ура! Ржавчина 1.5 выпущена! Но мы также забыли про одну вещь: так как прошло шесть недель, мы должны выпустить бета-исполнение <em>следующей</em>  исполнения Ржавчина 1.6. Поэтому после ответвления ветки <code>stable</code> из ветки <code>beta</code>, следующая исполнение <code>beta</code> ответвляется снова от <code>nightly</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Это называется “прообраз поезда” (train model), потому что каждые шесть недель выпуск “покидает станцию”, но ему все ещё нужно пройти поток beta, чтобы попасть в безотказную исполнение.</p>
<p>Rust выпускается каждые шесть недель, как часы. Если вы знаете дату одного выпуска Rust, вы знаете дату выпуска следующего: это шесть недель позднее. Хорошим особенностью выпуска исполнений каждые шесть недель является то, что следующий поезд прибывает скоро. Если какая-то функция не попадает в исполнение, не надо волноваться: ещё один выпуск произойдёт очень скоро! Это помогает снизить давление в случае если функция возможно не отполирована к дате выпуска.</p>
<p>Благодаря этому этапу, вы всегда можете посмотреть следующую исполнение Ржавчина и убедиться, что на неё легко будет перейти: если бета-выпуск будет работать не так как ожидалось, вы можете сообщить об этом разработчикам и он будет исправлен перед выпуском безотказной исполнения! Поломки в бета-исполнения случаются относительно редко, но <code>rustc</code> все ещё является частью программного обеспечения, поэтому дефекты все ещё существуют.</p>
<h3 id="Ненадежные-функции"><a class="header" href="#Ненадежные-функции">Ненадежные функции</a></h3>
<p>У этой подходы выпуска есть ещё один плюс: ненадежные функции. Ржавчина использует технику называемую “флаги возможностей” (feature flags) для определения функций, которые были включены в выпуске. Если новая функция находится в активной разработке, она попадает в ветку <code>master</code>, и поэтому попадает в ночную исполнение, но с <em>флагом функции</em> (feature flag). Если как пользователь, вы хотите попробовать работу такой функции, находящейся в разработке, вы должны использовать ночную исполнение Ржавчина и указать в вашем исходном коде определённый флаг.</p>
<p>Если вы используете бета или безотказную исполнение Rust, Вы не можете использовать флаги функций. Этот ключевой мгновение позволяет использовать в действительностиновые возможности перед их отладкой. Это может использоваться желающими идти в ногу со временем, а другие могут использовать безотказную исполнение и быть уверенными что их код не сломается. Безотказность без стагнации.</p>
<p>Эта книга содержит сведения только о безотказных возможностях, так как разрабатываемые возможности продолжают меняться в этапе и несомненно они будут отличаться в зависимости от того, когда эта книга написана и когда эти возможности будут включены в безотказные сборки. Вы можете найти сведения о возможностях ночной исполнения в интернете.</p>
<h3 id="rustup-и-значение-ночной-исполнения-rust"><a class="header" href="#rustup-и-значение-ночной-исполнения-rust">Rustup и значение ночной исполнения Rust</a></h3>
<p>Rustup делает лёгким изменение между различными потоками Rust, на вездесущем или местном для дела уровне. По умолчанию устанавливается безотказная исполнение Rust. Для установки ночной исполнения выполните приказ:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Вы можете также увидеть все установленные <em>средства разработчика (toolchains)</em> (исполнения Ржавчина и сопряженные составляющие) с помощью <code>rustup</code>. Это пример вывода у одного из авторов Ржавчина с компьютером на Windows:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Как видите, включенный набор средств (toolchain) используется по умолчанию. Большинство пользователей Ржавчина используют безотказные исполнения большую часть времени. Возможно, вы захотите использовать безотказную большую часть времени, но использовать каждую ночную исполнение в определенном деле, потому что заботитесь о передовых возможностях. Для этого вы можете использовать приказ <code>rustup override</code> в папке этого дела, чтобы установить ночной набор средств, должна использоваться приказ <code>rustup</code>, когда вы находитесь в этом папке:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Теперь каждый раз, когда вы вызываете <code>rustc</code> или <code>cargo</code> внутри <em>~/projects/needs-nightly</em>, <code>rustup</code> будет следить за тем, чтобы вы используете ночную исполнение Rust, а не безотказную по умолчанию. Это очень удобно, когда у вас есть множество Ржавчина дел!</p>
<h3 id="Этап-rfc-и-приказы"><a class="header" href="#Этап-rfc-и-приказы">Этап RFC и приказы</a></h3>
<p>Итак, как вы узнаете об этих новых возможностях? Прообраз разработки Ржавчина следует <em>этапу запроса примечаниев (RFC - Request For Comments)</em>. Если хотите улучшить Rust, вы можете написать предложение, которое называется RFC.</p>
<p>Любой может написать RFC для улучшения Rust, предложения рассматриваются и обсуждаются приказом Rust, которая состоит из множества тематических объединений и общин. На <a href="https://www.rust-lang.org/governance">веб-сайте Rust</a> есть полный список приказов, который включает приказы для каждой области дела: внешний вид языка, выполнение сборщика, инфраустройства, документация и многое другое. Соответствующая приказ читает предложение и примечания, пишет некоторые собственные примечания и в конечном итоге, приходит к согласию принять или отклонить эту возможность.</p>
<p>Если новая возможность принята и кто-то может выполнить её, то задача открывается в хранилища Rust. Человек выполняющий её, вполне может не быть тем, кто предложил эту возможность! Когда выполнение готова, она попадает в <code>master</code> ветвь с флагом функции, как мы обсуждали в разделе <a href="appendix-07-nightly-rust.html#unstable-features">"Небезотказных функциях"</a><!--  -->.</p>
<p>Через некоторое время, разработчики Ржавчина использующие ночные выпуски, смогут опробовать новую возможность, члены приказы обсудят её, как она работает в ночной исполнения и решат, должна ли она попасть в безотказную исполнение Ржавчина или нет. Если принимается решение двигать её вперёд, ограничение функции с помощью флага убирается и функция теперь считается безотказной! Она едет в новую  безотказную исполнение Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
