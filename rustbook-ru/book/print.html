<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Язык программирования Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Язык-программирования-rust"><a class="header" href="#Язык-программирования-rust">Язык программирования Rust</a></h1>
<p><em>От Стива Клабника и Кэрол Николс, при поддержке других участников сообщества Rust</em></p>
<p>В этой исполнения учебника предполагается, что вы используете Rust 1.67.1 (выпущен 09.02.2023) или новее. См. <a href="ch01-01-installation.html">раздел «Установка» главы 1</a><!-- ignore --> для установки или обновления Rust.</p>
<p>HTML-исполнение книги доступна онлайн по адресам <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a><sub>(англ.)</sub> и <a href="https://doc.rust-lang.ru/book">https://doc.rust-lang.ru/book</a><sub>(рус.)</sub> и офлайн. При установке Rust с помощью <code>rustup</code>: просто запустите <code>rustup docs --book</code>, чтобы её открыть.</p>
<p>Также доступны несколько <a href="appendix-06-translation.html">переводов</a> от сообщества.</p>
<p>Этот материал доступен в виде <a href="https://nostarch.com/rust-programming-language-2nd-edition">печатной книги в мягкой обложке и в формате электронной книги от No Starch Press</a> .</p>
<blockquote>
<p><strong>🚨 Предпочитаете более интерактивный процесс обучения? Попробуйте другую исполнение Rust Book, в которой есть: управлениеные вопросы, цветовое выделение, наглядные визуализации и многое другое</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Предисловие"><a class="header" href="#Предисловие">Предисловие</a></h1>
<p>Не всегда было ясно, но язык программирования Rust в основном посвящён <em>расширению возможностей</em>: независимо от того, какой код вы пишете сейчас, Rust позволяет вам достичь большего, чтобы программировать уверенно в более широком ряде областей, чем вы делали раньше.</p>
<p>Возьмём, к примеру, работу «системного уровня», которая касается низкоуровневых подробностей управления памятью, представления данных и многопоточности. Традиционно эта область программирования считается загадочной, доступной лишь немногим избранным, посвятившим долгие годы изучению всех её печально известных подводных камней. И даже те, кто практикуют это, делают всё с осторожностью, чтобы их код не был уязвим для эксплойтов, сбоев или повреждений.</p>
<p>Rust разрушает эти преграды, устраняя старые подводные камни и предоставляя дружелюбный, отполированный набор средств, который поможет вам на этом пути. Программисты, которым необходимо «погрузиться» в низкоуровневое управление, могут сделать это с помощью Rust, не беря на себя привычный риск аварий или дыр в безопасности и не изучая тонкости изменчивых наборов средств. Более того, язык предназначен для того, чтобы легко вести вас к надёжному коду, который эффективен с точки зрения скорости и использования памяти.</p>
<p>Программисты, которые уже работают с низкоуровневым кодом, могут использовать Rust для повышения своих чувства собственной значимости. Например, внедрение параллелизма в Rust является операцией с относительно низким риском: сборщик поймает для вас классические ошибки. И вы можете заняться более агрессивной оптимизацией в своём коде с уверенностью, что не будете случайно добавлять в код сбои или уязвимости.</p>
<p>Но Rust не ограничивается низкоуровневым системным программированием. Он достаточно выразителен и эргономичен, чтобы приложения CLI (Command Line Interface – окно выводаные программы), веб-серверы и многие другие виды кода были довольно приятными для написания — позже вы найдёте простые примеры того и другого в книге. Работа с Rust позволяет вырабатывать навыки, которые переносятся из одной предметной области в другую; вы можете изучить Rust, написав веб-приложение, а затем применить те же навыки для Raspberry Pi.</p>
<p>Эта книга полностью раскрывает потенциал Rust для расширения возможностей его пользователей. Это дружелюбный и доступный материал, призванный помочь вам повысить уровень не только ваших знаний о Rust, но и ваших возможностей и уверенности как программиста в целом. Так что погружайтесь, готовьтесь учиться и добро пожаловать в сообщество Rust!</p>
<p>— Nicholas Matsakis и Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<blockquote>
<p>Примечание. Это издание книги такое же, как и <a href="https://nostarch.com/rust-programming-language-2nd-edition">Язык программирования Rust</a>, доступное в печатном и электронном формате от <a href="https://nostarch.com/">No Starch Press</a>.</p>
</blockquote>
<p>Добро пожаловать в <em>The Rust Programming Language</em>, вводную книгу о Rust. Язык программирования Rust помогает создавать быстрые, более надёжные приложения. Хорошая эргономика и низкоуровневый управление часто являются противоречивыми требованиями для дизайна языков программирования; Rust бросает вызов этому конфликту. Благодаря уравновешенности мощных технических возможностей c большим удобством разработки, Rust предоставляет возможности управления низкоуровневыми элементами (например, использование памяти) без трудностей, традиционно связанных с таким управлением.</p>
<h2 id="Кому-подходит-rust"><a class="header" href="#Кому-подходит-rust">Кому подходит Rust</a></h2>
<p>Rust наилучше подходит для многих людей по целому ряду причин. Давайте рассмотрим несколько наиболее важных групп.</p>
<h3 id="Команды-разработчиков"><a class="header" href="#Команды-разработчиков">Команды разработчиков</a></h3>
<p>Rust  показал себя как продуктивный средство для совместной работы больших приказовразработчиков с разным уровнем знаний в области системного программирования. Низкоуровневый код подвержен различным трудноуловимым ошибкам, которые в большинстве других языков могут быть обнаружены только с помощью тщательного тестирования и проверки кода опытными разработчиками. В Rust сборщик играет роль привратника, отказываясь собирать код с этими неуловимыми ошибками, включая ошибки параллелизма. Работая вместе с сборщиком, приказ может сфокусироваться на работе над логикой программы, а не над поиском ошибок.</p>
<p>Rust также привносит современные средства разработчика в мир системного программирования:</p>
<ul>
<li>Cargo, входящий в комплект менеджер зависимостей и средство сборки, делает добавление, сборку и управление зависимостями безболезненным и согласованным в рамках всей экосистемы Rust.</li>
<li>Средство форматирования Rustfmt обеспечивает единый стиль кодирования для всех разработчиков.</li>
<li>Rust Language Server обеспечивает встраивание с встроенной средой разработки (IDE) для автодополнения кода и встроенных сообщений об ошибках.</li>
</ul>
<p>Благодаря применению этих и других средств в экосистеме Rust разработчики способны продуктивно работать при написании кода системного уровня.</p>
<h3 id="Студенты"><a class="header" href="#Студенты">Студенты</a></h3>
<p>Rust полезен для студентов и тех, кто увлечен в изучении  системных концепций. Используя Rust, многие люди узнали о таких темах, как разработка операционных систем. Сообщество радушно и с удовольствием ответит на вопросы начинающих. Благодаря усилиям — таким, как эта книга — приказы Rust хотят сделать концепции систем более доступными для большего числа людей, особенно для новичков в программировании.</p>
<h3 id="Компании"><a class="header" href="#Компании">Компании</a></h3>
<p>Сотни больших и малых компаний используют Rust в промышленных условиях для решения различных задач, включая средства приказной строки, веб-сервисы, средства DevOps, встраиваемые устройства, анализ и транскодирование аудио и видео, криптовалюты, биоинформатику, поисковые системы, приложения Интернета вещей, машинное обучение и даже основные части веб-браузера Firefox.</p>
<h3 id="Разработчики-open-source"><a class="header" href="#Разработчики-open-source">Разработчики Open Source</a></h3>
<p>Rust предназначен для людей, которые хотят развивать язык программирования Rust, сообщество, средства для разработчиков и библиотеки. Мы будем рады, если вы внесёте свой вклад в развитие языка Rust.</p>
<h3 id="Люди-ценящие-скорость-и-безотказность"><a class="header" href="#Люди-ценящие-скорость-и-безотказность">Люди, ценящие скорость и безотказность</a></h3>
<p>Rust предназначен для любителей скорости и безотказности в языке. Под скоростью мы подразумеваем как быстродействие программы на Rust, так и быстроту, с которой Rust позволяет писать программы. Проверки сборщика Rust обеспечивают безотказность за счёт функциональных дополнений и рефакторинга. Это выгодно отличается от хрупкого унаследованного кода в языках без таких проверок, который разработчики часто боятся изменять. Благодаря обеспечению абстракций с нулевой стоимостью, высокоуровневых возможностей, собираемых в низкоуровневый код такой же быстрый, как и написанный вручную, Rust стремится сделать безопасный код ещё и быстрым.</p>
<p>Язык Rust надеется поддержать и многих других пользователей; перечисленные здесь - лишь самые значимые увлеченные лица. В целом, главная цель Rust - избавиться от соглашений, на которые программисты шли десятилетиями, обеспечив безопасность <em>и</em> производительность, скорость <em>и</em> эргономичность. Попробуйте Rust и убедитесь, подойдут ли вам его решения.</p>
<h2 id="Для-кого-эта-книга"><a class="header" href="#Для-кого-эта-книга">Для кого эта книга</a></h2>
<p>В этой книге предполагается, что вы писали код на другом языке программирования, но не оговаривается, на каком именно. Мы постарались сделать материал доступным для широкого круга людей с разным уровнем подготовки в области программирования. Мы не будем тратить время на обсуждение <em>сути понятия</em> программирования или как его понимать. Если вы совсем новичок в программировании, советуем прочитать книгу, посвящённую введению в программирование.</p>
<h2 id="Как-использовать-эту-книгу"><a class="header" href="#Как-использовать-эту-книгу">Как использовать эту книгу</a></h2>
<p>В целом, книга предполагает, что вы будете читать последовательно от начала до конца. Более поздние главы опираются на концепции, изложенные в предыдущих главах, а предыдущие главы могут не углубляться в подробности именно темы, так как в последующих главах они будут рассматриваться более подробно.</p>
<p>В этой книге вы найдёте два вида глав: главы о концепциях и главы с проектом. В главах о концепциях вы узнаете о каком-либо особенности Rust. В главах проекта мы будем вместе создавать небольшие программы, применяя то, что вы уже узнали. Главы 2, 12 и 20 - это главы проекта; остальные - главы о концепциях.</p>
<p>Глава 1 объясняет, как установить Rust, как написать программу "Hello, world!" и как использовать Cargo, менеджер пакетов и средство сборки Rust. Глава 2 - это практическое введение в написание программы на Rust, в которой вам предлагается создать игру для угадывания чисел. Здесь мы рассмотрим концепции на высоком уровне, а в последующих главах будет предоставлена дополнительная сведения. Если вы хотите сразу же приступить к работе, глава 2 - самое подходящее место для этого. В главе 3 рассматриваются возможности Rust, схожие с возможностями других языков программирования, а в главе 4 вы узнаете о системе владения Rust. Если вы особенно дотошный ученик и предпочитаете изучить каждую подробность, прежде чем переходить к следующей, возможно, вы захотите пропустить главу 2 и сразу перейти к главе 3, вернувшись к главе 2, когда захотите поработать над проектом, применяя изученные подробности.</p>
<p>Глава 5 описывает структуры и способы, а глава 6 охватывает перечисления, выражения <code>match</code> и конструкции управления потоком <code>if let</code>. Вы будете использовать структуры и перечисления для создания пользовательских видов в Rust.</p>
<p>В главе 7 вы узнаете о системе модулей Rust, о правилах организации приватности вашего кода и его публичном внешней оболочке прикладного программирования (API). В главе 8 обсуждаются некоторые распространённые структуры данных - собрания, которые предоставляет стандартная библиотека, такие как векторы, строки и HashMaps. В главе 9 рассматриваются философия и способы обработки ошибок в Rust.</p>
<p>В главе 10 рассматриваются шаблонные виды данных, типажи и времена жизни, позволяющие написать код, который может использоваться разными видами. Глава 11 посвящена тестированию, которое даже с заверениями безопасности в Rust необходимо для обеспечения правильной логики вашей программы. В главе 12 мы создадим собственную реализацию подмножества функциональности средства приказной строки <code>grep</code>, предназначенного для поиска текста в файлах. Для этого мы будем использовать многие концепции, которые обсуждались в предыдущих главах.</p>
<p>В главе 13 рассматриваются замыкания и повторители: особенности Rust, пришедшие из функциональных языков программирования. В главе 14 мы более подробно рассмотрим Cargo и поговорим о лучших способах распространения ваших библиотек среди других разработчиков. В главе 15 обсуждаются умные указатели, которые предоставляет стандартная библиотека, и типажи, обеспечивающие их функциональность.</p>
<p>В главе 16 мы рассмотрим различные модели параллельного программирования и поговорим о возможности Rust для безбоязненного многопоточно программирования. В главе 17 рассматривается сравнение идиом Rust с принципами объектно-ориентированного программирования, которые наверняка вам знакомы.</p>
<p>Глава 18 - это справочник по шаблонам и сопоставлению с образцами, которые являются мощными способами выражения идей в программах на Rust. Глава 19 содержит множество важных дополнительных тем, включая небезопасный Rust, макросы и многое другое о времени жизни, типажах, видах, функциях и замыканиях.</p>
<p>В главе 20 мы завершим проект, в котором реализуем низкоуровневый многопоточный веб-сервер!</p>
<p>Наконец, некоторые приложения содержат полезную сведения о языке в более справочном формате. В приложении A рассматриваются ключевые слова Rust, в приложении B — операторы и символы Rust, в приложении C — производные типажи, предоставляемые встроенной библиотекой, в приложении D — некоторые полезные средства разработки, а в приложении E — издания Rust. В приложении F вы найдёте переводы книги, а в приложении G мы расскажем о том, как создаётся Rust и что такое nightly Rust.</p>
<p>Нет неправильного способа читать эту книгу: если вы хотите пропустить главу - сделайте это! Возможно, вам придётся вернуться к предыдущим главам, если возникнет недопонимание. Делайте все, как вам удобно.</p>
<p><span id="ferris"></span></p>
<p>Важной частью процесса обучения Rust является изучение того, как читать сообщения об ошибках, которые отображает сборщик: они приведут вас к работающему коду. Мы изучим много примеров, которые не собираются и отображают ошибки в сообщениях сборщика в разных ситуациях. Знайте, что если вы введёте и запустите случайный пример, он может не собраться! Убедитесь, что вы прочитали окружающий текст, чтобы понять, не предназначен ли пример, который вы пытаетесь запустить, для отображения ошибки. Ferris также поможет вам различить код, который не предназначен для работы:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Пояснения</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"></td><td>Этот код не собирается!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Феррис вскидывает руки"></td><td>Этот код вызывает панику!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Феррис с одним когтем вверх, пожимая плечами"></td><td>Этот код не приводит к желаемому поведению.</td></tr>
</tbody></table>
</div>
<p>В большинстве случаев мы приведём вас к правильной исполнения любого кода, который не собирается.</p>
<h2 id="Исходные-коды"><a class="header" href="#Исходные-коды">Исходные коды</a></h2>
<p>Файлы с исходным кодом, используемым в этой книге, можно найти на <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Начало-работы"><a class="header" href="#Начало-работы">Начало работы</a></h1>
<p>Начнём наше путешествие в Rust! Нужно много всего изучить, но каждое путешествие с чего-то начинается. В этой главе мы обсудим:</p>
<ul>
<li>установку Rust на Linux, macOS и Windows,</li>
<li>написание программы, печатающей <code>Hello, world!</code>,</li>
<li>использование <code>cargo</code>, менеджера пакетов и системы сборки в одном лице для Rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Установка"><a class="header" href="#Установка">Установка</a></h2>
<p>Первым шагом является установка Rust. Мы загрузим Rust, используя средство приказной строки <code>rustup</code>, предназначенный для управлениями исполнениями Rust и другими связанными с ним средствами. Вам понадобится интернет-соединение для его загрузки.</p>
<blockquote>
<p>Примечание: если вы по каким-то причинам предпочитаете не использовать rustup, пожалуйста, посетите <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">страницу «Другие способы установки Rust»</a> для получения дополнительных опций.</p>
</blockquote>
<p>Следующие шаги устанавливают последнюю безотказную исполнение сборщика Rust. Благодаря заверениям безотказности Rust все примеры в книге, которые собираются, будут собираться и в новых исполнениях Rust. Вывод может немного отличаться в разных исполнениях, поскольку Rust часто улучшает сообщения об ошибках и предупреждения. Другими словами, любая новая, безотказная исполнение Rust, которую вы установите с помощью этих шагов, должна работать с содержимым этой книги так, как ожидается.</p>
<blockquote>
<h3 id="Условные-обозначения-приказной-строки"><a class="header" href="#Условные-обозначения-приказной-строки">Условные обозначения приказной строки</a></h3>
<p>В этой главе и во всей книге мы будем выполнять некоторые приказы, используемые в окне вызова. Строки, которые вы должны вводить в окне вызова, начинаются с <code>$</code>. Вам не нужно вводить символ <code>$</code>; это подсказка приказной строки, отображаемая для обозначения начала каждой приказы. Строки, которые не начинаются с <code>$</code>, обычно показывают вывод предыдущей приказы. Кроме того, в примерах, своеобразных для PowerShell, будет использоваться <code>&gt;</code>, а не <code>$</code>.</p>
</blockquote>
<h3 id="Установка-rustup-на-linux-или-macos"><a class="header" href="#Установка-rustup-на-linux-или-macos">Установка <code>rustup</code> на Linux или macOS</a></h3>
<p>Если вы используете Linux или macOS, пожалуйста, выполните следующую приказ:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Приказ загружает сценарий и запускает установку средства <code>rustup</code>, который устанавливает последнюю безотказную исполнение Rust. Вам может быть предложено ввести пароль. Если установка прошла успешно, появится следующая строка:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Вам также понадобится <em>составитель (linker)</em> — программа, которую Rust использует для объединения своих собранных выходных данных в один файл. Скорее всего, он у вас уже есть. При возникновении ошибок объединения, вам следует установить сборщик C, который обычно будет включать в себя и составитель. Сборщик C также полезен, потому что некоторые распространённые пакеты Rust зависят от кода C и нуждаются в сборщике C.</p>
<p>На macOS вы можете получить сборщик C, выполнив приказ:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Пользователи Linux, как правило, должны устанавливать GCC или Clang в соответствии с документацией их дистрибутива. Например, при использовании Ubuntu можно установить пакет <code>build-essential</code>.</p>
<h3 id="Установка-rustup-на-windows"><a class="header" href="#Установка-rustup-на-windows">Установка <code>rustup</code> на Windows</a></h3>
<p>На Windows перейдите по адресу <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> и следуйте указаниям по установке Rust. На определённом этапе установки вы получите сообщение, предупреждающее, что вам также понадобятся средства сборки MSVC для Visual Studio 2013 или более поздней исполнения.</p>
<p>Чтобы получить средства сборки, вам потребуется установить <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a>. На вопрос о том, какие компоненты необходимо установить, выберите:</p>
<ul>
<li>“Desktop Development with C++”</li>
<li>The Windows 10 or 11 SDK</li>
<li>Английский языковой пакет вместе с любым другим языковым пакетом по вашему выбору.</li>
</ul>
<p>В остальной части этой книги используются приказы, которые работают как в <em>cmd.exe</em>, так и в PowerShell. При наличии отличительных различий мы объясним, что необходимо сделать в таких случаях.</p>
<h3 id="Устранение-возможных-ошибок"><a class="header" href="#Устранение-возможных-ошибок">Устранение возможных ошибок</a></h3>
<p>Чтобы проверить, правильно ли у вас установлен Rust, откройте оболочку и введите эту строку:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Вы должны увидеть номер исполнения, хэш фиксации и дату фиксации для последней безотказной исполнения, которая была выпущена, в следующем формате:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Если вы видите эту сведения, вы успешно установили Rust! Если вы не видите эту сведения, убедитесь, что Rust находится в вашей системной переменной <code>%PATH%</code> следующим образом:</p>
<p>В Windows CMD:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>В PowerShell:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>В Linux и macOS:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Если все было сделано правильно, но Rust все ещё не работает, есть несколько мест, где вам могут помочь. Узнайте, как связаться с другими Rustaceans (так мы себя называем) на <a href="https://www.rust-lang.org/community">странице сообщества</a>.</p>
<h3 id="Обновление-и-удаление"><a class="header" href="#Обновление-и-удаление">Обновление и удаление</a></h3>
<p>После установки Rust с помощью <code>rustup</code> обновление до новой исполнения не составит труда. В приказной оболочке запустите следующий скрипт обновления:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Чтобы удалить Rust и <code>rustup</code>, выполните следующую приказ:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="Локальная-документация"><a class="header" href="#Локальная-документация">Локальная документация</a></h3>
<p>Установка Rust также включает местную копию документации, чтобы вы могли читать её в без доступа к мировой сети режиме. Выполните <code>rustup doc</code>, чтобы открыть местную документацию в браузере.</p>
<p>Если стандартная библиотека предоставляет вид или функцию, а вы не знаете, что она делает или как её использовать, воспользуйтесь документацией внешней оболочки прикладного программирования (API), чтобы это узнать!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Привет-мир"><a class="header" href="#Привет-мир">Привет, мир!</a></h2>
<p>Теперь, когда вы установили Rust, пришло время написать свою первую программу на Rust. Традиционно при изучении нового языка принято писать небольшую программу, которая печатает на экране текст <code>Привет, мир!</code>, поэтому мы сделаем то же самое!</p>
<blockquote>
<p>Примечание: Эта книга предполагает наличие достаточного навыка работы с приказной строкой. Rust не предъявляет особых требований к тому, каким набором средств вы пользуетесь для изменения или хранения вашего кода, поэтому если вы предпочитаете использовать встроенную среду разработки (IDE) вместо приказной строки, смело используйте вашу любимую IDE. Многие IDE сейчас в той или иной степени поддерживают Rust; подробности можно узнать из документации к IDE. Объединение Rust сосредоточилась на обеспечении отличной поддержки IDE с помощью <code>rust-analyzer</code>. Более подробную сведения смотрите в <a href="appendix-04-useful-development-tools.html">Приложении D</a><!-- ignore -->.</p>
</blockquote>
<h3 id="Создание-папки-проекта"><a class="header" href="#Создание-папки-проекта">Создание папки проекта</a></h3>
<p>Прежде всего начнём с создания папки, в которой будем сохранять наш код на языке Rust. На самом деле не важно, где сохранять наш код. Однако, для упражнений и проектов, обсуждаемых в данной книге, мы советуем создать папку <em>projects</em> в вашем домашнем каталоге, там же и хранить в будущем код программ из книги.</p>
<p>Откройте окно вызова и введите следующие приказы для того, чтобы создать папку <em>projects</em> для хранения кода разных проектов, и, внутри неё, папку <em>hello_world</em> для проекта “Привет, мир!”.</p>
<p>Для Linux, macOS и PowerShell на Windows, введите:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Для Windows в CMD, введите:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="Написание-и-запуск-первой-rust-программы"><a class="header" href="#Написание-и-запуск-первой-rust-программы">Написание и запуск первой Rust программы</a></h3>
<p>Затем создайте новый исходный файл и назовите его <em>main.rs</em>. Файлы Rust всегда заканчиваются расширением <em>.rs</em>. Если вы используете более одного слова в имени файла, принято разделять их символом подчёркивания. Например, используйте <em>hello_world.rs</em> вместо <em>helloworld.rs</em>.</p>
<p>Теперь откроем файл <em>main.rs</em> для изменения и введём следующие строки кода:</p>
<p><span class="filename">Название файла: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Привет, мир!");
}</code></pre></pre>
<p><span class="caption">Приложение 1-1: Программа, которая печатает <code>Привет, мир!</code></span></p>
<p>Сохраните файл и вернитесь в окно окна вызова в каталог <em>~/projects/hello_world</em>. В Linux или macOS введите следующие приказы для сборки и запуска файла:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Привет, мир!
</code></pre>
<p>В Windows, введите приказ <code>.\main.exe</code> вместо <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Привет, мир!
</code></pre>
<p>Независимо от вашей операционной системы, строка <code>Привет, мир!</code> должна быть выведена на окно вызова. Если вы не видите такого вывода, обратитесь к разделу <a href="ch01-01-installation.html#troubleshooting">"Устранение неполадок"</a><!-- ignore -->, чтобы узнать, как получить помощь.</p>
<p>Если напечаталось <code>Привет, мир!</code>, то примите наши поздравления! Вы написали программу на Rust, что делает вас Rust программистом — добро пожаловать!</p>
<h3 id="Анатомия-программы-на-rust"><a class="header" href="#Анатомия-программы-на-rust">Анатомия программы на Rust</a></h3>
<p>Давайте рассмотрим «Привет, мир!» программу в подробностях. Вот первая часть головоломки:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>Эти строки определяют функцию с именем <code>main</code>. Функция <code>main</code> особенная: это всегда первый код, который запускается в каждой исполняемой программе Rust. Первая строка объявляет функцию с именем <code>main</code>, которая не имеет свойств и ничего не возвращает. Если бы были свойства, они бы заключались в круглые скобки <code>()</code>.</p>
<p>Тело функции заключено в <code>{}</code>. Rust требует фигурных скобок вокруг всех тел функций. Хороший стиль — поместить открывающую фигурную скобку на ту же строку, что и объявление функции, добавив между ними один пробел.</p>
<blockquote>
<p>Примечание: Если хотите придерживаться принятого стиля во всех проектах Rust, вы можете использовать средство самостоятельного форматирования под названием <code>rustfmt</code> для форматирования кода в определённом стиле (подробнее о <code>rustfmt</code> в <a href="appendix-04-useful-development-tools.html">Приложении D</a><!-- ignore -->. Объединение Rust включила этот средство в стандартный дистрибутив Rust, как <code>rustc</code>, поэтому он уже должен быть установлен на вашем компьютере!</p>
</blockquote>
<p>Тело функции <code>main</code> содержит следующий код:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!("Привет, мир!");
<span class="boring">}</span></code></pre></pre>
<p>Эта строка делает всю работу в этой маленькой программе: печатает текст на экран. Можно заметить четыре важных подробности.</p>
<p>Во-первых, стиль Rust предполагает отступ в четыре пробела, а не табуляцию.</p>
<p>Во-вторых, <code>println!</code> вызывается макрос Rust. Если бы вместо него была вызвана функция, она была бы набрана как <code>println</code> (без <code>!</code>). Более подробно мы обсудим макросы Rust в главе 19. Пока достаточно знать, что использование <code>!</code> подразумевает вызов макроса вместо обычной функции, и что макросы не всегда подчиняются тем же правилам как функции.</p>
<p>В-третьих, вы видите строку <code>"Привет, мир!"</code>. Мы передаём её в качестве переменной макросу <code>println!</code>, и она выводится на экран.</p>
<p>В-четвёртых, мы завершаем строку точкой с запятой (<code>;</code>), которая указывает на окончание этого выражения и возможность начала следующего. Большинство строк кода Rust заканчиваются точкой с запятой.</p>
<h3 id="Сборка-и-запуск---это-отдельные-шаги"><a class="header" href="#Сборка-и-запуск---это-отдельные-шаги">Сборка и запуск - это отдельные шаги</a></h3>
<p>Вы только что запустили впервые созданную программу, поэтому давайте рассмотрим каждый шаг этого процесса.</p>
<p>Перед запуском программы на Rust вы должны собрать её с помощью сборщика Rust, введя приказ <code>rustc</code> и передав ей имя вашего исходного файла, например:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Если у вас есть опыт работы с C или C++, вы заметите, что это похоже на <code>gcc</code> или <code>clang</code>. После успешной сборки Rust выводит двоичный исполняемый файл.</p>
<p>В Linux, macOS и PowerShell в Windows вы можете увидеть исполняемый файл, введя приказ <code>ls</code> в оболочке:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>В Linux и macOS вы увидите два файла. При использовании PowerShell в Windows вы увидите такие же три файла, как и при использовании CMD. Используя CMD в Windows, введите следующее:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Это показывает исходный код файла с расширением <em>.rs</em>, исполняемый файл (<em>main.exe</em> на Windows, но <em>main</em> на всех других платформах) и, при использовании Windows, файл, содержащий отладочную сведения с расширением <em>.pdb</em>. Отсюда вы запускаете файлы <em>main</em> или <em>main.exe</em>, например:</p>
<pre><code class="language-console">$ ./main # для Linux
&gt; .\main.exe # для Windows
</code></pre>
<p>Если ваш <em>main.rs</em> — это ваша программа «Привет, мир!», эта строка выведет в окно вызова <code>Привет, мир!</code>.</p>
<p>Если вы лучше знакомы с изменяемыми языками, такими как Ruby, Python или JavaScript, возможно, вы не привыкли собирать и запускать программу как отдельные шаги. Rust — это предварительно <em>собранный</em> язык, то есть вы можете собрать программу и передать исполняемый файл кому-то другому, и он сможет запустить его даже без установленного Rust. Если вы даёте кому-то файл <em>.rb</em> , <em>.py</em> или <em>.js</em>, у него должна быть установлена реализация Ruby, Python или JavaScript (соответственно). Но в этих языках вам нужна только одна приказ для сборки и запуска вашей программы. В дизайне языков программирования всё — соглашение.</p>
<p>Сборка с помощью <code>rustc</code> подходит для простых программ, но по мере роста вашего проекта вы захотите управлять всеми свойствами и упростить передачу кода. Далее мы познакомим вас с средством Cargo, который поможет вам писать программы из реального мира на Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Привет-cargo"><a class="header" href="#Привет-cargo">Привет, Cargo!</a></h2>
<p>Cargo - это система сборки и менеджер пакетов Rust. Большая часть разработчиков используют данный средство для управления проектами, потому что Cargo выполняет за вас множество задач, таких как сборка кода, загрузка библиотек, от которых зависит ваш код, и создание этих библиотек. (Мы называем библиотеки, которые нужны вашему коду, <em>зависимостями</em>.)</p>
<p>Самые простые программы на Rust, подобные той, которую мы написали, не имеют никаких зависимостей. Если бы мы сделали проект «Hello, world!» с Cargo, он бы использовал только ту часть Cargo, которая отвечает за сборку вашего кода. По мере написания более сложных программ на Rust вы будете добавлять зависимости, а если вы начнёте проект с использованием Cargo, добавлять зависимости станет намного проще.</p>
<p>Поскольку значительное число проектов Rust используют Cargo, оставшаяся часть книги подразумевает, что вы тоже используете Cargo. Cargo входит в комплект поставки Rust, если вы использовали напрямую от разрабочиков программы установки, рассмотренные в разделе <a href="ch01-01-installation.html#installation">"Установка"</a><!-- ignore -->. Если вы установили Rust другим способом, проверьте, установлен ли Cargo, введя в окне вызова следующее:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Если приказ выдал номер исполнения, то значит Cargo установлен. Если вы видите ошибку, вроде <code>command not found</code> ("приказ не найдена"), загляните в документацию для использованного вами способа установки, чтобы выполнить установку Cargo отдельно.</p>
<h3 id="Создание-проекта-с-помощью-cargo"><a class="header" href="#Создание-проекта-с-помощью-cargo">Создание проекта с помощью Cargo</a></h3>
<p>Давайте создадим новый проект с помощью Cargo и посмотрим, как он отличается от нашего начального проекта "Hello, world!". Перейдите обратно в папку <em>projects</em> (или любую другую, где вы решили сохранять код). Затем, в любой операционной системе, запустите приказ:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Первая приказ создаёт новый каталог и проект с именем <em>hello_cargo</em>. Мы назвали наш проект <em>hello_cargo</em>, и Cargo создаёт свои файлы в каталоге с тем же именем.</p>
<p>Перейдём в каталог <em>hello_cargo</em> и посмотрим файлы. Увидим, что Cargo сгенерировал два файла и одну папку: файл  <em>Cargo.toml</em> и каталог <em>src</em> с файлом <em>main.rs</em> внутри.</p>
<p>Кроме того, cargo инициализировал новый репозиторий Git вместе с файлом <em>.gitignore</em>. Файлы Git не будут сгенерированы, если вы запустите <code>cargo new</code> в существующем репозитории Git; вы можете изменить это поведение, используя <code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Примечание. Git — это распространённая система управления исполнений. Вы можете изменить <code>cargo new</code>, чтобы использовать другую систему управления исполнений или не использовать систему управления исполнений, используя флаг <code>--vcs</code>. Запустите <code>cargo new --help</code>, чтобы увидеть доступные свойства.</p>
</blockquote>
<p>Откройте файл <em>Cargo.toml</em> в любом текстовом редакторе. Он должен выглядеть как код в приложении 1-2.</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Приложение 1-2: Содержимое файла <em>Cargo.toml</em>, сгенерированное приказом <code>cargo new</code></span></p>
<p>Это файл в формате <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!--  --> (<em>Tom’s Obvious, Minimal Language</em>), который является форматом настроек Cargo.</p>
<p>Первая строка, <code>[package]</code>, является заголовочной секцией, которая указывает что следующие указания настраивают пакет. По мере добавления больше сведений в данный файл, будет добавляться больше секций и указаний (строк).</p>
<p>Следующие три строки задают сведения о настройке, необходимую Cargo для сборки вашей программы: имя, исполнение и издание Rust, который будет использоваться. Мы поговорим о ключе <code>edition</code> в <a href="appendix-05-editions.html">Приложении E</a><!-- ignore -->.</p>
<p>Последняя строка, <code>[dependencies]</code> является началом секции для списка любых зависимостей вашего проекта. В Rust, это внешние пакеты кода, на которые ссылаются ключевым словом <em>crate</em>. Нам не нужны никакие зависимости в данном проекте, но мы будем использовать их в первом проекте главы 2, так что нам пригодится данная секция зависимостей потом.</p>
<p>Откройте файл <em>src/main.rs</em> и загляните в него:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo сгенерировал для вас программу "Hello, world!", подобную той, которую мы написали в Приложении 1-1! Пока что различия между нашим предыдущим проектом и проектом, сгенерированным при помощи Cargo, заключаются в том, что Cargo поместил исходный код в каталог <em>src</em>, и у нас есть настроечный файл <em>Cargo.toml</em> в верхнем каталоге проекта.</p>
<p>Cargo ожидает, что ваши исходные файлы находятся внутри каталога <em>src</em>. Каталог верхнего уровня проекта предназначен только для файлов README, сведений о лицензии, файлы настройке и чего то ещё не относящего к вашему коду. Использование Cargo помогает организовывать проект. Есть место для всего и все находится на своём месте.</p>
<p>Если вы начали проект без использования Cargo, как мы делали для "Hello, world!" проекта, то можно преобразовывать его в проект с использованием Cargo. Переместите код в подкаталог <em>src</em> и создайте соответствующий файл <em>Cargo.toml</em> в папке.</p>
<h3 id="Сборка-и-запуск-cargo-проекта"><a class="header" href="#Сборка-и-запуск-cargo-проекта">Сборка и запуск Cargo проекта</a></h3>
<p>Посмотрим, в чем разница при сборке и запуске программы "Hello, world!" с помощью Cargo. В каталоге <em>hello_cargo</em> соберите проект следующей приказом:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Этот приказ создаёт исполняемый файл в <em>target/debug/hello_cargo</em> (или <em>target\debug\hello_cargo.exe</em> в Windows), а не в вашем текущем каталоге. Поскольку стандартная сборка является отладочной, Cargo помещает двоичный файл в каталог с именем <em>debug</em>. Вы можете запустить исполняемый файл с помощью этой приказы:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>Если все хорошо, то <code>Hello, world!</code> печатается в окне вызова. Запуск приказы <code>cargo build</code> в первый раз также приводит к созданию нового файла <em>Cargo.lock</em> в папке верхнего уровня. Данный файл хранит точные исполнения зависимостей вашего проекта. Так как у нас нет зависимостей, то файл пустой. Вы никогда не должны менять этот файл вручную: Cargo сам управляет его содержимым для вас.</p>
<p>Только что мы собрали проект приказом <code>cargo build</code> и запустили его из <code>./target/debug/hello_cargo</code>. Но мы также можем при помощи приказы <code>cargo run</code> сразу и собрать код, и затем запустить полученный исполняемый файл всего лишь одной приказом:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Использование <code>cargo run</code> более удобно, чем необходимость помнить и запускать <code>cargo build</code>, а затем использовать весь путь к двоичному файлу, поэтому большинство разработчиков используют <code>cargo run</code>.</p>
<p>Обратите внимание, что на этот раз мы не видели вывода, указывающего на то, что Cargo собирает <code>hello_cargo</code>. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать, а просто запустил двоичный файл. Если бы вы изменили свой исходный код, Cargo пересобрал бы проект перед его запуском, и вы бы увидели этот вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo также предоставляет приказ, называемую <code>cargo check</code>. Этот приказ быстро проверяет ваш код, чтобы убедиться, что он собирается, но не создаёт исполняемый файл:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Почему вам не нужен исполняемый файл? Часто <code>cargo check</code> выполняется намного быстрее, чем <code>cargo build</code>, поскольку пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу во время написания кода, использование <code>cargo check</code> ускорит процесс информирования вас о том, что ваш проект всё ещё собирается! Таким образом, многие Rustacean периодически запускают <code>cargo check</code>, когда пишут свои программы, чтобы убедиться, что она собирается. Затем они запускают <code>cargo build</code>, когда готовы использовать исполняемый файл.</p>
<p>Давайте подытожим, что мы уже узнали о Cargo:</p>
<ul>
<li>Мы можем создать проект с помощью <code>cargo new</code>.</li>
<li>можно собирать проект, используя приказ <code>cargo build</code>,</li>
<li>можно одновременно собирать и запускать проект одной приказом <code>cargo run</code>,</li>
<li>можно собрать проект для проверки ошибок с помощью <code>cargo check</code>, не тратя время на кодогенерацию исполняемого файла,</li>
<li>cargo сохраняет результаты сборки не в папку с исходным кодом, а в отдельный каталог <em>target/debug</em>.</li>
</ul>
<p>Дополнительным преимуществом использования Cargo является то, что его приказы одинаковы для разных операционных систем. С этой точки зрения, мы больше не будем предоставлять отдельные указания для Linux, macOS или Windows.</p>
<h3 id="Сборка-финальной-исполнения-release"><a class="header" href="#Сборка-финальной-исполнения-release">Сборка финальной исполнения (Release)</a></h3>
<p>Когда проект, наконец, готов к релизу, можно использовать приказ <code>cargo build --release</code> для его сборки с оптимизацией. Данная приказ создаёт исполняемый файл в папке <em>target/release</em> в отличии от папки <em>target/debug</em>. Оптимизации делают так, что Rust код работает быстрее, но их включение увеличивает время сборки. По этой причине есть два отдельных профиля: один для разработки, когда нужно осуществлять сборку быстро и часто, и другой, для сборки финальной программы, которую будете отдавать пользователям, которая готова к работе и будет выполняться максимально быстро. Если вы замеряете время выполнения вашего кода, убедитесь, что собрали проект с оптимизацией <code>cargo build --release</code> и тестируете исполняемый файл из папки <em>target/release</em>.</p>
<h3 id="cargo-как-Конвенция"><a class="header" href="#cargo-как-Конвенция">Cargo как Конвенция</a></h3>
<p>В простых проектах Cargo не даёт больших преимуществ по сравнению с использованием <code>rustc</code>, но он проявит себя, когда ваши программы станут более сложными. Когда программы вырастают до нескольких файлов или нуждаются в зависимостях, гораздо проще позволить Cargo координировать сборку.</p>
<p>Не смотря на то, что проект <code>hello_cargo</code> простой, теперь он  использует большую часть реального набора средств, который вы будете повседневно использовать в вашей карьере, связанной с Rust. Когда потребуется работать над проектами размещёнными в сети, вы сможете просто использовать следующую последовательность приказовдля получения кода с помощью Git, перехода в каталог проекта, сборку проекта:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Для получения дополнительной сведений о Cargo ознакомьтесь с <a href="https://doc.rust-lang.org/cargo/">его документацией</a> .</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Теперь вы готовы начать своё Rust путешествие! В данной главе вы изучили как:</p>
<ul>
<li>установить последнюю безотказную исполнение Rust, используя <code>rustup</code>,</li>
<li>обновить Rust до последней исполнения,</li>
<li>открыть местно установленную документацию,</li>
<li>написать и запустить программу вида "Hello, world!", используя напрямую сборщик <code>rustc</code>,</li>
<li>создать и запустить новый проект, используя соглашения и приказы Cargo.</li>
</ul>
<p>Это отличное время для создания более существенной программы, чтобы привыкнуть читать и писать код на языке Rust. Итак, в главе 2 мы построим программу для игры в угадай число. Если вы предпочитаете начать с изучения того, как работают общие концепции программирования в Rust, обратитесь к главе 3, а затем вернитесь к главе 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Программируем-игру-в-загадки"><a class="header" href="#Программируем-игру-в-загадки">Программируем игру в загадки</a></h1>
<p>Давайте окунёмся в Rust, вместе поработав над практическим проектом! В этой главе вы познакомитесь с несколькими общими концепциями Rust, показав, как использовать их в существующей программе. Вы узнаете о <code>let</code> , <code>match</code>, способах, ассоциированных функциях, внешних дополнениях и многом другом! В следующих главах мы рассмотрим эти идеи более подробно. В этой главе вы просто попрактикуетесь в основах.</p>
<p>Мы реализуем классическую для начинающих программистов задачу — игру в загадки. Вот как это работает: программа генерирует случайное целое число в ряде от 1 до 100. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра напечатает поздравительное сообщение и завершится.</p>
<h2 id="Настройка-нового-проекта"><a class="header" href="#Настройка-нового-проекта">Настройка нового проекта</a></h2>
<p>Для настройки нового проекта перейдите в каталог <em>projects</em>, который вы создали в главе 1, и создайте новый проект с использованием Cargo, как показано ниже:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Первая приказ, <code>cargo new</code>, принимает в качестве первого переменной имя проекта (<code>guessing_game</code>). Вторая приказ изменяет каталог на новый каталог проекта.</p>
<p>Загляните в созданный файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
</code></pre>
<p>Как вы уже видели в главе 1, <code>cargo new</code> создаёт программу «Hello, world!». Посмотрите файл <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Теперь давайте соберем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью приказы <code>cargo run</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
</code></pre>
<p>Приказ <code>run</code> пригодится, когда необходимо ускоренно выполнить повторение проекта. Именно так мы собираемся делать в этом проекте, быстро тестируя каждую повторение, прежде чем перейти к следующей.</p>
<p>Снова откройте файл <em>src/main.rs</em>. Весь код вы будете писать в нем.</p>
<h2 id="Обработка-догадки"><a class="header" href="#Обработка-догадки">Обработка догадки</a></h2>
<p>Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой форме. Начнём с того, что позволим игроку ввести догадку. Вставьте код из приложения 2-1 в <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}</code></pre>
<p><span class="caption">Приложение 2-1: код, который получает догадку от пользователя и выводит её на экран</span></p>
<p>Этот код содержит много сведений, поэтому давайте рассмотрим его построчно. Чтобы получить пользовательский ввод и затем вывести результат, нам нужно включить в область видимости библиотеку ввода/вывода <code>io</code>. Библиотека <code>io</code> является частью встроенной библиотеки, известной как <code>std</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}</code></pre>
<p>По умолчанию в Rust есть набор элементов, определённых в встроенной библиотеке, которые он добавляет в область видимости каждой программы. Этот набор называется <em>прелюдией</em>, и вы можете изучить его содержание <a href="../std/prelude/index.html">в документации встроенной библиотеки</a>.</p>
<p>Если вид, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора <code>use</code>. Использование библиотеки <code>std::io</code> предоставляет ряд полезных функциональных возможностей, включая способность принимать пользовательский ввод.</p>
<p>Как уже отмечалось в главе 1, функция <code>main</code> является точкой входа в программу:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}</code></pre>
<p>Ключевое слово <code>fn</code> объявляет новую функцию, круглые скобки <code>()</code> показывают, что у функции нет входных свойств, фигурная скобка <code>{</code> - обозначение начала тела функции.</p>
<p>Также в главе 1 упоминалось, что <code>println!</code> — это макрос, который выводит строку на экран:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}</code></pre>
<p>Этот код показывает сведения о ходе игры и запрашивает пользовательский ввод.</p>
<h3 id="Хранение-значений-с-помощью-переменных"><a class="header" href="#Хранение-значений-с-помощью-переменных">Хранение значений с помощью переменных</a></h3>
<p>Далее мы создаём <em>переменную</em> для хранения пользовательского ввода, как показано ниже:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}</code></pre>
<p>Вот теперь программа становится важнее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем оператор <code>let</code>. Вот ещё один пример:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Эта строка создаёт новую переменную с именем <code>apples</code> и привязывает её к значению 5. В Rust переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту концепцию в разделе <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">"Переменные и изменчивость".</a><!-- ignore --> в главе 3. Чтобы сделать переменную изменяемой, мы добавляем <code>mut</code> перед её именем:</p>
<pre><code class="language-rust ignore">let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая</code></pre>
<blockquote>
<p>Примечание: сочетание знаков <code>//</code> начинает комментарий, который продолжается до конца строки. Rust пренебрегает всё, что находится в комментариях. Мы обсудим комментарии более подробно в <a href="ch03-04-comments.html">Главе 3</a><!-- ignore -->.</p>
</blockquote>
<p>Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что <code>let mut guess</code> предоставит изменяемую переменную с именем <code>guess</code>. Знак равенства (<code>=</code>) сообщает Rust, что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с <code>guess</code>, которое является результатом вызова функции <code>String::new</code>, возвращающей новый экземпляр <code>String</code>. <a data-md-type="raw_html" href="../std/string/struct.String.html"><code>String</code></a> — это вид строки, предоставляемый встроенной библиотекой, который является расширяемым фрагментом текста в кодировке UTF-8.</p>
<p>Синтаксис <code>::</code> в строке <code>::new</code> указывает, что <code>new</code> является ассоциированной функцией вида <code>String</code>. <em>Ассоциированная функция</em> — это функция, реализованная для вида, в данном случае <code>String</code>. Функция <code>new</code> создаёт новую пустую строку. Функцию <code>new</code> можно встретить во многих видах, это привычное название для функции, которая создаёт новое значение какого-либо вида.</p>
<p>В конечном итоге строка <code>let mut guess = String::new();</code> создала изменяемую переменную, которая связывается с новым пустым экземпляром <code>String</code>. Фух!</p>
<h3 id="Получение-пользовательского-ввода"><a class="header" href="#Получение-пользовательского-ввода">Получение пользовательского ввода</a></h3>
<p>Напомним: мы подключили функциональность ввода/вывода из встроенной библиотеки с помощью <code>use std::io;</code> в первой строке программы. Теперь мы вызовем функцию <code>stdin</code> из модуля <code>io</code>, которая позволит нам обрабатывать пользовательский ввод:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}</code></pre>
<p>Если бы мы не импортировали библиотеку <code>io</code> с помощью <code>use std::io</code> в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как <code>std::io::stdin</code>. Функция <code>stdin</code> возвращает экземпляр <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>, который является видом, представляющим дескриптор принятого ввода для вашего окна вызова.</p>
<p>Далее строка <code>.read_line(&amp;mut guess)</code> вызывает способ <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> на дескрипторе принятого ввода для получения ввода от пользователя. Мы также передаём <code>&amp;mut guess</code> в качестве переменной <code>read_line</code>, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача <code>read_line</code> — принять все, что пользователь вводит в стандартный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве переменной. Строковый переменная должен быть изменяемым, чтобы способ мог изменить содержимое строки.</p>
<p>Символ <code>&amp;</code> указывает, что этот переменная является <em>ссылкой</em>, которая предоставляет возможность нескольким частям вашего кода получить доступ к одному фрагменту данных без необходимости копировать эти данные в память несколько раз. Ссылки — это сложная функциональная возможность, а одним из главных преимуществ Rust является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>. (В главе 4 ссылки будут описаны более подробно).</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Обработка-потенциального-сбоя-с-помощью-вида-result"><a class="header" href="#Обработка-потенциального-сбоя-с-помощью-вида-result">Обработка потенциального сбоя с помощью вида <code>Result</code></a></h3>
<p>Мы всё ещё работаем над этой строкой кода. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной логической строки. Следующая часть — способ:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}</code></pre>
<p>Мы могли бы написать этот код так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове способа с помощью синтаксиса <code>.method_name()</code> часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.</p>
<p>Как упоминалось ранее, <code>read_line</code> помещает всё, что вводит пользователь, в строку, которую мы ему передаём, но также возвращает значение <code>Result</code>. <a data-md-type="raw_html" href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> — это <a href="ch06-00-enums.html"><em>перечисление</em></a><!-- ignore -->, часто называемое <em>enum</em>, то есть вид, который может находиться в одном из нескольких возможных состояний. Мы называем каждое такое состояние <em>вариантом</em>.</p>
<p>В <a href="ch06-00-enums.html">Главе 6</a> рассмотрим перечисления более подробно. Задачей видов <code>Result</code> является кодирование сведений для обработки ошибок.</p>
<p>Вариантами <code>Result</code> являются <code>Ok</code> и <code>Err</code>. Вариант <code>Ok</code> указывает, что действие завершилась успешно, а внутри <code>Ok</code> находится успешно сгенерированное значение. Вариант <code>Err</code> означает, что действие не удалась, а <code>Err</code> содержит сведения о причинах неудачи.</p>
<p>Значения вида <code>Result</code>, как и значения любого вида, имеют определённые для них способы. У экземпляра <code>Result</code> есть <a href="../std/result/enum.Result.html#method.expect">способ <code>expect</code></a><!-- ignore -->, который можно вызвать. Если этот экземпляр <code>Result</code> является значением <code>Err</code>, <code>expect</code> вызовет сбой программы и отобразит сообщение, которое вы передали в качестве переменной. Если способ <code>read_line</code> возвращает <code>Err</code>, то это, скорее всего, результат ошибки основной операционной системы. Если экземпляр <code>Result</code> является значением <code>Ok</code>, <code>expect</code> возьмёт возвращаемое значение, которое удерживает <code>Ok</code>, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.</p>
<p>Если не вызвать <code>expect</code>, программа ссобирается, но будет получено предупреждение:</p>
<pre><code class="language-console">{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
</code></pre>
<p>Rust предупреждает о неиспользованном значении <code>Result</code>, возвращаемого из <code>read_line</code>, показывая, что программа не учла возможность возникновения ошибки.</p>
<p>Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении проблемы, поэтому используем <code>expect</code>. О способах восстановления после ошибок вы узнаете в <a href="ch09-02-recoverable-errors-with-result.html">главе 9</a>.</p>
<h3 id="Вывод-значений-с-помощью-заполнителей-println"><a class="header" href="#Вывод-значений-с-помощью-заполнителей-println">Вывод значений с помощью заполнителей <code>println!</code></a></h3>
<p>Кроме закрывающей фигурной скобки, в коде на данный момент есть ещё только одно место для обсуждения:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}</code></pre>
<p>Этот код выводит строку, которая теперь содержит ввод пользователя. Набор фигурных скобок <code>{}</code> является заполнителем: думайте о <code>{}</code> как о маленьких клешнях краба, которые удерживают значение на месте. При печати значения переменной имя переменной может заключаться в фигурные скобки. При печати результата вычисления выражения поместите пустые фигурные скобки в строку формата, затем после строки формата укажите список выражений, разделённых запятыми, которые будут напечатаны в каждом заполнителе пустой фигурной скобки в том же порядке. Печать переменной и результата выражения одним вызовом <code>println!</code> будет выглядеть так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Этот код выведет <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="Тестирование-первой-части"><a class="header" href="#Тестирование-первой-части">Тестирование первой части</a></h3>
<p>Давайте протестируем первую часть игры. Запустите её используя <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.</p>
<h2 id="Генерация-секретного-числа"><a class="header" href="#Генерация-секретного-числа">Генерация секретного числа</a></h2>
<p>Далее нам нужно сгенерировать секретное число, которое пользователь попытается угадать. Секретное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в ряде от 1 до 100, чтобы игра не была слишком сложной. Rust пока не включает функциональность случайных чисел в свою стандартную библиотеку. Однако приказ Rust предоставляет [крейт <code>rand</code>] с подобной функциональностью.</p>
<h3 id="Использование-крейта-для-получения-дополнительного-функционала"><a class="header" href="#Использование-крейта-для-получения-дополнительного-функционала">Использование крейта для получения дополнительного функционала</a></h3>
<p>Помните, что пакет (crate) - это собрание файлов исходного кода Rust. Проект, создаваемый нами, представляет собой <br> <em>двоичный пакет (binary crate)</em>, который является исполняемым файлом. Пакет <code>rand</code> - это <em>библиотечный пакет (library crate)</em>, содержащий код, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.</p>
<p>Координация работы внешних пакетов является тем местом, где Cargo на самом деле блистает. Чтобы начать писать код, использующий <code>rand</code>, необходимо изменить файл <em>Cargo.toml</em>, включив в него в качестве зависимости пакет <code>rand</code>. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком секции <code>[dependencies]</code>, созданным для вас Cargo. Обязательно укажите <code>rand</code> в точности так же, как здесь, с таким же номером исполнения, иначе примеры кода из этого урока могут не заработать.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Имя файла: Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:8:}}
</code></pre>
<p>В файле <em>Cargo.toml</em> всё, что следует за заголовком, является частью этой секции, которая продолжается до тех пор, пока не начнётся следующая. В <code>[dependencies]</code> вы сообщаете Cargo, от каких внешних крейтов зависит ваш проект и какие исполнения этих крейтов вам нужны. В этом случае мы указываем крейт <code>rand</code> со спецификатором семантической исполнения <code>0.8.5</code>. Cargo понимает <a href="http://semver.org">семантическое версионирование</a> (иногда называемое <em>SemVer</em>), которое является стандартом для описания исполнений. Число <code>0.8.5</code> на самом деле является сокращением от <code>^0.8.5</code>, что означает любую исполнение не ниже <code>0.8.5</code>, но ниже <code>0.9.0</code>.</p>
<p>Cargo рассчитывает, что эти исполнения имеют общедоступное API, совместимое с исполнением <code>0.8.5</code>, и вы получите последние исполнения исправлений, которые по-прежнему будут собираться с кодом из этой главы. Не обеспечивается, что исполнение <code>0.9.0</code> или выше будет иметь тот же API, что и в следующих примерах.</p>
<p>Теперь, не меняя ничего в коде, давайте соберём проект, как показано в приложении 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Приложение 2-2: результат выполнения <code>cargo build</code> после добавления крейта rand в качестве зависимости</span></p>
<p>Вы можете увидеть другие номера исполнений (но все они будут совместимы с кодом благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.</p>
<p>Когда мы включаем внешнюю зависимость, Cargo берет последние исполнения всего, что нужно этой зависимости, из <em>реестра (registry)</em>, который является копией данных с <a href="https://crates.io/">Crates.io</a>. Crates.io — это место, где участники экосистемы Rust размещают свои проекты с открытым исходным кодом для использования другими.</p>
<p>После обновления реестра Cargo проверяет раздел <code>[dependencies]</code> и загружает все указанные в списке пакеты, которые ещё не были загружены. В нашем случае, хотя мы указали только <code>rand</code> в качестве зависимости, Cargo также захватил другие пакеты, от которых зависит работа <code>rand</code>. После загрузки пакетов Rust собирает их, а затем собирает проект с имеющимися зависимостями.</p>
<p>Если сразу же запустить <code>cargo build</code> снова, не внося никаких изменений, то кроме строки <code>Finished</code> вы не получите никакого вывода. Cargo знает, что он уже загрузил и собрал зависимости, и вы не вносили никаких изменений в файл <em>Cargo.toml</em>. Cargo также знает, что вы ничего не изменили в своём коде, поэтому он не пересоберет и его. Если делать нечего, он просто завершает работу.</p>
<p>Если вы откроете файл <em>src/main.rs</em>, внесёте тривиальное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле <em>src/main.rs</em>. Ваши зависимости не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и собрано для них.</p>
<h4 id="Обеспечение-воспроизводимых-сборок-с-помощью-файла-cargolock"><a class="header" href="#Обеспечение-воспроизводимых-сборок-с-помощью-файла-cargolock">Обеспечение воспроизводимых сборок с помощью файла <em>Cargo.lock</em></a></h4>
<p>В Cargo есть механизм, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает ваш код. Пока вы не укажете обратное, Cargo будет использовать только те исполнения зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит исполнение 0.8.6 пакета <code>rand</code> , и она содержит важное исправление ошибки, но также регрессию, которая может сломать ваш код. Чтобы справиться с этим, Rust создаёт файл <em>Cargo.lock</em> при первом запуске <code>cargo build</code>, поэтому теперь он есть в каталоге <em>guessing_game</em>.</p>
<p>Когда вы создаёте проект в первый раз, Cargo определяет все исполнения зависимостей, которые соответствуют критериям, а затем записывает их в файл <em>Cargo.lock</em>. Когда вы будете собирать свой проект в будущем, Cargo увидит, что файл <em>Cargo.lock</em> существует, и будет использовать указанные там исполнения, а не выполнять всю работу по выяснению исполнений заново. Это позволяет самостоятельно создавать воспроизводимую сборку. Другими словами, ваш проект останется на <code>0.8.5</code> до тех пор, пока вы явно не обновите его благодаря файлу <em>Cargo.lock</em>. Поскольку файл <em>Cargo.lock</em> важен для воспроизводимых сборок, он часто хранится в системе управления исполнениями вместе с остальным кодом проекта.</p>
<h4 id="Обновление-пакета-для-получения-новой-исполнения"><a class="header" href="#Обновление-пакета-для-получения-новой-исполнения">Обновление пакета для получения новой исполнения</a></h4>
<p>Если вы <em>захотите</em> обновить пакет, Cargo предоставляет приказ <code>update</code>, которая пренебрегает файл <em>Cargo.lock</em> и определяет последние исполнения, соответствующие вашим спецификациям из файла <em>Cargo.toml</em>. После этого Cargo запишет эти исполнения в файл <em>Cargo.lock</em>. Иначе по умолчанию Cargo будет искать только исполнения больше 0.8.5, но при этом меньше 0.9.0. Если пакет <code>rand</code> имеет две новые исполнения — 0.8.6 и 0.9.0 — то при запуске <code>cargo update</code> вы увидите следующее:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo пренебрегает релиз 0.9.0. В этот момент также появится изменение в файле <em>Cargo.lock</em>, указывающее на то, что исполнение <code>rand</code>, которая теперь используется, равна 0.8.6. Чтобы использовать <code>rand</code> исполнения 0.9.0 или любой другой исполнения из серии 0.9.<em>x</em>, необходимо обновить файл <em>Cargo.toml</em> следующим образом:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>В следующий раз, при запуске <code>cargo build</code>, Cargo обновит реестр доступных пакетов и пересмотрит ваши требования к <code>rand</code> в соответствии с новой исполнением, которую вы указали.</p>
<p>Можно много рассказать про <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> и <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">его экосистему</a><!-- ignore --> которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Rust разработчики имеют возможность писать меньшие проекты, которые составлены из многих пакетов.</p>
<h3 id="Генерация-случайного-числа"><a class="header" href="#Генерация-случайного-числа">Генерация случайного числа</a></h3>
<p>Давайте начнём использовать <code>rand</code>, чтобы сгенерировать число для угадывания. Следующим шагом будет обновление <em>src/main.rs</em>, как показано в приложении 2-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}</code></pre>
<p><span class="caption">Приложение 2-3: Добавление кода который генерирует случайное число</span></p>
<p>Сначала мы добавляем строку <code>use rand::Rng</code>. Типаж <code>Rng</code> определяет способы, реализующие генераторы случайных чисел, и этот типаж должен быть в области видимости, чтобы эти способы можно было использовать. В главе 10 мы рассмотрим типажи подробно.</p>
<p>Затем мы добавляем две строки посередине. В первой строке мы вызываем функцию <code>rand::thread_rng</code>, дающую нам генератор случайных чисел, который мы собираемся использовать: тот самый, который является местным для текущего потока выполнения и запускается операционной системой. Затем мы вызываем его способ <code>gen_range</code>. Этот способ определяется <code>Rng</code>, который мы включили в область видимости с помощью оператора <code>use rand::Rng</code>. Способ <code>gen_range</code> принимает в качестве переменной выражение ряда и генерирует случайное число в этом ряде. Вид используемого выражения ряда принимает форму <code>start..=end</code> и включает нижнюю и верхнюю границы, поэтому, чтобы запросить число от 1 до 100, нам нужно указать <code>1..=100</code>.</p>
<blockquote>
<p>Примечание: непросто сразу разобраться, какие типажи использовать, какие способы и функции вызывать из пакета, поэтому каждый пакет имеет документацию с указаниями по его использованию. Ещё одной замечательной особенностью Cargo является выполнение приказы <code>cargo doc --open</code>, которая местно собирает документацию, предоставляемую всеми вашими зависимостями, и открывает её в браузере. К примеру, если важна другая функциональность из пакета <code>rand</code>, запустите <code>cargo doc --open</code> и нажмите <code>rand</code> в боковой панели слева.</p>
</blockquote>
<p>Во второй новой строке мы увидим загаданное число. Во время разработки программы полезно иметь возможность её протестировать, но в финальной исполнения мы это удалим. Конечно, ведь это совсем не похоже на игру, если программа печатает ответ сразу после запуска!</p>
<p>Попробуйте запустить программу несколько раз:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Вы должны получить разные случайные числа, и все они должны быть числами в ряде от 1 до 100. Отличная работа!</p>
<h2 id="Сравнение-догадки-с-секретным-числом"><a class="header" href="#Сравнение-догадки-с-секретным-числом">Сравнение догадки с секретным числом</a></h2>
<p>Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем сравнить их. Этот шаг показан в приложении 2-4. Учтите, что этот код ещё не ссобирается, подробнее мы объясним дальше.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 2-4: Обработка возможных возвращаемых значений при сравнении двух чисел</span></p>
<p>Сначала добавим ещё один оператор <code>use</code>, который вводит вид с именем <code>std::cmp::Ordering</code> в область видимости из встроенной библиотеки. Вид <code>Ordering</code> является ещё одним перечислением и имеет варианты <code>Less</code>, <code>Greater</code> и <code>Equal</code>. Это три возможных исхода при сравнении двух величин.</p>
<p>После чего ниже добавляем пять новых строк, использующих вид <code>Ordering</code>. Способ <code>cmp</code> сравнивает два значения и может вызываться для всего, что можно сравнить. Он принимает ссылку на все, что требуется сравнить: здесь сравнивается <code>guess</code> с <code>secret_number</code>. В результате возвращается вариант перечисления <code>Ordering</code>, которое мы ввели в область видимости с помощью оператора <code>use</code>. Для принятия решения о том, что делать дальше, мы используем выражение <a href="ch06-02-match.html"><code>match</code></a>, определяющее, какой вариант <code>Ordering</code> был возвращён из вызова <code>cmp</code> со значениями <code>guess</code> и <code>secret_number</code>.</p>
<p>Выражение <code>match</code> состоит из <em>веток (arms)</em>. Ветка состоит из <em>шаблона</em> для сопоставления и кода, который будет запущен, если значение, переданное в <code>match</code>, соответствует шаблону этой ветки. Rust принимает значение, заданное <code>match</code>, и по очереди просматривает шаблон каждой ветки. Шаблоны и конструкция <code>match</code> — это мощные возможности Rust, позволяющие выразить множество ситуаций, с которыми может столкнуться ваш код, и обеспечить их обработку. Эти возможности будут подробно раскрыты в главе 6 и главе 18 соответственно.</p>
<p>Давайте рассмотрим пример с выражением <code>match</code>, которое мы здесь используем. Скажем, пользователь угадал 50, а случайно сгенерированное секретное число на этот раз — 38.</p>
<p>Когда код сравнивает 50 с 38, способ <code>cmp</code> вернёт <code>Ordering::Greater</code>, поскольку 50 больше, чем 38. Выражение <code>match</code> получит значение <code>Ordering::Greater</code> и начнёт проверять шаблон в каждой ветке. Он просмотрит шаблон первой ветки, <code>Ordering::Less</code>, и увидит, что значение <code>Ordering::Greater</code> не соответствует <code>Ordering::Less</code>, поэтому пропренебрегает код этой ветки и перейдёт к следующей. Шаблон следующей ветки — <code>Ordering::Greater</code>, который <em>соответствует</em> <code>Ordering::Greater</code>! Код этой ветки будет выполнен и напечатает <code>Too big!</code> на экран. Выражение <code>match</code> заканчивается после первого успешного совпадения, поэтому в этом сценарии оно не будет рассматривать последнюю ветку.</p>
<p>Однако код в приложении 2-4 всё ещё не ссобирается. Давайте попробуем:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
</code></pre>
<p>Суть ошибки заключается в наличии <em>несовпадающих видов</em>. У Rust строгая статическая система видов. Однако в нем также есть механизм вывода видов. Когда мы написали <code>let mut guess = String::new()</code>, Rust смог сделать вывод, что <code>guess</code> должна быть <code>String</code> и не заставил указывать вид. С другой стороны, <code>secret_number</code> — это числовой вид. Несколько видов чисел в Rust могут иметь значение от 1 до 100: <code>i32</code>, 32-битное число; <code>u32</code>, беззнаковое 32-битное число; <code>i64</code>, 64-битное число, и так далее. Если не указано иное, Rust по умолчанию использует <code>i32</code>, который будет видом <code>secret_number</code>, если вы не добавите сведения о виде где-то ещё, чтобы заставить Rust вывести другой числовой вид. Причина ошибки заключается в том, что Rust не может сравнить строку и числовой вид.</p>
<p>В конечном итоге необходимо преобразовать <code>String</code>, считываемую программой в качестве входных данных, в существующий числовой вид, чтобы иметь возможность числового сравнения с загаданным числом. Для этого добавьте в тело функции <code>main</code> следующую строку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}</code></pre>
<p>Вот эта строка:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>Мы создаём переменную с именем <code>guess</code>. Но подождите, разве в программе уже нет переменной с этим именем <code>guess</code>? Так и есть, но Rust позволяет нам затенять предыдущее значение <code>guess</code> новым. <em>Затенение</em> позволяет нам повторно использовать имя переменной <code>guess</code>, чтобы избежать создания двух уникальных переменных, таких как <code>guess_str</code> и <code>guess</code>, например. Мы рассмотрим это более подробно в главе 3, а пока знайте, что эта функция часто используется, когда необходимо преобразовать значение из одного вида в другой.</p>
<p>Мы связываем эту новую переменную с выражением <code>guess.trim().parse()</code>. Переменная <code>guess</code> в этом выражении относится к исходной переменной <code>guess</code>, которая содержала входные данные в виде строки. Способ <code>trim</code> на экземпляре <code>String</code> удалит любые пробельные символы в начале и конце строки для того, чтобы мы могли сопоставить строку с <code>u32</code>, который содержит только числовые данные. Пользователь должен нажать <span class="keystroke">enter</span>, чтобы выполнить <code>read_line</code> и ввести свою догадку, при этом в строку добавится символ новой строки. Например, если пользователь набирает <span class="keystroke">5</span> и нажимает <span class="keystroke">enter</span>, <code>guess</code> будет выглядеть так: <code>5\n</code>. Символ <code>\n</code> означает "новая строка". (В Windows нажатие <span class="keystroke">enter</span> сопровождается возвратом каретки и новой строкой, <code>\r\n</code>). Способ <code>trim</code> убирает <code>\n</code> или <code>\r\n</code>, оставляя только <code>5</code>.</p>
<p>Способ <a href="../std/primitive.str.html#method.parse"><code>parse</code> строк</a><!-- ignore --> преобразует строку в другой вид. Здесь мы используем его для преобразования строки в число. Нам нужно сообщить Rust точный числовой вид, который мы хотим получить, используя <code>let guess: u32</code>. Двоеточие ( <code>:</code> ) после <code>guess</code> говорит Rust, что мы аннотируем вид переменной. В Rust есть несколько встроенных числовых видов; <code>u32</code>, показанный здесь, представляет собой 32-битное целое число без знака. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других видах чисел в главе 3.</p>
<p>Кроме того, изложение <code>u32</code> в этом примере программы и сравнение с <code>secret_number</code> означает, что Rust сделает вывод, что <code>secret_number</code> должен быть <code>u32</code>. Итак, теперь сравнение будет между двумя значениями одного типа!</p>
<p>Способ <code>parse</code> будет работать только с символами, которые логически могут быть преобразованы в числа, и поэтому легко может вызвать ошибки. Если, например, строка содержит <code>A👍%</code>, преобразовать её в число невозможно. Так как способ <code>parse</code> может потерпеть неудачу, он возвращает вид <code>Result</code> — так же как и способ <code>read_line</code> (обсуждалось ранее в разделе <a data-md-type="raw_html" href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">«Обработка потенциальной ошибки с помощью вида <code>Result</code>»</a>). Мы будем точно так же обрабатывать данный <code>Result</code>, вновь используя способ <code>expect</code>. Если <code>parse</code> вернёт вариант <code>Result</code> <code>Err</code>, так как не смог создать число из строки, вызов <code>expect</code> аварийно завершит игру и отобразит переданное ему сообщение. Если <code>parse</code> сможет успешно преобразовать строку в число, он вернёт вариант <code>Result</code> <code>Ok</code>, а <code>expect</code> вернёт число, полученное из значения <code>Ok</code>.</p>
<p>Давайте запустим программу теперь:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Хорошо! Несмотря на то, что были добавлены пробелы в строке ввода, программа всё равно поняла, что пользователь имел в виду число 76. Запустите программу несколько раз, чтобы проверить разное поведение при различных видах ввода: задайте число правильно, задайте слишком большое число и задайте слишком маленькое число.</p>
<p>Сейчас у нас работает большая часть игры, но пользователь может сделать только одну догадку. Давайте изменим это, добавив цикл!</p>
<h2 id="Возможность-нескольких-догадок-с-помощью-циклов"><a class="header" href="#Возможность-нескольких-догадок-с-помощью-циклов">Возможность нескольких догадок с помощью циклов</a></h2>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Мы добавляем цикл, чтобы дать пользователям больше шансов угадать число:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}</code></pre>
<p>Как видите, мы переместили всё, начиная с подсказки ввода догадки, в цикл. Не забудьте добавить ещё по четыре пробела на отступы строк внутри цикла и запустите программу снова. Теперь программа будет бесконечно запрашивать ещё одну догадку, что фактически создаёт новую проблему. Похоже, пользователь не сможет выйти из игры!</p>
<p>Пользователь может прервать выполнение программы с помощью сочетания клавиш <span class="keystroke">ctrl+c</span>. Но есть и другой способ спастись от этого ненасытного монстра, о котором говорилось при обсуждении <code>parse</code> в <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">«Сравнение догадки с секретным числом»</a>: если пользователь введёт нечисловой ответ, программа завершится аварийно. Мы можем воспользоваться этим, чтобы позволить пользователю выйти из игры, как показано здесь:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ввод <code>quit</code> приведёт к выходу из игры, но, как вы заметите, так же будет и при любом другом нечисловом вводе. Однако это, мягко говоря, не оптимально. Мы хотим, чтобы игра самостоятельно остановилась, когда будет угадано правильное число.</p>
<h3 id="Выход-после-правильной-догадки"><a class="header" href="#Выход-после-правильной-догадки">Выход после правильной догадки</a></h3>
<p>Давайте запрограммируем игру на выход при выигрыше пользователя, добавив оператор <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}</code></pre>
<p>Добавление строки <code>break</code> после <code>You win!</code> заставляет программу выйти из цикла, когда пользователь правильно угадает секретное число. Выход из цикла также означает выход из программы, так как цикл является последней частью <code>main</code>.</p>
<h3 id="Обработка-недопустимого-ввода"><a class="header" href="#Обработка-недопустимого-ввода">Обработка недопустимого ввода</a></h3>
<p>Чтобы улучшить поведение игры, вместо аварийного завершения программы, когда пользователь вводит не число, давайте заставим игру пренебрегать этот факт, позволяя пользователю продолжить угадывание. Для этого необходимо изменить строку, в которой <code>guess</code> преобразуется из <code>String</code> в <code>u32</code>, как показано в приложении 2-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 2-5. Пренебрежение нечисловой догадки и запрос другой догадки вместо завершения программы</span></p>
<p>Мы заменяем вызов <code>expect</code> на выражение <code>match</code>, чтобы перейти от аварийного завершения при ошибке к обработке ошибки. Помните, что <code>parse</code> возвращает вид <code>Result</code>, а <code>Result</code> — это перечисление, которое имеет варианты <code>Ok</code> и <code>Err</code>. Здесь мы используем выражение <code>match</code>, как и в случае с результатом <code>Ordering</code> способа <code>cmp</code>.</p>
<p>Если <code>parse</code> успешно преобразует строку в число, он вернёт значение <code>Ok</code>, содержащее полученное число. Это значение <code>Ok</code> будет соответствовать шаблону первой ветки, а выражение <code>match</code> просто вернёт значение <code>num</code>, которое <code>parse</code> произвёл и поместил внутрь значения <code>Ok</code>. Это число окажется в нужной нам переменной <code>guess</code>, которую мы создали.</p>
<p>Если способ <code>parse</code> <em>не способен</em> превратить строку в число, он вернёт значение <code>Err</code>, которое содержит более подробную сведения об ошибке. Значение <code>Err</code> не совпадает с шаблоном <code>Ok(num)</code> в первой ветке <code>match</code>, но совпадает с шаблоном <code>Err(_)</code> второй ветки. Подчёркивание <code>_</code> является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений <code>Err</code>, независимо от того, какая сведения находится внутри. Поэтому программа выполнит код второй ветки, <code>continue</code>, который сообщает программе перейти к следующей повторения <code>loop</code> и запросить ещё одну догадку. В этом случае программа эффективно пренебрегает все ошибки, с которыми <code>parse</code> может столкнуться!</p>
<p>Всё в программе теперь должно работать как положено. Давайте попробуем:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Потрясающе! С помощью одной маленькой последней правки мы закончим игру в угадывание. Напомним, что программа все ещё печатает секретное число. Это хорошо подходило для тестирования, но это портит игру. Давайте удалим <code>println!</code>, который выводит секретное число. В Приложении 2-6 показан окончательный вариант кода.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 2-6: полный код игры</span></p>
<p>На данный момент вы успешно создали игру в загадки. Поздравляем!</p>
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Этот проект — практический способ познакомить вас со многими новыми концепциями Rust: <code>let</code>, <code>match</code>, функции, использование внешних крейтов и многое другое. В следующих нескольких главах вы изучите эти концепции более подробно. Глава 3 охватывает понятия, которые есть в большинстве языков программирования, такие как переменные, виды данных и функции, и показывает, как использовать их в Rust. В главе 4 рассматривается владение — особенность, которая отличает Rust от других языков. В главе 5 обсуждаются структуры и синтаксис способов, а в главе 6 объясняется, как работают перечисления.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Общие-концепции-программирования"><a class="header" href="#Общие-концепции-программирования">Общие концепции программирования</a></h1>
<p>В этой главе рассматриваются концепции, присутствующие почти в каждом языке программирования, и то, как они работают в Rust. В основе большинства языков программирования есть много общего. Все концепции, представленные в этой главе, не являются уникальными для Rust, но мы обсудим их в среде Rust и разъясним правила использования этих концепций.</p>
<p>В частности вы изучите переменные, основные виды, функции, комментарии и поток управления. Эти фундаментальные понятия будут присутствовать в каждой программе на Rust, и их изучение на ранней стадии даст вам прочную основу для начала работы.</p>
<blockquote>
<p><b>Ключевые слова </b></p>
<p>В языке Rust как и в других языках есть набор <em>ключевых слов</em>, зарезервированных только для использования в языке. Помните, что нельзя использовать эти слова в качестве имён переменных или функций. Большинство этих ключевых слов имеют особые назначения, и вы будете использовать их для выполнения различных задач в своих программах на Rust. Некоторые из них сейчас не имеют функционального назначения, но зарезервированы для функциональности, которая может быть добавлена в Rust в будущем. Список ключевых слов вы можете найти в <a href="appendix-01-keywords.html" data-md-type="link">Приложении А</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Переменные-и-изменяемость"><a class="header" href="#Переменные-и-изменяемость">Переменные и изменяемость</a></h2>
<p>Как упоминалось в разделе <a href="ch02-00-guessing-game-tutorial.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85">"Хранение значений с помощью переменных"</a>, по умолчанию переменные неизменяемы. Это один из многих стимулов Rust, позволяющий писать код с использованием преимущества безопасности и удобной состязательности (concurrency), предоставляемых Rust. Тем не менее, существует возможность сделать переменные изменяемыми. Давайте рассмотрим, как и почему Rust побуждает предпочесть неизменяемость и почему иногда можно отказаться от этого.</p>
<p>Если переменная является неизменяемой, то после привязки значения к имени изменить его будет нельзя. Чтобы показать это, создайте новый проект под названием <em>variables</em> в каталоге <em>projects</em> с помощью приказы <code>cargo new variables</code>.</p>
<p>Далее, в новом каталоге <em>variables</em> откройте <em>src/main.rs</em> и замените в нем код на ниже приведённый, который пока не будет собираться:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
let x = 5;
println!("The value of x is: {}", x);
x = 6;
println!("The value of x is: {}", x);
}</code></pre>
<p>Сохраните и запустите программу, используя <code>cargo run</code>. Будет получено сообщение об ошибке относительно неизменяемости, как показано в этом выводе:</p>
<pre><code class="language-console">error[E0384]: cannot assign twice to immutable variable `x`  --&gt; src/main.rs:4:5   | 2 |     let x = 5;   |         - first assignment to `x` 3 |     println!("The value of x is: {}", x); 4 |     x = 6;   |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>В этом примере показано, как сборщик помогает находить ошибки в ваших программах. Ошибки сборщика могут расстраивать, но в действительности они означают, что программа пока не делает правильно то, что вы ожидаете; это <em>не значит</em>, что вы плохой программист! Даже опытные Rustaceans иногда сталкиваются с ошибками сборщика.</p>
<p>Вы получили сообщение об ошибке <code>cannot assign twice to immutable variable </code>x``, потому что попытались присвоить новое значение неизменяемой переменной <code>x</code>.</p>
<p>Важно, чтобы при попытке изменить значение, объявленное неизменяемым, выдавались ошибки времени сборки, так как подобная ситуация может привести к сбоям. Если одна часть нашего кода функционирует исходя из уверенности в неизменяемости значения, а другая часть изменяет это значение, то велика вероятность , что первая часть не выполнит своего предназначения. Причину такой ошибки бывает трудно отследить, особенно если вторая часть кода изменяет значение лишь <em>изредка</em>. Сборщик Rust предоставляет заверение, что если объявить значение неизменяемым, то оно действительно не изменится, а значит, не нужно следить за этим самим. Таким образом, ваш код становится проще для понимания.</p>
<p>Однако изменяемость может быть очень полезной и может сделать код более удобным для написания. Хотя переменные по умолчанию неизменяемы, их можно сделать изменяемыми, добавив <code>mut</code> перед именем переменной, как это было сделано в <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">Главе 2</a>. Добавление <code>mut</code> также передаёт будущим читателям кода намерение, обозначая, что другие части кода будут изменять значение этой переменной.</p>
<p>Например, изменим <em>src/main.rs</em> на следующий код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Запустив программу, мы получим результат:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
</code></pre>
<p>Нам разрешено изменить значение, связанное с x, с 5 на 6 при помощи mut. В конечном счёте, решение об использовании изменяемости остаётся за вами и зависит от вашего мнения о наилучшем варианте в данной именно ситуации.</p>
<h3 id="Константы"><a class="header" href="#Константы">Константы</a></h3>
<p>Подобно неизменяемым переменным, <em>константы</em> — это значения, которые связаны с именем и не могут изменяться, но между константами и переменными есть несколько различий.</p>
<p>Во-первых, нельзя использовать <code>mut</code> с константами. Константы не просто неизменяемы по умолчанию — они неизменяемы всегда. Для объявления констант используется ключевое слово <code>const</code> вместо <code>let</code>, а также вид значения <em>должен быть</em> указан в изложении. Мы рассмотрим виды и изложении видов в следующем разделе <a href="ch03-02-data-types.html#data-types">«Виды данных».</a><!-- ignore -->, так что не беспокойтесь о подробностях прямо сейчас. Просто знайте, что вы всегда должны аннотировать вид.</p>
<p>Константы можно объявлять в любой области видимости, включая вездесущую, благодаря этому они полезны для значений, которые нужны во многих частях кода.</p>
<p>Последнее отличие в том, что константы могут быть заданы только константным выражением, но не результатом вычисленного во время выполнения значения.</p>
<p>Вот пример объявления константы:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Имя константы - <code>THREE_HOURS_IN_SECONDS</code>, а её значение устанавливается как результат умножения 60 (количество секунд в минуте) на 60 (количество минут в часе) на 3 (количество часов, которые нужно посчитать в этой программе). Соглашение Rust для именования констант требует использования всех заглавных букв с подчёркиванием между словами. Сборщик может вычислять ограниченный набор действий во время сборки, позволяющий записать это значение более понятным и простым для проверки способом, чем установка этой константы в значение 10 800. Дополнительную сведения о том, какие действия можно использовать при объявлении констант, см. в разделе <a href="../reference/const_eval.html">Раздел справки Rust по вычислениям констант</a>.</p>
<p>Константы существуют в течение всего времени работы программы в пределах области, в которой они были объявлены. Это свойство делает константы полезными для значений в домене вашего приложения, о которых могут знать несколько частей программы, например, максимальное количество очков, которое может заработать любой игрок в игре, или скорость света.</p>
<p>Обозначение жёстко закодированных значений, используемых в программе, как константы полезно для передачи смысла этого значения будущим сопровождающим кода. Это также позволяет иметь единственное место в коде, которое нужно будет изменить, если в будущем потребуется обновить значение.</p>
<h3 id="Затенение-переменных"><a class="header" href="#Затенение-переменных">Затенение (переменных)</a></h3>
<p>Как было показано в уроке по игре в Угадайка в <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">главе 2</a>, можно объявить новую переменную с тем же именем, как и у существующей переменной. Rustaceans говорят, что первая переменная <em>затеняется</em> второй, то есть вторая переменная - это то, что увидит сборщик, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не станет тенью, либо не закончится область видимости. Мы можем затенять переменную, используя то же имя переменной и повторяя использование ключевого слова <code>let</code> следующим образом:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Эта программа сначала привязывает <code>x</code> к значению <code>5</code>. Затем она создаёт новую переменную <code>x</code>, повторяя <code>let x =</code>, беря исходное значение и добавляя <code>1</code>, чтобы значение <code>x</code> стало равным <code>6</code>. Затем во внутренней области видимости, созданной с помощью фигурных скобок, третий оператор <code>let</code> также затеняет <code>x</code> и создаёт новую переменную, умножая предыдущее значение на <code>2</code>, чтобы дать <code>x</code> значение <code>12</code>. Когда эта область заканчивается, внутреннее затенение заканчивается, и <code>x</code> возвращается к значению <code>6</code>. Запустив эту программу, она выведет следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
</code></pre>
<p>Затенение отличается от объявления переменной с помощью <code>mut</code>, так как мы получим ошибку сборки, если случайно попробуем переназначить значение без использования ключевого слова <code>let</code>. Используя <code>let</code>, можно выполнить несколько превращений над значением, при этом оставляя переменную неизменяемой, после того как все эти превращения завершены.</p>
<p>Другой разницей между <code>mut</code> и затенением является то, что мы создаём совершенно новую переменную, когда снова используем слово <code>let</code> (ещё одну). Мы можем даже изменить вид значения, но снова использовать прежнее имя. К примеру, наша программа спрашивает пользователя, сколько пробелов он хочет разместить между некоторым текстом, запрашивая символы пробела, но мы на самом деле хотим сохранить данный ввод как число:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Первая переменная <code>spaces</code> — является строковым видом, а вторая переменная <code>spaces</code> — числовым видом. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как <code>spaces_str</code> и <code>spaces_num</code>. Вместо этого мы можем повторно использовать более простое имя <code>spaces</code>. Однако, если мы попытаемся использовать для этого <code>mut</code>, как показано далее, то получим ошибку времени сборки:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}</code></pre>
<p>Ошибка говорит, что не разрешается менять вид переменной:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
</code></pre>
<p>Теперь, когда мы изучили, как работают переменные, давайте рассмотрим различные виды данных, которые они могут иметь.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Виды-Данных"><a class="header" href="#Виды-Данных">Виды Данных</a></h2>
<p>Каждое значение в Rust относится к определённому <em>виду данных</em>, который указывает на вид данных, что позволяет Rust знать, как работать с этими данными. Мы рассмотрим два подмножества видов данных: скалярные и составные.</p>
<p>Не забывайте, что Rust является <em>статически типизированным</em> (statically typed) языком. Это означает, что он должен знать виды всех переменных во время сборки. Обычно сборщик может предположить, какой вид используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько видов, необходимо добавлять изложение вида вручную. Например, когда мы преобразовали <code>String</code> в число с помощью вызова <code>parse</code> в разделе <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">«Сравнение предположения с загаданным номером»</a> главы 2, мы должны добавить такую изложение:<!-- ignore --></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre></pre>
<p>Если мы не добавим изложение вида <code>: u32</code>, показанную в предыдущем коде, Rust отобразит следующую ошибку, которая означает, что сборщику нужно от нас больше сведений, чтобы узнать, какой вид мы хотим использовать:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
</code></pre>
<p>В будущем вы увидите различные изложении для разных видов данных.</p>
<h3 id="Скалярные-виды-данных"><a class="header" href="#Скалярные-виды-данных">Скалярные виды данных</a></h3>
<p><em>Скалярный</em> вид представляет собой единичное значение. В Rust есть четыре основных скалярных вида: целочисленный, числа с плавающей точкой, логический и символы. Вы наверняка знакомы с этими видами по другим языкам программирования. Давайте разберёмся, как они работают в Rust.</p>
<h4 id="Целочисленные-виды"><a class="header" href="#Целочисленные-виды">Целочисленные виды</a></h4>
<p>Целочисленный вид (<em>integer</em>) — это число без дробной части. В главе 2 мы использовали один целочисленный вид — вид <code>u32</code>. Такое объявление вида указывает, что значение, с которым оно связано, должно быть целым числом без знака (виды целых чисел со знаком начинаются с <code>i</code> вместо <code>u</code>), которое занимает 32 бита памяти. В Таблице 3-1 показаны встроенные целочисленные виды в Rust. Мы можем использовать любой из этих вариантов для объявления вида целочисленного значения.</p>
<p><span class="caption">Таблица 3-1: целочисленные виды в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Длина</th><th>Со знаком</th><th>Без знака</th></tr></thead><tbody>
<tr><td>8 бит</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 бит</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 бита</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 бита</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 бит</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>архитектурно-зависимая</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Каждый вариант может быть как со знаком, так и без знака и имеет явный размер. Такая характеристика вида как <em>знаковый</em> и <em>беззнаковый</em> определяет возможность числа быть отрицательным. Другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, число отображается со знаком плюс или со знаком минус; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся с использованием <a href="https://en.wikipedia.org/wiki/Two%27s_complement">дополнительного кода</a>.</p>
<p>Каждый вариант со знаком может хранить числа от -(2 <sup>n - 1</sup> ) до 2 <sup>n - 1</sup> - 1 включительно, где <em>n</em> — количество битов, которые использует этот вариант. Таким образом, <code>i8</code> может хранить числа от -(2 <sup>7</sup> ) до 2 <sup>7</sup> - 1, что равно значениям от -128 до 127. Варианты без знака могут хранить числа от 0 до 2 <sup>n</sup> - 1, поэтому <code>u8</code> может хранить числа от 0 до 2 <sup>8</sup> - 1, что равно значениям от 0 до 255.</p>
<p>Кроме того, виды <code>isize</code> и <code>usize</code> зависят от архитектуры компьютера, на котором выполняется программа, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.</p>
<p>Вы можете записывать целочисленные литералы в любой из форм, показанных в таблице 3-2. Заметьте, что числовые литералы, имеющие несколько числовых видов, допускают использование суффикса вида, например <code>57u8</code>, для обозначения вида. Числовые литералы также могут использовать <code>_</code> в качестве визуального разделителя для облегчения чтения числа, например <code>1_000</code>, который будет иметь такое же значение, как если бы было задано <code>1000</code>.</p>
<p><span class="caption">Таблица 3-2: Целочисленные литералы в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Числовой литерал</th><th>Пример</th></tr></thead><tbody>
<tr><td>Десятичный</td><td><code>98_222</code></td></tr>
<tr><td>Шестнадцатеричный</td><td><code>0xff</code></td></tr>
<tr><td>восьмеричный</td><td><code>0o77</code></td></tr>
<tr><td>Двоичный</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Байт (только <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Как же узнать, какой вид целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные виды по умолчанию <code>i32</code>. Основной случай, в котором вы должны использовать <code>isize</code> или <code>usize</code>, — это упорядочевание какой-либо собрания.</p>
<blockquote>
<p><h>Целочисленное переполнение</h> Допустим, имеется переменная вида <code>u8</code>, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого ряда, например, 256, произойдёт <em>целочисленное переполнение</em>, что может привести к одному из двух вариантов поведения. Если выполняется сборка в режиме отладки, Rust включает проверку на целочисленное переполнение, приводящую вашу программу к <em>панике</em> во время выполнения, когда возникает такое поведение. Rust использует термин <em>паника(panicking)</em>, когда программа завершается с ошибкой. Мы обсудим панику более подробно в разделе <a href="ch09-01-unrecoverable-errors-with-panic.html">"Неустранимые ошибки с <code>panic!</code>"</a> в главе 9. . При сборки в режиме release с флагом <code>--release</code>, Rust <em>не</em> включает проверки на целочисленное переполнение, которое вызывает панику. Вместо этого, в случае переполнения, Rust выполняет <em>обёртывание второго дополнения</em>. Проще говоря, значения, превышающие максимальное значение, которое может хранить вид, "оборачиваются" к минимальному из значений, которые может хранить вид. В случае <code>u8</code> значение 256 становится 0, значение 257 становится 1, и так далее. Программа не запаникует, но переменная будет иметь значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Полагаться на поведение обёртывания целочисленного переполнения считается ошибкой. Для явной обработки возможности переполнения существует семейство способов, предоставляемых встроенной библиотекой для примитивных числовых видов:</p>
<ul>
<li>Обёртывание во всех режимах с помощью способов <code>wrapping_*</code>, таких как <code>wrapping_add</code>.</li>
<li>Возврат значения <code>None</code> при переполнении с помощью способов <code>checked_*</code>.</li>
<li>Возврат значения и логический индикатор, указывающий, произошло ли переполнение при использовании способов <code>overflowing_*</code>.</li>
<li>Насыщение минимальным или максимальным значением с помощью способов <code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="Числа-с-плавающей-запятой"><a class="header" href="#Числа-с-плавающей-запятой">Числа с плавающей запятой</a></h4>
<p>Также в Rust есть два примитивных вида для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Виды с плавающей точкой в Rust - это f32 и f64, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется вид f64, поскольку на современных процессорах он работает примерно с той же скоростью, как и f32, но обладает большей точностью. Все виды с плавающей запятой являются знаковыми.</p>
<p>Вот пример, отображающий числа с плавающей запятой в действии:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Числа с плавающей запятой представлены в соответствии со стандартом IEEE-754. Вид <code>f32</code> является плавающей запятой одинарной точности, а <code>f64</code> - двойной точности.</p>
<h4 id="Числовые-действия"><a class="header" href="#Числовые-действия">Числовые действия</a></h4>
<p>Rust поддерживает основные математические действия, привычные для всех видов чисел: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующий код показывает, как можно использовать каждую числовую действие в указания <code>let</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Каждое выражение в этих указаниях использует математический оператор и вычисляется в одно значение, которое связывается с переменной. <a href="appendix-02-operators.html">Приложении B</a> содержит список всех операторов, которые предоставляет Rust.</p>
<h4 id="Логический-вид-данных"><a class="header" href="#Логический-вид-данных">Логический вид данных</a></h4>
<p>Как и в большинстве других языков программирования, логический вид в Rust имеет два возможных значения: <code>true</code> и <code>false</code>. Значения логических видов имеют размер в один байт. Логический вид в Rust задаётся с помощью <code>bool</code>. Например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Основной способ использования логических значений - это использование условий, таких как выражение <code>if</code>. Мы рассмотрим, как выражения <code>if</code> работают в Rust в разделе <a href="ch03-05-control-flow.html#control-flow">"Поток управления"</a>.</p>
<h4 id="Символьный-вид-данных"><a class="header" href="#Символьный-вид-данных">Символьный вид данных</a></h4>
<p>Вид <code>char</code> в Rust является самым примитивным алфавитным видом языка. Вот несколько примеров объявления значений <code>char</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Заметьте, мы указываем литералы <code>char</code> с одинарными кавычками, в отличие от строковых литералов, для которых используются двойные кавычки. Вид <code>char</code> в Rust имеет размер четыре байта и представляет собой скалярное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины - все это допустимые значения вида <code>char</code> в Rust. Скалярные значения Unicode находятся в ряде от <code>U+0000</code> до <code>U+D7FF</code> и от <code>U+E000</code> до <code>U+10FFFF</code> включительно. Однако "символ" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "символ", может не совпадать с тем, что такое <code>char</code> в Rust. Мы подробно обсудим эту тему в главе 8 "Хранение текста в кодировке UTF-8 с помощью строк".</p>
<h3 id="Составные-виды-данных"><a class="header" href="#Составные-виды-данных">Составные виды данных</a></h3>
<p><em>Составные виды</em> могут группировать различные значения в один вид. В Rust есть два примитивных составных вида: кортежи и массивы.</p>
<h4 id="Кортежи"><a class="header" href="#Кортежи">Кортежи</a></h4>
<p><em>Кортеж</em>- это универсальный способ объединения нескольких значений с различными видами в один составной вид. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.</p>
<p>Мы создаём кортеж, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждая позиция в кортеже имеет вид, причём виды различных значений в кортеже не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные изложении видов:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Переменная <code>tup</code> связана со всем кортежем, поскольку кортеж является одним составным элементом. Чтобы получить отдельные значения из кортежа, можно использовать сопоставление с образцом для деструктуризации значения кортежа, например, так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Эта программа сначала создаёт кортеж и связывает его с переменной <code>tup</code>. Затем с помощью шаблона <code>let</code> берётся <code>tup</code> и превращается в три отдельные переменные, <code>x</code>, <code>y</code> и <code>z</code>. Это называется <em>деструктуризацией</em>, поскольку разбивает единый кортеж на три части. Наконец, программа печатает значение <code>y</code>, которое равно <code>6.4</code>.</p>
<p>Мы также можем получить доступ к элементу кортежа напрямую, используя точку (<code>.</code>), за которой следует порядковый казательзначения, требуемого для доступа. Например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Эта программа создаёт кортеж <code>x</code>, а затем обращается к каждому элементу кортежа, используя соответствующие порядковые указатели. Как и в большинстве языков программирования, первый порядковый казательв кортеже равен 0.</p>
<p>Кортеж, не имеющий значений, имеет особое имя  <em>единичный вид (unit)</em>. Это значение и соответствующий ему вид записываются как <code>()</code> и представляет собой пустое значение или пустой возвращаемый вид. Выражения неявно возвращают значение единичного вида, если не возвращают никакого другого значения.</p>
<h4 id="Массивы"><a class="header" href="#Массивы">Массивы</a></h4>
<p>Другим способом создания собрания из нескольких значений является массив <em>array</em>. В отличие от кортежа, каждый элемент массива должен иметь один и тот же вид. В отличие от массивов в некоторых других языках, массивы в Rust имеют фиксированную длину.</p>
<p>Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Массивы удобно использовать, если данные необходимо разместить в стеке, а не в куче (мы подробнее обсудим стек и кучу в <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">Главе 4</a>) или если требуется, чтобы количество элементов всегда было фиксированным. Однако массив не так гибок, как вектор. <em>Вектор</em> - это подобный вид собрания, предоставляемый встроенной библиотекой, который <em>может</em> увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор. Более подробно векторы рассматриваются в <a href="ch08-01-vectors.html">Главе 8</a>.</p>
<p>Однако массивы более полезны, когда вы знаете, что количество элементов не нужно будет изменять. Например, если бы вы использовали названия месяцев в программе, вы, вероятно, использовали бы массив, а не вектор, потому что вы знаете, что он всегда будет содержать 12 элементов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p>Вид массива записывается следующим образом: в квадратных скобках обозначается вид элементов массива, а затем, через точку с запятой, количество элементов. Например:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Здесь <code>i32</code> является видом каждого элемента массива. После точки с запятой указано число <code>5</code>, показывающее, что массив содержит 5 элементов.</p>
<p>Вы также можете объявить массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо вида. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>Массив в переменной <code>a</code> будет включать <code>5</code> элементов, значение которых будет равно <code>3</code>. Данная запись подобна коду <code>let a = [3, 3, 3, 3, 3];</code>, но является более краткой.</p>
<h5 id="Доступ-к-элементам-массива"><a class="header" href="#Доступ-к-элементам-массива">Доступ к элементам массива</a></h5>
<p>Массив — это единый фрагмент памяти известного фиксированного размера, который может быть размещён в стеке. Вы можете получить доступ к элементам массива с помощью упорядочевания, например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>В этом примере переменная с именем first получит значение 1, потому что это значение находится по порядковому указателю [0] в массиве. Переменная с именем second получит значение 2 по порядковому указателю [1] в массиве.</p>
<h5 id="Некорректный-доступ-к-элементу-массива"><a class="header" href="#Некорректный-доступ-к-элементу-массива">Некорректный доступ к элементу массива</a></h5>
<p>Давайте посмотрим, что произойдёт, если попытаться получить доступ к элементу массива, находящемуся за его пределами. Допустим, вы запускаете данный код, похожий на игру в угадывание из Главы 2, чтобы получить от пользователя порядковый казательмассива:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}</code></pre>
<p>Этот код успешно собирается. Если запустить этот код с помощью <code>cargo run</code> и ввести <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> или <code>4</code>, программа напечатает соответствующее значение по данному порядковому указателю в массиве. Если вместо этого ввести число за пределами массива, например, <code>10</code>, то программа выведет следующее:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Программа столкнулась с ошибкой во <em>времени выполнения</em> на этапе применения недопустимого значения в действия упорядочевания. Программа завершилась с сообщением об ошибке и не выполнила финальную указанию <code>println!</code>. При попытке доступа к элементу с помощью упорядочевания Rust проверяет, что указанный порядковый казательменьше длины массива. Если порядковый казательбольше или равен длине, Rust паникует. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что сборщик не может знать, какое значение введёт пользователь при последующем выполнении кода.</p>
<p>Это пример принципов безопасности памяти Rust в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный порядковый указатель, доступ к памяти может быть некорректным. Rust защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу. В главе 9 подробнее обсуждается обработка ошибок в Rust и то, как вы можете написать читаемый, безопасный код, который не вызывает панику и не разрешает некорректный доступ к памяти.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Функции"><a class="header" href="#Функции">Функции</a></h2>
<p>Функции широко распространены в коде Rust. Вы уже познакомились с одной из самых важных функций в языке: функцией <code>main</code>, которая является точкой входа большинства программ. Вы также видели ключевое слово <code>fn</code>, позволяющее объявлять новые функции.</p>
<p>Код Rust использует <em>змеиный регистр (snake case)</em> как основной стиль для имён функций и переменных, в котором все буквы строчные, а символ подчёркивания разделяет слова. Вот программа, содержащая пример определения функции:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Для определения функции в Rust необходимо указать <code>fn</code>, за которым следует имя функции и набор круглых скобок. Фигурные скобки указывают сборщику, где начинается и заканчивается тело функции.</p>
<p>Мы можем вызвать любую функцию, которую мы определили ранее, введя её имя и набор скобок следом. Поскольку в программе определена <code>another_function</code>, её можно вызвать из функции <code>main</code>. Обратите внимание, что <code>another_function</code> определена <em>после</em> функции <code>main</code> в исходном коде; мы могли бы определить её и раньше. Rust не важно, где вы определяете свои функции, главное, чтобы они были определены где-то в той области видимости, которую может видеть вызывающий их код.</p>
<p>Создадим новый двоичный проект с названием <em>functions</em> для дальнейшего изучения функций. Поместите пример <code>another_function</code> в файл <em>src/main.rs</em> и запустите его. Вы должны увидеть следующий вывод:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
</code></pre>
<p>Строки выполняются в том порядке, в котором они расположены в функции <code>main</code>. Сначала печатается сообщение "Hello, world!", а затем вызывается <code>another_function</code>, которая также печатает сообщение.</p>
<h3 id="Свойства-функции"><a class="header" href="#Свойства-функции">Свойства функции</a></h3>
<p>Мы можем определить функции, имеющие <em>свойства</em>, которые представляют собой особые переменные, являющиеся частью сигнатуры функции. Когда у функции есть свойства, необходимо предоставить ей определенные значения этих свойств. Технически определенные значения называются <em>переменные</em>, но в повседневном общении люди обычно используют слова <em>свойство</em> и <em>переменная</em> как взаимозаменяемые либо для переменных в определении функции, либо для определенных значений, передаваемых при вызове функции.</p>
<p>В этой исполнения <code>another_function</code> мы добавляем свойство:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Попробуйте запустить эту программу. Должны получить следующий результат:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
</code></pre>
<p>Объявление <code>another_function</code> содержит один свойство с именем <code>x</code>. Вид <code>x</code> задан как <code>i32</code>. Когда мы передаём <code>5</code> в <code>another_function</code>, макрос <code>println!</code> помещает <code>5</code> на место пары фигурных скобок, содержащих <code>x</code> в строке формата.</p>
<p>В сигнатурах функций вы <em>обязаны</em> указывать вид каждого свойства. Это намеренное решение в дизайне Rust: требование аннотаций видов в определениях функций позволяет сборщику в дальнейшем избежать необходимости использовать их в других местах кода, чтобы определить, какой вид вы имеете в виду. Сборщик также может выдавать более полезные сообщения об ошибках, если он знает, какие виды ожидает функция.</p>
<p>При определении нескольких свойств, разделяйте объявления свойств запятыми, как показано ниже:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Этот пример создаёт функцию под именем <code>print_labeled_measurement</code> с двумя свойствами. Первый свойство называется <code>value</code> с видом <code>i32</code>. Второй называется <code>unit_label</code> и имеет вид <code>char</code>. Затем функция печатает текст, содержащий <code>value</code> и <code>unit_label</code>.</p>
<p>Попробуем запустить этот код. Замените текущую программу проекта <em>functions</em> в файле <em>src/main.rs</em> на предыдущий пример и запустите его с помощью <code>cargo run</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
</code></pre>
<p>Поскольку мы вызвали функцию с <code>5</code> в качестве значения для <code>value</code> и <code>'h'</code> в качестве значения для <code>unit_label</code>, вывод программы содержит эти значения.</p>
<h3 id="Указания-и-выражения"><a class="header" href="#Указания-и-выражения">Указания и выражения</a></h3>
<p>Тела функций состоят из ряда указаний, необязательно заканчивающихся выражением. До сих пор функции, которые мы рассматривали, не включали завершающее выражение, но вы видели выражение как часть указания. Поскольку Rust является языком, основанным на выражениях, это важное различие необходимо понимать. В других языках таких различий нет, поэтому давайте рассмотрим, что такое указания и выражения, и как их различия влияют на тела функций.</p>
<ul>
<li><strong>Указания</strong> выполняют какое-либо действие и не возвращают значения.</li>
<li><strong>Выражения</strong> вычисляются до результирующего значения. Давайте рассмотрим несколько примеров.</li>
</ul>
<p>На самом деле мы уже использовали указания и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова <code>let</code> является оператором. В Приложении 3-1, <code>let y = 6;</code> — это указание.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 3-1: Объявление функции <code>main</code>, содержащей одну указанию</span></p>
<p>Определения функций также являются указанием. Весь предыдущий пример сам по себе является указанием.</p>
<p>Указания не возвращают значения. Следовательно вы не можете присвоить <code>let</code> указанию другой переменной, как это пытается сделать следующий код. Вы получите ошибку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}</code></pre>
<p>Если вы запустите эту программу, то ошибка будет выглядеть так:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
</code></pre>
<p>Указание <code>let y = 6</code> не возвращает значение, поэтому не с чем связать переменную <code>x</code>. Это отличается от поведения в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В таких языках можно писать код <code>x = y = 6</code> и обе переменные <code>x</code> и <code>y</code> будут иметь значение <code>6</code>. Но в Rust не так.</p>
<p>Выражения вычисляют значение и составляют большую часть остального кода, который вы напишете на Rust. Рассмотрим математическую действие, к примеру <code>5 + 6</code>, которая является выражением, вычисляющим значение <code>11</code>. Выражения могут быть частью указаний: в приложении 3-1 <code>6</code> в указания <code>let y = 6;</code> является выражением, которое вычисляется в значение <code>6</code>. Вызов функции — это выражение. Вызов макроса — это выражение. Новый разделобласти видимости, созданный с помощью фигурных скобок, представляет собой выражение, например:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Это выражение:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>это блок, который в данном случае вычисляется в значение <code>4</code>. Это значение связывается с <code>y</code> как часть указания <code>let</code>. Обратите внимание, что строка <code>x + 1</code> не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения не содержат завершающих точек с запятой. Если вы добавите точку с запятой в конец выражения, вы превратите его в указанию, и тогда она не будет возвращать значение. Помните об этом, когда будете изучать возвращаемые значения функций и выражения.</p>
<h3 id="Функции-с-возвращаемыми-значениями"><a class="header" href="#Функции-с-возвращаемыми-значениями">Функции с возвращаемыми значениями</a></h3>
<p>Функции могут возвращать значения коду, который их вызывает. Мы не называем возвращаемые значения, но мы должны объявить их вид после стрелки ( <code>-&gt;</code> ). В Rust возвращаемое значение функции является синонимом значения конечного выражения в разделе тела функции. Вы можете раньше выйти из функции и вернуть значение, используя ключевое слово <code>return</code> и указав значение, но большинство функций неявно возвращают последнее выражение. Вот пример такой функции:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>В коде функции <code>five</code> нет вызовов функций, макросов или даже указаний  <code>let</code> — есть только одно число <code>5</code>. Это является абсолютно корректной функцией в Rust. Заметьте, что возвращаемый вид у данной функции определён как <code>-&gt; i32</code>. Попробуйте запустить этот код. Вывод будет таким:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
</code></pre>
<p>Значение <code>5</code> в <code>five</code> является возвращаемым функцией значением, поэтому возвращаемый вид - <code>i32</code>. Рассмотрим пример более подробно. Здесь есть два важных момента: во-первых, строка <code>let x = five();</code> показывает использование возвращаемого функцией значения для объявления переменной. Так как функция <code>five</code> возвращает <code>5</code>, то эта строка эквивалентна следующей:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Во-вторых, у функции <code>five</code> нет свойств и определён вид возвращаемого значения, но тело функции представляет собой одинокую <code>5</code> без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.</p>
<p>Рассмотрим другой пример:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Запуск кода напечатает <code>The value of x is: 6</code>. Но если поставить точку с запятой в конце строки, содержащей <code>x + 1</code>, превратив её из выражения в указанию, мы получим ошибку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}</code></pre>
<p>Сборка данного кода вызывает следующую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
</code></pre>
<p>Основное сообщение об ошибке, <code>несовпадение видов</code>, раскрывает ключевую проблему этого кода. Определение функции <code>plus_one</code> сообщает, что будет возвращено <code>i32</code>, но указания не вычисляются в значение, что и выражается единичным видом <code>()</code>. Следовательно, ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Rust выдаёт сообщение, которое, возможно, поможет исправить эту проблему: он предлагает удалить точку с запятой для устранения ошибки.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Комментарии"><a class="header" href="#Комментарии">Комментарии</a></h2>
<p>Все программисты стремятся сделать свой код простым для понимания, но иногда требуется дополнительное объяснение. В таких случаях программисты оставляют в исходном коде <em>комментарии</em>, которые сборщик пренебрегает, но люди, читающие исходный код, вероятно, сочтут их полезными.</p>
<p>Пример простого комментария:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hello, world.
<span class="boring">}</span></code></pre></pre>
<p>В Rust принят идиоматический стиль комментариев, который начинает комментарий с двух косых черт, и комментарий продолжается до конца строки. Для комментариев, выходящих за пределы одной строки, необходимо включить <code>//</code> в каждую строку, как показано ниже:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Итак, мы делаем что-то сложное, настолько длинное, что нам нужно
// несколько строк комментариев, чтобы сделать это! Ух! Надеюсь, этот комментарий
// объясняет, что происходит.
<span class="boring">}</span></code></pre></pre>
<p>Комментарии также можно размещать в конце строк, содержащих код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-24-comments-end-of-line/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Но чаще всего они используются в таком формате: комментарий располагается на отдельной строке над кодом, который он аннотирует:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-25-comments-above-line/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>В Rust есть ещё один вид комментариев - документационные комментарии, которые мы обсудим в разделе <a href="ch14-02-publishing-to-crates-io.html">"Публикация пакета на Crates.io"</a> главы 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Управляющие-конструкции"><a class="header" href="#Управляющие-конструкции">Управляющие конструкции</a></h2>
<p>Возможности запуска некоторого кода в зависимости от некоторого условия, и циклического выполнения некоторого кода, являются основными элементами в большинстве языков программирования. Наиболее распространёнными конструкциями, позволяющими управлять потоком выполнения кода Rust, являются выражения <code>if</code> и циклы.</p>
<h3 id="Выражения-if"><a class="header" href="#Выражения-if">Выражения <code>if</code></a></h3>
<p>Выражение <code>if</code> позволяет выполнять части кода в зависимости от условий. Вы задаёте условие, а затем указываете: "Если это условие выполняется, выполните этот разделкода. Если условие не выполняется, не выполняйте этот разделкода".</p>
<p>Для изучения выражения <code>if</code> создайте новый проект под названием <em>branches</em> в каталоге <em>projects</em>. В файл <em>src/main.rs</em> поместите следующий код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-26-if-true/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Условие начинается с ключевого слова <code>if</code>, за которым следует условное выражение. В данном случае условное выражение проверяет, имеет ли переменная <code>number</code> значение меньше 5. Сразу после условного выражения внутри фигурных скобок мы помещаем разделкода, который будет выполняться, если результат равен <code>true</code>. Блоки кода, связанные с условными выражениями, иногда называют <em>ветками</em>, как и ветки в выражениях <code>match</code>, которые мы обсуждали в разделе <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">"Сравнение догадки с секретным числом"</a> главы 2.</p>
<p>Это необязательно, но мы также можем использовать ключевое слово <code>else</code>, которое мы используем в данном примере, чтобы предоставить программе иной разделвыполнения кода, выполняющийся если результат вычисления будет ложным. Если не указать выражение <code>else</code> и условие будет ложным, программа просто пропустит раздел<code>if</code> и перейдёт к следующему фрагменту кода.</p>
<p>Попробуйте запустить этот код. Появится следующий результат:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-26-if-true/output.txt}}
</code></pre>
<p>Попробуйте изменить значение <code>number</code> на значение, которое делает условие <code>false</code> и посмотрите, что произойдёт:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-27-if-false/src/main.rs:here}}</code></pre>
<p>Запустите программу снова и посмотрите на вывод:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-27-if-false/output.txt}}
</code></pre>
<p>Также стоит отметить, что условие в этом коде <em>должно</em> быть логического вида <code>bool</code>. Если условие не является <code>bool</code>, возникнет ошибка. Например, попробуйте запустить следующий код:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/src/main.rs}}</code></pre>
<p>На этот раз условие <code>if</code> вычисляется в значение <code>3</code>, и Rust бросает ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/output.txt}}
</code></pre>
<p>Ошибка говорит, что Rust ожидал вид <code>bool</code>, но получил значение целочисленного вида. В отличии от других языков вроде Ruby и JavaScript, Rust не будет пытаться самостоятельно преобразовывать <em>нелогические</em> виды в логические. Необходимо явно и всегда использовать <code>if</code> с логическим видом в качестве условия. Если нужно, чтобы разделкода <code>if</code> запускался только, когда число не равно <code>0</code>, то, например, мы можем изменить выражение <code>if</code> на следующее:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-29-if-not-equal-0/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Будет напечатана следующая строка <code>number was something other than zero</code>.</p>
<h4 id="Обработка-нескольких-условий-с-помощью-else-if"><a class="header" href="#Обработка-нескольких-условий-с-помощью-else-if">Обработка нескольких условий с помощью <code>else if</code></a></h4>
<p>Можно использовать несколько условий, комбинируя <code>if</code> и <code>else</code> в выражении <code>else if</code>. Например:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-30-else-if/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>У этой программы есть четыре возможных пути выполнения. После её запуска вы должны увидеть следующий результат:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-30-else-if/output.txt}}
</code></pre>
<p>Во время выполнения этой программы по очереди проверяется каждое выражение <code>if</code> и выполняется первый блок, для которого условие <code>true</code>. Заметьте, что хотя 6 делится на 2, мы не видим ни вывода <code>number is divisible by 2</code>, ни текста <code>number is not divisible by 4, 3, or 2</code> из раздела <code>else</code>. Так происходит потому, что Rust выполняет разделтолько для первого истинного условия, а обнаружив его, даже не проверяет остальные.</p>
<p>Использование множества выражений <code>else if</code> приводит к загромождению кода, поэтому при наличии более чем одного выражения, возможно, стоит провести рефакторинг кода. В главе 6 описана мощная конструкция ветвления Rust для таких случаев, называемая <code>match</code>.</p>
<h4 id="Использование-if-в-указания-let"><a class="header" href="#Использование-if-в-указания-let">Использование <code>if</code> в указания <code>let</code></a></h4>
<p>Поскольку <code>if</code> является выражением, его можно использовать в правой части указания <code>let</code> для присвоения результата переменной, как в приложении 3-2.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-02/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 3-2: Присвоение результата выражения <code>if</code> переменной</span></p>
<p>Переменная <code>number</code> будет привязана к значению, которое является результатом выражения <code>if</code>. Запустим код и посмотрим, что происходит:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/listing-03-02/output.txt}}
</code></pre>
<p>Вспомните, что разделы кода вычисляются последним выражением в них, а числа сами по себе также являются выражениями. В данном случае, значение всего выражения <code>if</code> зависит от того, какой разделвыполняется. При этом значения, которые могут быть результатами каждого из ветвей <code>if</code>, должны быть одного вида. В Приложении 3-2, результатами обеих ветвей <code>if</code> и <code>else</code> являются целочисленный вид <code>i32</code>. Если виды не совпадают, как в следующем примере, мы получим ошибку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/src/main.rs}}</code></pre>
<p>При попытке сборки этого кода, мы получим ошибку. Ветви <code>if</code> и <code>else</code> представляют несовместимые виды значений, и Rust точно указывает, где искать проблему в программе:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/output.txt}}
</code></pre>
<p>Выражение в разделе <code>if</code> вычисляется как целочисленное, а выражение в разделе <code>else</code> вычисляется как строка. Это не сработает, потому что переменные должны иметь один вид, а Rust должен знать во время сборки, какого вида переменная <code>number</code>. Зная вид <code>number</code>, сборщик может убедиться, что вид действителен везде, где мы используем <code>number</code>. Rust не смог бы этого сделать, если бы вид <code>number</code> определялся только во время выполнения. Сборщик усложнился бы и давал бы меньше заверений в отношении кода, если бы ему приходилось отслеживать несколько гипотетических видов для любой переменной.</p>
<h3 id="Повторное-выполнение-кода-с-помощью-циклов"><a class="header" href="#Повторное-выполнение-кода-с-помощью-циклов">Повторное выполнение кода с помощью циклов</a></h3>
<p>Часто бывает полезно выполнить раздел кода более одного раза. Для этой задачи Rust предоставляет несколько конструкций цикла, которые позволяют выполнить разделкода  до конца, а затем сразу же вернуться в начало. Для экспериментов с циклами давайте создадим новый проект под названием <em>loops</em>.</p>
<p>В Rust есть три вида циклов: <code>loop</code>, <code>while</code> и <code>for</code>. Давайте попробуем каждый из них.</p>
<h4 id="Повторение-выполнения-кода-с-помощью-loop"><a class="header" href="#Повторение-выполнения-кода-с-помощью-loop">Повторение выполнения кода с помощью <code>loop</code></a></h4>
<p>Ключевое слово <code>loop</code> говорит Rust выполнять разделкода снова и снова до бесконечности или пока не будет явно приказано остановиться.</p>
<p>В качестве примера, измените код файла <em>src/main.rs</em> в каталоге проекта <em>loops</em> на код ниже:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-loop/src/main.rs}}</code></pre>
<p>Когда запустим эту программу, увидим, как <code>again!</code> печатается снова и снова, пока не остановить программу вручную. Большинство окно вызоваов поддерживают сочетание клавиш <span class="keystroke">ctrl-c</span> для прерывания программы, которая застряла в непрерывном цикле. Попробуйте:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>Символ <code>^C</code> обозначает место, где было нажато <span class="keystroke">ctrl-c </span>. В зависимости от того, где находился код в цикле в момент получения сигнала прерывания, вы можете увидеть или не увидеть слово <code>again!</code>, напечатанное после <code>^C</code>.</p>
<p>К счастью, Rust также предоставляет способ выйти из цикла с помощью кода. Ключевое слово <code>break</code> нужно поместить в цикл, чтобы указать программе, когда следует прекратить выполнение цикла. Напоминаем, мы делали так в игре "Угадайка" в разделе <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">"Выход после правильной догадки"</a><!-- ignore --> Главы 2, чтобы выйти из программы, когда пользователь выиграл игру, угадав правильное число.</p>
<p>Мы также использовали <code>continue</code> в игре "Угадайка", которое указывает программе в цикле пропустить весь оставшийся код в данной повторения цикла и перейти к следующей повторения.</p>
<h4 id="Возвращение-значений-из-циклов"><a class="header" href="#Возвращение-значений-из-циклов">Возвращение значений из циклов</a></h4>
<p>Одно из применений <code>loop</code> - это повторение действия, которая может закончиться неудачей, например, проверка успешности выполнения потоком своего задания. Также может понадобиться передать из цикла результат этой действия в остальную часть кода. Для этого можно добавить возвращаемое значение после выражения <code>break</code>, которое используется для остановки цикла. Это значение будет возвращено из цикла, и его можно будет использовать, как показано здесь:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-33-return-value-from-loop/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Перед циклом мы объявляем переменную с именем <code>counter</code> и объявим её значением <code>0</code>. Затем мы объявляем переменную с именем <code>result</code> для хранения значения, возвращаемого из цикла. На каждой повторения цикла мы добавляем <code>1</code> к переменной <code>counter</code>, а затем проверяем, равняется ли <code>10</code> переменная <code>counter</code>. Когда это происходит, мы используем ключевое слово <code>break</code> со значением <code>counter * 2</code>. После цикла мы ставим точку с запятой для завершения указания, присваивающей значение <code>result</code>. Наконец, мы выводим значение в <code>result</code>, равное в данном случае 20.</p>
<h4 id="Метки-циклов-для-устранения-неоднозначности-между-несколькими-циклами"><a class="header" href="#Метки-циклов-для-устранения-неоднозначности-между-несколькими-циклами">Метки циклов для устранения неоднозначности между несколькими циклами</a></h4>
<p>Если у вас есть циклы внутри циклов, <code>break</code> и <code>continue</code> применяются к самому внутреннему циклу в этой цепочке. При желании вы можете создать <em>метку цикла</em>, которую вы затем сможете использовать с <code>break</code> или <code>continue</code> для указания, что эти ключевые слова применяются к помеченному циклу, а не к самому внутреннему циклу. Метки цикла должны начинаться с одинарной кавычки. Вот пример с двумя вложенными циклами:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Внешний цикл имеет метку <code>'counting_up</code>, и он будет считать от 0 до 2. Внутренний цикл без метки ведёт обратный отсчёт от 10 до 9. Первый <code>break</code>, который не содержит метку, выйдет только из внутреннего цикла. Указание <code>break 'counting_up;</code> завершит внешний цикл. Этот код напечатает:</p>
<pre><code class="language-console">{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/output.txt}}
</code></pre>
<h4 id="Циклы-с-условием-while"><a class="header" href="#Циклы-с-условием-while">Циклы с условием <code>while</code></a></h4>
<p>В программе часто требуется проверить состояние условия в цикле. Пока условие истинно, цикл выполняется. Когда условие перестаёт быть истинным, программа вызывает <code>break</code>, останавливая цикл. Такое поведение можно реализовать с помощью сочетания <code>loop</code>, <code>if</code>, <code>else</code> и <code>break</code>. При желании попробуйте сделать это в программе. Это настолько распространённый паттерн, что в Rust реализована встроенная языковая конструкция для него, называемая цикл <code>while</code>. В приложении 3-3 мы используем <code>while</code>, чтобы выполнить три цикла программы, производя каждый раз обратный отсчёт, а затем, после завершения цикла, печатаем сообщение и выходим.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-03/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 3-3: Использование цикла <code>while</code> для выполнения кода, пока условие истинно</span></p>
<p>Эта конструкция устраняет множество вложений, которые потребовались бы при использовании <code>loop</code>, <code>if</code>, <code>else</code> и <code>break</code>, и она более понятна. Пока условие вычисляется в <code>true</code>, код выполняется; в противном случае происходит выход из цикла.</p>
<h4 id="Цикл-по-элементам-собрания-с-помощью-for"><a class="header" href="#Цикл-по-элементам-собрания-с-помощью-for">Цикл по элементам собрания с помощью <code>for</code><a id="looping-through-a-collection-with-for"></a></a></h4>
<p>Для перебора элементов собрания, например, массива, можно использовать конструкцию <code>while</code>. Например, цикл в приложении 3-4 печатает каждый элемент массива <code>a</code>.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-04/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 3-4: Перебор каждого элемента собрания с помощью цикла <code>while</code></span></p>
<p>Этот код выполняет перебор элементов массива. Он начинается с порядкового казателя <code>0</code>, а затем циклически выполняется, пока не достигнет последнего порядкового казателя в массиве (то есть, когда <code>index &lt; 5</code> уже не является истиной). Выполнение этого кода напечатает каждый элемент массива:</p>
<pre><code class="language-console">{{#include ../listings/ch03-common-programming-concepts/listing-03-04/output.txt}}
</code></pre>
<p>Все пять значений массива появляются в окне вызова, как и ожидалось. Поскольку <code>index</code> в какой-то момент достигнет значения <code>5</code>, цикл прекратит выполнение перед попыткой извлечь шестое значение из массива.</p>
<p>Однако такой подход чреват ошибками; мы можем вызвать панику в программе, если значение порядкового казателя или условие проверки неверны. Например, если изменить определение массива <code>a</code> на четыре элемента, но забыть обновить условие на <code>while index &lt; 4</code>, код вызовет панику. Также это медленно, поскольку сборщик добавляет код времени выполнения для обеспечения проверки нахождения порядкового казателя в границах массива на каждой повторения цикла.</p>
<p>В качестве более краткой иного решения можно использовать цикл <code>for</code> и выполнять некоторый код для каждого элемента собрания. Цикл <code>for</code> может выглядеть как код в приложении 3-5.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-05/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 3-5: Перебор каждого элемента собрания с помощью цикла <code>for</code></span></p>
<p>При выполнении этого кода мы увидим тот же результат, что и в приложении 3-4. Что важнее, теперь мы повысили безопасность кода и устранили вероятность ошибок, которые могут возникнуть в результате выхода за пределы массива или недостаточно далёкого перехода и пропуска некоторых элементов.</p>
<p>При использовании цикла <code>for</code> не нужно помнить о внесении изменений в другой код, в случае изменения количества значений в массиве, как это было бы с способом, использованным в приложении 3-4.</p>
<p>Безопасность и краткость циклов <code>for</code> делают их наиболее часто используемой конструкцией цикла в Rust. Даже в ситуациях необходимости выполнения некоторого кода определённое количество раз, как в примере обратного отсчёта, в котором использовался цикл <code>while</code> из Приложения 3-3, большинство Rustaceans использовали бы цикл <code>for</code>. Для этого можно использовать <code>Range</code>, предоставляемый встроенной библиотекой, который генерирует последовательность всех чисел, начиная с первого числа и заканчивая вторым числом, но не включая его (т.е. <code>(1..4)</code> эквивалентно <code>[1, 2, 3]</code> или в общем случае <code>(start..end)</code> эквивалентно <code>[start, start+1, start+2, ... , end-2, end-1]</code> - прим.переводчика).</p>
<p>Вот как будет выглядеть обратный отсчёт с использованием цикла <code>for</code> и другого способа, о котором мы ещё не говорили, <code>rev</code>, для разворота ряда:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-34-for-range/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Данный код выглядит лучше, не так ли?</p>
<h2 id="Итоги-1"><a class="header" href="#Итоги-1">Итоги</a></h2>
<p>Вы справились! Это была объёмная глава: вы узнали о переменных, скалярных и составных видах данных, функциях, комментариях, выражениях <code>if</code> и циклах! Для практики работы с концепциями, обсуждаемыми в этой главе, попробуйте создать программы для выполнения следующих действий:</p>
<ul>
<li>Преобразование температур между значениями по Фаренгейту к Цельсию.</li>
<li>Генерирование n-го числа Фибоначчи.</li>
<li>Распечатайте текст рождественской песни "Двенадцать дней Рождества", воспользовавшись повторами в песне.</li>
</ul>
<p>Когда вы будете готовы двигаться дальше, мы поговорим о концепции в Rust, которая <em>не существует</em> обычно в других языках программирования: владение.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Понимание-Владения"><a class="header" href="#Понимание-Владения">Понимание Владения</a></h1>
<p>Владение - это самая уникальная особенность Rust, которая имеет глубокие последствия для всего языка. Это позволяет Rust обеспечивать безопасность памяти без использования сборщика мусора, поэтому важно понимать, как работает владение. В этой главе мы поговорим о владении, а также о нескольких связанных с ним возможностях: заимствовании, срезах и о том, как Rust раскладывает данные в памяти.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Что-такое-владение"><a class="header" href="#Что-такое-владение">Что такое владение?</a></h2>
<p><em>Владение</em> — это набор правил, определяющих, как программа на языке Rust управляет памятью. Все программы так или иначе должны управлять тем, как они используют память компьютера во время работы. Некоторые языки имеют сборщик мусора, регулярно отслеживающий неиспользуемую память во время работы программы; в других языках программист должен явно выделять и освобождать память. В Rust используется третий подход: память управляется через систему владения с набором правил, которые проверяются сборщиком. При нарушении любого из правил программа не будет собрана. Ни одна из особенностей системы владения не замедлит работу вашей программы.</p>
<p>Поскольку владение является новой концепцией для многих программистов, требуется некоторое время, чтобы привыкнуть к ней. Хорошая новость заключается в том, что чем больше у вас будет опыта с Rust и с правилами системы владения, тем легче вам будет естественным образом разрабатывать безопасный и эффективный код. Держитесь! Не сдавайтесь!</p>
<p>Понимание концепции владения даст вам основу для понимания всех остальных особенностей, делающих Rust уникальным. В этой главе вы изучите владение на примерах, которые сфокусированы на наиболее часто используемой структуре данных: строках.</p>
<blockquote>
<h3 id="Стек-и-куча"><a class="header" href="#Стек-и-куча">Стек и куча</a></h3>
<p>Многие языки программирования не требуют, чтобы вы слишком часто думали о стеке и куче. Но в языках системного программирования, одним из которых является Rust, то, какое значение находится в стеке или в куче, влияет на поведение языка и на принятие вами определённых решений. Владение будет описано через призму стека и кучи позже в этой главе, а пока — краткое пояснение.</p>
<p>И стек, и куча — это части памяти, доступные вашему коду для использования во время выполнения. Однако они структурированы по-разному. Стек хранит значения в порядке их получения, а удаляет — в обратном. Это называется <em>«последним пришёл — первым ушёл»</em>. Подумайте о стопке тарелок: когда вы добавляете тарелки, вы кладёте их сверху стопки — когда вам нужна тарелка, вы берёте одну так же сверху. Добавление или удаление тарелок посередине или снизу не сработает! Добавление данных называется <em>помещением в стек</em>, а удаление — извлечением <em>из стека</em>. Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер. Данные, размер которых во время сборки неизвестен или может измениться, должны храниться в куче.</p>
<p>Куча устроена менее организованно: когда вы кладёте данные в кучу, вы запрашиваете определённый объём пространства. Операционная система находит в куче свободный участок памяти достаточного размера, помечает его как используемый и возвращает <em>указатель</em>, являющийся адресом этого участка памяти. Этот процесс называется <em>выделением памяти в куче</em> и иногда сокращается до <em>выделения памяти</em> (помещение значений в стек не считается выделением). Поскольку указатель на участок памяти в куче имеет определённый фиксированный размер, его можно расположить в стеке, однако когда вам понадобятся актуальные данные, вам придётся проследовать по указателю. Представьте, что вы сидите в ресторане. Когда вы входите, вы называете количество человек в вашей группе, и персонал находит свободный стол, которого хватит на всех, и ведёт вас туда. Если кто-то из вашей группы опоздает, он может спросить, куда вас посадили, чтобы найти вас.</p>
<p>Помещение в стек происходит более быстро, чем выделение памяти в куче, потому что операционная система не должна искать место для размещения сведений — это место всегда на верхушке стека. Для сравнения, выделение памяти в куче требует больше работы, потому что операционная система сначала должна найти участок памяти достаточного размера, а затем произвести некоторые действия для подготовки к следующему выделению памяти.</p>
<p>Доступ к данным в куче медленнее, чем доступ к данным в стеке, потому что вам нужно следовать по адресу указателя, чтобы добраться туда. Современные процессоры работают быстрее, если они меньше прыгают по памяти. Продолжая подобие, рассмотрим официанта в ресторане, принимающего заказы со многих столов. Наиболее эффективно будет получить все заказы за одним столом, прежде чем переходить к следующему столу. Получение заказа со стола А, затем со стола В, затем снова одного с А, а затем снова одного с В было бы гораздо более медленным делом. Точно так же процессор может выполнять свою работу лучше, если он работает с данными, которые находятся близко к другим данным (как в стеке), а не далеко (как это может быть в куче).</p>
<p>Когда ваш код вызывает функцию, значения, переданные в неё (потенциально включающие указатели на данные в куче), и местные переменные помещаются в стек. Когда функция завершается, эти значения извлекаются из стека.</p>
<p>Отслеживание того, какие части кода используют какие данные, минимизация количества повторяющихся данных и очистка неиспользуемых данных в куче, чтобы не исчерпать пространство, — все эти проблемы решает владение. Как только вы поймёте, что такое владение, вам не нужно будет слишком часто думать о стеке и куче. Однако знание того, что основная цель владения — управление данными кучи, может помочь объяснить, почему оно работает именно так.</p>
</blockquote>
<h3 id="Правила-владения"><a class="header" href="#Правила-владения">Правила владения</a></h3>
<p>Во-первых, давайте взглянем на правила владения. Помните об этих правилах, пока мы работаем с примерами, которые их отображают:</p>
<ul>
<li>У каждого значения в Rust есть <em>владелец</em>,</li>
<li>У значения может быть только один владелец в один момент времени,</li>
<li>Когда владелец покидает область видимости, значение удаляется.</li>
</ul>
<h3 id="Область-видимости-переменной"><a class="header" href="#Область-видимости-переменной">Область видимости переменной</a></h3>
<p>Теперь, когда мы прошли основной синтаксис Rust, мы не будем включать весь код <code>fn main() {</code> в примеры. Поэтому, если вы будете следовать этому курсу, убедитесь, что следующие примеры помещены в функцию <code>main</code> вручную. В результате наши примеры будут более лаконичными, что позволит нам сосредоточиться на существующих подробностях, а не на шаблонном коде.</p>
<p>В качестве первого примера владения мы рассмотрим <em>область видимости</em> некоторых переменных. Область видимости — это рядвнутри программы, для которого допустим элемент. Возьмём следующую переменную:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>Переменная <code>s</code> относится к строковому литералу, где значение строки жёстко прописано в тексте нашей программы. Переменная действительна с момента её объявления до конца текущей <em>области видимости</em>. В приложении 4-1 показана программа с комментариями, указывающими, где допустима переменная <code>s</code> .</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-1: переменная и область действия, в которой она допустима</span></p>
<p>Другими словами, здесь есть два важных момента:</p>
<ul>
<li>Когда переменная <code>s</code> <em>появляется</em> в области видимости, она считается действительной,</li>
<li>Она остаётся действительной до момента <em>выхода</em> за границы этой области.</li>
</ul>
<p>На этом этапе объяснения взаимосвязь между областями видимости и допустимостью переменных подобна той, что существует в других языках программирования. Теперь мы будем опираться на это понимание, введя вид <code>String</code>.</p>
<h3 id="Вид-данных-string"><a class="header" href="#Вид-данных-string">Вид данных <code>String</code></a></h3>
<p>Для отображения правил владения нам требуется более сложный вид данных чем те, что мы обсуждали в части <a href="ch03-02-data-types.html#data-types">"Виды данных"</a> Главы 3. Виды, рассмотренные ранее, имеют определённый размер, а значит могут быть размещены на стеке и извлечены из него, когда их область видимости закончится, и могут быть быстро и тривиально скопированы для создания новой, независимой копии, если другой части кода нужно использовать то же самое значение в другой области видимости. Но мы хотим посмотреть на данные, хранящиеся в куче, и выяснить, как Rust узнаёт, когда нужно очистить эти данные, поэтому вид <code>String</code> — отличный пример.</p>
<p>Мы сконцентрируемся на тех частях <code>String</code>, которые связаны с владением. Эти особенности также применимы к другим сложным видам данных, независимо от того, предоставлены они встроенной библиотекой или созданы вами. Более подробно мы обсудим <code>String</code> в <a href="ch08-02-strings.html">главе 8</a><!-- ignore -->.</p>
<p>Мы уже видели строковые литералы, где строковое значение жёстко прописано в нашей программе. Строковые литералы удобны, но они подходят не для каждой ситуации, где мы можем хотеть использовать текст. Одна из причин заключается в том, что они неизменны. Кроме того, не каждое строковое значение может быть известно во время написания кода: что, если мы захотим принять и сохранить пользовательский ввод? Для таких ситуаций в Rust есть ещё один строковый вид — <code>String</code>. Этот вид управляет данными, выделенными в куче, и поэтому может хранить объём текста, который во время сборки неизвестен. Также вы можете создать <code>String</code> из строкового литерала, используя функцию <code>from</code>, например:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>Оператор "Двойное двоеточие" <code>::</code> позволяет использовать пространство имён данной именно функции <code>from</code> с видом <code>String</code>, а не какое-то иное имя, такое как <code>string_from</code>. Мы обсудим этот синтаксис более подробно в разделе <a href="ch05-03-method-syntax.html#method-syntax">«Синтаксис способа»</a>. раздел <!-- ignore --> Главы 5, и в ходе обсуждения пространств имён с модулями в <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"> «Пути для обращения к элементу в дереве модулей»</a><!-- ignore --> в главе 7.</p>
<p>Строка такого вида <em>может</em> быть изменяема:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>В чем же тут разница? Почему строку <code>String</code> можно изменить, а литералы — нельзя? Разница заключается в том, как эти два вида работают с памятью.</p>
<h3 id="Память-и-способы-её-выделения"><a class="header" href="#Память-и-способы-её-выделения">Память и способы её выделения</a></h3>
<p>В случае строкового литерала мы знаем его содержимое во время сборки, и оно жёстко прописано в итоговом исполняемом файле. Причина того, что строковые литералы более быстрые и эффективные, в их неизменяемости. К сожалению, нельзя поместить неопределённый кусок памяти в выполняемый файл для текста, размер которого неизвестен при сборки и может меняться во время выполнения программы.</p>
<p>Чтобы поддерживать изменяемый, увеличивающийся текст вида <code>String</code>, необходимо выделять память в куче для всего содержимого, объем которого неизвестен во время сборки. Это означает, что:</p>
<ul>
<li>Память должна запрашиваться у операционной системы во время выполнения программы,</li>
<li>Необходим способ возврата этой памяти операционной системе, когда мы закончили в программе работу со <code>String</code>.</li>
</ul>
<p>Первая часть выполняется нами: когда мы вызываем <code>String::from</code>, его реализация запрашивает необходимую память. Это работает довольно похоже во всех языках программирования.</p>
<p>Однако вторая часть отличается. В языках со <em>сборщиком мусора (GC)</em>, память, которая больше не используется, отслеживается и очищается с его помощью — нам не нужно об этом думать. В большинстве языков без сборщика мусора мы обязаны сами определять, когда память больше не используется, и вызывать код для явного её освобождения, точно так же, как мы делали это для её запроса. Правильное выполнение этого процесса исторически было сложной проблемой программирования. Если мы забудем освободить память, она будет потеряна. Если мы сделаем это слишком рано, у нас будет недопустимая переменная. Сделать это дважды — тоже будет ошибкой. Нам нужно соединить ровно один <code>allocate</code> ровно с одним <code>free</code>.</p>
<p>Rust выбирает другой путь: память самостоятельно возвращается, как только владеющая памятью переменная выходит из области видимости. Вот исполнение примера с областью видимости из приложения 4-1, в котором используется вид <code>String</code> вместо строкового литерала:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Существует естественный момент, когда мы можем вернуть память, необходимую нашему <code>String</code>, обратно распределителю — когда <code>s</code> выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Rust вызывает для нас особую функцию. Эта функция называется <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, и именно здесь автор <code>String</code> может поместить код для возврата памяти. Rust самостоятельно вызывает <code>drop</code> после закрывающей фигурной скобки.</p>
<blockquote>
<p>Примечание: в C++ этот паттерн освобождения ресурсов в конце времени жизни элемента иногда называется <em>«Получение ресурса есть объявление» (англ. Resource Acquisition Is Initialization (RAII))</em>. Функция <code>drop</code> в Rust покажется вам знакомой, если вы использовали шаблоны RAII.</p>
</blockquote>
<p>Этот шаблон оказывает глубокое влияние на способ написания кода в Rust. Сейчас это может казаться простым, но в более сложных ситуациях поведение кода может быть неожиданным, например когда хочется иметь несколько переменных, использующих данные, выделенные в куче. Изучим несколько таких ситуаций.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-перемещения"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-перемещения">Взаимодействие переменных и данных с помощью перемещения</a></h4>
<p>Несколько переменных могут по-разному взаимодействовать с одними и теми же данными в Rust. Давайте рассмотрим пример использования целого числа в приложении 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-2. Присвоение целочисленного значения переменной <code>x</code> переменной <code>y</code></span></p>
<p>Мы можем догадаться, что делает этот код: «привязать значение <code>5</code> к <code>x</code>; затем сделать копию значения в <code>x</code> и привязать его к <code>y</code>». Теперь у нас есть две переменные: <code>x</code> и <code>y</code>, и обе равны <code>5</code>. Это то, что происходит на самом деле, потому что целые числа — это простые значения с известным фиксированным размером, и эти два значения <code>5</code> помещаются в стек.</p>
<p>Теперь рассмотрим исполнение с видом <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Это выглядит очень похоже, поэтому мы можем предположить, что происходит то же самое: вторая строка сделает копию значения в <code>s1</code> и привяжет его к <code>s2</code>. Но это не совсем так.</p>
<p>Взгляните на рисунок 4-1, чтобы увидеть, что происходит со <code>String</code> под капотом. <code>String</code> состоит из трёх частей, показанных слева: указатель на память, в которой хранится содержимое строки, длина и ёмкость. Эта группа данных хранится в стеке. Справа — память в куче, которая содержит содержимое.</p>
<img alt="Two tables: the first table contains the representation of s1 on the&lt;br&gt;stack, consisting of its length (5), capacity (5), and a pointer to the first&lt;br&gt;value in the second table. The second table contains the representation of the&lt;br&gt;string data on the heap, byte by byte." src="https://github.com/rust-lang-ru/book/blob/master/rustbook-ru/src/img/trpl04-01.svg?raw=true" class="">
<p><span class="caption">Рисунок 4-1: представление в памяти <code>String</code>, содержащей значение <code>"hello"</code>, привязанное к <code>s1</code></span></p>
<p>Длина — это объём памяти в байтах, который в настоящее время использует содержимое <code>String</code>. Ёмкость — это общий объём памяти в байтах, который <code>String</code> получил от распределителя. Разница между длиной и ёмкостью имеет значение, но не в этом среде, поэтому на данный момент можно пренебрегать ёмкость.</p>
<p>Когда мы присваиваем <code>s1</code> значению <code>s2</code>, данные <code>String</code> копируются, то есть мы копируем указатель, длину и ёмкость, которые находятся в стеке. Мы не копируем данные в куче, на которые указывает указатель. Другими словами, представление данных в памяти выглядит так, как показано на рис. 4-2.</p>
<img alt="Three tables: tables s1 and s2 representing those strings on the&lt;br&gt;stack, respectively, and both pointing to the same string data on the heap." src="https://github.com/rust-lang-ru/book/blob/master/rustbook-ru/src/img/trpl04-02.svg?raw=true" class="">
<p><span class="caption">Рисунок 4-2: представление в памяти переменной <code>s2</code>, имеющей копию указателя, длины и ёмкости <code>s1</code></span></p>
<p>Представление <em>не</em> похоже на рисунок 4-3, как выглядела бы память, если бы вместо этого Rust также скопировал данные кучи. Если бы Rust сделал это, действие <code>s2 = s1</code> могла бы быть очень дорогой с точки зрения производительности во время выполнения, если бы данные в куче были большими.</p>
<img alt="Two tables: the first table contains the representation of s1 on the&lt;br&gt;stack, consisting of its length (5), capacity (5), and a pointer to the first&lt;br&gt;value in the second table. The second table contains the representation of the&lt;br&gt;string data on the heap, byte by byte." src="https://github.com/rust-lang-ru/book/blob/master/rustbook-ru/src/img/trpl04-01.svg?raw=true" class="">
<p><span class="caption">Рисунок 4-3: другой вариант того, что может сделать <code>s2 = s1</code>, если Rust также скопирует данные кучи</span></p>
<p>Ранее мы сказали, что когда переменная выходит за пределы области видимости, Rust самостоятельно вызывает функцию <code>drop</code> и очищает память в куче для данной переменной. Но на рис. 4.2 оба указателя данных указывают на одно и то же место. Это проблема: когда переменные <code>s2</code> и <code>s1</code> выходят из области видимости, они обе будут пытаться освободить одну и ту же память в куче. Это известно как <em>ошибка двойного освобождения (double free)</em> и является одной из ошибок безопасности памяти, упоминаемых ранее. Освобождение памяти дважды может привести к повреждению памяти, что потенциально может привести к уязвимостям безопасности.</p>
<p>Чтобы обеспечить безопасность памяти, после строки <code>let s2 = s1;</code> , Rust считает <code>s1</code> более недействительным. Следовательно, Rust не нужно ничего освобождать, когда <code>s1</code> выходит за пределы области видимости. Посмотрите, что происходит, когда вы пытаетесь использовать <code>s1</code> после создания <code>s2</code> ; это не сработает:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}</code></pre>
<p>Вы получите похожую ошибку, потому что Rust не позволяет вам использовать недействительную ссылку:</p>
<pre><code class="language-console">{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
</code></pre>
<p>Если вы слышали термины <em>поверхностное копирование</em> и <em>глубокое копирование</em> при работе с другими языками, концепция копирования указателя, длины и ёмкости без копирования данных, вероятно, звучит как создание поверхностной копии. Но поскольку Rust также аннулирует первую переменную, вместо того, чтобы называть это поверхностным копированием, это называется <em>перемещением</em>. В этом примере мы бы сказали, что <code>s1</code> был <em>перемещён</em> в <code>s2</code>. Итак, что на самом деле происходит, показано на рисунке 4-4.</p>
<img alt="Три таблицы: таблицы s1 и s2, представляющие эти строки в стеке соответственно, и обе указывающие на одни и те же строковые данные в куче. Таблица s1 выделена серым цветом, потому что s1 больше недействительна; только s2 можно использовать для доступа к данным кучи." src="img/trpl04-04.svg" class="center" style="width: 50%;">
<p><span class="caption">Рисунок 4-4: представление в памяти после того, как <code>s1</code> был признан недействительным</span></p>
<p>Это решает нашу проблему! Действительной остаётся только переменная <code>s2</code>. Когда она выходит из области видимости, то она одна будет освобождать память в куче.</p>
<p>Такой выбор дизайна языка даёт дополнительное преимущество: Rust никогда не будет самостоятельно создавать «глубокие» копии ваших данных. Следовательно любое такое <em>самостоятельное</em> копирование можно считать недорогим с точки зрения производительности во время выполнения.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-клонирования"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-клонирования">Взаимодействие переменных и данных с помощью клонирования</a></h4>
<p>Если мы <em>хотим</em> глубоко скопировать данные кучи <code>String</code>, а не только данные стека, мы можем использовать общий способ, называемый <code>clone</code>. Мы обсудим синтаксис способов в главе 5, но поскольку способы являются общей чертой многих языков программирования, вы, вероятно, уже встречались с ними.</p>
<p>Вот пример работы способа <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Это отлично работает и очевидно приводит к поведению, представленному на рисунке 4-3, где данные кучи <em>были</em> скопированы.</p>
<p>Когда вы видите вызов <code>clone</code>, вы знаете о выполнении некоторого кода, который может быть дорогим. В то же время использование <code>clone</code> является визуальным индикатором того, что тут происходит что-то нестандартное.</p>
<h4 id="Стековые-данные-копирование"><a class="header" href="#Стековые-данные-копирование">Стековые данные: копирование</a></h4>
<p>Это ещё одна особенность о которой мы ранее не говорили. Этот код, часть которого была показа ранее в приложении 4-2, использует целые числа. Он работает без ошибок:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Но этот код, кажется, противоречит тому, что мы только что узнали: у нас нет вызова <code>clone</code>, но <code>x</code> всё ещё действителен и не был перемещён в <code>y</code>.</p>
<p>Причина в том, что такие виды, как целые числа, размер которых известен во время сборки, полностью хранятся в стеке, поэтому копии фактических значений создаются быстро. Это означает, что нет причин, по которым мы хотели бы предотвратить доступность <code>x</code> после того, как создадим переменную <code>y</code>. Другими словами, здесь нет разницы между глубоким и поверхностным копированием, поэтому вызов <code>clone</code> ничем не отличается от обычного поверхностного копирования, и мы можем его опустить.</p>
<p>В Rust есть особая изложение, называемая типажом <code>Copy</code>, которую мы можем размещать на видах, хранящихся в стеке, как и целые числа (подробнее о видах мы поговорим в <a href="ch10-02-traits.html">главе 10</a><!-- ignore -->). Если вид реализует типаж <code>Copy</code>, переменные, которые его используют, не перемещаются, а тривиально копируются, что делает их действительными после присвоения другой переменной.</p>
<p>Rust не позволит нам аннотировать вид с помощью <code>Copy</code>, если вид или любая из его частей реализует <code>Drop</code>. Если для вида нужно, чтобы произошло что-то особенное, когда значение выходит за пределы области видимости, и мы добавляем изложение <code>Copy</code> к этому виду, мы получим ошибку времени сборки. Чтобы узнать, как добавить изложение <code>Copy</code> к вашему виду для реализации типажа, смотрите <a href="appendix-03-derivable-traits.html">раздел «Производные типажи»</a><!-- ignore --> в приложении С.</p>
<p>Но какие же виды реализуют трейт <code>Copy</code>? Можно проверить документацию любого вида для уверенности, но как правило любая группа простых скалярных значений может быть реализовывать <code>Copy</code>, и никакие виды, которые требуют выделения памяти в куче или являются некоторой формой ресурсов, не реализуют трейта <code>Copy</code>. Вот некоторые виды, которые реализуют <code>Copy</code>:</p>
<ul>
<li>Все целочисленные виды, такие как <code>u32</code>,</li>
<li>Логический вид данных <code>bool</code>, возможные значения которого <code>true</code> и <code>false</code>,</li>
<li>Все виды с плавающей запятой, такие как <code>f64</code>.</li>
<li>Символьный вид <code>char</code>,</li>
<li>Кортежи, но только если они содержат виды, которые также реализуют <code>Copy</code>. Например, <code>(i32, i32)</code> будет с <code>Copy</code>, но кортеж <code>(i32, String)</code> уже нет.</li>
</ul>
<h3 id="Владение-и-функции"><a class="header" href="#Владение-и-функции">Владение и функции</a></h3>
<p>Механика передачи значения функции подобна тому, что происходит при присвоении значения переменной. Передача переменной в функцию приведёт к перемещению или копированию, как и присваивание. В приложении 4-3 есть пример с некоторыми изложениями, показывающими, где переменные входят в область видимости и выходят из неё.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-3. Функции с аннотированными владельцами и областью действия</span></p>
<p>Если попытаться использовать <code>s</code> после вызова <code>takes_ownership</code>, Rust выдаст ошибку времени сборки. Такие статические проверки защищают от ошибок. Попробуйте добавить код в <code>main</code>, который использует переменную <code>s</code> и <code>x</code>, чтобы увидеть где их можно использовать и где правила владения предотвращают их использование.</p>
<h3 id="Возвращение-значений-и-область-видимости"><a class="header" href="#Возвращение-значений-и-область-видимости">Возвращение значений и область видимости</a></h3>
<p>Возвращаемые значения также могут передавать право владения. В приложении 4-4 показан пример функции, возвращающей некоторое значение, с такими же изложениями, как в приложении 4-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-4: передача права владения на возвращаемые значения</span></p>
<p>Владение переменной каждый раз следует одному и тому же шаблону: присваивание значения другой переменной перемещает его. Когда переменная, содержащая данные в куче, выходит из области видимости, содержимое в куче будет очищено функцией <code>drop</code>, если только данные не были перемещены во владение другой переменной.</p>
<p>Хотя это работает, получение права владения, а затем возвращение владения каждой функцией немного утомительно. Что, если мы хотим, чтобы функция использовала значение, но не становилась владельцем? Очень раздражает, что всё, что мы передаём, также должно быть передано обратно, если мы хотим использовать это снова, в дополнение к любым данным, полученным из тела функции, которые мы также можем захотеть вернуть.</p>
<p>Rust позволяет нам возвращать несколько значений с помощью кортежа, как показано в приложении 4-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-5: возврат права владения на свойства</span></p>
<p>Но это слишком высокопарно и многословно для концепции, которая должна быть общей. К счастью для нас, в Rust есть возможность использовать значение без передачи права владения, называемая <em>ссылками</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Ссылки-и-заимствование"><a class="header" href="#Ссылки-и-заимствование">Ссылки и заимствование</a></h2>
<p>Проблема с кодом кортежа в приложении 4-5 заключается в том, что мы должны вернуть <code>String</code> из вызванной функции, чтобы использовать <code>String</code> после вызова <code>calculate_length</code>, потому что <code>String</code> была перемещена в <code>calculate_length</code>. Вместо этого мы можем предоставить ссылку на значение <code>String</code>. <em>Ссылка</em> похожа на указатель в том смысле, что это адрес, по которому мы можем проследовать, чтобы получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка обязательно указывает на допустимое значение определённого вида в течение всего срока существования этой ссылки.</p>
<p>Вот как вы могли бы определить и использовать функцию <code>calculate_length</code>, имеющую ссылку на объект в качестве свойства, вместо того, чтобы брать на себя ответственность за значение:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
<span class="boring">}</span></code></pre></pre>
<p>Во-первых, обратите внимание, что весь код кортежа в объявлении переменной и возвращаемое значение функции исчезли. Во-вторых, обратите внимание, что мы передаём <code>&amp;s1</code> в <code>calculate_length</code> и в его определении используем <code>&amp;String</code>, а не <code>String</code>. Эти знаки представляют собой <em>ссылки</em>, и они позволяют вам ссылаться на некоторое значение, не принимая владение над ним. Рисунок 4-5 изображает эту концепцию.</p>
<img alt="&amp;String s pointing at String s1" src="img/trpl04-05.svg" class="">
<p><span class="caption">Рисунок 4-5: диаграмма для <code>&amp;String s</code>, указывающей на <code>String s1</code></span></p>
<blockquote>
<p>Примечание: противоположностью ссылки с использованием <code>&amp;</code> является <em>разыменование</em>, выполняемое с помощью оператора разыменования <code>*</code>. Мы увидим некоторые варианты использования оператора разыменования в главе 8 и обсудим подробности разыменования в главе 15.</p>
</blockquote>
<p>Давайте подробнее рассмотрим механизм вызова функции:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> позволяет нам создать ссылку, которая <em>ссылается</em> на значение <code>s1</code>, но не владеет им. Поскольку она не владеет им, значение, на которое она указывает, не будет удалено, когда ссылка перестанет использоваться.</p>
<p>Сигнатура функции использует <code>&amp;</code> для индикации того, что вид свойства <code>s</code> является ссылкой. Добавим объясняющие комментарии:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Область действия <code>s</code> такая же, как и область действия любого свойства функции, но значение, на которое указывает ссылка, не удаляется, когда <code>s</code> перестаёт использоваться, потому что <code>s</code> не является его владельцем. Когда функции имеют ссылки в качестве свойств вместо фактических значений, нам не нужно возвращать значения, чтобы вернуть право владения, потому что мы никогда не владели ими.</p>
<p>Мы называем процесс создания ссылки <em>заимствованием</em>. Как и в существующей жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть это законному владельцу.</p>
<p>А что произойдёт, если попытаться изменить то, что было позаимствовано? Попробуйте код приложения 4-6 Спойлер: этот код не сработает!</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 4-6: попытка модификации заимствованной переменной</span></p>
<p>Вот ошибка:</p>
<pre><code class="language-console">{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
</code></pre>
<p>Как переменные неизменяемы по умолчанию, так и ссылки. Нам не разрешено изменять то, на что у нас есть ссылка.</p>
<h3 id="Изменяемые-ссылки"><a class="header" href="#Изменяемые-ссылки">Изменяемые ссылки</a></h3>
<p>Мы можем исправить код из приложения 4-6, чтобы позволить себе изменять заимствованное значение, с помощью нескольких небольших настроек, которые используют <em>изменяемую ссылку</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Сначала мы меняем <code>s</code> на <code>mut</code>. Затем мы создаём изменяемую ссылку с помощью <code>&amp;mut s</code>, у которой вызываем <code>change</code> и обновляем сигнатуру функции, чтобы принять изменяемую ссылку с помощью <code>some_string: &amp;mut String</code>. Это даёт понять, что <code>change</code> изменит значение, которое заимствует.</p>
<p>Изменяемые ссылки имеют одно большое ограничение: если у вас есть изменяемая ссылка на значение, у вас не может быть других ссылок на это же значение. Код, который пытается создать две изменяемые ссылки на <code>s</code>, завершится ошибкой:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}</code></pre>
<p>Описание ошибки:</p>
<pre><code class="language-console">{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
</code></pre>
<p>Эта ошибка говорит о том, что код недействителен, потому что мы не можем заимствовать <code>s</code> как изменяемые более одного раза в один момент. Первое изменяемое заимствование находится в <code>r1</code> и должно длиться до тех пор, пока оно не будет использовано в <code>println!</code>, но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку в <code>r2</code>, которая заимствует те же данные, что и <code>r1</code>.</p>
<p>Ограничение, предотвращающее одновременное использование нескольких изменяемых ссылок на одни и те же данные, допускает изменение, но очень управляющим образом. Это то, с чем борются новые Rustaceans, потому что большинство языков позволяют изменять значение в любой момент. Преимущество этого ограничения заключается в том, что Rust может предотвратить гонку данных во время сборки. <em>Гонка данных</em> похожа на состояние гонки и происходит, когда возникают следующие три сценария:</p>
<ul>
<li>Два или больше указателей используют одни и те же данные в одно и то же время,</li>
<li>Минимум один указатель используется для записи данных,</li>
<li>Отсутствуют механизмы для синхронизации доступа к данным.</li>
</ul>
<p>Гонки данных вызывают неопределённое поведение, и их может быть сложно диагностировать и исправить, когда вы пытаетесь отследить их во время выполнения. Rust предотвращает такую проблему, отказываясь собирать код с гонками данных!</p>
<p>Как всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не <em>одновременно</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Rust применяет подобное правило для комбинирования изменяемых и неизменяемых ссылок. Этот код приводит к ошибке:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}</code></pre>
<p>Ошибка:</p>
<pre><code class="language-console">{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
</code></pre>
<p>Вау! У нас <em>также</em> не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение.</p>
<p>Пользователи неизменяемой ссылки не ожидают, что значение внезапно изменится из-под них! Однако разрешены множественные неизменяемые ссылки, потому что никто, кто просто читает данные, не может повлиять на чтение данных кем-либо ещё.</p>
<p>Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, этот код будет собираться, потому что последнее использование неизменяемых ссылок <code>println!</code>, происходит до того, как вводится изменяемая ссылка:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Области неизменяемых ссылок <code>r1</code> и <code>r2</code> заканчиваются после <code>println!</code> где они использовались в последний раз, то есть до создания изменяемой ссылки <code>r3</code>. Эти области не перекрываются, поэтому этот код разрешён: сборщик может сказать, что ссылка больше не используется в точке перед концом области.</p>
<p>Несмотря на то, что ошибки заимствования могут иногда вызывать разочарование, помните, что сборщик Rust заранее указывает на потенциальную ошибку (во время сборки, а не во время выполнения) и точно показывает, в чем проблема. Тогда вам не придётся выяснять, почему ваши данные оказались не такими, как вы ожидали.</p>
<h3 id="Висячие-ссылки"><a class="header" href="#Висячие-ссылки">Висячие ссылки</a></h3>
<p>В языках с указателями весьма легко ошибочно создать недействительную (висячую) <em>(dangling)</em> ссылку. Ссылку указывающую на участок памяти, который мог быть передан кому-то другому, путём освобождения некоторой памяти при сохранении указателя на эту память. Rust сборщик заверяет, что ссылки никогда не станут недействительными: если у вас есть ссылка на какие-то данные, сборщик обеспечит что эти данные не выйдут из области видимости прежде, чем из области видимости исчезнет ссылка.</p>
<p>Давайте попробуем создать висячую ссылку, чтобы увидеть, как Rust предотвращает их появление с помощью ошибки во время сборки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}</code></pre>
<p>Здесь ошибка:</p>
<pre><code class="language-console">{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
</code></pre>
<p>Это сообщение об ошибке относится к особенности языка, которую мы ещё не рассмотрели: времени жизни. Мы подробно обсудим времена жизни в главе 10. Но если вы не обращаете внимания на части, касающиеся времени жизни, сообщение будет содержать ключ к тому, почему этот код является проблемой:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Давайте подробнее рассмотрим, что именно происходит на каждом этапе нашего кода <code>dangle</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}</code></pre>
<p>Поскольку <code>s</code> создаётся внутри <code>dangle</code>, когда код <code>dangle</code> будет завершён, <code>s</code> будет освобождена. Но мы попытались вернуть ссылку на неё. Это означает, что эта ссылка будет указывать на недопустимую <code>String</code>. Это нехорошо! Rust не позволит нам сделать это.</p>
<p>Решением будет вернуть непосредственно <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Это работает без проблем. Владение перемещено, и ничего не освобождено.</p>
<h3 id="Правила-работы-с-ссылками"><a class="header" href="#Правила-работы-с-ссылками">Правила работы с ссылками</a></h3>
<p>Давайте повторим  все, что мы обсудили про ссылки:</p>
<ul>
<li>В любой момент времени у вас может быть <em>одна</em> (но не обе) изменяемая ссылка или любое количество неизменяемых ссылок.</li>
<li>Все ссылки должны быть действительными.</li>
</ul>
<p>В следующей главе мы рассмотрим другой вид ссылок — срезы.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Вид-срезы"><a class="header" href="#Вид-срезы">Вид срезы</a></h2>
<p><em>Срезы</em> позволяют ссылаться на непрерывную последовательность элементов в собрания, а не на всю собрание. Срез является своего рода ссылкой, поэтому он не имеет права владения.</p>
<p>Вот небольшая проблема программирования: напишите функцию, которая принимает строку слов, разделённых пробелами, и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробела в строке, вся строка должна состоять из одного слова, поэтому должна быть возвращена вся строка.</p>
<p>Давайте рассмотрим, как бы мы написали сигнатуру этой функции без использования срезов, чтобы понять проблему, которую решат срезы:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>Функция <code>first_word</code> имеет <code>&amp;String</code> в качестве свойства. Мы не хотим владения, так что всё в порядке. Но что мы должны вернуть? На самом деле у нас нет способа говорить о <em>части</em> строки. Однако мы могли бы вернуть порядковый казательконца слова, обозначенного пробелом. Давайте попробуем, как показано в Приложении 4-7.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-7. Функция <code>first_word</code>, возвращающая значение порядкового казателя байта в свойство <code>String</code></span></p>
<p>Поскольку нам нужно просмотреть <code>String</code> поэлементно и проверить, является ли значение пробелом, мы преобразуем нашу <code>String</code> в массив байтов с помощью способа <code>as_bytes</code>.</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}</code></pre>
<p>Далее, мы создаём <em>повторитель</em> по массиву байт используя способ <code>iter</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}</code></pre>
<p>Мы обсудим повторители более подробно в <a href="ch13-02-iterators.html">Главе 13</a><!-- ignore -->. На данный момент знайте, что <code>iter</code> — это способ, который возвращает каждый элемент в собрания, а <code>enumerate</code> оборачивает результат <code>iter</code> и вместо этого возвращает каждый элемент как часть кортежа. Первый элемент кортежа, возвращаемый из <code>enumerate</code>, является порядковым казателем, а второй элемент — ссылкой на элемент. Это немного удобнее, чем вычислять порядковый казательсамостоятельно.</p>
<p>Поскольку способ <code>enumerate</code> возвращает кортеж, мы можем использовать шаблоны для деструктурирования этого кортежа. Мы подробнее обсудим шаблоны в <a href="ch06-02-match.html#patterns-that-bind-to-values">Главе 6.</a><!-- ignore -->. В цикле <code>for</code> мы указываем шаблон, имеющий <code>i</code> для порядкового казателя в кортеже и <code>&amp;item</code> для одного байта в кортеже. Поскольку мы получаем ссылку на элемент из <code>.iter().enumerate()</code>, мы используем <code>&amp;</code> в шаблоне.</p>
<p>Внутри цикла <code>for</code> мы ищем байт, представляющий пробел, используя синтаксис байтового литерала. Если мы находим пробел, мы возвращаем позицию. В противном случае мы возвращаем длину строки с помощью <code>s.len()</code>.</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}</code></pre>
<p>Теперь у нас есть способ узнать порядковый казательбайта указывающего на конец первого слова в строке, но есть проблема. Мы возвращаем сам <code>usize</code>, но это число имеет значение только в среде <code>&amp;String</code>. Другими словами, поскольку это значение отдельное от <code>String</code>, то нет заверения, что оно все ещё будет действительным в будущем. Рассмотрим программу из приложения 4-8, которая использует функцию <code>first_word</code> приложения 4-7.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 4-8. Сохранение результата вызова функции <code>first_word</code> и последующего изменения содержимого <code>String</code></span></p>
<p>Данная программа собирается без ошибок и будет успешно работать, даже после того как мы воспользуемся переменной <code>word</code> после вызова <code>s.clear()</code>. Так как значение <code>word</code> совсем не связано с состоянием переменной <code>s</code>, то <code>word</code> сохраняет своё значение <code>5</code> без изменений. Мы бы могли воспользоваться значением <code>5</code> чтобы получить первое слово из переменной <code>s</code>, но это приведёт к ошибке, потому что содержимое <code>s</code> изменилось после того как мы сохранили <code>5</code> в переменной <code>word</code> (стало пустой строкой в вызове <code>s.clear()</code>).</p>
<p>Необходимость беспокоиться о том, что порядковый казательв переменной <code>word</code> не синхронизируется с данными в переменной  <code>s</code> является утомительной и подверженной ошибкам! Управление этими порядковыми указателями становится ещё более хрупким, если мы напишем функцию <code>second_word</code>. Её сигнатура могла бы выглядеть так:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Теперь мы отслеживаем начальный <em>и</em> конечный порядковый указатель, и у нас есть ещё больше значений, которые были рассчитаны на основе данных в определённом состоянии, но вообще не привязаны к этому состоянию. У нас есть три несвязанные переменные, которые необходимо синхронизировать.</p>
<p>К счастью в Rust есть решение данной проблемы: строковые срезы.</p>
<h3 id="Строковые-срезы"><a class="header" href="#Строковые-срезы">Строковые срезы</a></h3>
<p>Строковый срез - это ссылка на часть строки <code>String</code> и он выглядит следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Вместо ссылки на всю <code>String</code> <code>hello</code> является ссылкой на часть <code>String</code>, указанную в дополнительном куске кода <code>[0..5]</code>. Мы создаём срезы, используя рядв квадратных скобках, указав <code>[starting_index..ending_index]</code>, где <code>starting_index</code> — это первая позиция, а<code>ending_index</code> конечный_порядковый казатель— это на единицу больше, чем последняя позиция в срезе. Внутри структура данных среза хранит начальную позицию и длину среза, что соответствует <code>ending_index</code> минус <code>starting_index</code>. Итак, в случае <code>let world = &amp;s[6..11];</code>, <code>world</code> будет срезом, содержащим указатель на байт с порядковым казателем 6 <code>s</code> со значением длины <code>5</code>.</p>
<p>Рисунок 4-6 отображает это на диаграмме.</p>
 <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="">
<p><span class="caption">Рисунок 4-6: Строковый срез ссылается на часть <code>String</code></span></p>
<p>С синтаксисом Rust <code>..</code>, если вы хотите начать с порядкового казателя 0, вы можете отбросить значение перед двумя точками. Другими словами, они равны:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>Таким же образом, если ваш срез включает последний байт <code>String</code>, вы можете отбросить конечный номер. Это означает, что они равны:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>Вы также можете отбросить оба значения, чтобы получить часть всей строки. Итак, они равны:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Примечание. Порядковые указатели ряда срезов строк должны располагаться на допустимых границах символов UTF-8. Если вы попытаетесь создать фрагмент строки нарушая границы символа в котором больше одного байта, ваша программа завершится с ошибкой. В целях введения срезов строк мы предполагаем, что в этом разделе используется только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">«Сохранение закодированного текста UTF-8 со строками»</a>.<!-- ignore --> раздел главы 8.</p>
</blockquote>
<p>Давайте используем полученную сведения и перепишем способ <code>first_word</code> так, чтобы он возвращал срез. Для обозначения вида "срез строки" существует запись <code>&amp;str</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы получаем порядковый казательконца слова так же, как в приложении 4.7, ища первое вхождение пробела. Когда мы находим пробел, мы возвращаем фрагмент строки, используя начало строки и порядковый казательпробела в качестве начального и конечного порядковых указателей.</p>
<p>Теперь, когда мы вызываем <code>first_word</code>, мы возвращаем одно значение, привязанное к основным данным. Значение состоит из ссылки на начальную точку среза и количества элементов в срезе.</p>
<p>Подобным образом можно переписать и второй способ <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Теперь у нас есть простой API, который гораздо сложнее испортить, потому что сборщик заверяет, что ссылки в <code>String</code> останутся действительными. Помните ошибку в программе в приложении 4-8, когда мы получили порядковый казательдо конца первого слова, но затем очистили строку, так что наш порядковый казательстал недействительным? Этот код был логически неправильным, но не показывал немедленных ошибок. Проблемы проявятся позже, если мы попытаемся использовать порядковый казательпервого слова с пустой строкой. Срезы делают эту ошибку невозможной и сообщают нам о проблеме с нашим кодом гораздо раньше. Так, использование исполнения способа <code>first_word</code> со срезом вернёт ошибку сборки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}</code></pre>
<p>Ошибка сборки:</p>
<pre><code class="language-console">{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
</code></pre>
<p>Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на что-то, мы не можем также взять изменяемую ссылку. Поскольку для <code>clear</code> необходимо обрезать <code>String</code>, необходимо получить изменяемую ссылку. <code>println!</code> после вызова <code>clear</code> использует ссылку в <code>word</code>, поэтому неизменяемая ссылка в этот момент всё ещё должна быть активной. Rust запрещает одновременное существование изменяемой ссылки в формате <code>clear</code> и неизменяемой ссылки в <code>word</code>, и сборка завершается ошибкой. Rust не только упростил использование нашего API, но и устранил целый класс ошибок во время сборки!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="Строковые-литералы---это-срезы"><a class="header" href="#Строковые-литералы---это-срезы">Строковые литералы - это срезы</a></h4>
<p>Напомним, что мы говорили о строковых литералах, хранящихся внутри двоичного файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые литералы:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>Вид <code>s</code> здесь <code>&amp;str</code>: это срез, указывающий на эту определенную точку двоичного файла. Вот почему строковые литералы неизменяемы; <code>&amp;str</code> — неизменяемая ссылка.</p>
<h4 id="Строковые-срезы-как-свойства"><a class="header" href="#Строковые-срезы-как-свойства">Строковые срезы как свойства</a></h4>
<p>Знание того, что вы можете брать срезы литералов и <code>String</code> значений, приводит нас к ещё одному улучшению <code>first_word</code>, и это его сигнатура:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Более опытный пользователь Rustacean вместо этого написал бы сигнатуру, показанную в приложении 4.9, потому что это позволяет нам использовать одну и ту же функцию как для значений <code>&amp;String</code>, так и для значений <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 4-9: Улучшение функции <code>first_word</code> используя вид строкового среза для свойства <code>s</code></span></p>
<p>Если у нас есть фрагмент строки, мы можем передать его напрямую. Если у нас есть <code>String</code>, мы можем передать часть <code>String</code> или ссылку на <code>String</code>. Эта гибкость использует преимущества <em>приведения deref</em>, функции, которую мы рассмотрим в <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">разделе «Неявное приведение Deref с функциями и способами».</a><!-- ignore --> раздел главы 15.</p>
<p>Определение функции для получения фрагмента строки вместо ссылки на <code>String</code> делает наш API более общим и полезным без потери какой-либо функциональности:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
<span class="boring">}</span></code></pre></pre>
<h3 id="Другие-срезы"><a class="header" href="#Другие-срезы">Другие срезы</a></h3>
<p>Срезы строк, как вы можете себе представить, отличительны для строк. Но есть и более общий вид среза. Рассмотрим этот массив:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Точно так же, как мы можем захотеть сослаться на часть строки, мы можем захотеть сослаться на часть массива. Мы бы сделали так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Этот срез имеет вид <code>&amp;[i32]</code>. Он работает так же, как и срезы строк, сохраняя ссылку на первый элемент и его длину. Вы будете использовать этот вид фрагмента для всех видов других собраний. Мы подробно обсудим эти собрания, когда будем говорить о векторах в главе 8.</p>
<h2 id="Итоги-2"><a class="header" href="#Итоги-2">Итоги</a></h2>
<p>Концепции владения, заимствования и срезов обеспечивают безопасность памяти в программах на Rust во время сборки. Язык Rust даёт вам управление над использованием памяти так же, как и другие языки системного программирования, но то, что владелец данных самостоятельно очищает эти данные, когда владелец выходит за рамки, означает, что вам не нужно писать и отлаживать дополнительный код, чтобы получить этот управление.</p>
<p>Владение влияет на множество других частей и концепций языка Rust. Мы будем говорить об этих концепциях на протяжении оставшихся частей книги. Давайте перейдём к Главе 5 и рассмотрим группировку частей данных в структуры <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Использование-структур-для-структурирования-связанных-данных"><a class="header" href="#Использование-структур-для-структурирования-связанных-данных">Использование структур для структурирования связанных данных</a></h1>
<p><em>Структура (struct)</em> — это пользовательский вид данных, позволяющий назвать и упаковать вместе несколько связанных значений, составляющих значимую логическую группу. Если вы знакомы с объектно-ориентированными языками, <em>структура</em> похожа на атрибуты данных объекта. В этой главе мы сравним и сопоставим кортежи со структурами, чтобы опираться на то, что вы уже знаете, и отобразим, когда структуры являются лучшим способом группировки данных.</p>
<p>Мы отобразим, как определять структуры и создавать их экземпляры. Мы обсудим, как определить ассоциированные функции, особенно ассоциированные функции, называемые <em>способами</em>, для указания поведения, ассоциированного с видом структуры. Структуры и перечисления (обсуждаемые в главе 6) являются строительными разделами для создания новых видов в предметной области вашей программы. Они дают возможность в полной мере воспользоваться преимуществами проверки видов во время сборки Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Определение-и-объявление-структур"><a class="header" href="#Определение-и-объявление-структур">Определение и объявление структур</a></h2>
<p>Структуры похожи на кортежи, рассмотренные в разделе <a href="ch03-02-data-types.html#the-tuple-type">"Кортежи"</a><!-- ignore -->, так как оба хранят несколько связанных значений. Как и кортежи, части структур могут быть разных видов. В отличие от кортежей, в структуре необходимо именовать каждую часть данных для понимания смысла значений. Добавление этих имён обеспечивает большую гибкость структур по сравнению с кортежами: не нужно полагаться на порядок данных для указания значений экземпляра или доступа к ним.</p>
<p>Для определения структуры указывается ключевое слово <code>struct</code> и её название. Название должно описывать значение частей данных, сгруппированных вместе. Далее, в фигурных скобках для каждой новой части данных поочерёдно определяются имя части данных и её вид. Каждая пара <code>имя: тип</code> называется <em>полем</em>. Приложение 5-1 описывает структуру для хранения сведений об учётной записи пользователя:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-01/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-1: Определение структуры <code>User</code></span></p>
<p>После определения структуры можно создавать её <em>экземпляр</em>, назначая определённое значение каждому полю с соответствующим видом данных. Чтобы создать экземпляр, мы указываем имя структуры, затем добавляем фигурные скобки и включаем в них пары <code>ключ: значение</code> (key: value), где ключами являются имена полей, а значениями являются данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления полей в описании структуры (но всё-таки желательно для удобства чтения). Другими словами, объявление структуры - это как шаблон нашего вида, в то время как экземпляр структуры использует этот шаблон, заполняя его определёнными данными, для создания значений нашего вида. Например, можно объявить пользователя как в приложении 5-2:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-2: Создание экземпляра структуры <code>User</code></span></p>
<p>Чтобы получить определенное значение из структуры, мы используем запись через точку. Например, чтобы получить доступ к адресу электронной почты этого пользователя, мы используем <code>user1.email</code>. Если экземпляр является изменяемым, мы можем поменять значение, используя точечную нотацию и присвоение к определенному полю. В Приложении 5-3 показано, как изменить значение в поле <code>email</code> изменяемого экземпляра <code>User</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-3: Изменение значения в поле <code>email</code> экземпляра <code>User</code></span></p>
<p>Стоит отметить, что весь экземпляр структуры должен быть изменяемым; Rust не позволяет помечать изменяемыми отдельные поля. Как и для любого другого выражения, мы можем использовать выражение создания структуры в качестве последнего выражения тела функции для неявного возврата нового экземпляра.</p>
<p>На приложении 5-4 функция <code>build_user</code> возвращает экземпляр <code>User</code> с указанным адресом и именем. Поле <code>active</code> получает значение <code>true</code>, а поле <code>sign_in_count</code> получает значение <code>1</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-04/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-4: Функция <code>build_user</code>, которая принимает email и имя пользователя и возвращает экземпляр <code>User</code></span></p>
<p>Имеет смысл называть свойства функции теми же именами, что и поля структуры, но необходимость повторять <code>email</code> и <code>username</code> для названий полей и переменных несколько утомительна. Если структура имеет много полей,  повторение каждого имени станет ещё более раздражающим. К счастью, есть удобное сокращение!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="Использование-сокращённой-объявления-поля"><a class="header" href="#Использование-сокращённой-объявления-поля">Использование сокращённой объявления поля</a></h3>
<p>Так как имена входных свойств функции и полей структуры являются полностью равноценными в приложении 5-4, возможно использовать синтаксис <em>сокращённой объявления поля</em>, чтобы переписать <code>build_user</code> так, чтобы он работал точно также, но не содержал повторений для <code>username</code> и <code>email</code>, как в приложении 5-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-05/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-5: функция <code>build_user</code> использует сокращённую объявление полей, потому что её входные свойства <code>username</code> и <code>email</code> имеют имена подобные именам полей структуры</span></p>
<p>Здесь происходит создание нового экземпляра структуры <code>User</code>, которая имеет поле с именем <code>email</code>. Мы хотим установить поле структуры <code>email</code> значением входного свойства <code>email</code> функции <code>build_user</code>. Так как поле <code>email</code> и входной свойство функции <code>email</code> имеют одинаковое название, можно писать просто <code>email</code> вместо кода <code>email: email</code>.</p>
<h3 id="Создание-экземпляра-структуры-из-экземпляра-другой-структуры-с-помощью-синтаксиса-обновления-структуры"><a class="header" href="#Создание-экземпляра-структуры-из-экземпляра-другой-структуры-с-помощью-синтаксиса-обновления-структуры">Создание экземпляра структуры из экземпляра другой структуры с помощью синтаксиса обновления структуры</a></h3>
<p>Часто бывает полезно создать новый экземпляр структуры, который включает большинство значений из другого экземпляра, но некоторые из них изменяет. Это можно сделать с помощью <em>синтаксиса обновления структуры</em>.</p>
<p>Сначала в приложении 5-6 показано, как обычно создаётся новый экземпляр <code>User</code> в <code>user2</code> без синтаксиса обновления. Мы задаём новое значение для <code>email</code>, но в остальном используем те же значения из <code>user1</code>, которые были заданы в приложении 5-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-06/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-6: Создание нового экземпляра <code>User</code> с использованием некоторых значений из экземпляра <code>user1</code></span></p>
<p>Используя синтаксис обновления структуры, можно получить тот же эффект, используя меньше кода как показано в приложении 5-7. Синтаксис <code>..</code> указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного экземпляра.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-07/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-7: Использование синтаксиса обновления структуры для установки нового значения <code>email</code> для экземпляра <code>User</code>, но использование остальных значений из экземпляра <code>user1</code></span></p>
<p>Код в приложении 5-7 также создаёт экземпляр в <code>user2</code>, который имеет другое значение для <code>email</code>, но с тем же значением для полей <code>username</code>, <code>active</code> и <code>sign_in_count</code> из <code>user1</code>. Оператор <code>..user1</code> должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в <code>user1</code>, но можно указать значения для любого количества полей в любом порядке, независимо от порядка полей в определении структуры.</p>
<p>Стоит отметить, что синтаксис обновления структуры использует <code>=</code> как присваивание. Это связано с перемещением данных, как мы видели в разделе <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">«Взаимодействие переменных и данных с помощью перемещения»</a><!-- ignore -->. В этом примере мы больше не можем использовать <code>user1</code> после создания <code>user2</code>, потому что <code>String</code> в поле <code>username</code> из <code>user1</code> было перемещено в <code>user2</code>. Если бы мы задали <code>user2</code> новые значения <code>String</code> для <code>email</code> и <code>username</code>, и таким образом, использовали только значения <code>active</code> и <code>sign_in_count</code> из <code>user1</code>, то <code>user1</code> всё ещё был бы действительным после создания <code>user2</code>. Оба вида <code>active</code> и <code>sign_in_count</code> реализуют типаж <code>Copy</code>, поэтому они ведут себя так, как мы обсуждали в разделе <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">«Стековые данные: копирование»</a><!-- ignore -->.</p>
<h3 id="Кортежные-структуры-структуры-без-именованных-полей-для-создания-разных-видов"><a class="header" href="#Кортежные-структуры-структуры-без-именованных-полей-для-создания-разных-видов">Кортежные структуры: структуры без именованных полей для создания разных видов</a></h3>
<p>Rust также поддерживает структуры, похожие на кортежи, которые называются <em>кортежные структуры</em>. Кортежные структуры обладают дополнительным смыслом, который даёт имя структуры, но при этом не имеют имён, связанных с их полями. Скорее, они просто хранят виды полей. Кортежные структуры полезны, когда вы хотите дать имя всему кортежу и сделать кортеж отличным от других кортежей, и когда именование каждого поля, как в обычной структуре, было бы многословным или избыточным.</p>
<p>Чтобы определить кортежную структуру, начните с ключевого слова <code>struct</code> и имени структуры, за которым следуют виды в кортеже. Например, здесь мы определяем и используем две кортежные структуры с именами <code>Color</code> и <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-01-tuple-structs/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Обратите внимание, что значения <code>black</code> и <code>origin</code> — это разные виды, потому что они являются экземплярами разных кортежных структур. Каждая определяемая вами структура имеет собственный вид, даже если поля внутри структуры могут иметь одинаковые виды. Например, функция, принимающая свойство вида <code>Color</code>, не может принимать <code>Point</code> в качестве переменной, даже если оба вида состоят из трёх значений <code>i32</code>. В остальном экземпляры кортежных структур похожи на кортежи в том смысле, что вы можете деструктурировать их на отдельные части и использовать <code>.</code>, за которой следует порядковый казательдля доступа к отдельному значению.</p>
<h3 id="Единично-подобные-структуры-структуры-без-полей"><a class="header" href="#Единично-подобные-структуры-структуры-без-полей">Единично-подобные структуры: структуры без полей</a></h3>
<p>Также можно определять структуры, не имеющие полей! Они называются <em>единично-подобными структурами</em>, поскольку ведут себя подобно <code>()</code>, единичному виду, о котором мы говорили в разделе <a href="ch03-02-data-types.html#the-tuple-type">"Кортежи"</a><!-- ignore -->. Единично-подобные структуры могут быть полезны, когда требуется реализовать типаж для некоторого вида, но у вас нет данных, которые нужно хранить в самом виде. Мы обсудим типажи в главе 10. Вот пример объявления и создание экземпляра единичной структуры с именем <code>AlwaysEqual</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-04-unit-like-structs/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Чтобы определить <code>AlwaysEqual</code>, мы используем ключевое слово <code>struct</code>, желаемое имя, а затем точку с запятой. Нет необходимости в фигурных или круглых скобках! Затем мы можем получить экземпляр <code>AlwaysEqual</code> в переменной <code>subject</code> подобным образом: используя имя, которое мы определили, без фигурных и круглых скобок. Представим, что в дальнейшем мы реализуем поведение для этого вида таким образом, что каждый экземпляр <code>AlwaysEqual</code> всегда будет равен каждому экземпляру любого другого вида, возможно, с целью получения ожидаемого результата для тестирования. Для реализации такого поведения нам не нужны никакие данные! В главе 10 вы увидите, как определять черты и реализовывать их для любого вида, включая единично-подобные структуры.</p>
<blockquote>
<h3 id="Владение-данными-структуры"><a class="header" href="#Владение-данными-структуры">Владение данными структуры</a></h3>
<p>В определении структуры <code>User</code> в приложении 5-1 мы использовали владеющий вид <code>String</code> вместо вида строковый срез <code>&amp;str</code>. Это осознанный выбор, поскольку мы хотим, чтобы каждый экземпляр этой структуры владел всеми своими данными и чтобы эти данные были действительны до тех пор, пока действительна вся структура.</p>
<p>Структуры также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого необходимо использовать возможность Rust <em>время жизни</em>, которую мы обсудим в главе 10. Время жизни заверяет, что данные, на которые ссылается структура, будут действительны до тех пор, пока существует структура. Допустим, если попытаться сохранить ссылку в структуре без указания времени жизни, как в следующем примере; это не сработает:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
<p>Сборщик будет жаловаться на необходимость определения времени жизни ссылок:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>В главе 10 мы обсудим, как исправить эти ошибки, чтобы иметь возможность хранить ссылки в структурах, а пока мы исправим подобные ошибки, используя владеющие виды вроде <code>String</code> вместо ссылок <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="Пример-использования-структур"><a class="header" href="#Пример-использования-структур">Пример использования структур</a></h2>
<p>Чтобы понять, когда нам может понадобиться использование структур, давайте напишем программу, которая вычисляет площадь прямоугольника. Мы начнём с использования одиночных переменных, а затем будем улучшать программу до использования структур.</p>
<p>Давайте создадим новый проект программы при помощи Cargo и назовём его <em>rectangles</em>. Наша программа будет получать на вход длину и ширину прямоугольника в пикселях и затем рассчитывать площадь прямоугольника. Приложение 5-8 показывает один из коротких вариантов кода, который позволит нам сделать именно то, что надо, в файле проекта <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:all}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-8: вычисление площади прямоугольника, заданного отдельными переменными ширины и высоты</span></p>
<p>Теперь запустим программу, используя <code>cargo run</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/output.txt}}
</code></pre>
<p>Этот код успешно вычисляет площадь прямоугольника, вызывая функцию <code>area</code> с каждым измерением, но мы можем улучшить его ясность и читабельность.</p>
<p>Проблема данного способа очевидна из сигнатуры <code>area</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:here}}</code></pre>
<p>Функция <code>area</code> должна вычислять площадь одного прямоугольника, но функция, которую мы написали, имеет два свойства, и нигде в нашей программе не ясно, что эти свойства взаимосвязаны. Было бы более читабельным и управляемым сгруппировать ширину и высоту вместе. В разделе <a href="ch03-02-data-types.html#the-tuple-type">«Кортежи»</a><!-- ignore --> главы 3 мы уже обсуждали один из способов сделать это — использовать кортежи.</p>
<h3 id="Рефакторинг-при-помощи-кортежей"><a class="header" href="#Рефакторинг-при-помощи-кортежей">Рефакторинг при помощи кортежей</a></h3>
<p>Приложение 5-9 — это другая исполнение программы, использующая кортежи.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-09/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-9: определение ширины и высоты прямоугольника с помощью кортежа</span></p>
<p>С одной стороны, эта программа лучше. Кортежи позволяют добавить немного структуры, и теперь мы передаём только один переменная. Но с другой стороны, эта исполнение менее понятна: кортежи не называют свои элементы, поэтому нам приходится упорядочивать части кортежа, что делает наше вычисление менее очевидным.</p>
<p>Если мы перепутаем местами ширину с высотой при расчёте площади, то это не имеет значения. Но если мы хотим нарисовать прямоугольник на экране, то это уже будет важно! Мы должны помнить, что ширина  <code>width</code> находится в кортеже с порядковым казателем <code>0</code>, а высота <code>height</code> — с порядковым казателем <code>1</code>. Если кто-то другой поработал бы с кодом, ему бы пришлось разобраться в этом и также помнить про порядок. Легко забыть и перепутать эти значения — и это вызовет ошибки, потому что данный код не передаёт наши намерения.</p>
<h3 id="Рефакторинг-при-помощи-структур-добавим-больше-смысла"><a class="header" href="#Рефакторинг-при-помощи-структур-добавим-больше-смысла">Рефакторинг при помощи структур: добавим больше смысла</a></h3>
<p>Мы используем структуры, чтобы добавить смысл данным при помощи назначения им осмысленных имён . Мы можем переделать используемый кортеж в структуру с единым именем для сущности и частными названиями её частей, как показано в приложении 5-10.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-10/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-10: определение структуры <code>Rectangle</code></span></p>
<p>Здесь мы определили структуру и дали ей имя <code>Rectangle</code>. Внутри фигурных скобок определили поля как <code>width</code> и <code>height</code>, оба — вида <code>u32</code>. Затем в <code>main</code> создали определенный экземпляр <code>Rectangle</code> с шириной в <code>30</code> и высотой в <code>50</code> единиц.</p>
<p>Наша функция <code>area</code> теперь определена с одним свойствоом, названным <code>rectangle</code>, чей вид является неизменяемым заимствованием структуры <code>Rectangle</code>. Как упоминалось в главе 4, необходимо заимствовать структуру, а не передавать её во владение. Таким образом функция <code>main</code> сохраняет <code>rect1</code> в собственности и может использовать её дальше. По этой причине мы и используем <code>&amp;</code> в сигнатуре и в месте вызова функции.</p>
<p>Функция <code>area</code> получает доступ к полям <code>width</code> и <code>height</code> экземпляра <code>Rectangle</code> (обратите внимание, что доступ к полям заимствованного экземпляра структуры не приводит к перемещению значений полей, поэтому вы часто видите заимствования структур). Наша сигнатура функции для <code>area</code> теперь говорит именно то, что мы имеем в виду: вычислить площадь <code>Rectangle</code>, используя его поля <code>width</code> и <code>height</code>. Это означает, что ширина и высота связаны друг с другом, и даёт описательные имена значениям, а не использует значения порядкового казателя кортежа <code>0</code> и <code>1</code>. Это торжество ясности.</p>
<h3 id="Добавление-полезной-функциональности-при-помощи-выводимых-типажей"><a class="header" href="#Добавление-полезной-функциональности-при-помощи-выводимых-типажей">Добавление полезной функциональности при помощи выводимых типажей</a></h3>
<p>Было бы полезно иметь возможность печатать экземпляр <code>Rectangle</code> во время отладки программы и видеть значения всех полей. Приложение 5-11 использует макрос <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a><!-- ignore -->, который мы уже использовали в предыдущих главах. Тем не менее, это не работает.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 5-11: Попытка вывести значения экземпляра <code>Rectangle</code></span></p>
<p>При сборки этого кода мы получаем ошибку с сообщением:</p>
<pre><code class="language-text">{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:3}}
</code></pre>
<p>Макрос <code>println!</code> умеет выполнять множество видов форматирования, и по умолчанию фигурные скобки в <code>println!</code> означают использование форматирование, известное как типаж <code>Display</code>. Его вывод предназначен для непосредственного использования конечным пользователем. Примитивные виды, изученные ранее, по умолчанию реализуют типаж <code>Display</code>, потому что есть только один способ отобразить число <code>1</code> или любой другой примитивный вид. Но для структур форматирование <code>println!</code> менее очевидно, потому что есть гораздо больше способов отображения: Вы хотите запятые или нет? Вы хотите печатать фигурные скобки? Должны ли отображаться все поля? Из-за этой неоднозначности Rust не пытается  угадать, что нам нужно, а структуры не имеют встроенной реализации <code>Display</code> для использования в <code>println!</code> с заполнителем <code>{}</code>.</p>
<p>Продолжив чтение текста ошибки, мы найдём полезное замечание:</p>
<pre><code class="language-text">{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:9:10}}
</code></pre>
<p>Давайте попробуем! Вызов макроса <code>println!</code> теперь будет выглядеть так <code>println!("rect1 is {:?}", rect1);</code>. Ввод спецификатора <code>:?</code> внутри фигурных скобок говорит макросу <code>println!</code>, что мы хотим использовать другой формат вывода, известный как <code>Debug</code>. Типаж <code>Debug</code> позволяет печатать структуру способом, удобным для разработчиков, чтобы видеть значение во время отладки кода.</p>
<p>Соберем код с этими изменениями. Упс! Мы всё ещё получаем ошибку:</p>
<pre><code class="language-text">{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:3}}
</code></pre>
<p>Снова сборщик даёт нам полезное замечание:</p>
<pre><code class="language-text">{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:9:10}}
</code></pre>
<p>Rust <em>реализует</em> функциональность для печати отладочной сведений, но <em>не включает (не выводит) её по умолчанию</em>. Мы должны явно включить эту функциональность для нашей структуры. Чтобы это сделать, добавляем внешний атрибут <code>#[derive(Debug)]</code> сразу перед определением структуры, как показано в приложении 5-12.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-12: добавление атрибута для вывода типажа <code>Debug</code> и печати экземпляра <code>Rectangle</code> с отладочным форматированием</span></p>
<p>Теперь при запуске программы мы не получим ошибок и увидим следующий вывод:</p>
<pre><code class="language-console">{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/output.txt}}
</code></pre>
<p>Отлично! Это не самый красивый вывод, но он показывает значения всех полей экземпляра, которые определённо помогут при отладке. Когда у нас более крупные структуры, то полезно иметь более простой для чтения вывод; в таких случаях можно использовать код <code>{:#?}</code> вместо <code>{:?}</code> в строке макроса <code>println!</code>. В этом примере использование стиля <code>{:#?}</code> приведёт к такому выводу:</p>
<pre><code class="language-console">{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-02-pretty-debug/output.txt}}
</code></pre>
<p>Другой способ распечатать значение в формате <code>Debug</code> — использовать макрос <a href="../std/macro.dbg.html"><code>dbg!</code></a><!-- ignore -->, который становится владельцем выражения (в отличие от <code>println!</code>, принимающего ссылку), печатает номер файла и строки, где происходит вызов макроса <code>dbg!</code>, вместе с результирующим значением этого выражения и возвращает владение на значение.</p>
<blockquote>
<p>Примечание: при вызове макроса <code>dbg!</code> выполняется печать в стандартный поток ошибок (<code>stderr</code>), в отличие от <code>println!</code>, который использует стандартный поток вывода в окно вывода (<code>stdout</code>). Подробнее о <code>stderr</code> и <code>stdout</code> мы поговорим в разделе <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">«Запись сообщений об ошибках в стандартный вывод ошибок вместо принятого вывода» главы 12</a><!-- ignore -->.</p>
</blockquote>
<p>Вот пример, когда нас важно значение, которое присваивается полю <code>width</code>, а также значение всей структуры в <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Можем написать макрос <code>dbg!</code> вокруг выражения <code>30 * scale</code>, потому что <code>dbg!</code> возвращает владение значения выражения. Поле <code>width</code> получит то же значение, как если бы у нас не было вызова <code>dbg!</code>. Мы не хотим, чтобы макрос <code>dbg!</code> становился владельцем <code>rect1</code>, поэтому используем ссылку на <code>rect1</code> в следующем вызове. Вот как выглядит вывод этого примера:</p>
<pre><code class="language-console">{{#include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/output.txt}}
</code></pre>
<p>Мы можем увидеть, что первый отладочный вывод поступил из строки 10 <em>src/main.rs</em>, там, где мы отлаживаем выражение <code>30 * scale</code>, и его результирующее значение равно 60 (<code>Debug</code> форматирование, реализованное для целых чисел, заключается в печати только их значения). Вызов <code>dbg!</code> в строке 14 <em>src/main.rs</em> выводит значение <code>&amp;rect1</code>, которое является структурой <code>Rectangle</code>. В этом выводе используется красивое форматирование <code>Debug</code> вида <code>Rectangle</code>. Макрос <code>dbg!</code> может быть очень полезен, когда вы пытаетесь понять, что делает ваш код!</p>
<p>В дополнение к <code>Debug</code>, Rust предоставил нам ряд типажей, которые мы можем использовать с атрибутом <code>derive</code> для добавления полезного поведения к нашим пользовательским видам. Эти типажи и их поведение перечислены в <a href="appendix-03-derivable-traits.html">приложении C</a><!-- ignore -->. Мы расскажем, как реализовать эти трейты с пользовательским поведением, а также как создать свои собственные трейты в главе 10. Кроме того, есть много других атрибутов помимо <code>derive</code>; для получения дополнительной сведений смотрите <a href="https://doc.rust-lang.org/reference/attributes.html">раздел “Атрибуты” справочника Rust</a>.</p>
<p>Функция <code>area</code> является довольно отличительной: она считает только площадь прямоугольников. Было бы полезно привязать данное поведение как можно ближе к структуре <code>Rectangle</code>, потому что наш отличительный код не будет работать с любым другим видом. Давайте рассмотрим, как можно улучшить наш код превращая функцию <code>area</code> в <em>способ</em> <code>area</code>, определённый для вида <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Синтаксис-способа"><a class="header" href="#Синтаксис-способа">Синтаксис способа</a></h2>
<p><em>Способы</em> похожи на функции: мы объявляем их с помощью ключевого слова <code>fn</code> и имени, они могут иметь свойства и возвращаемое значение, и они содержат код, запускающийся в случае вызова способа. В отличие от функций, способы определяются в среде структуры (или объекта перечисления или типажа, которые мы рассмотрим в <a href="ch06-00-enums.html">главе 6)</a><!-- ignore --> и <a href="ch17-02-trait-objects.html">главе 17</a><!-- ignore --> соответственно), а их первым свойствоом всегда является <code>self</code>, представляющий собой экземпляр структуры, с которой вызывается этот способ.</p>
<h3 id="Определение-способов"><a class="header" href="#Определение-способов">Определение способов</a></h3>
<p>Давайте изменим функцию <code>area</code> так, чтобы она имела экземпляр <code>Rectangle</code> в качестве входного свойства и сделаем её способом <code>area</code>, определённым для структуры <code>Rectangle</code>, как показано в приложении 5-13:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-13/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-13: Определение способа <code>area</code> для структуры <code>Rectangle</code></span></p>
<p>Чтобы определить функцию в среде <code>Rectangle</code>, мы создаём раздел<code>impl</code> (implementation - реализация) для <code>Rectangle</code>. Всё в <code>impl</code> будет связано с видом <code>Rectangle</code>. Затем мы перемещаем функцию <code>area</code> внутрь фигурных скобок <code>impl</code> и меняем первый (и в данном случае единственный) свойство на <code>self</code> в сигнатуре и в теле. В <code>main</code>, где мы вызвали функцию <code>area</code> и передали <code>rect1</code> в качестве переменной, теперь мы можем использовать <em>синтаксис способа</em> для вызова способа <code>area</code> нашего экземпляра <code>Rectangle</code>. Синтаксис способа идёт после экземпляра: мы добавляем точку, за которой следует имя способа, круглые скобки и любые переменные.</p>
<p>В сигнатуре <code>area</code> мы используем <code>&amp;self</code> вместо <code>rectangle: &amp;Rectangle</code>. <code>&amp;self</code> на самом деле является сокращением от <code>self: &amp;Self</code>. Внутри раздела <code>impl</code> вид <code>Self</code> является псевдонимом вида, для которого реализован раздел<code>impl</code>. Способы обязаны иметь свойство с именем <code>self</code> вида <code>Self</code>, поэтому Rust позволяет вам сокращать его, используя только имя <code>self</code> на месте первого свойства. Обратите внимание, что нам по-прежнему нужно использовать <code>&amp;</code> перед сокращением <code>self</code>, чтобы указать на то, что этот способ заимствует экземпляр <code>Self</code>, точно так же, как мы делали это в <code>rectangle: &amp;Rectangle</code>. Как и любой другой свойство, способы могут брать во владение <code>self</code>, заимствовать неизменяемый <code>self</code>, как мы поступили в данном случае, или заимствовать изменяемый <code>self</code>.</p>
<p>Мы выбрали <code>&amp;self</code> здесь по той же причине, по которой использовали <code>&amp;Rectangle</code> в исполнения кода с функцией: мы не хотим брать структуру во владение, мы просто хотим прочитать данные в структуре, а не писать в неё. Если бы мы хотели изменить экземпляр, на котором мы вызывали способ силами самого способа, то мы бы использовали <code>&amp;mut self</code> в качестве первого свойства. Наличие способа, который берёт экземпляр во владение, используя только <code>self</code> в качестве первого свойства, является редким; эта техника обычно используется, когда способ превращает <code>self</code> во что-то ещё, и вы хотите запретить вызывающей стороне использовать исходный экземпляр после превращения.</p>
<p>Основная причина использования способов вместо функций, помимо синтаксиса способа, где нет необходимости повторять вид <code>self</code> в сигнатуре каждого способа, заключается в организации кода. Мы поместили все, что мы можем сделать с экземпляром вида, в один <code>impl</code> вместо того, чтобы заставлять будущих пользователей нашего кода искать доступный функционал <code>Rectangle</code> в разных местах предоставляемой нами библиотеки.</p>
<p>Обратите внимание, что мы можем дать способу то же имя, что и одному из полей структуры. Например, для <code>Rectangle</code> мы можем определить способ, также названный <code>width</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-06-method-field-interaction/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы определили, чтобы способ <code>width</code> возвращал значение <code>true</code>, если значение в поле <code>width</code> экземпляра больше <code>0</code>, и значение <code>false</code>, если значение равно <code>0</code>, но мы можем использовать поле в способе с тем же именем для любых целей. В <code>main</code>, когда мы ставим после <code>rect1.width</code> круглые скобки, Rust знает, что мы имеем в виду способ <code>width</code>. Когда мы не используем круглые скобки, Rust понимает, что мы имеем в виду поле <code>width</code>.</p>
<p>Часто, но не всегда, когда мы создаём способы с тем же именем, что и у поля, мы хотим, чтобы он только возвращал значение одноимённого поля и больше ничего не делал. Подобные способы называются <em>геттерами</em>, и Rust не реализует их самостоятельно для полей структуры, как это делают некоторые другие языки. Геттеры полезны, поскольку вы можете сделать поле приватным, а способ публичным и, таким образом, включить доступ только для чтения к этому полю как часть общедоступного API вида. Мы обсудим, что такое публичность и приватность, и как обозначить поле или способ в качестве публичного или приватного в <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">главе 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="Где-используется-оператор--"><a class="header" href="#Где-используется-оператор--">Где используется оператор <code>-&gt;</code>?</a></h3>
<p>В языках C и C++, используются два различных оператора для вызова способов: используется <code>.</code>, если вызывается способ непосредственно у экземпляра структуры и используется <code>-&gt;</code>, если вызывается способ для указателя на объект. Другими словами, если <code>object</code> является указателем, то вызовы способа <code>object-&gt;something()</code> и <code> (*object).something()</code> являются подобными.</p>
<p>Rust не имеет эквивалента оператора <code>-&gt;</code>, наоборот, в Rust есть функциональность называемая <em>самостоятельное обращение по ссылке и разыменование</em> (automatic referencing and dereferencing). Вызов способов является одним из немногих мест в Rust, в котором есть такое поведение.</p>
<p>Вот как это работает: когда вы вызываете способ <code>object.something()</code>, Rust самостоятельно добавляет <code>&amp;</code>, <code>&amp;mut</code> или  <code>*</code>, таким образом, чтобы <code>object</code> соответствовал сигнатуре способа. Другими словами, это то же самое:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>Первый пример выглядит намного понятнее. Самостоятельный вывод ссылки работает потому, что способы имеют понятного получателя - вид <code>self</code>. Учитывая получателя и имя способа, Rust может точно определить, что в данном случае делает код: читает ли способ (<code>&amp;self</code>), делает ли изменение (<code>&amp;mut self</code>) или поглощает (<code>self</code>). Тот факт, что Rust делает заимствование неявным для принимающего способа, в значительной степени способствует тому, чтобы сделать владение эргономичным на практике.</p>
</blockquote>
<h3 id="Способы-с-несколькими-свойствами"><a class="header" href="#Способы-с-несколькими-свойствами">Способы с несколькими свойствами</a></h3>
<p>Давайте попрактикуемся в использовании способов, реализовав второй способ в структуре <code>Rectangle</code>. На этот раз мы хотим, чтобы экземпляр <code>Rectangle</code> брал другой экземпляр <code>Rectangle</code> и возвращал <code>true</code>, если второй <code>Rectangle</code> может полностью поместиться внутри <code>self</code> (первый <code>Rectangle</code>); в противном случае он должен вернуть <code>false</code>. То есть, как только мы определим способ <code>can_hold</code>, мы хотим иметь возможность написать программу, показанную в Приложении 5-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-14/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 5-14: Использование ещё не написанного способа <code>can_hold</code></span></p>
<p>Ожидаемый результат будет выглядеть следующим образом, т.к. оба размера в экземпляре <code>rect2</code> меньше, чем размеры в экземпляре <code>rect1</code>, а <code>rect3</code> шире, чем <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Мы знаем, что хотим определить способ, поэтому он будет находится в <code>impl Rectangle</code> разделе. Имя способа будет <code>can_hold</code>, и оно будет принимать неизменяемое заимствование на другой <code>Rectangle</code> в качестве свойства. Мы можем сказать, какой это будет вид свойства, посмотрев на код вызывающего способа: способ <code>rect1.can_hold(&amp;rect2)</code> передаёт в него  <code>&amp;rect2</code> , который является неизменяемым заимствованием экземпляра <code>rect2</code> вида <code>Rectangle</code>. В этом есть смысл, потому что нам нужно только читать <code>rect2</code> (а не писать, что означало бы, что нужно изменяемое заимствование), и мы хотим, чтобы <code>main</code> сохранил право собственности на экземпляр <code>rect2</code>, чтобы мы могли использовать его снова после вызов способа <code>can_hold</code>. Возвращаемое значение <code>can_hold</code> имеет булевый вид, а реализация проверяет, являются ли ширина и высота <code>self</code> больше, чем ширина и высота другого <code>Rectangle</code> соответственно. Давайте добавим новый способ <code>can_hold</code> в <code>impl</code> разделиз приложения 5-13, как показано в приложении 5-15.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-15/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-15: Реализация способа <code>can_hold</code> для <code>Rectangle</code>, принимающего другой экземпляр <code>Rectangle</code> в качестве свойства</span></p>
<p>Когда мы запустим код с функцией <code>main</code> приложения 5-14, мы получим желаемый вывод. Способы могут принимать несколько свойств, которые мы добавляем в сигнатуру после первого  свойства <code>self</code>, и эти свойства работают так же, как свойства в функциях.</p>
<h3 id="Ассоциированные-функции"><a class="header" href="#Ассоциированные-функции">Ассоциированные функции</a></h3>
<p>Все функции, определённые в разделе <code>impl</code>, называются <em>ассоциированными функциями</em>, потому что они ассоциированы с видом, указанным после ключевого слова <code>impl</code>. Мы можем определить ассоциированные функции, которые не имеют <code>self</code> в качестве первого свойства (и, следовательно, не являются способами), потому что им не нужен экземпляр вида для работы. Мы уже использовали одну подобную функцию: функцию <code>String::from</code>, определённую для вида <code>String</code>.</p>
<p>Ассоциированные функции, не являющиеся способами, часто используются для конструкторов, возвращающих новый экземпляр структуры. Их часто называют <code>new</code>, но <code>new</code> не является особым именем и не встроена в язык. Например, мы можем предоставить ассоциированную функцию с именем <code>square</code>, которая будет иметь один свойство размера и использовать его как ширину и высоту, что упростит создание квадратного <code>Rectangle</code>, вместо того, чтобы указывать одно и то же значение дважды:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-03-associated-functions/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Ключевые слова <code>Self</code> в возвращаемом виде и в теле функции являются псевдонимами для вида, указанного после ключевого слова <code>impl</code>, которым в данном случае является <code>Rectangle</code>.</p>
<p>Чтобы вызвать эту связанную функцию, используется синтаксис <code>::</code> с именем структуры; например <code>let sq = Rectangle::square(3);</code>. Эта функция находится в пространстве имён структуры. Синтаксис <code>::</code> используется как для связанных функций, так и для пространств имён, созданных модулями. Мы обсудим модули в <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">главе 7</a><!-- ignore -->.</p>
<h3 id="Несколько-разделов-impl"><a class="header" href="#Несколько-разделов-impl">Несколько разделов <code>impl</code></a></h3>
<p>Каждая структура может иметь несколько <code>impl</code>. Например, Приложение 5-15 эквивалентен коду, показанному в приложении 5-16, в котором каждый способ находится в своём собственном разделе <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-16/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 5-16: Переписанный Приложения 5-15 с использованием нескольких <code>impl</code></span></p>
<p>Здесь нет причин разделять способы на несколько <code>impl</code>, но это допустимый синтаксис. Мы увидим случай, когда несколько <code>impl</code> могут оказаться полезными, в Главе 10, рассматривающей обобщённые виды и свойства.</p>
<h2 id="Итоги-3"><a class="header" href="#Итоги-3">Итоги</a></h2>
<p>Структуры позволяют создавать собственные виды, которые имеют смысл в вашей предметной области. Используя структуры, вы храните ассоциированные друг с другом фрагменты данных и даёте название частям данных, чтобы ваш код был более понятным. Способы позволяют определить поведение, которое имеют экземпляры ваших структур, а ассоциированные функции позволяют привязать функциональность к вашей структуре, не обращаясь к её экземпляру.</p>
<p>Но структуры — не единственный способ создавать собственные виды: давайте обратимся к перечислениям в Rust, чтобы добавить ещё один средство в свой арсенал.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Перечисления-и-сопоставление-с-образцом"><a class="header" href="#Перечисления-и-сопоставление-с-образцом">Перечисления и сопоставление с образцом</a></h1>
<p>В этой главе мы рассмотрим <em>перечисления (enumerations)</em>, также называемые <em>enums</em>. Перечисления позволяют определить вид путём перечисления его возможных <em>вариантов</em> . Сначала мы определим и используем перечисление, чтобы показать, как оно может объединить значения и данные. Далее мы рассмотрим особенно полезное перечисление под названием <code>Option</code>, которое выражает, что значение может быть либо чем-то, либо ничем. Затем мы рассмотрим, как сопоставление с образцом в выражении <code>match</code> позволяет легко запускать разный код для разных значений перечисления. Наконец, мы узнаем, насколько конструкция <code>if let</code> удобна и лаконична для обработки перечислений в вашем коде.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Определение-перечисления"><a class="header" href="#Определение-перечисления">Определение перечисления</a></h2>
<p>Там, где структуры дают вам возможность группировать связанные поля и данные, например <code>Rectangle</code> с его <code>width</code> и <code>height</code>, перечисления дают вам способ сказать, что значение является одним из возможных наборов значений. Например, мы можем захотеть сказать, что <code>Rectangle</code> — это одна из множества возможных фигур, в которую также входят <code>Circle</code> и <code>Triangle</code>. Для этого Rust позволяет нам закодировать эти возможности в виде перечисления.</p>
<p>Давайте рассмотрим ситуацию, которую мы могли бы захотеть отразить в коде, и поймём, почему перечисления полезны и более уместны, чем структуры в этом случае. Допустим, нам нужно работать с IP-адресами. В настоящее время для обозначения IP-адресов используются два основных стандарта: четвёртая и шестая исполнения. Поскольку это единственно возможные варианты IP-адресов, с которыми может столкнуться наша программа, мы можем <em>перечислить</em> все возможные варианты, откуда перечисление и получило своё название.</p>
<p>Любой IP-адрес может быть либо четвёртой, либо шестой исполнения, но не обеими одновременно. Эта особенность IP-адресов делает структуру данных enum подходящей, поскольку значение enum может представлять собой только один из его возможных вариантов. Адреса как четвёртой, так и шестой исполнения по своей сути все равно являются IP-адресами, поэтому их следует рассматривать как один и тот же вид, когда в коде обрабатываются задачи, относящиеся к любому виду IP-адресов.</p>
<p>Можно выразить эту концепцию в коде, определив перечисление <code>IpAddrKind</code> и составив список возможных видов IP-адресов, <code>V4</code> и <code>V6</code>. Вот варианты перечислений:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:def}}
<span class="boring">}</span></code></pre></pre>
<p><code>IpAddrKind</code> теперь является пользовательским видом данных, который мы можем использовать в другом месте нашего кода.</p>
<h3 id="Значения-перечислений"><a class="header" href="#Значения-перечислений">Значения перечислений</a></h3>
<p>Экземпляры каждого варианта перечисления <code>IpAddrKind</code> можно создать следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:instance}}
<span class="boring">}</span></code></pre></pre>
<p>Обратите внимание, что варианты перечисления находятся в пространстве имён вместе с его определителем, а для их обособления мы используем двойное двоеточие. Это удобно тем, что теперь оба значения <code>IpAddrKind::V4</code> и <code>IpAddrKind::V6</code> относятся к одному виду: <code>IpAddrKind</code>. Затем мы можем, например, определить функцию, которая принимает любой из вариантов <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn}}
<span class="boring">}</span></code></pre></pre>
<p>Можно вызвать эту функцию с любым из вариантов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn_call}}
<span class="boring">}</span></code></pre></pre>
<p>Использование перечислений позволяет получить ещё больше преимуществ. Если подумать о нашем виде для IP-адреса, то выяснится, что на данный момент у нас нет возможности хранить собственно сам <em>IP-адрес</em>; мы будем знать только его <em>вид</em>. Учитывая, что недавно в главе 5 вы узнали о структурах, у вас может возникнуть соблазн решить эту проблему с помощью структур, как показано в приложении 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-01/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-1. Сохранение данных и <code>IpAddrKind</code> IP-адреса с использованием <code>struct</code></span></p>
<p>Здесь мы определили структуру <code>IpAddr</code>, у которой есть два поля: <code>kind</code> вида <code>IpAddrKind</code> (перечисление, которое мы определили ранее) и <code>address</code> вида <code>String</code>. У нас есть два экземпляра этой структуры. Первый - <code>home</code>, который является <code>IpAddrKind::V4</code> в качестве значения <code>kind</code> с соответствующим адресом <code>127.0.0.1</code>. Второй экземпляр - <code>loopback</code>. Он в качестве значения <code>kind</code> имеет другой вариант <code>IpAddrKind</code>, <code>V6</code>, и с ним ассоциирован адрес <code>::1</code>. Мы использовали структуру для объединения значений <code>kind</code> и <code>address</code> вместе, таким образом вид формата адреса теперь ассоциирован со значением.</p>
<p>Однако представление этой же концепции с помощью перечисления более лаконично: вместо того, чтобы помещать перечисление в структуру, мы можем поместить данные непосредственно в любой из вариантов перечисления. Это новое определение перечисления <code>IpAddr</code> гласит, что оба варианта <code>V4</code> и <code>V6</code> будут иметь соответствующие значения <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-02-enum-with-data/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы прикрепляем данные к каждому варианту перечисления напрямую, поэтому нет необходимости в дополнительной структуре. Здесь также легче увидеть ещё одну подробность того, как работают перечисления: имя каждого варианта перечисления, который мы определяем, также становится функцией, которая создаёт экземпляр перечисления. То есть <code>IpAddr::V4()</code> - это вызов функции, который принимает <code>String</code> и возвращает экземпляр вида <code>IpAddr</code>. Мы самостоятельно получаем эту функцию-конструктор, определяемую в результате определения перечисления.</p>
<p>Ещё одно преимущество использования перечисления вместо структуры заключается в том, что каждый вариант перечисления может иметь разное количество ассоциированных данных представленных в разных видах. Исполнение 4 для IP адресов всегда будет содержать четыре цифровых компонента, которые будут иметь значения между 0 и 255. При необходимости сохранить адреса вида <code>V4</code> как четыре значения вида <code>u8</code>, а также описать адреса вида <code>V6</code> как единственное значение вида  <code>String</code>, мы не смогли бы с помощью структуры. Перечисления решают эту задачу легко:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-03-variants-with-different-data/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы показали несколько различных способов определения структур данных для хранения IP-адресов четвёртой и шестой исполнений. Однако, как оказалось, желание хранить IP-адреса и указывать их вид настолько распространено, что в встроенной библиотеке есть определение, которое мы можем использовать!<!-- ignore --> Давайте посмотрим, как стандартная библиотека определяет <code>IpAddr</code>: в ней есть точно такое же перечисление с вариантами, которое мы определили и использовали, но она помещает данные об адресе внутрь этих вариантов в виде двух различных структур, которые имеют различные определения для каждого из вариантов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код отображает что мы можем добавлять любой вид данных в значение перечисления: строку, число, структуру и пр. Вы даже можете включить в перечисление другие перечисления! Стандартные виды данных не очень сложны, хотя, потенциально, могут быть очень сложными (вложенность данных может быть очень глубокой).</p>
<p>Обратите внимание, что хотя определение перечисления <code>IpAddr</code> есть в встроенной библиотеке, мы смогли объявлять и использовать свою собственную реализацию с подобным названием без каких-либо конфликтов, потому что мы не добавили определение встроенной библиотеки в область видимости кода. Подробнее об этом поговорим в Главе 7.</p>
<p>Рассмотрим другой пример перечисления в приложении 6-2: в этом примере каждый элемент перечисления имеет свой особый вид данных внутри:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-2. Перечисление <code>Message</code>, в каждом из вариантов которого хранятся разные количества и виды значений.</span></p>
<p>Это перечисление имеет 4 элемента:</p>
<ul>
<li><code>Quit</code> - пустой элемент без ассоциированных данных,</li>
<li><code>Move</code> имеет именованные поля, как и структура.</li>
<li><code>Write</code> - элемент с единственной строкой вида <code>String</code>,</li>
<li><code>ChangeColor</code> - кортеж из трёх значений вида <code>i32</code>.</li>
</ul>
<p>Определение перечисления с вариантами, такими как в приложении 6-2, похоже на определение значений различных видов внутри структур, за исключением того, что перечисление не использует ключевое слово <code>struct</code> и все варианты сгруппированы внутри вида <code>Message</code>. Следующие структуры могут содержать те же данные, что и предыдущие варианты перечислений:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-04-structs-similar-to-message-enum/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Но когда мы использовали различные структуры, каждая из которых имеет свои собственные виды, мы не могли легко определять функции, которые принимают любые виды сообщений, как это можно сделать с помощью перечисления вида <code>Message</code>, объявленного в приложении 6-2, который является единым видом.</p>
<p>Есть ещё одно сходство между перечислениями и структурами: так же, как мы можем определять способы для структур с помощью <code>impl</code> раздела, мы можем определять и способы для перечисления. Вот пример способа с именем <code>call</code>, который мы могли бы определить в нашем перечислении <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-05-methods-on-enums/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>В теле способа будет использоваться <code>self</code> для получения значение того объекта, у которого мы вызвали этот способ. В этом примере мы создали переменную <code>m</code>, содержащую значение <code>Message::Write(String::from("hello"))</code>, и именно это значение будет представлять <code>self</code> в теле способа <code>call</code> при выполнении <code>m.call()</code>.</p>
<p>Теперь посмотрим на другое наиболее часто используемое перечисление из встроенной библиотеки, которое является очень распространённым и полезным: <code>Option</code>.</p>
<h3 id="Перечисление-option-и-его-преимущества-перед-null-значениями"><a class="header" href="#Перечисление-option-и-его-преимущества-перед-null-значениями">Перечисление <code>Option</code> и его преимущества перед Null-значениями</a></h3>
<p>В этом разделе рассматривается пример использования <code>Option</code>, ещё одного перечисления, определённого в встроенной библиотеке. Вид <code>Option</code> кодирует очень распространённый сценарий, в котором значение может быть чем-то, а может быть ничем.</p>
<p>Например, если вы запросите первый элемент из непустого списка, вы получите значение. Если вы запросите первый элемент пустого списка, вы ничего не получите. Выражение этой концепции в терминах системы видов означает, что сборщик может проверить, обработали ли вы все случаи, которые должны были обработать; эта функциональность может предотвратить ошибки, которые чрезвычайно распространены в других языках программирования.</p>
<p>Дизайн языка программирования часто рассматривается с точки зрения того, какие функции вы включаете в него, но те функции, которые вы исключаете, также важны. Например в Rust нет такого функционала как null значения, однако он есть во многих других языках. <em>Null значение</em> - это значение, которое означает, что значения нет. В языках с null значением переменные всегда могут находиться в одном из двух состояний: <em>нет значения (null)</em> или <em>есть значение (not-null)</em>.</p>
<p>В своей презентации 2009 года «Null ссылки: ошибка в миллиард долларов» Тони Хоар (Tony Hoare), изобретатель null, сказал следующее:</p>
<blockquote>
<p>Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую комплексную систему видов для ссылок на объектно-ориентированном языке. Моя цель состояла в том, чтобы обеспечить, что любое использование ссылок должно быть абсолютно безопасным, с самостоятельной проверкой сборщиком. Но я не мог устоять перед соблазном вставить пустую ссылку просто потому, что это было так легко реализовать. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, причинили боль и ущерб на миллиард долларов за последние сорок лет.</p>
</blockquote>
<p>Проблема с null значениями заключается в том, что если вы попытаетесь использовать null значение в качестве not-null значения, вы получите ошибку определённого рода. Поскольку свойство null или not-null распространено повсеместно, сделать такую ошибку очень просто.</p>
<p>Тем не менее, концепция, которую null пытается выразить, является полезной: null - это значение, которое в настоящее время по какой-то причине недействительно или отсутствует.</p>
<p>Проблема на самом деле не в концепции, а в именно реализации. Таким образом, в Rust нет значений null, но есть перечисление, которое может закодировать концепцию присутствия или отсутствия значения. Это перечисление <code>Option&lt;T&gt;</code> , и оно <a href="../std/option/enum.Option.html">определено встроенной библиотекой <!-- ignore --> следующим образом:</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Перечисление <code>Option&lt;T&gt;</code> настолько полезно, что оно даже включено в прелюдию; вам не нужно явно вводить его в область видимости. Его варианты также включены в прелюдию: вы можете использовать <code>Some</code> и <code>None</code> напрямую, без префикса <code>Option::</code>. При всём при этом, <code>Option&lt;T&gt;</code> является обычным перечислением, а <code>Some(T)</code> и <code>None</code> представляют собой его варианты.</p>
<p><code>&lt;T&gt;</code> - это особенность Rust, о которой мы ещё не говорили. Это свойство обобщённого вида, и мы рассмотрим его более подробно в главе 10. На данный момент всё, что вам нужно знать, это то, что <code>&lt;T&gt;</code> означает, что вариант <code>Some</code> <code>Option</code> может содержать один фрагмент данных любого вида, и что каждый определенный вид, который используется вместо <code>T</code> делает общий <code>Option&lt;T&gt;</code> другим видом. Вот несколько примеров использования <code>Option</code> для хранения числовых и строковых видов:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Вид <code>some_number</code> - <code>Option&lt;i32&gt;</code>. Вид <code>some_char</code> - <code>Option&lt;char&gt;</code>, это другой вид. Rust может вывести эти виды, потому что мы указали значение внутри варианта <code>Some</code>. Для <code>absent_number</code> Rust требует, чтобы мы аннотировали общий вид для <code>Option</code>: сборщик не может вывести вид, который будет в <code>Some</code>, глядя только на значение <code>None</code>. Здесь мы сообщаем Rust, что <code>absent_number</code> должен иметь вид <code>Option&lt;i32&gt;</code>.</p>
<p>Когда есть значение <code>Some</code>, мы знаем, что значение присутствует и содержится внутри <code>Some</code>. Когда есть значение <code>None</code>, это означает то же самое, что и null в некотором смысле: у нас нет действительного значения. Так почему наличие <code>Option&lt;T&gt;</code> лучше, чем null?</p>
<p>Вкратце, поскольку <code>Option&lt;T&gt;</code> и <code>T</code> (где <code>T</code> может быть любым видом) относятся к разным видам, сборщик не позволит нам использовать значение <code>Option&lt;T&gt;</code> даже если бы оно было определённо допустимым значением. Например, этот код не будет собираться, потому что он пытается добавить <code>i8</code> к значению вида <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here}}</code></pre>
<p>Если мы запустим этот код, то получим такое сообщение об ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}
</code></pre>
<p>Сильно! Фактически, это сообщение об ошибке означает, что Rust не понимает, как сложить <code>i8</code> и <code>Option&lt;i8&gt;</code>, потому что это разные виды. Когда у нас есть значение вида наподобие <code>i8</code>, сборщик заверяет, что у нас всегда есть допустимое значение вида. Мы можем уверенно продолжать работу, не проверяя его на null перед использованием. Однако, когда у нас есть значение вида <code>Option&lt;T&gt;</code> (где <code>T</code> - это любое значение любого вида <code>T</code>, упакованное в <code>Option</code>, например значение вида <code>i8</code> или <code>String</code>), мы должны беспокоиться о том, что <em>значение</em> вида T возможно не имеет значения (является вариантом <code>None</code>), и сборщик позаботится о том, чтобы мы обработали такой случай, прежде чем мы бы попытались использовать <code>None</code> значение.</p>
<p>Другими словами, вы должны преобразовать <code>Option&lt;T&gt;</code> в <code>T</code> прежде чем вы сможете выполнять действия с этим <code>T</code>. Как правило, это помогает выявить одну из наиболее распространённых проблем с null: предполагая, что что-то не равно null, когда оно на самом деле равно null.</p>
<p>Устранение риска ошибочного предположения касательно не-null значения помогает вам быть более уверенным в своём коде. Чтобы иметь значение, которое может быть null, вы должны явно описать вид этого значения с помощью <code>Option&lt;T&gt;</code>. Затем, когда вы используете это значение, вы обязаны явно обрабатывать случай, когда значение равно null. Везде, где значение имеет вид, отличный от <code>Option&lt;T&gt;</code>, вы <em>можете</em> смело рассчитывать на то, что значение не равно null. Это продуманное проектное решение в Rust, ограничивающее распространение null и увеличивающее безопасность кода на Rust.</p>
<p>Итак, как же получить значение <code>T</code> из варианта <code>Some</code>, если у вас на руках есть только объект <code>Option&lt;T&gt;</code>, и как можно его, вообще, использовать? Перечисление <code>Option&lt;T&gt;</code> имеет большое количество способов, полезных в различных ситуациях; вы можете ознакомиться с ними в <a href="../std/option/enum.Option.html">его документации</a><!-- ignore -->. Знакомство с способами перечисления <code>Option&lt;T&gt;</code> будет чрезвычайно полезным в вашем путешествии с Rust.</p>
<p>В общем случае, чтобы использовать значение <code>Option&lt;T&gt;</code>, нужен код, который будет обрабатывать все варианты перечисления <code>Option&lt;T&gt;</code>. Вам понадобится некоторый код, который будет работать только тогда, когда у вас есть значение <code>Some(T)</code>, и этому коду разрешено использовать внутри <code>T</code>. Также вам понадобится другой код, который будет работать, если у вас есть значение <code>None</code>, и у этого кода не будет доступного значения <code>T</code>. Выражение <code>match</code> — это конструкция управления потоком выполнения программы, которая делает именно это при работе с перечислениями: она запускает разный код в зависимости от того, какой вариант перечисления имеется, и этот код может использовать данные, находящиеся внутри совпавшего варианта.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="Управляющая-конструкция-match"><a class="header" href="#Управляющая-конструкция-match">Управляющая конструкция <code>match</code></a></h2>
<p>В Rust есть чрезвычайно мощный механизм управления потоком, именуемый <code>match</code>, который позволяет сравнивать значение с различными шаблонами и затем выполнять код в зависимости от того, какой из шаблонов совпал. Шаблоны могут состоять из литеральных значений, имён переменных, подстановочных знаков и многого другого; в главе 18 рассматриваются все различные виды шаблонов и то, что они делают. Сила <code>match</code> заключается в выразительности шаблонов и в том, что сборщик проверяет, что все возможные случаи обработаны.</p>
<p>Думайте о выражении <code>match</code> как о машине для сортировки монет: монеты скользят по дорожке с различными по размеру отверстиями, и каждая монета падает через первое попавшееся отверстие, в которое она поместилась. Таким же образом значения проходят через каждый шаблон в <code>match</code>, и при первом же "подходящем" шаблоне значение попадает в соответствующий раздел кода, который будет использоваться во время выполнения.</p>
<p>Говоря о монетах, давайте используем их в качестве примера, используя <code>match</code>! Для этого мы напишем функцию, которая будет получать на вход неизвестную монету Соединённых Штатов и, подобно счётной машине, определять, какая это монета, и возвращать её стоимость в центах, как показано в приложении 6-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-3: Перечисление и выражение <code>match</code>, использующее в качестве шаблонов его варианты</span></p>
<p>Давайте разберём <code>match</code> в функции <code>value_in_cents</code>. Сначала пишется ключевое слово <code>match</code>, затем следует выражение, которое в данном случае является значением <code>coin</code>. Это выглядит очень похоже на условное выражение, используемое в <code>if</code>, но есть большая разница: с <code>if</code> выражение должно возвращать <em>булево значение</em>, а здесь это может быть любой вид. Вид <code>coin</code> в этом примере — перечисление вида <code>Coin</code>, объявленное в строке 1.</p>
<p>Далее идут ветки <code>match</code>. Ветки состоят из двух частей: шаблон и некоторый код. Здесь первая ветка имеет шаблон, который является значением <code>Coin::Penny</code>, затем идёт оператор <code>=&gt;</code>, который разделяет шаблон и код для выполнения. Код в этом случае - это просто значение <code>1</code>. Каждая ветка отделяется от последующей при помощи запятой.</p>
<p>Когда выполняется выражение <code>match</code>, оно сравнивает полученное значение с образцом каждого ответвления по порядку. Если образец совпадает со значением, то выполняется код, связанный с этим образцом. Если этот образец не соответствует значению, то выполнение продолжается со следующей ветки, так же, как в автомате по сортировке монет. У нас может быть столько ответвлений, сколько нужно: в приложении 6-3 наш <code>match</code> состоит из четырёх ответвлений.</p>
<p>Код, связанный с каждым ответвлением, является выражением, а полученное значение выражения в соответствующем ответвлении — это значение, которое возвращается для всего выражения <code>match</code>.</p>
<p>Обычно фигурные скобки не используются, если код совпадающей ветви невелик, как в приложении 6-3, где каждая ветвь просто возвращает значение. Если вы хотите выполнить несколько строк кода в одной ветви, вы должны использовать фигурные скобки, а запятая после этой ветви необязательна. Например, следующий код печатает "Lucky penny!" каждый раз, когда способ вызывается с <code>Coin::Penny</code>, но при этом он возвращает последнее значение раздела - <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-08-match-arm-multiple-lines/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<h3 id="Образцы-привязывающие-значения"><a class="header" href="#Образцы-привязывающие-значения">Образцы, привязывающие значения</a></h3>
<p>Есть ещё одно полезное качество у веток в выражении <code>match</code>: они могут привязываться к частям тех значений, которые совпали с шаблоном. Благодаря этому можно извлекать значения из вариантов перечисления.</p>
<p>В качестве примера, давайте изменим один из вариантов перечисления так, чтобы он хранил в себе данные. С 1999 по 2008 год Соединённые Штаты чеканили 25 центов с различным дизайном на одной стороне для каждого из 50 штатов. Ни одна другая монета не получила дизайна штата, только четверть доллара имела эту дополнительную особенность. Мы можем добавить эту сведения в наш <code>enum</code> путём изменения варианта <code>Quarter</code> и включить в него значение <code>UsState</code>, как сделано в приложении 6-4.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-04/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-4: Перечисление <code>Coin</code>, в котором вариант <code>Quarter</code> также сохраняет значение <code>UsState</code></span></p>
<p>Представьте, что ваш друг пытается собрать четвертаки всех 50 штатов. Сортируя монеты по виду, мы также будем сообщать название штата, к которому относится каждый четвертак, чтобы, если у нашего друга нет такой монеты, он мог добавить её в свою собрание.</p>
<p>В выражении match для этого кода мы добавляем переменную с именем <code>state</code> в шаблон, который соответствует значениям варианта <code>Coin::Quarter</code>. Когда <code>Coin::Quarter</code> совпадёт с шаблоном, переменная <code>state</code> будет привязана к значению штата этого четвертака. Затем мы сможем использовать <code>state</code> в коде этой ветки, вот так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-09-variable-in-pattern/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Если мы сделаем вызов функции <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, то <code>coin</code> будет иметь значение <code>Coin::Quarter(UsState::Alaska)</code>. Когда мы будем сравнивать это значение с каждой из веток, ни одна из них не будет совпадать, пока мы не достигнем варианта <code>Coin::Quarter(state)</code>. В этот момент <code>state</code> привяжется к значению <code>UsState::Alaska</code>. Затем мы сможем использовать эту привязку в выражении <code>println!</code>, получив таким образом внутреннее значение варианта <code>Quarter</code> перечисления <code>Coin</code>.</p>
<h3 id="Сопоставление-шаблона-для-optiont"><a class="header" href="#Сопоставление-шаблона-для-optiont">Сопоставление шаблона для <code>Option&lt;T&gt;</code></a></h3>
<p>В предыдущем разделе мы хотели получить внутреннее значение <code>T</code> для случая <code>Some</code> при использовании <code>Option&lt;T&gt;</code>; мы можем обработать вид <code>Option&lt;T&gt;</code> используя <code>match</code>, как уже делали с перечислением <code>Coin</code>! Вместо сравнения монет мы будем сравнивать варианты <code>Option&lt;T&gt;</code>, независимо от этого изменения механизм работы выражения <code>match</code> останется прежним.</p>
<p>Допустим, мы хотим написать функцию, которая принимает <code>Option&lt;i32&gt;</code> и если есть значение внутри, то добавляет 1 к существующему значению. Если значения нет, то функция должна возвращать значение <code>None</code> и не пытаться выполнить какие-либо действия.</p>
<p>Такую функцию довольно легко написать благодаря выражению <code>match</code>, код будет выглядеть как в приложении 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-5: Функция, использующая выражение <code>match</code> для <code>Option&lt;i32&gt;</code></span></p>
<p>Давайте более подробно рассмотрим первое выполнение <code>plus_one</code>. Когда мы вызываем <code>plus_one(five)</code>, переменная <code>x</code> в теле <code>plus_one</code> будет иметь значение <code>Some(5)</code>. Затем мы сравниваем это значение с каждой ветвью сопоставления:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}</code></pre>
<p>Значение <code>Some(5)</code> не соответствует образцу <code>None</code>, поэтому мы продолжаем со следующим ответвлением:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:second_arm}}</code></pre>
<p>Совпадает ли <code>Some(5)</code> с образцом <code>Some(i)</code>? Да, это так! У нас такой же вариант. Тогда переменная <code>i</code> привязывается к значению, содержащемуся внутри <code>Some</code>, поэтому <code>i</code> получает значение <code>5</code>. Затем выполняется код ассоциированный для данного ответвления, поэтому мы добавляем 1 к значению <code>i</code> и создаём новое значение <code>Some</code> со значением <code>6</code> внутри.</p>
<p>Теперь давайте рассмотрим второй вызов <code>plus_one</code> в приложении 6-5, где <code>x</code> является <code>None</code>. Мы входим в выражение <code>match</code> и сравниваем значение с первым ответвлением:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}</code></pre>
<p>Оно совпадает! Для данной ветки шаблон (<em>None</em>) не подразумевает наличие какого-то значения к которому можно было бы что-то добавить, поэтому программа останавливается и возвращает значение которое находится справа от <code>=&gt;</code> - т.е. <code>None</code>. Так как шаблон первой ветки совпал, то никакие другие шаблоны веток не сравниваются.</p>
<p>Комбинирование <code>match</code> и перечислений полезно во многих ситуациях. Вы часто будете видеть подобную сочетание в коде на Rust: сделать сопоставление значений перечисления используя <code>match</code>, привязать переменную к данным внутри значения, выполнить код на основе привязанных данных. Сначала это может показаться немного сложным, но как только вы привыкнете, то захотите чтобы такая возможность была бы во всех языках. Это неизменно любимый пользователями приём.</p>
<h3 id="match-объемлет-все-варианты-значения"><a class="header" href="#match-объемлет-все-варианты-значения">Match объемлет все варианты значения</a></h3>
<p>Есть ещё один особенность <code>match</code>, который мы должны обсудить: шаблоны должны покрывать все возможные варианты. Рассмотрим эту исполнение нашей функции <code>plus_one</code>, которая содержит ошибку и не собирается:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/src/main.rs:here}}</code></pre>
<p>Мы не обработали вариант <code>None</code>, поэтому этот код вызовет изъян в программе. К счастью, Rust знает и умеет ловить такой случай. Если мы попытаемся собрать такой код, мы получим ошибку сборки:</p>
<pre><code class="language-console">{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt}}
</code></pre>
<p>Rust знает, что мы не описали все возможные случаи, и даже знает, какой именно из шаблонов мы упустили! Сопоставления в Rust являются <em>исчерпывающими</em>: мы должны покрыть все возможные варианты, чтобы код был корректным. Особенно в случае <code>Option&lt;T&gt;</code>, когда Rust не даёт нам забыть обработать явным образом значение <code>None</code>, тем самым он защищает нас от предположения, что у нас есть значение, в то время как у нас может быть и null, что делает невозможным совершить ошибку на миллиард долларов, о которой говорилось ранее.</p>
<h3 id="Универсальные-шаблоны-и-заполнитель-_"><a class="header" href="#Универсальные-шаблоны-и-заполнитель-_">Универсальные шаблоны и заполнитель <code>_</code></a></h3>
<p>Используя перечисления, мы также можем выполнять особые действия для нескольких определённых значений, а для всех остальных значений выполнять одно действие по умолчанию. Представьте, что мы реализуем игру, в которой при выпадении 3 игрок не двигается, а получает новую модную шляпу. Если выпадает 7, игрок теряет шляпу. При всех остальных значениях ваш игрок перемещается на столько-то мест на игровом поле. Вот <code>match</code>, реализующий эту логику, в котором результат броска костей жёстко закодирован, а не является случайным значением, а вся остальная логика представлена функциями без тел, поскольку их реализация не входит в рамки данного примера:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-15-binding-catchall/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Для первых двух веток шаблонами являются литеральные значения 3 и 7. Для последней ветки, которая охватывает все остальные возможные значения, шаблоном является переменная, которую мы решили назвать <code>other</code>. Код, выполняемый для ветки <code>other</code>, использует эту переменную, передавая её в функцию <code>move_player</code>.</p>
<p>Этот код собирается, даже если мы не перечислили все возможные значения <code>u8</code>, потому что последний паттерн будет соответствовать всем значениям, не указанным в определенном списке. Этот универсальный шаблон удовлетворяет требованию, что соответствие должно быть исчерпывающим. Обратите внимание, что мы должны поместить ветку с универсальным шаблоном последней, потому что шаблоны оцениваются по порядку. Rust предупредит нас, если мы добавим ветки после универсального шаблона, потому что эти последующие ветки никогда не будут выполняться!</p>
<p>В Rust также есть шаблон, который можно использовать, когда мы не хотим использовать значение в универсальном шаблоне: <code>_</code>, который является особым шаблоном, который соответствует любому значению и не привязывается к этому значению. Это говорит Rust, что мы не собираемся использовать это значение, поэтому Rust не будет предупреждать нас о неиспользуемой переменной.</p>
<p>Давайте изменим правила игры так: если выпадает что-то, кроме 3 или 7, нужно бросить ещё раз. Нам не нужно использовать значение в этом случае, поэтому мы можем изменить наш код, чтобы использовать <code>_</code> вместо переменной с именем <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-16-underscore-catchall/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Этот пример также удовлетворяет требованию исчерпывающей полноты, поскольку мы явно пренебрегаем все остальные значения в последней ветке; мы ничего не забыли.</p>
<p>Если мы изменим правила игры ещё раз, чтобы в ваш ход не происходило ничего другого, если вы бросаете не 3 или 7, мы можем выразить это, используя единичное значение (пустой вид кортежа, о котором мы упоминали в разделе <a href="ch03-02-data-types.html#the-tuple-type">"Кортежи"</a><!-- ignore -->) в качестве кода, который идёт вместе с веткой <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-17-underscore-unit/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы явно говорим Rust, что не собираемся использовать никакое другое значение, которое не соответствует шаблонам в предыдущих ветках, и не хотим запускать никакой код в этом случае.</p>
<p>Подробнее о шаблонах и совпадениях мы поговорим в <a href="ch18-00-patterns.html">Главе 18</a><!-- ignore -->. Пока же мы перейдём к синтаксису <code>if let</code>, который может быть полезен в ситуациях, когда выражение <code>match</code> слишком многословно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Краткое-управление-потоком-выполнения-с-if-let"><a class="header" href="#Краткое-управление-потоком-выполнения-с-if-let">Краткое управление потоком выполнения с <code>if let</code></a></h2>
<p>Синтаксис <code>if let</code> позволяет скомбинировать <code>if</code> и <code>let</code> в менее многословную конструкцию, и затем обработать значения соответствующе только одному шаблону, одновременно пренебрегая все остальные. Рассмотрим программу в приложении 6-6, которая обрабатывает сопоставление значения <code>Option&lt;u8&gt;</code> в переменной <code>config_max</code>, но хочет выполнить код только в том случае, если значение является вариантом <code>Some</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 6-6. Выражение <code>match</code>, которое выполнит код только при значении равном <code>Some</code></span></p>
<p>Если значение равно <code>Some</code>, мы распечатываем значение в варианте <code>Some</code>, привязывая значение к переменной <code>max</code> в шаблоне. Мы не хотим ничего делать со значением <code>None</code>. Чтобы удовлетворить выражение <code>match</code>, мы должны добавить <code>_ =&gt; ()</code> после обработки первой и единственной ветки, и добавление шаблонного кода раздражает.</p>
<p>Вместо этого, мы могли бы написать это более коротким способом, используя <code>if let</code>. Следующий код ведёт себя так же, как выражение <code>match</code> в приложении 6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Синтаксис <code>if let</code> принимает шаблон и выражение, разделённые знаком равенства. Он работает так же, как <code>match</code>, когда в него на вход передадут выражение и подходящим шаблоном для этого выражения окажется первая ветка. В данном случае шаблоном является <code>Some(max)</code>, где <code>max</code> привязывается к значению внутри <code>Some</code>. Затем мы можем использовать <code>max</code> в теле раздела <code>if let</code> так же, как мы использовали <code>max</code> в соответствующей ветке <code>match</code>. Код в разделе <code>if let</code> не запускается, если значение не соответствует шаблону.</p>
<p>Используя <code>if let</code> мы меньше печатаем, меньше делаем отступов и меньше получаем шаблонного кода. Тем не менее, мы теряем полную проверку всех вариантов, предоставляемую выражением <code>match</code>. Выбор между <code>match</code> и <code>if let</code> зависит от того, что вы делаете в вашем определенном случае и является ли получение краткости при потере полноты проверки подходящим соглашением.</p>
<p>Другими словами, вы можете думать о конструкции <code>if let</code> как о <em>синтаксическом сахаре</em> для <code>match</code>, который выполнит код если входное значение будет соответствовать единственному шаблону, и пропренебрегает все остальные значения.</p>
<p>Можно добавлять <code>else</code> к <code>if let</code>. Разделкода, который находится внутри <code>else</code> подобен по смыслу блоку кода ветки связанной с шаблоном <code>_</code> выражения <code>match</code> (которое эквивалентно сборной конструкции <code>if let</code> и <code>else</code>). Вспомним объявление перечисления <code>Coin</code> в приложении 6-4, где вариант <code>Quarter</code> также содержит внутри значение штата вида <code>UsState</code>. Если бы мы хотели посчитать все монеты не являющиеся четвертями, а для четвертей печатать название штата, то мы могли бы сделать это с помощью выражения <code>match</code> таким образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Или мы могли бы использовать выражение <code>if let</code> и <code>else</code> так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Если у вас есть ситуация в которой ваша программа имеет логику которая слишком многословна для того чтобы её выражать используя <code>match</code>, помните, о том, что также в вашем наборе средств Rust есть <code>if let</code>.</p>
<h2 id="Итоги-4"><a class="header" href="#Итоги-4">Итоги</a></h2>
<p>Мы рассмотрели как использовать перечисления для создания пользовательских видов, которые могут быть одним из наборов перечисляемых значений. Мы показали, как вид <code>Option&lt;T&gt;</code> из встроенной библиотеки помогает использовать систему видов для предотвращения ошибок. А когда значения перечисления имеют данные внутри них, можно использовать <code>match</code> или <code>if let</code>, чтобы извлечь и пользоваться значением, в зависимости от того, сколько случаев нужно обработать.</p>
<p>Теперь ваши программы на Rust могут выражать концепции вашей предметной области, используя структуры и перечисления. Создание и использование пользовательских видов в API обеспечивает <em>типобезопасность</em>: сборщик позаботится о том, чтобы функции получали значения только того вида, который они ожидают.</p>
<p>Чтобы предоставить вашим пользователям хорошо организованный API, который прост в использовании и предоставляет только то, что нужно вашим пользователям, надо поговорить о модулях в Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Управление-растущими-проектами-с-помощью-пакетов-крейтов-и-модулей"><a class="header" href="#Управление-растущими-проектами-с-помощью-пакетов-крейтов-и-модулей">Управление растущими проектами с помощью пакетов, крейтов и модулей</a></h1>
<p>По мере роста кодовой хранилища ваших программ, организация проекта будет иметь большое значение, ведь отслеживание всей программы в голове будет становиться всё более сложным.  Группируя связанные функции и разделяя код по основным функциональностям <em>(фичам, feature)</em>, вы делаете более прозрачным понимание о том, где искать код реализующий определённую функцию и где стоит вносить изменения для того чтобы изменить её поведение.</p>
<p>Программы, которые мы писали до сих пор, были в одном файле одного модуля. По мере роста проекта, мы можем организовывать код иначе, разделив его на несколько модулей и несколько файлов. Пакет может содержать несколько двоичных крейтов и опционально один крейт библиотеки. Пакет может включать в себя много двоичных крейтов и опционально один библиотечный крейт. По мере роста пакета вы можете извлекать части программы в отдельные крейты, которые затем станут внешними зависимостями для основного кода нашей программы. Эта глава охватывает все эти техники. В свою очередь для очень крупных проектов, состоящих из набора взаимосвязанных пакетов развивающихся вместе, Cargo предоставляет рабочие пространства, <em>workspaces</em>, их мы рассмотрим за пределами данной главы, в разделе <a href="ch14-03-cargo-workspaces.html">"Рабочие пространства Cargo"</a> Главы 14.</p>
<p>Мы также обсудим инкапсуляцию подробностей, которая позволяет использовать код снова на более высоком уровне: единожды реализовав какую-то действие, другой код может вызывать этот код через публичный внешняя оболочка, не зная как работает реализация. То, как вы пишете код, определяет какие части общедоступны для использования другим кодом и какие части являются закрытыми деталями реализации для которых вы оставляете право на изменения только за собой. Это ещё один способ ограничить количество подробностей, которые вы должны держать в голове.</p>
<p>Связанное понятие - это область видимости: вложенный среда в котором написан код имеющий набор имён, которые определены «в текущей области видимости». При чтении, письме и сборки кода, программистам и сборщикам необходимо знать, относится ли определенное имя в определённом месте к переменной, к функции, к структуре, к перечислению, к модулю, к константе или другому элементу и что означает этот элемент. Можно создавать области видимости и изменять какие имена входят или выходят за их рамки. Нельзя иметь два элемента с тем же именем в одной области; есть доступные средства для разрешения конфликтов имён.</p>
<p>Rust имеет ряд функций, которые позволяют управлять организацией кода, в том числе управлять тем какие подробности открыты, какие подробности являются частными, какие имена есть в каждой области вашей программы. Эти функции иногда вместе именуемые <em>модульной системой</em> включают в себя:</p>
<ul>
<li><strong>Пакеты:</strong> Функционал Cargo позволяющий собирать, тестировать и делиться крейтами</li>
<li><strong>Крейты:</strong> Дерево модулей, которое создаёт библиотечный или исполняемый файл</li>
<li><strong>Модули</strong> и <strong>use:</strong> Позволяют вместе управлять организацию, область видимости и скрытие путей</li>
<li><strong>Пути:</strong> способ именования элемента, такого как структура, функция или модуль</li>
</ul>
<p>В этой главе мы рассмотрим все эти функции, обсудим как они взаимодействуют и объясним, как использовать их для управления областью видимости. К концу у вас должно появиться солидное понимание модульной системы и умение работать с областями видимости на уровне профессионала!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Пакеты-и-крейты"><a class="header" href="#Пакеты-и-крейты">Пакеты и крейты</a></h2>
<p>Первые части модульной системы, которые мы рассмотрим — это пакеты и крейты.</p>
<p><em>Крейт</em> — это наименьший объем кода, который сборщик Rust рассматривает за раз. Даже если вы запустите <code>rustc</code> вместо <code>cargo</code> и передадите один файл с исходным кодом (как мы уже делали в разделе «Написание и запуск программы на Rust» Главы 1), сборщик считает этот файл крейтом. Крейты могут содержать модули, и модули могут быть определены в других файлах, которые собираются вместе с крейтом, как мы увидим в следующих разделах.</p>
<p>Крейт может быть одним из двух видов: двоичный крейт или библиотечный крейт. <em>Бинарные крейты</em> — это программы, которые вы можете собрать в исполняемые файлы, которые вы можете запускать, например программу приказной строки или сервер. У каждого двоичного крейта должна быть функция с именем <code>main</code>, которая определяет, что происходит при запуске исполняемого файла. Все крейты, которые мы создали до сих пор, были двоичными крейтами.</p>
<p><em>Библиотечные крейты</em> не имеют функции <code>main</code> и не собираются в исполняемый файл. Вместо этого они определяют функциональность, предназначенную для совместного использования другими проектами. Например, крейт <code>rand</code>, который мы использовали в <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">Главе 2</a><!-- ignore --> обеспечивает функциональность, которая генерирует случайные числа. В большинстве случаев, когда Rustaceans говорят «крейт», они имеют в виду библиотечный крейт, и они используют «крейт» взаимозаменяемо с общей концепцией программирования «библиотека».</p>
<p><em>Корневой модуль крейта</em> — это исходный файл, из которого сборщик Rust начинает собирать корневой модуль вашего крейта (мы подробно объясним модули в разделе <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">«Определение модулей для управления видимости и закрытости»</a><!-- ignore -->).</p>
<p><em>Пакет</em> — это набор из одного или нескольких крейтов, предоставляющий набор функциональности. Пакет содержит файл <em>Cargo.toml</em>, в котором описывается, как собирать эти крейты. На самом деле Cargo — это пакет, содержащий двоичный крейт для средства приказной строки, который вы использовали для создания своего кода. Пакет Cargo также содержит библиотечный крейт, от которого зависит двоичный крейт. Другие проекты тоже могут зависеть от библиотечного крейта Cargo, чтобы использовать ту же логику, что и средство приказной строки Cargo.</p>
<p>Пакет может содержать сколько угодно двоичных крейтов, но не более одного библиотечного крейта. Пакет должен содержать хотя бы один крейт, библиотечный или двоичный.</p>
<p>Давайте пройдёмся по тому, что происходит, когда мы создаём пакет. Сначала введём приказ <code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>После того, как мы запустили <code>cargo new</code>, мы используем <code>ls</code>, чтобы увидеть, что создал Cargo. В каталоге проекта есть файл <em>Cargo.toml</em>, дающий нам пакет. Также есть каталог <em>src</em>, содержащий <em>main.rs</em>. Откройте <em>Cargo.toml</em> в текстовом редакторе и обратите внимание, что в нём нет упоминаний о <em>src/main.rs</em>. Cargo следует соглашению о том, что <em>src/main.rs</em> — это корневой модуль двоичного крейта с тем же именем, что и у пакета. Точно так же Cargo знает, что если каталог пакета содержит <em>src/lib.rs</em>, пакет содержит библиотечный крейт с тем же именем, что и пакет, а <em>src/lib.rs</em> является корневым модулем этого крейта. Cargo передаёт файлы корневого модуля крейта в <code>rustc</code> для сборки библиотечного или двоичного крейта.</p>
<p>Здесь у нас есть пакет, который содержит только <em>src/main.rs</em>, что означает, что он содержит только двоичный крейт с именем <code>my-project</code>. Если пакет содержит <em>src/main.rs</em> и <em>src/lib.rs</em>, он имеет два крейта: двоичный и библиотечный, оба с тем же именем, что и пакет. Пакет может иметь несколько двоичных крейтов, помещая их файлы в каталог <em>src/bin</em>: каждый файл будет отдельным двоичным крейтом.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Определение-модулей-для-управления-видимости-и-закрытости"><a class="header" href="#Определение-модулей-для-управления-видимости-и-закрытости">Определение модулей для управления видимости и закрытости</a></h2>
<p>В этом разделе мы поговорим о модулях и других частях системы модулей, а именно: <em>путях</em> (paths), которые позволяют именовать элементы; ключевом слове <code>use</code>, которое приносит путь в область видимости; ключевом слове <code>pub</code>, которое делает элементы общедоступными. Мы также обсудим ключевое слово <code>as</code>, внешние пакеты и оператор glob. А пока давайте сосредоточимся на модулях!</p>
<p>Во-первых, мы начнём со списка правил, чтобы вам было легче ориентироваться при организации кода в будущем. Затем мы подробно объясним каждое из правил.</p>
<h3 id="Шпаргалка-по-модулям"><a class="header" href="#Шпаргалка-по-модулям">Шпаргалка по модулям</a></h3>
<p>Здесь мы даём краткий обзор того, как модули, пути, ключевое слово <code>use</code> и ключевое слово <code>pub</code> работают в сборщике и как большинство разработчиков организуют свой код. В этой главе мы рассмотрим примеры каждого из этих правил, и это удобный момент чтобы напомнить о том, как работают модули.</p>
<ul>
<li><strong>Начнём с корня крейта</strong>: при сборки сборщик сначала ищет корневой модуль крейта (обычно это <em>src/lib.rs</em> для библиотечного крейта или <em>src/main.rs</em> для двоичного крейта) для сборки кода.</li>
<li><strong>Объявление модулей</strong>: В файле корневого модуля крейта вы можете объявить новые модули; скажем, вы объявляете модуль “garden” с помощью <code>mod garden;</code>. Сборщик будет искать код модуля в следующих местах:
<ul>
<li>в этом же файле, между фигурных скобок, которые заменяют точку с запятой после <code>mod garden</code></li>
<li>в файле <em>src/garden.rs</em></li>
<li>в файле <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Объявление подмодулей</strong>: В любом файле, кроме корневого модуля крейта, вы можете объявить подмодули. К примеру, вы можете объявить  <code>mod vegetables;</code> в <em>src/garden.rs</em>. Сборщик будет искать код подмодуля в каталоге с именем родительского модуля в следующих местах:
<ul>
<li>в этом же файле, сразу после <code>mod vegetables</code>, между фигурных скобок, которые заменяют точку с запятой</li>
<li>в файле <em>src/garden/vegetables.rs</em></li>
<li>в файле <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Пути к коду в модулях</strong>: После того, как модуль станет частью вашего крейта и если допускают правила приватности, вы можете ссылаться на код в этом модуле из любого места вашего крейта, используя путь к коду. Например, вид <code>Asparagus</code>, в подмодуле vegetables модуля garden, будет найден по пути <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>Скрытие или общедоступность</strong>: Код в модуле по умолчанию скрыт от родительского модуля. Чтобы сделать модуль общедоступным, объявите его как <code>pub mod</code> вместо <code>mod</code>. Чтобы сделать элементы общедоступного модуля тоже общедоступными, используйте <code>pub</code> перед их объявлением.</li>
<li><strong>Ключевое слово <code>use</code></strong>: Внутри области видимости использование ключевого слова <code>use</code> создаёт псевдонимы для элементов, чтобы уменьшить повторение длинных путей. В любой области видимости, в которой может обращаться к <code>crate::garden::vegetables::Asparagus</code>, вы можете создать псевдоним <code>use crate::garden::vegetables::Asparagus;</code> и после этого вам нужно просто писать <code>Asparagus</code>, чтобы использовать этот вид в этой области видимости.</li>
</ul>
<p>Мы создали двоичный крейт <code>backyard</code>, который отображает эти правила. Директория крейта, также названная как <code>backyard</code>, содержит следующие файлы и папки:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>Файл корневого модуля крейта в нашем случае  <em>src/main.rs</em>, и его содержимое:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/main.rs}}</code></pre>
<p>Строка <code>pub mod garden;</code> говорит сборщику о подключении кода, найденном в <em>src/garden.rs</em>:</p>
<p><span class="filename">Файл: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden.rs}}</code></pre>
<p>А здесь <code>pub mod vegetables;</code> указывает на подключаемый код в <em>src/garden/vegetables.rs</em>. Этот код:</p>
<pre><code class="language-rust noplayground ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden/vegetables.rs}}</code></pre>
<p>Теперь давайте рассмотрим подробности этих правил и отобразим их в действии!</p>
<h3 id="Группировка-связанного-кода-в-модулях"><a class="header" href="#Группировка-связанного-кода-в-модулях">Группировка связанного кода в модулях</a></h3>
<p><em>Модули</em> позволяют упорядочивать код внутри крейта для удобочитаемости и лёгкого повторного использования. Модули также позволяют нам управлять <em>приватностью</em> элементов, поскольку код внутри модуля по умолчанию является закрытым. Частные элементы — это внутренние подробности реализации, недоступные для внешнего использования. Мы можем сделать модули и элементы внутри них общедоступными, что позволит внешнему коду использовать их и зависеть от них.</p>
<p>В качестве примера, давайте напишем библиотечный крейт предоставляющий функциональность ресторана. Мы определим сигнатуры функций, но оставим их тела пустыми, чтобы сосредоточиться на организации кода, вместо реализации кода для ресторана.</p>
<p>В ресторанной индустрии некоторые части ресторана называются <em>фронтом дома</em>, а другие <em>задней частью дома</em>. Фронт дома это там где находятся клиенты; здесь размещаются места клиентов, официанты принимают заказы и оплаты, а бармены делают напитки. Задняя часть дома это где шеф-повара и повара работают на кухне,  работают посудомоечные машины, а менеджеры занимаются административной деятельностью.</p>
<p>Чтобы структурировать крейт подобно тому, как работает настоящий ресторан, можно организовать размещение функций во вложенных модулях. Создадим новую библиотеку (библиотечный крейт) с именем <code>restaurant</code> выполнив приказ <code>cargo new restaurant --lib</code>; затем вставим код из приложения 7-1 в <em>src/lib.rs</em> для определения некоторых модулей и сигнатур функций. Это секция фронта дома:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-01/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-1: Модуль <code>front_of_house</code> , содержащий другие модули, которые в свою очередь содержат функции</span></p>
<p>Мы определяем модуль, начиная с ключевого слова  <code>mod</code>, затем определяем название модуля (в данном случае <code>front_of_house</code>) и размещаем фигурные скобки вокруг тела модуля. Внутри модулей, можно иметь другие модули, как в случае с модулями <code>hosting</code> и <code>serving</code>. Модули также могут содержать определения для других элементов, таких как структуры, перечисления, константы, типажи или — как в приложении 7-1 — функции.</p>
<p>Используя модули, мы можем сгруппировать связанные определения вместе и сказать почему они являются связанными. Программистам будет легче найти необходимую функциональность в сгруппированном коде, вместо того чтобы искать её в одном общем списке. Программисты, добавляющие новые функции в этот код, будут знать, где разместить код для поддержания порядка в программе.</p>
<p>Как мы упоминали ранее, файлы <em>src/main.rs</em> и <em>src/lib.rs</em> называются <em>корневыми модулями крейта</em>. Причина такого именования в том, что содержимое любого из этих двух файлов образует модуль с именем <code>crate</code> в корне структуры модулей крейта, известной как <em>дерево модулей</em>.</p>
<p>В приложении 7-2 показано дерево модулей для структуры модулей, приведённой в коде приложения 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Приложение 7-2: Древо модулей для программы из Приложения 7-1</span></p>
<p>Это дерево показывает, как некоторые из модулей вкладываются друг в друга; например, <code>hosting</code> находится внутри <code>front_of_house</code>. Дерево также показывает, что некоторые модули являются  <em>братьями</em> (siblings) друг для друга, то есть они определены в одном модуле; <code>hosting</code> и <code>serving</code> это братья которые определены внутри <code>front_of_house</code>. Если модуль A содержится внутри модуля B, мы говорим, что модуль A является <em>потомком</em> (child) модуля B, а модуль B является <em>родителем</em> (parent) модуля A. Обратите внимание, что родителем всего дерева модулей является неявный модуль с именем <code>crate</code>.</p>
<p>Дерево модулей может напомнить вам дерево каталогов файловой системы на компьютере; это очень удачное сравнение! По подобию с каталогами в файловой системе, мы используется модули для организации кода. И так же, как нам надо искать файлы в каталогах на компьютере, нам требуется способ поиска нужных модулей.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Пути-для-ссылки-на-элемент-в-дереве-модулей"><a class="header" href="#Пути-для-ссылки-на-элемент-в-дереве-модулей">Пути для ссылки на элемент в дереве модулей</a></h2>
<p>Чтобы показать Rust, где найти элемент в дереве модулей, мы используем путь так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать её путь.</p>
<p>Пути бывают двух видов:</p>
<ul>
<li><em>абсолютный путь</em> - это полный путь, начинающийся от корневого модуля крейта; для кода из внешнего крейта абсолютный путь начинается с имени крейта, а для кода из текущего крейта он начинается с литерала <code>crate</code>.</li>
<li><em>относительный путь</em> начинается с текущего модуля и использует ключевые слова <code>self</code>, <code>super</code> или определитель в текущем модуле.</li>
</ul>
<p>Как абсолютные, так и относительные, пути состоят из одного или нескольких определителей, разделённых двойными двоеточиями (<code>::</code>).</p>
<p>Вернёмся к приложению 7-1, скажем, мы хотим вызвать функцию <code>add_to_waitlist</code>. Это то же самое, что спросить: какой путь у функции <code>add_to_waitlist</code>? В приложении 7-3 мы немного упростили код приложения 7-1, удалив некоторые модули и функции.</p>
<p>Мы покажем два способа вызова функции <code>add_to_waitlist</code> из новой функции <code>eat_at_restaurant</code>, определённой в корневом модуле крейта. Эти пути правильные, но остаётся ещё одна проблема, которая не позволит этому примеру собраться как есть. Мы скоро объясним почему.</p>
<p>Функция <code>eat_at_restaurant</code> является частью общедоступного API нашего библиотечного крейта, поэтому мы помечаем её ключевым словом <code>pub</code>. В разделе <a data-md-type="raw_html" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Раскрываем приватные пути с помощью ключевого слова <code>pub</code>"</a><!-- ignore --> мы рассмотрим более подробно <code>pub</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-3. Вызов функции <code>add_to_waitlist</code> с использованием абсолютного и относительного пути</span></p>
<p>При первом вызове функции <code>add_to_waitlist</code> из <code>eat_at_restaurant</code> мы используем абсолютный путь. Функция <code>add_to_waitlist</code> определена в том же крейте, что и <code>eat_at_restaurant</code>, и это означает, что мы можем использовать ключевое слово <code>crate</code> в начале абсолютного пути. Затем мы добавляем каждый из последующих дочерних модулей, пока не составим путь до <code>add_to_waitlist</code>. Вы можете представить себе файловую систему с такой же структурой: мы указываем путь <code>/front_of_house/hosting/add_to_waitlist</code> для запуска программы <code>add_to_waitlist</code>; использование имени <code>crate</code> в качестве корневого модуля крейта подобно использованию <code>/</code> для указания корня файловой системы в вашей оболочке.</p>
<p>Второй раз, когда мы вызываем <code>add_to_waitlist</code> из <code>eat_at_restaurant</code>, мы используем относительный путь. Путь начинается с имени модуля <code>front_of_house</code>, определённого на том же уровне дерева модулей, что и <code>eat_at_restaurant</code>. Для эквивалентной файловой системы использовался бы путь <code>front_of_house/hosting/add_to_waitlist</code>. Начало пути с имени модуля означает, что путь является относительным.</p>
<p>Выбор, использовать относительный или абсолютный путь, является решением, которое вы примете на основании вашего проекта. Решение должно зависеть от того, с какой вероятностью вы переместите объявление элемента отдельно от или вместе с кодом использующим этот элемент. Например, в случае перемещения модуля <code>front_of_house</code> и его функции <code>eat_at_restaurant</code> в другой модуль с именем <code>customer_experience</code>, будет необходимо обновить абсолютный путь до <code>add_to_waitlist</code>, но относительный путь всё равно будет действителен. Однако, если мы переместим отдельно функцию <code>eat_at_restaurant</code> в модуль с именем <code>dining</code>, то абсолютный путь вызова <code>add_to_waitlist</code> останется прежним, а относительный путь нужно будет обновить. Мы предпочитаем указывать абсолютные пути, потому что это позволяет проще перемещать определения кода и вызовы элементов независимо друг от друга.</p>
<p>Давайте попробуем собрать код из приложения 7-3 и выяснить, почему он ещё не собирается. Ошибка, которую мы получаем, показана в приложении 7-4.</p>
<pre><code class="language-console">{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
</code></pre>
<p><span class="caption">Приложение 7-4. Ошибки сборки при сборке кода из приложения 7-3</span></p>
<p>Сообщения об ошибках говорят о том, что модуль <code>hosting</code> является приватным. Другими словами, у нас есть правильные пути к модулю <code>hosting</code> и функции <code>add_to_waitlist</code>, но Rust не позволяет нам использовать их, потому что у него нет доступа к приватным разделам. В Rust все элементы (функции, способы, структуры, перечисления, модули и константы) по умолчанию являются приватными для родительских модулей. Если вы хотите сделать элемент, например функцию или структуру, приватным, вы помещаете его в модуль.</p>
<p>Элементы в родительском модуле не могут использовать приватные элементы внутри дочерних модулей, но элементы в дочерних модулях могут использовать элементы у своих модулях-предках. Это связано с тем, что дочерние модули оборачивают и скрывают подробности своей реализации, но дочерние модули могут видеть среда, в котором они определены. Продолжая нашу метафору, подумайте о правилах приватности как о задней части ресторана: то, что там происходит, скрыто от клиентов ресторана, но офис-менеджеры могут видеть и делать всё в ресторане, которым они управляют.</p>
<p>В Rust решили, что система модулей должна функционировать таким образом, чтобы по умолчанию скрывать подробности реализации. Таким образом, вы знаете, какие части внутреннего кода вы можете изменять не нарушая работы внешнего кода. Тем не менее, Rust даёт нам возможность открывать внутренние части кода дочерних модулей для внешних модулей-предков, используя ключевое слово <code>pub</code>, чтобы сделать элемент общедоступным.</p>
<h3 id="Раскрываем-приватные-пути-с-помощью-ключевого-слова-pub"><a class="header" href="#Раскрываем-приватные-пути-с-помощью-ключевого-слова-pub">Раскрываем приватные пути с помощью ключевого слова <code>pub</code><a id="exposing-paths-with-the-pub-keyword"></a></a></h3>
<p>Давайте вернёмся к ошибке в приложении 7-4, которая говорит, что модуль <code>hosting</code> является приватным. Мы хотим, чтобы функция <code>eat_at_restaurant</code> из родительского модуля имела доступ к функции <code>add_to_waitlist</code> в дочернем модуле, поэтому мы помечаем модуль <code>hosting</code> ключевым словом <code>pub</code>, как показано в приложении 7-5.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-5. Объявление модуля <code>hosting</code> как <code>pub</code> для его использования из <code>eat_at_restaurant</code></span></p>
<p>К сожалению, код в приложении 7-5 всё ещё приводит к ошибке, как показано в приложении 7-6.</p>
<pre><code class="language-console">{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
</code></pre>
<p><span class="caption">Приложение 7-6: Ошибки сборки при сборке кода в приложении 7-5</span></p>
<p>Что произошло? Добавление ключевого слова <code>pub</code> перед <code>mod hosting</code> сделало модуль общедоступным. После этого изменения, если мы можем получить доступ к модулю <code>front_of_house</code>, то мы можем получить доступ к модулю <code>hosting</code>. Но <em>содержимое</em> модуля <code>hosting</code> всё ещё является приватным: превращение модуля в общедоступный модуль не делает его содержимое общедоступным. Ключевое слово <code>pub</code> позволяет внешнему коду в модулях-предках обращаться только к модулю, без доступа ко внутреннему коду. Поскольку модули являются дополнениями, мы мало что можем сделать, просто сделав модуль общедоступным; нам нужно пойти дальше и сделать один или несколько элементов в модуле общедоступными.</p>
<p>Ошибки в приложении 7-6 говорят, что функция <code>add_to_waitlist</code> является приватной. Правила приватности применяются к структурам, перечислениям, функциям и способам, также как и к модулям.</p>
<p>Давайте также сделаем функцию <code>add_to_waitlist</code> общедоступной, добавив ключевое слово <code>pub</code> перед её определением, как показано в приложении 7-7.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-7. Добавление ключевого слова <code>pub</code> к <code>mod hosting</code> и к <code>fn add_to_waitlist</code> позволяет нам вызывать функцию из <code>eat_at_restaurant</code></span></p>
<p>Теперь код собирается! Чтобы понять, почему добавление ключевого слова <code>pub</code> позволяет нам использовать эти пути для <code>add_to_waitlist</code> в соответствии с правилами приватности, давайте рассмотрим абсолютный и относительный пути.</p>
<p>В случае абсолютного пути мы начинаем с <code>crate</code>, корня дерева модулей нашего крейта. Модуль <code>front_of_house</code> определён в корневом модуле крейта. Хотя <code>front_of_house</code> не является общедоступным, но поскольку функция <code>eat_at_restaurant</code> определена в том же модуле, что и <code>front_of_house</code> (то есть, <code>eat_at_restaurant</code> и <code>front_of_house</code> являются потомками одного родителя), мы можем ссылаться на <code>front_of_house</code> из <code>eat_at_restaurant</code>. Далее идёт модуль <code>hosting</code>, помеченный как <code>pub</code>. Мы можем получить доступ к родительскому модулю модуля <code>hosting</code>, поэтому мы можем получить доступ и к <code>hosting</code>. Наконец, функция <code>add_to_waitlist</code> помечена как <code>pub</code>, и так как мы можем получить доступ к её родительскому модулю, то вызов этой функции разрешён!</p>
<p>В случае относительного пути логика такая же как для абсолютного пути, за исключением первого шага: вместо того, чтобы начинать с корневого модуля крейта, путь начинается с <code>front_of_house</code>. Модуль <code>front_of_house</code> определён в том же модуле, что и <code>eat_at_restaurant</code>, поэтому относительный путь, начинающийся с модуля, в котором определена <code>eat_at_restaurant</code> тоже работает. Тогда, по причине того, что <code>hosting</code> и <code>add_to_waitlist</code> помечены как <code>pub</code>, остальная часть пути работает и вызов этой функции разрешён!</p>
<p>Если вы планируете предоставить общий доступ к своему библиотечному крейту, чтобы другие проекты могли использовать ваш код, ваш общедоступный API — это ваш контракт с пользователями вашего крейта, определяющий, как они могут взаимодействовать с вашим кодом. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать необременительным для людей зависимость от вашего крейта. Эти соображения выходят за рамки этой книги; если вам важна эта тема, см. <a href="https://rust-lang.github.io/api-guidelines/">The Rust API Guidelines</a>.</p>
<blockquote>
<h4 id="Лучшие-практики-для-пакетов-с-двоичным-и-библиотечным-крейтами"><a class="header" href="#Лучшие-практики-для-пакетов-с-двоичным-и-библиотечным-крейтами">Лучшие практики для пакетов с двоичным и библиотечным крейтами</a></h4>
<p>Мы упоминали, что пакет может содержать как корневой модуль двоичного крейта <em>src/main.rs</em>, так и корневой модуль библиотечного крейта <em>src/lib.rs</em>, и оба крейта будут по умолчанию иметь имя пакета. Как правило, пакеты с таким шаблоном, содержащим как библиотечный, так и двоичный крейт, будут иметь достаточно кода в двоичном крейте, чтобы запустить исполняемый файл, который вызывает код из библиотечного крейта. Это позволяет другим проектам извлечь выгоду из большей части функциональности, предоставляемой пакетом, поскольку код библиотечного крейта можно использовать совместно.</p>
<p>Дерево модулей должно быть определено в <em>src/lib.rs</em>. Затем любые общедоступные элементы можно использовать в двоичном крейте, начав пути с имени пакета. Двоичный крейт становится пользователем библиотечного крейта точно так же, как полностью внешний крейт использует библиотечный крейт: он может использовать только общедоступный API. Это поможет вам разработать хороший API; вы не только автор, но и пользователь!</p>
<p>В <a href="ch12-00-an-io-project.html">Главе 12</a><!-- ignore --> мы эту практику организации кода с помощью окно выводаной программы, которая будет содержать как двоичный, так и библиотечный крейты.</p>
</blockquote>
<h3 id="Начинаем-относительный-путь-с-помощью-super"><a class="header" href="#Начинаем-относительный-путь-с-помощью-super">Начинаем относительный путь с помощью <code>super</code></a></h3>
<p>Также можно построить относительные пути, которые начинаются в родительском модуле, используя ключевое слово <code>super</code> в начале пути. Это похоже на синтаксис начала пути файловой системы <code>..</code>. Использование <code>super</code> позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском модуле, что может упростить переупорядочение дерева модулей, чем когда модуль тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве модулей.</p>
<p>Рассмотрим код в приложении 7-8, где моделируется ситуация, в которой повар исправляет неправильный заказ и лично приносит его клиенту. Функция <code>fix_incorrect_order</code> вызывает функцию <code>deliver_order</code>, определённую в родительском модуле, указывая путь к <code>deliver_order</code>, начинающийся с <code>super</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-8: Вызов функции с использованием относительного пути, начинающегося с <code>super</code></span></p>
<p>Функция <code>fix_incorrect_order</code> находится в модуле <code>back_of_house</code>, поэтому мы можем использовать <code>super</code> для перехода к родительскому модулю модуля <code>back_of_house</code>, который в этом случае является <code>crate</code>, корневым модулем. В этом модуле мы ищем <code>deliver_order</code> и находим его. Успех! Мы думаем, что модуль <code>back_of_house</code> и функция <code>deliver_order</code>, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут перемещены вместе, если мы решим реорганизовать дерево модулей крейта. Поэтому мы использовали <code>super</code>, чтобы в будущем у нас было меньше мест для обновления кода, если этот код будет перемещён в другой модуль.</p>
<h3 id="Делаем-общедоступными-структуры-и-перечисления"><a class="header" href="#Делаем-общедоступными-структуры-и-перечисления">Делаем общедоступными структуры и перечисления</a></h3>
<p>Мы также можем использовать <code>pub</code> для обозначения структур и перечислений как общедоступных, но есть несколько дополнительных подробностей использования <code>pub</code> со структурами и перечислениями. Если мы используем <code>pub</code> перед определением структуры, мы делаем структуру общедоступной, но поля структуры по-прежнему остаются приватными. Мы можем сделать каждое поле общедоступным или нет в каждом определенном случае. В приложении 7-9 мы определили общедоступную структуру <code>back_of_house::Breakfast</code> с общедоступным полем <code>toast</code> и с приватным полем <code>seasonal_fruit</code>. Это моделирует случай в ресторане, когда клиент может выбрать вид хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому клиенты не могут выбирать фрукты или даже увидеть, какие фрукты они получат.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-9: Структура с общедоступными и приватными полями</span></p>
<p>Поскольку поле <code>toast</code> в структуре <code>back_of_house::Breakfast</code> является открытым, то в функции <code>eat_at_restaurant</code> можно писать и читать поле <code>toast</code>, используя точечную нотацию. Обратите внимание, что мы не можем использовать поле <code>seasonal_fruit</code> в <code>eat_at_restaurant</code>, потому что <code>seasonal_fruit</code> является приватным. Попробуйте убрать комментирование с последней строки для значения поля <code>seasonal_fruit</code>, чтобы увидеть какую ошибку вы получите!</p>
<p>Также обратите внимание, что поскольку <code>back_of_house::Breakfast</code> имеет приватное поле, то структура должна предоставить публичную ассоциированную функцию, которая создаёт экземпляр <code>Breakfast</code> (мы назвали её <code>summer</code>). Если <code>Breakfast</code> не имел бы такой функции, мы бы не могли создать экземпляр <code>Breakfast</code> внутри <code>eat_at_restaurant</code>, потому что мы не смогли бы установить значение приватного поля <code>seasonal_fruit</code> в функции <code>eat_at_restaurant</code>.</p>
<p>В отличии от структуры, если мы сделаем общедоступным перечисление, то все его варианты будут общедоступными. Нужно только указать <code>pub</code> перед ключевым словом <code>enum</code>, как показано в приложении 7-10.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-10. Определяя перечисление общедоступным мы делаем все его варианты общедоступными</span></p>
<p>Поскольку мы сделали общедоступным перечисление <code>Appetizer</code>, то можно использовать варианты <code>Soup</code> и <code>Salad</code> в функции <code>eat_at_restaurant</code>.</p>
<p>Перечисления не очень полезны, если их варианты не являются общедоступными: было бы досадно каждый раз аннотировать все варианты перечисления как <code>pub</code>. По этой причине по умолчанию варианты перечислений являются общедоступными. Структуры часто полезны, если их поля не являются общедоступными, поэтому поля структуры следуют общему правилу, согласно которому, всё по умолчанию является приватным, если не указано <code>pub</code>.</p>
<p>Есть ещё одна ситуация с <code>pub</code>, которую мы не освещали, и это последняя особенность модульной системы: ключевое слово <code>use</code>. Мы сначала опишем <code>use</code> само по себе, а затем покажем как сочетать <code>pub</code> и <code>use</code> вместе.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Подключение-путей-в-область-видимости-с-помощью-ключевого-слова-use"><a class="header" href="#Подключение-путей-в-область-видимости-с-помощью-ключевого-слова-use">Подключение путей в область видимости с помощью ключевого слова <code>use</code></a></h2>
<p>Необходимость записывать пути к функциям вызова может показаться неудобной и повторяющейся. В приложении 7-7 независимо от того, выбирали ли мы абсолютный или относительный путь к функции <code>add_to_waitlist</code> , каждый раз, когда мы хотели вызвать <code>add_to_waitlist</code> , нам приходилось также указывать <code>front_of_house</code> и <code>hosting</code> . К счастью, есть способ упростить этот процесс: мы можем один раз создать псевдоним на путь при помощи ключевого слова <code>use</code>, а затем использовать более короткое имя везде в области видимости.</p>
<p>В приложении 7-11 мы подключили модуль <code>crate::front_of_house::hosting</code> в область действия функции <code>eat_at_restaurant</code>, поэтому нам достаточно только указать <code>hosting::add_to_waitlist</code> для вызова функции <code>add_to_waitlist</code> внутри <code>eat_at_restaurant</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-11/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-11. Добавление модуля в область видимости при помощи <code>use</code></span></p>
<p>Добавление <code>use</code> и пути в область видимости подобно созданию символической ссылки в файловой системе. С добавлением <code>use crate::front_of_house::hosting</code> в корневой модуль крейта, <code>hosting</code> становится допустимым именем в этой области, как если бы модуль <code>hosting</code> был определён в корневом модуле крейта. Пути, подключённые в область видимости с помощью <code>use</code>, также проверяются на доступность, как и любые другие пути.</p>
<p>Обратите внимание, что <code>use</code> создаёт псевдоним только для той именно области, в которой это объявление <code>use</code> и находится. В приложении 7-12 функция <code>eat_at_restaurant</code> перемещается в новый дочерний модуль с именем <code>customer</code>, область действия которого отличается от области действия указания <code>use</code>, поэтому тело функции не будет собираться:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-12. Указание <code>use</code> применяется только в её собственной области видимости</span></p>
<p>Ошибка сборщика показывает, что данный псевдоним не может использоваться в модуле <code>customer</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch07-managing-growing-projects/listing-07-12/output.txt}}
</code></pre>
<p>Обратите внимание, что есть также предупреждение о том, что <code>use</code> не используется в своей области! Чтобы решить эту проблему, можно переместить <code>use</code> в модуль <code>customer</code>, или же можно сослаться на псевдоним в родительском модуле с помощью <code>super::hosting</code> в дочернем модуле <code>customer</code>.</p>
<h3 id="Создание-идиоматических-путей-с-use"><a class="header" href="#Создание-идиоматических-путей-с-use">Создание идиоматических путей с <code>use</code></a></h3>
<p>В приложении 7-11 вы могли бы задаться вопросом, почему мы указали  <code>use crate::front_of_house::hosting</code>, а затем вызвали <code>hosting::add_to_waitlist</code> внутри <code>eat_at_restaurant</code> вместо указания в  <code>use</code> полного пути прямо до функции <code>add_to_waitlist</code> для получения того же результата, что в приложении 7-13.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-13/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-13: Добавление функции <code>add_to_waitlist</code> в область видимости с <code>use</code> неидиоматическим способом</span></p>
<p>Хотя приложениеи 7-11 и 7-13 выполняют одну и ту же задачу, приложение 7-11 является идиоматическим способом подключения функции в область видимости с помощью <code>use</code>. Подключение родительского модуля функции в область видимости при помощи <code>use</code> означает, что мы должны указывать родительский модуль при вызове функции. Указание родительского модуля при вызове функции даёт понять, что функция не определена местно, но в то же время сводя к минимуму повторение полного пути. В коде приложения 7-13 не ясно, где именно определена <code>add_to_waitlist</code>.</p>
<p>С другой стороны, при подключении структур, перечислений и других элементов используя <code>use</code>, идиоматически правильным будет указывать полный путь. Приложение 7-14 показывает идиоматический способ подключения структуры встроенной библиотеки <code>HashMap</code> в область видимости двоичного крейта.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-14/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 7-14. Включение <code>HashMap</code> в область видимости идиоматическим способом</span></p>
<p>За этой идиомой нет веской причины: это просто соглашение, которое появилось само собой. Люди привыкли читать и писать код на Rust таким образом.</p>
<p>Исключением из этой идиомы является случай, когда мы подключаем два элемента с одинаковыми именами в область видимости используя указанию <code>use</code> — Rust просто не позволяет этого сделать. Приложение 7-15 показывает, как подключить в область действия два вида с одинаковыми именами <code>Result</code>, но из разных родительских модулей и как на них ссылаться.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-15/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 7-15. Для включения двух видов с одинаковыми именами в одну область видимости необходимо использовать их родительские модули.</span></p>
<p>Как видите, использование имени родительских модулей позволяет различать два вида <code>Result</code>. Если бы вместо этого мы указали <code>use std::fmt::Result</code> и <code>use std::io::Result</code>, мы бы имели два вида <code>Result</code> в одной области видимости, и Rust не смог бы понять какой из двух <code>Result</code> мы имели в виду, когда нашёл бы их употребление в коде.</p>
<h3 id="Предоставление-новых-имён-с-помощью-ключевого-слова-as"><a class="header" href="#Предоставление-новых-имён-с-помощью-ключевого-слова-as">Предоставление новых имён с помощью ключевого слова <code>as</code></a></h3>
<p>Есть другое решение проблемы добавления двух видов с одинаковыми именами в одну и ту же область видимости используя <code>use</code>: после пути можно указать <code>as</code> и новое местное имя (псевдоним) для вида. Приложение 7-16 показывает как по-другому написать код из приложения 7-15, путём переименования одного из двух видов <code>Result</code> используя <code>as</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-16/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 7-16: Переименование вида, когда он включён в область видимости с помощью ключевого слова <code>as</code></span></p>
<p>Во второй указания <code>use</code> мы выбрали новое имя <code>IoResult</code> для вида <code>std::io::Result</code>, которое теперь не будет конфликтовать с видом <code>Result</code> из <code>std::fmt</code>, который также подключён в область видимости. Приложения 7-15 и 7-16 считаются идиоматичными, поэтому выбор за вами!</p>
<h3 id="Реэкспорт-имён-с-pub-use"><a class="header" href="#Реэкспорт-имён-с-pub-use">Реэкспорт имён с <code>pub use</code></a></h3>
<p>Когда мы подключаем имя в область видимости, используя ключевое слово <code>use</code>, то имя, доступное в новой области видимости, является приватным. Чтобы позволить коду, который вызывает наш код, ссылаться на это имя, как если бы оно было определено в области видимости данного кода, можно объединить <code>pub</code> и <code>use</code>. Этот способ называется <em>реэкспортом (re-exporting)</em>, потому что мы подключаем элемент в область видимости, но также делаем этот элемент доступным для подключения в других областях видимости.</p>
<p>Приложение 7-17 показывает код из приложения 7-11, где <code>use</code> в корневом модуле заменено на <code>pub use</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-17/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-17. Предоставление имени для использования любым кодом из новой области при помощи <code>pub use</code></span></p>
<p>До этого изменения внешний код должен был вызывать функцию <code>add_to_waitlist</code> , используя путь <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> . Теперь, когда это объявление <code>pub use</code> повторно экспортировало модуль <code>hosting</code> из корневого модуля, внешний код теперь может использовать вместо него путь <code>restaurant::hosting::add_to_waitlist()</code> .</p>
<p>Реэкспорт полезен, когда внутренняя структура вашего кода отличается от того, как программисты, вызывающие ваш код, думают о предметной области. Например, по подобию с рестораном люди, управляющие им, думают о «передней части дома» и «задней части дома». Но клиенты, посещающие ресторан, вероятно, не будут думать о частях ресторана в таких терминах. Используя <code>pub use</code> , мы можем написать наш код с одной структурой, но сделать общедоступной другую структуру. Благодаря этому наша библиотека хорошо организована для программистов, работающих над библиотекой, и для программистов, вызывающих библиотеку. Мы рассмотрим ещё один пример <code>pub use</code> и его влияние на документацию вашего крейта в разделе <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use" data-md-type="link">«Экспорт удобного общедоступного API с <code>pub use</code>»</a><!-- ignore --> Главы 14.</p>
<h3 id="Использование-внешних-пакетов"><a class="header" href="#Использование-внешних-пакетов">Использование внешних пакетов</a></h3>
<p>В Главе 2 мы запрограммировали игру угадывания числа, где использовался внешний пакет с именем <code>rand</code> для генерации случайного числа. Чтобы использовать <code>rand</code> в нашем проекте, мы добавили эту строку в <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:9:}}
</code></pre>
<p>Добавление <code>rand</code> в качестве зависимости в <em>Cargo.toml</em> указывает Cargo загрузить пакет <code>rand</code> и все его зависимости из <a href="https://crates.io/">crates.io</a> и сделать <code>rand</code> доступным для нашего проекта.</p>
<p>Затем, чтобы подключить определения <code>rand</code> в область видимости нашего пакета, мы добавили строку <code>use</code> начинающуюся с названия пакета <code>rand</code> и списка элементов, которые мы хотим подключить в область видимости. Напомним, что в разделе <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">"Генерация случайного числа"</a><!-- ignore --> Главы 2, мы подключили трейт <code>Rng</code> в область видимости и вызвали функцию <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:ch07-04}}</code></pre>
<p>Члены сообщества Rust сделали много пакетов доступными на ресурсе <a href="https://crates.io/">crates.io</a>, и добавление любого из них в ваш пакет включает в себя одни и те же шаги: добавить внешние пакеты в файл <em>Cargo.toml</em> вашего пакета, использовать <code>use</code> для подключения элементов внешних пакетов в область видимости.</p>
<p>Обратите внимание, что стандартная библиотека <code>std</code> также является крейтом, внешним по отношению к нашему пакету. Поскольку стандартная библиотека поставляется с языком Rust, нам не нужно изменять <em>Cargo.toml</em> для подключения <code>std</code>. Но нам нужно ссылаться на неё при помощи <code>use</code>, чтобы добавить элементы оттуда в область видимости нашего пакета. Например, с <code>HashMap</code> мы использовали бы эту строку:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Это абсолютный путь, начинающийся с <code>std</code>, имени крейта встроенной библиотеки.</p>
<h3 id="Использование-вложенных-путей-для-уменьшения-длинных-списков-use"><a class="header" href="#Использование-вложенных-путей-для-уменьшения-длинных-списков-use">Использование вложенных путей для уменьшения длинных списков <code>use</code></a></h3>
<p>Если мы используем несколько элементов, определённых в одном крейте или в том же модуле, то перечисление каждого элемента в отдельной строке может занимать много вертикального пространства в файле. Например, эти две указания <code>use</code> используются в программе угадывания числа (приложение 2-4) для подключения элементов из <code>std</code> в область видимости:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-01-use-std-unnested/src/main.rs:here}}</code></pre>
<p>Вместо этого, мы можем использовать вложенные пути, чтобы добавить эти элементы в область видимости одной строкой. Мы делаем это, как показано в приложении 7-18, указывая общую часть пути, за которой следуют два двоеточия, а затем фигурные скобки вокруг списка тех частей продолжения пути, которые отличаются.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-18/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 7-18. Указание вложенного пути для добавления нескольких элементов с одинаковым префиксом в область видимости</span></p>
<p>В больших программах, подключение множества элементов из одного пакета или модуля с использованием вложенных путей может значительно сократить количество необходимых отдельных указаний <code>use</code>!</p>
<p>Можно использовать вложенный путь на любом уровне, что полезно при объединении двух указаний <code>use</code>, которые имеют общую часть пути. Например, в приложении 7-19 показаны две указания <code>use</code>: одна подключает <code>std::io</code>, а другая подключает <code>std::io::Write</code> в область видимости.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-19/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-19: Две указания <code>use</code>, в которых один путь является частью другого</span></p>
<p>Общей частью этих двух путей является <code>std::io</code>, и это полный первый путь. Чтобы объединить эти два пути в одной указания <code>use</code>, мы можем использовать ключевое слово <code>self</code> во вложенном пути, как показано в приложении 7-20.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-20/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-20: Объединение путей из Приложения 7-19 в одну указанию <code>use</code></span></p>
<p>Эта строка подключает <code>std::io</code> и <code>std::io::Write</code> в область видимости.</p>
<h3 id="Оператор--glob"><a class="header" href="#Оператор--glob">Оператор * (glob)</a></h3>
<p>Если мы хотим включить в область видимости <em>все</em> общедоступные элементы, определённые в пути, мы можем указать этот путь, за которым следует оператор <code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Эта указание <code>use</code> подключает все открытые элементы из модуля <code>std::collections</code> в текущую область видимости. Будьте осторожны при использовании оператора <code>*</code>! Он может усложнить понимание, какие имена находятся в области видимости и где были определены имена, используемые в вашей программе.</p>
<p>Оператор <code>*</code> часто используется при тестировании для подключения всего что есть в модуле <code>tests</code>; мы поговорим об этом в разделе <a href="ch11-01-writing-tests.html#how-to-write-tests">"Как писать тесты"</a><!-- ignore --> Главы 11. Оператор <code>*</code> также иногда используется как часть шаблона <em>самостоятельного импорта (prelude)</em>: смотрите <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">документацию по встроенной библиотеке</a><!-- ignore --> для получения дополнительной сведений об этом шаблоне.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Разделение-модулей-на-разные-файлы"><a class="header" href="#Разделение-модулей-на-разные-файлы">Разделение модулей на разные файлы</a></h2>
<p>До сих пор все примеры в этой главе определяли несколько модулей в одном файле. Когда модули становятся большими, вы можете захотеть переместить их определения в отдельные файлы, чтобы упростить навигацию по коду.</p>
<p>Например, давайте начнём с кода из приложения 7-17, в котором было несколько модулей ресторана. Мы будем извлекать модули в файлы вместо того, чтобы определять все модули в корневом модуле крейта. В нашем случае корневой модуль крейта - <em>src/lib.rs</em>, но это разделение также работает и с двоичными крейтами, у которых корневой модуль крейта — <em>src/main.rs</em>.</p>
<p>Сначала мы извлечём модуль <code>front_of_house</code> в свой собственный файл. Удалите код внутри фигурных скобок для модуля <code>front_of_house</code>, оставив только объявление <code>mod front_of_house;</code>, так что теперь <em>src/lib.rs</em> содержит код, показанный в приложении 7-21. Обратите внимание, что этот вариант не ссобирается, пока мы не создадим файл <em>src/front_of_house.rs</em> из приложении 7-22.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-21-and-22/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 7-21. Объявление модуля <code>front_of_house</code>, чьё содержимое будет в <em>src/front_of_house.rs</em></span></p>
<p>Затем поместим код, который был в фигурных скобках, в новый файл с именем <em>src/front_of_house.rs</em>, как показано в приложении 7-22. Сборщик знает, что нужно искать в этом файле, потому что он наткнулся в корневом модуле крейта на объявление модуля с именем <code>front_of_house</code>.</p>
<p><span class="filename">Файл: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-21-and-22/src/front_of_house.rs}}</code></pre>
<p><span class="caption">Приложение 7-22. Определение содержимого модуля <code>front_of_house</code> в файле <em>src/front_of_house.rs</em></span></p>
<p>Обратите внимание, что вам нужно только <em>один раз</em> загрузить файл с помощью объявления <code>mod</code> в вашем дереве модулей. Как только сборщик узнает, что файл является частью проекта (и узнает, где в дереве модулей находится код из-за того, куда вы поместили указанию <code>mod</code>), другие файлы в вашем проекте должны ссылаться на код загруженного файла, используя путь к месту, где он был объявлен, как описано в разделе <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">«Пути для ссылки на элемент в дереве модулей»</a><!-- ignore -->. Другими словами, <code>mod</code> — это <em>не</em> действие «включения», которую вы могли видеть в других языках программирования.</p>
<p>Далее мы извлечём модуль <code>hosting</code> в его собственный файл. Процесс немного отличается, потому что <code>hosting</code> является дочерним модулем для <code>front_of_house</code>, а не корневого модуля. Мы поместим файл для <code>hosting</code> в новый каталог, который будет назван по имени его предка в дереве модулей, в данном случае это <em>src/front_of_house/</em>.</p>
<p>Чтобы начать перенос <code>hosting</code>, мы меняем <em>src/front_of_house.rs</em> так, чтобы он содержал только объявление модуля <code>hosting</code>:</p>
<p><span class="filename">Файл: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-02-extracting-hosting/src/front_of_house.rs}}</code></pre>
<p>Затем мы создаём каталог <em>src/front_of_house</em> и файл <em>hosting.rs</em>, в котором будут  определения, сделанные в модуле <code>hosting</code>:</p>
<p><span class="filename">Файл: src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-02-extracting-hosting/src/front_of_house/hosting.rs}}</code></pre>
<p>Если вместо этого мы поместим <em>hosting.rs</em> в каталог <em>src</em>, сборщик будет думать, что код в <em>hosting.rs</em> это модуль <code>hosting</code>, объявленный в корне крейта, а не объявленный как дочерний модуль <code>front_of_house</code>. Правила сборщика для проверки какие файлы содержат код каких модулей предполагают, что каталоги и файлы точно соответствуют дереву модулей.</p>
<blockquote>
<h3 id="Иные-пути-к-файлам"><a class="header" href="#Иные-пути-к-файлам">Иные пути к файлам</a></h3>
<p>До сих пор мы рассматривали наиболее идиоматические пути к файлам, используемые сборщиком Rust, но Rust также поддерживает и старый стиль пути к файлу. Для модуля с именем <code>front_of_house</code>, объявленного в корневом модуле крейта, сборщик будет искать код модуля в:</p>
<ul>
<li><em>src/front_of_house.rs</em> (что мы рассматривали)</li>
<li><em>src/front_of_house/mod.rs</em> (старый стиль, всё ещё поддерживаемый путь)</li>
</ul>
<p>Для модуля с именем <code>hosting</code>, который является подмодулем <code>front_of_house</code>, сборщик будет искать код модуля в:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (что мы рассматривали)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (старый стиль, всё ещё поддерживаемый путь)</li>
</ul>
<p>Если вы используете оба стиля для одного и того же модуля, вы получите ошибку сборщика. Использование сочетания обоих стилей для разных модулей в одном проекте разрешено, но это может сбивать с толку людей, перемещающихся по вашему проекту.</p>
<p>Основным недостатком стиля, в котором используются файлы с именами <em>mod.rs</em>, является то, что в вашем проекте может оказаться много файлов с именами <em>mod.rs</em>, что может привести к путанице, если вы одновременно откроете их в редакторе.</p>
</blockquote>
<p>Мы перенесли код каждого модуля в отдельный файл, а дерево модулей осталось прежним. Вызовы функций в <code>eat_at_restaurant</code> будут работать без каких-либо изменений, несмотря на то, что определения находятся в разных файлах. Этот способ позволяет перемещать модули в новые файлы по мере увеличения их размеров.</p>
<p>Обратите внимание, что указание <code>pub use crate::front_of_house::hosting</code> в <em>src/lib.rs</em> также не изменилась, и <code>use</code> не влияет на то, какие файлы собираются как часть крейта. Ключевое слово <code>mod</code> объявляет модули, и Rust ищет в файле с тем же именем, что и у модуля, код, который входит в этот модуль.</p>
<h2 id="Итог"><a class="header" href="#Итог">Итог</a></h2>
<p>Rust позволяет разбить пакет на несколько крейтов и крейт - на модули, так что вы можете ссылаться на элементы, определённые в одном модуле, из другого модуля. Это можно делать при помощи указания абсолютных или относительных путей. Эти пути можно добавить в область видимости указанием <code>use</code>, поэтому вы можете пользоваться более короткими путями для многократного использования элементов в этой области видимости. Код модуля по умолчанию является приватным, но можно сделать определения общедоступными, добавив ключевое слово <code>pub</code>.</p>
<p>В следующей главе мы рассмотрим некоторые собрания структур данных из встроенной библиотеки, которые вы можете использовать в своём правильноно организованном коде.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Общие-собрания"><a class="header" href="#Общие-собрания">Общие собрания</a></h1>
<p>Стандартная библиотека содержит несколько полезных структур данных, которые называются <em>собраниями</em>. Большая часть других видов данных представляют собой хранение определенного значения, но особенностью собраний является хранение множества однотипных значений. В отличии от массива или кортежа данные собраний хранятся в куче, а это значит, что размер собрания может быть неизвестен в момент сборки программы. Он может изменяться (увеличиваться, уменьшаться) во время работы программы. Каждый вид собраний имеет свои возможности и отличается по производительности, так что выбор именно собрания зависит от ситуации и является умением разработчика, вырабатываемым со временем. В этой главе будет рассмотрено несколько собраний:</p>
<ul>
<li><em>Вектор (vector)</em> - позволяет нам сохранять различное количество последовательно хранящихся значений,</li>
<li><em>Строка (string)</em> - это последовательность символов. Мы же упоминали вид <code>String</code> ранее, но в данной главе мы поговорим о нем подробнее.</li>
<li><em>Хеш-таблица (hash map)</em> - собрание которая позволяет хранить перечень ассоциаций значения с ключом (перечень пар ключ:значение). Является именно реализацией более общей структуры данных называемой <em>map</em>.</li>
</ul>
<p>Для того, чтобы узнать о других видах собраний предоставляемых встроенной библиотекой смотрите <a href="https://doc.rust-lang.org/std/collections/index.html">документацию</a>.</p>
<p>Мы обсудим как создавать и обновлять векторы, строки и хеш-таблицы, а также объясним что делает каждую из них особенной.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Хранение-списков-значений-в-векторах"><a class="header" href="#Хранение-списков-значений-в-векторах">Хранение списков значений в векторах</a></h2>
<p>Первым видом собрания, который мы разберём, будет <code>Vec&lt;T&gt;</code>, также известный как <em>вектор</em> (vector). Векторы позволяют хранить более одного значения в единой структуре данных, хранящей элементы в памяти один за другим. Векторы могут хранить данные только одного вида. Их удобно использовать, когда нужно хранить список элементов, например, список текстовых строк из файла, или список цен товаров в корзине покупок.</p>
<h3 id="Создание-нового-вектора"><a class="header" href="#Создание-нового-вектора">Создание нового вектора</a></h3>
<p>Чтобы создать новый пустой вектор, мы вызываем функцию <code>Vec::new</code>, как показано в приложении 8-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-01/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-1: Создание нового пустого вектора для хранения значений вида <code>i32</code></span></p>
<p>Обратите внимание, что здесь мы добавили изложение вида. Поскольку мы не вставляем никаких значений в этот вектор, Rust не знает, какие элементы мы собираемся хранить. Это важный момент. Векторы реализованы с использованием обобщённых видов; мы рассмотрим, как использовать обобщённые виды с вашими собственными видами в Главе 10. А пока знайте, что вид <code>Vec&lt;T&gt;</code>, предоставляемый встроенной библиотекой, может хранить любой вид. Когда мы создаём новый вектор для хранения определенного вида, мы можем указать этот вид в угловых скобках. В приложении 8-1 мы сообщили Rust, что <code>Vec&lt;T&gt;</code> в <code>v</code> будет хранить элементы вида <code>i32</code>.</p>
<p>Чаще всего вы будете создавать <code>Vec&lt;T&gt;</code> с начальными значениями и Rust может определить вид сохраняемых вами значений, но иногда вам всё же придётся указывать изложение вида. Для удобства Rust предоставляет макрос <code>vec!</code>, который создаст новый вектор, содержащий заданные вами значения. В приложении 8-2 создаётся новый <code>Vec&lt;i32&gt;</code>, который будет хранить значения <code>1</code>, <code>2</code> и <code>3</code>. Числовым видом является <code>i32</code>, потому что это вид по умолчанию для целочисленных значений, о чём упоминалось в разделе <a href="ch03-02-data-types.html#data-types">“Виды данных”</a> Главы 3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-2: Создание нового вектора, содержащего значения</span></p>
<p>Поскольку мы указали начальные значения вида <code>i32</code>, Rust может сделать вывод, что вид переменной <code>v</code> это <code>Vec&lt;i32&gt;</code> и изложение вида здесь не нужна. Далее мы посмотрим как изменять вектор.</p>
<h3 id="Изменение-вектора"><a class="header" href="#Изменение-вектора">Изменение вектора</a></h3>
<p>Чтобы создать вектор и затем добавить к нему элементы, можно использовать способ <code>push</code> показанный в приложении 8-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-3: Использование способа <code>push</code> для добавления значений в вектор</span></p>
<p>Как и с любой переменной, если мы хотим изменить её значение, нам нужно сделать её изменяемой с помощью ключевого слова <code>mut</code>, что обсуждалось в Главе 3. Все числа которые мы помещаем в вектор имеют вид <code>i32</code> по этому Rust с лёгкостью выводит вид вектора, по этой причине нам не нужна здесь изложение вида вектора <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="Чтение-данных-вектора"><a class="header" href="#Чтение-данных-вектора">Чтение данных вектора</a></h3>
<p>Есть два способа сослаться на значение, хранящееся в векторе: с помощью порядкового казателя или способа <code>get</code> . В следующих примерах для большей ясности мы указали виды значений, возвращаемых этими функциями.</p>
<p>В приложении 8-4 показаны оба способа доступа к значению в векторе: либо с помощью синтаксиса упорядочевания и с помощью способа <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-04/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-4. Использование синтаксиса упорядочевания и способа <code>get</code> для доступа к элементу в векторе</span></p>
<p>Обратите внимание здесь на пару подробностей. Мы используем значение порядкового казателя <code>2</code> для получения третьего элемента: векторы упорядочеваются начиная с нуля. Указывая <code>&amp;</code> и <code>[]</code> мы получаем ссылку на элемент по указанному порядковому казателю. Когда мы используем способ <code>get</code> содержащего порядковый указатель, переданный в качестве переменной, мы получаем вид <code>Option&lt;&amp;T&gt;</code>, который мы можем проверить с помощью <code>match</code>.</p>
<p>Причина, по которой Rust предоставляет два способа ссылки на элемент, заключается в том, что вы можете выбрать, как программа будет себя вести, когда вы попытаетесь использовать значение порядкового казателя за пределами ряда существующих элементов. В качестве примера давайте посмотрим, что происходит, когда у нас есть вектор из пяти элементов, а затем мы пытаемся получить доступ к элементу с порядковым казателем 100 с помощью каждого способа, как показано в приложении 8-5.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-05/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-5. Попытка доступа к элементу с порядковым казателем 100 в векторе, содержащем пять элементов</span></p>
<p>Когда мы запускаем этот код, первая строка с <code>&amp;v[100]</code> вызовет панику программы, потому что происходит попытка получить ссылку на несуществующий элемент. Такой подход лучше всего использовать, когда вы хотите, чтобы ваша программа аварийно завершила работу при попытке доступа к элементу за пределами вектора.</p>
<p>Когда способу <code>get</code> передаётся порядковый указатель, который находится за пределами вектора, он без паники возвращает <code>None</code>. Вы могли бы использовать такой подход, если доступ к элементу за пределами рядавектора происходит время от времени при нормальных обстоятельствах. Тогда ваш код будет иметь логику для обработки наличия <code>Some(&amp;element)</code> или <code>None</code>, как обсуждалось в Главе 6. Например, порядковый казательможет исходить от человека, вводящего число. Если пользователь случайно введёт слишком большое число, то программа получит значение <code>None</code> и у вас будет возможность сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему возможность ввести допустимое значение. Такое поведение было бы более дружелюбным для пользователя, чем внезапный сбой программы из-за опечатки!</p>
<p>Когда у программы есть действительная ссылка, borrow checker (средство проверки заимствований), обеспечивает соблюдение правил владения и заимствования (описанные в Главе 4), чтобы обеспечить, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, которое гласит, что у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в приложении 8-6, где мы храним неизменяемую ссылку на первый элемент вектора и затем пытаемся добавить элемент в конец вектора. Данная программа не будет работать, если мы также попробуем сослаться на данный элемент позже в функции:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-06/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 8-6. Попытка добавить некоторый элемент в вектор, в то время когда есть ссылка на элемент вектора</span></p>
<p>Сборка этого кода приведёт к ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch08-common-collections/listing-08-06/output.txt}}
</code></pre>
<p>Код в приложении 8-6 может выглядеть так, как будто он должен работать. Почему ссылка на первый элемент должна заботиться об изменениях в конце вектора? Эта ошибка возникает из-за особенности того, как работают векторы: поскольку векторы размещают значения в памяти друг за другом, добавление нового элемента в конец вектора может потребовать выделения новой памяти и копирования старых элементов в новое пространство, если нет достаточного места, чтобы разместить все элементы друг за другом там, где в данный момент хранится вектор. В этом случае ссылка на первый элемент будет указывать на освобождённую память. Правила заимствования предотвращают попадание программ в такую ситуацию.</p>
<blockquote>
<p>Примечание: Дополнительные сведения о реализации вида <code>Vec&lt;T&gt;</code> смотрите в разделе <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">"The Rustonomicon"</a>.</p>
</blockquote>
<h3 id="Перебор-значений-в-векторе"><a class="header" href="#Перебор-значений-в-векторе">Перебор значений в векторе</a></h3>
<p>Для доступа к каждому элементу вектора по очереди, мы повторяем все элементы, вместо использования порядковых указателей для доступа к одному за раз. В приложении 8-7 показано, как использовать цикл <code>for</code> для получения неизменяемых ссылок на каждый элемент в векторе значений вида <code>i32</code> и их вывода.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-07/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-7. Печать каждого элемента векторе, при помощи повторения по элементам вектора с помощью цикла <code>for</code></span></p>
<p>Мы также можем повторять изменяемые ссылки на каждый элемент изменяемого вектора, чтобы вносить изменения во все элементы. Цикл <code>for</code> в приложении 8-8 добавит <code>50</code> к каждому элементу.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-8. Повторение и изменение элементов вектора по изменяемым ссылкам</span></p>
<p>Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать оператор разыменования ссылки <code>*</code> для получения значения по ссылке в переменной <code>i</code> прежде чем использовать оператор <code>+=</code>. Мы поговорим подробнее об операторе разыменования в разделе <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“Следование по указателю к значению с помощью оператора разыменования”</a> Главы 15.</p>
<p>Перебор вектора, будь то неизменяемый или изменяемый, безопасен из-за правил проверки заимствования. Если бы мы попытались вставить или удалить элементы в телах цикла <code>for</code> в приложениях 8-7 и 8-8, мы бы получили ошибку сборщика, подобную той, которую мы получили с кодом в приложении 8-6. Ссылка на вектор, содержащийся в цикле for, предотвращает одновременную модификацию всего вектора.</p>
<h3 id="Использование-перечислений-для-хранения-множества-разных-видов"><a class="header" href="#Использование-перечислений-для-хранения-множества-разных-видов">Использование перечислений для хранения множества разных видов</a></h3>
<p>Векторы могут хранить значения только одинакового вида. Это может быть неудобно; определённо могут быть случаи когда надо хранить список элементов разных видов. К счастью, варианты перечисления определены для одного и того же вида перечисления, поэтому, когда нам нужен один вид для представления элементов разных видов, мы можем определить и использовать перечисление!</p>
<p>Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, некоторые числа с плавающей точкой, а другие - строковые значения. Можно определить перечисление, варианты которого будут содержать разные виды значений и тогда все варианты перечисления будут считаться одним и тем же видом: видом самого перечисления. Затем мы можем создать вектор для хранения этого перечисления и, в конечном счёте, для хранения различных видов. Мы покажем это в приложении 8-9.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-09/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-9: Определение <code>enum</code> для хранения значений разных видов в одном векторе</span></p>
<p>Rust должен знать, какие виды будут в векторе во время сборки, чтобы точно знать сколько памяти в куче потребуется для хранения каждого элемента. Мы также должны чётко указать, какие виды разрешены в этом векторе. Если бы Rust позволял вектору содержать любой вид, то был бы шанс что один или несколько видов вызовут ошибки при выполнении действий над элементами вектора. Использование перечисления вместе с выражением <code>match</code> означает, что во время сборки Rust  заверяет, что все возможные случаи будут обработаны, как обсуждалось в главе 6.</p>
<p>Если вы не знаете исчерпывающий набор видов, которые программа получит во время выполнения для хранения в векторе, то техника использования перечисления не сработает. Вместо этого вы можете использовать типаж-объект, который мы рассмотрим в главе 17.</p>
<p>Теперь, когда мы обсудили некоторые из наиболее распространённых способов использования векторов, обязательно ознакомьтесь <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">с документацией по API вектора</a>, чтобы узнать о множестве полезных способов, определённых в <code>Vec&lt;T&gt;</code> встроенной библиотеки. Например, в дополнение к способу <code>push</code>, существует способ <code>pop</code>, который удаляет и возвращает последний элемент.</p>
<h3 id="Удаление-элементов-из-вектора"><a class="header" href="#Удаление-элементов-из-вектора">Удаление элементов из вектора</a></h3>
<p>Подобно структурам <code>struct</code>, вектор высвобождает свою память когда выходит из области видимости, что показано в приложении 8-10.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-10/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-10. Показано как удаляется вектор и его элементы</span></p>
<p>Когда вектор удаляется, всё его содержимое также удаляется: удаление вектора означает и удаление значений, которые он содержит. Средство проверки заимствования заверяет, что любые ссылки на содержимое вектора используются только тогда, когда сам вектор действителен.</p>
<p>Давайте перейдём к следующему виду собрания: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Хранение-закодированного-текста-utf-8-в-строках"><a class="header" href="#Хранение-закодированного-текста-utf-8-в-строках">Хранение закодированного текста UTF-8 в строках</a></h2>
<p>Мы говорили о строках в главе 4, но сейчас мы рассмотрим их более подробно. Новички в Rust обычно застревают на строках из-за  сочетания трёх причин: склонность Rust сборщика к выявлению возможных ошибок, более сложная структура данных чем считают многие программисты и UTF-8. Эти факторы объединяются таким образом, что тема может показаться сложной, если вы пришли из других языков программирования.</p>
<p>Полезно обсуждать строки в среде собраний, потому что строки реализованы в виде набора байтов, плюс некоторые способы для обеспечения полезной функциональности, когда эти байты преобразуются как текст. В этом разделе мы поговорим об действиех над <code>String</code> таких как создание, обновление и чтение, которые есть у каждого вида собраний. Мы также обсудим какими особенностями <code>String</code> отличается от других собраний, а именно каким образом упорядочевание в  <code>String</code> осложняется различием между тем как люди и компьютеры преобразуют данные заключённые в  <code>String</code>.</p>
<h3 id="Что-же-такое-строка"><a class="header" href="#Что-же-такое-строка">Что же такое строка?</a></h3>
<p>Сначала мы определим, что мы подразумеваем под термином  <em>строка</em> (string). В Rust есть только один строковый вид в ядре языка - срез строки <code>str</code>, обычно используемый в заимствованном виде как <code>&amp;str</code>. В Главе 4 мы говорили о <em>срезах строк, string slices</em>, которые являются ссылками на некоторые строковые данные в кодировке UTF-8. Например, строковые литералы хранятся в двоичном файле программы и поэтому являются срезами строк.</p>
<p>Вид <code>String</code> предоставляемый встроенной библиотекой Rust, не встроен в ядро языка и является расширяемым, изменяемым, владеющим, строковым видом в UTF-8 кодировке.  Когда Rustaceans говорят о "строках" то, они обычно имеют в виду виды <code>String</code> или строковые срезы <code>&amp;str</code>, а не просто один из них. Хотя этот раздел в основном посвящён <code>String</code>, оба вида усиленно используются в встроенной библиотеке Rust, оба, и <code>String</code> и строковые срезы, кодируются в UTF-8.</p>
<h3 id="Создание-новых-строк"><a class="header" href="#Создание-новых-строк">Создание новых строк</a></h3>
<p>Многие из тех же действий, которые доступны <code>Vec&lt;T&gt;</code> , доступны также в <code>String</code>, потому что <code>String</code> фактически реализован как обёртка вокруг вектора байтов с некоторыми дополнительными заверениями, ограничениями и возможностями. Примером функции, которая одинаково работает с <code>Vec&lt;T&gt;</code> и <code>String</code>, является функция  <code>new</code>, создающая новый экземпляр вида, и показана в Приложении 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-11. Создание новой пустой <code>String</code> строки</span></p>
<p>Эта строка создаёт новую пустую строковую переменную с именем <code>s</code>, в которую мы можем затем загрузить данные. Часто у нас есть некоторые начальные данные, которые мы хотим назначить строке. Для этого мы используем способ <code>to_string</code> доступный для любого вида, который реализует типаж <code>Display</code>, как у строковых литералов. Приложение 8-12 показывает два примера.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-12: Использование способа <code>to_string</code> для создания экземпляра вида <code>String</code>  из строкового литерала</span></p>
<p>Эти выражения создают строку с  <code>initial contents</code>.</p>
<p>Мы также можем использовать функцию <code>String::from</code> для создания <code>String</code>  из строкового литерала. Код приложения 8-13 является эквивалентным коду из приложения 8-12, который использует функцию <code>to_string</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-13: Использование функции <code>String::from</code> для создания экземпляра вида <code>String</code> из строкового литерала</span></p>
<p>Поскольку строки используются для очень многих вещей, можно использовать множество API для строк, предоставляющих множество возможностей. Некоторые из них могут показаться избыточными, но все они занимаются своим делом!  В данном случае <code>String::from</code> и <code>to_string</code> делают одно и тоже, поэтому выбор зависит от стиля который вам больше импонирует.</p>
<p>Запомните, что строки хранятся в кодировке UTF-8, поэтому можно использовать любые правильно кодированные данные в них, как показано в приложении 8-14:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-14: Хранение приветствий в строках на разных языках</span></p>
<p>Все это допустимые <code>String</code> значения.</p>
<h3 id="Обновление-строковых-данных"><a class="header" href="#Обновление-строковых-данных">Обновление строковых данных</a></h3>
<p>Строка <code>String</code> может увеличиваться в размере, а её содержимое может меняться, по подобию как содержимое <code>Vec&lt;T&gt;</code> при вставке в него большего количества данных. Кроме того, можно использовать оператор <code>+</code> или макрос <code>format!</code> для объединения значений <code>String</code>.</p>
<h4 id="Присоединение-к-строке-с-помощью-push_str-и-push"><a class="header" href="#Присоединение-к-строке-с-помощью-push_str-и-push">Присоединение к строке с помощью <code>push_str</code> и <code>push</code></a></h4>
<p>Мы можем нарастить <code>String</code> используя способ <code>push_str</code> который добавит в исходное значение новый строковый срез, как показано в приложении 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-15. Добавление среза строки к <code>String</code> с помощью способа <code>push_str</code></span></p>
<p>После этих двух строк кода <code>s</code> будет содержать <code>foobar</code>. Способ <code>push_str</code> принимает строковый срез, потому что мы не всегда хотим владеть входным свойствоом. Например, код в приложении 8-16 показывает вариант, когда будет не желательно поведение, при котором мы не сможем использовать <code>s2</code> после его добавления к содержимому значения переменной <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-16: Использование среза строки после добавления её содержимого к другой <code>String</code></span></p>
<p>Если способ <code>push_str</code> стал бы владельцем переменной<code>s2</code>, мы не смогли бы напечатать его значение в последней строке. Однако этот код работает так, как мы ожидали!</p>
<p>Способ <code>push</code> принимает один символ в качестве свойства и добавляет его к <code>String</code>. В приложении 8-17 показан код, добавляющий букву “l” к <code>String</code> используя способ <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-17: Добавление одного символа в <code>String</code> значение используя <code>push</code></span></p>
<p>В результате <code>s</code> будет содержать <code>lol</code>.</p>
<h4 id="Объединение-строк-с-помощью-оператора--или-макроса-format"><a class="header" href="#Объединение-строк-с-помощью-оператора--или-макроса-format">Объединение строк с помощью оператора <code>+</code> или макроса <code>format!</code></a></h4>
<p>Часто хочется объединять две существующие строки. Один из возможных способов — это использование оператора <code>+</code> из приложения 8-18:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-18: Использование оператора <code>+</code> для объединения двух значений <code>String</code> в новое <code>String</code> значение</span></p>
<p>Строка <code>s3</code> будет содержать <code>Hello, world!</code>. Причина того, что <code>s1</code> после добавления больше недействительна и причина, по которой мы использовали ссылку на <code>s2</code> имеют отношение к сигнатуре вызываемого способа при использовании оператора <code>+</code>. Оператор <code>+</code> использует способ <code>add</code>, чья сигнатура выглядит примерно так:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>В встроенной библиотеке вы увидите способ <code>add</code> определённым с использованием обобщённых и связанных видов. Здесь мы видим сигнатуру  с определенными видами, заменяющими обобщённый, что происходит когда вызывается данный способ со значениями <code>String</code>. Мы обсудим обобщённые виды в Главе 10. Эта сигнатура даёт нам ключ для понимания особенностей оператора <code>+</code>.</p>
<p>Во-первых, перед <code>s2</code> мы видим <code>&amp;</code>, что означает что мы складываем <em>ссылку</em> на вторую строку с первой строкой. Это происходит из-за  свойства <code>s</code> в функции <code>add</code>: мы можем добавить только <code>&amp;str</code> к <code>String</code>; мы не можем сложить два значения <code>String</code>. Но подождите — вид <code>&amp;s2</code> это <code>&amp;String</code>, а не <code>&amp;str</code>, как определён второй свойство в <code>add</code>. Так почему код в приложении 8-18 собирается?</p>
<p>Причина, по которой мы можем использовать <code>&amp;s2</code> в вызове <code>add</code> заключается в том, что сборщик может <em>принудительно привести (coerce)</em> переменная вида <code>&amp;String</code> к виду <code>&amp;str</code>. Когда мы вызываем способ <code>add</code> в Rust используется <em>принудительное приведение</em> (deref coercion), которое превращает <code>&amp;s2</code> в <code>&amp;s2[..]</code>. Мы подробно обсудим принудительное приведение в Главе 15. Так как <code>add</code> не забирает во владение свойство <code>s</code>, <code>s2</code> по прежнему будет действительной строкой <code>String</code> после применения действия.</p>
<p>Во-вторых, как можно видеть в сигнатуре, <code>add</code> забирает во владение <code>self</code>, потому что  <code>self</code> <em>не имеет</em> <code>&amp;</code>. Это означает, что <code>s1</code> в приложении 8-18 будет перемещён в вызов <code>add</code> и больше не будет действителен после этого вызова. Не смотря на то, что код <code>let s3 = s1 + &amp;s2;</code> выглядит как будто он скопирует обе строки и создаёт новую, эта указание фактически забирает во владение переменную <code>s1</code>, присоединяет к ней копию содержимого <code>s2</code>, а затем возвращает владение результатом.  Другими словами, это выглядит как будто код создаёт множество копий, но это не так; данная реализация более эффективна, чем копирование.</p>
<p>Если нужно объединить несколько строк, поведение оператора <code>+</code> становится громоздким:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Здесь переменная <code>s</code> будет содержать <code>tic-tac-toe</code>. С множеством символов <code>+</code> и <code>"</code> становится трудно понять, что происходит. Для более сложного комбинирования строк можно использовать макрос <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Этот код также устанавливает переменную <code>s</code> в значение <code>tic-tac-toe</code>. Макрос <code>format!</code> работает тем же способом что макрос <code>println!</code>, но вместо вывода на экран возвращает вид <code>String</code> с содержимым. Исполнение кода с использованием <code>format!</code> значительно легче читается, а также код, сгенерированный макросом <code>format!</code>, использует ссылки, а значит не забирает во владение ни один из его свойств.</p>
<h3 id="Упорядочевание-в-строках"><a class="header" href="#Упорядочевание-в-строках">Упорядочевание в строках</a></h3>
<p>Доступ к отдельным символам в строке, при помощи ссылки на них по порядковому казателю, является допустимой и распространённой операцией во многих других языках программирования. Тем не менее, если вы попытаетесь получить доступ к частям <code>String</code>, используя синтаксис упорядочевания в Rust, то вы получите ошибку. Рассмотрим неверный код в приложении 8-19.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 8-19: Попытка использовать синтаксис порядкового казателя со строкой</span></p>
<p>Этот код приведёт к следующей ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
</code></pre>
<p>Ошибка и примечание говорит, что в Rust строки не поддерживают упорядочевание. Но почему так? Чтобы ответить на этот вопрос, нужно обсудить то, как Rust хранит строки в памяти.</p>
<h4 id="Внутреннее-представление"><a class="header" href="#Внутреннее-представление">Внутреннее представление</a></h4>
<p>Вид <code>String</code> является оболочкой над видом  <code>Vec&lt;u8&gt;</code>. Давайте посмотрим на несколько закодированных корректным образом в UTF-8 строк из примера приложения 8-14. Начнём с этой:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
<span class="boring">}</span></code></pre></pre>
<p>В этом случае <code>len</code> будет 4, что означает вектор, хранит строку "Hola" длиной 4 байта. Каждая из этих букв занимает 1 байт при кодировании в UTF-8. Но как насчёт следующей строки? (Обратите внимание, что эта строка начинается с заглавной кириллической "З", а не цифры 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
<span class="boring">}</span></code></pre></pre>
<p>Отвечая на вопрос, какова длина строки, вы можете ответить 12. Однако ответ Rust - 24, что равно числу байт, необходимых для кодирования «Здравствуйте» в UTF-8, так происходит, потому что каждое скалярное значение Unicode символа в этой строке занимает 2 байта памяти. Следовательно, порядковый казательпо байтам строки не всегда бы соответствовал действительному скалярному Unicode значению. Для отображения рассмотрим этот недопустимый код Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>Каким должно быть значение переменной <code>answer</code>? Должно ли оно быть значением первой буквы <code>З</code>? При кодировке в UTF-8, первый байт значения <code>З</code> равен <code>208</code>, а второй - <code>151</code>, поэтому значение в <code>answer</code> на самом деле должно быть <code>208</code>, но само по себе <code>208</code> не является действительным символом. Возвращение <code>208</code>, скорее всего не то, что хотел бы получить пользователь: ведь он ожидает первую букву этой строки; тем не менее, это единственный байт данных, который в Rust доступен по порядковому указателю 0. Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если <code>&amp;"hello"[0] </code>было бы допустимым кодом, который вернул значение байта, то он вернул бы <code>104</code>, а не <code>h</code>.</p>
<p>Таким образом, чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки которые не могут быть сразу обнаружены, Rust просто не собирает такой код и предотвращает недопонимание на ранних этапах процесса разработки.</p>
<h4 id="Байты-скалярные-значения-и-кластеры-графем-Боже-мой"><a class="header" href="#Байты-скалярные-значения-и-кластеры-графем-Боже-мой">Байты, скалярные значения и кластеры графем! Боже мой!</a></h4>
<p>Ещё один момент, касающийся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Rust: как байты, как скалярные значения и как кластеры графем (самая близкая вещь к тому, что мы назвали бы <em>буквами</em>).</p>
<p>Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор значений <code>u8</code> который выглядит следующим образом:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Эти 18 байт являются именно тем, как компьютеры в конечном итоге сохранят в памяти эту строку. Если мы посмотрим на 18 байт как на скалярные Unicode значения, которые являются Rust видом <code>char</code>, то байты будут выглядеть так:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Здесь есть шесть значений вида <code>char</code>, но четвёртый и шестой являются не буквами: они диакритики, особые обозначения которые не имеют смысла сами по себе. Наконец, если мы посмотрим на байты как на кластеры графем, то получим то, что человек назвал бы словом на хинди состоящем из четырёх букв:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust предоставляет различные способы преобразования необработанных строковых данных, которые компьютеры хранят так, чтобы каждой программе можно было выбрать необходимую преобразование, независимо от того, на каком человеческом языке представлены эти данные.</p>
<p>Последняя причина, по которой Rust не позволяет нам упорядочивать <code>String</code> для получения символов является то, что программисты ожидают, что действия упорядочевания всегда имеют постоянное время (O(1)) выполнения. Но невозможно обеспечить такую производительность для <code>String</code>, потому что Rust понадобилось бы пройтись по содержимому от начала до порядкового указателя, чтобы определить, сколько было действительных символов.</p>
<h3 id="Срезы-строк"><a class="header" href="#Срезы-строк">Срезы строк</a></h3>
<p>Упорядочевание строк часто является плохой идеей, потому что не ясно каким должен быть возвращаемый вид такой действия: байтовым значением, символом, кластером графем или срезом строки. Поэтому Rust просит вас быть более определенным, если действительно требуется использовать порядковые указатели для создания срезов строк.</p>
<p>Вместо упорядочевания с помощью числового порядкового казателя <code>[]</code>, вы можете использовать оператор ряда<code>[]</code> при создании среза строки в котором содержится указание на то, срез каких байтов надо делать:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Здесь переменная <code>s</code> будет вида <code>&amp;str</code> который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов был по 2 байта, что означает, что <code>s</code> будет содержать <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end -->.</p>
<p>Что бы произошло, если бы мы использовали <code>&amp;hello[0..1]</code>? Ответ: Rust бы запаниковал во время выполнения точно так же, как если бы обращались к недействительному порядковому указателю в векторе:</p>
<pre><code class="language-console">{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
</code></pre>
<p>Вы должны использовать ряды для создания срезов строк с осторожностью, потому что это может привести к сбою вашей программы.</p>
<h3 id="Способы-для-перебора-строк"><a class="header" href="#Способы-для-перебора-строк">Способы для перебора строк</a></h3>
<p>Лучший способ работать с фрагментами строк — чётко указать, нужны ли вам символы или байты. Для отдельных скалярных значений в Юникоде используйте способ <code>chars</code>. Вызов <code>chars</code> у <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end --> выделяет и возвращает два значения вида <code>char</code>, и вы можете выполнить повторение по результату для доступа к каждому элементу:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>Код напечатает следующее:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Способ <code>bytes</code> возвращает каждый байт, который может быть подходящим в другой предметной области:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код выведет четыре байта, составляющих эту строку:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Но делая так, обязательно помните, что валидные скалярные Unicode значения могут состоять более чем из одного байта.</p>
<p>Извлечение кластеров графем из строк, как в случае с языком хинди, является сложным, поэтому эта функциональность не предусмотрена встроенной библиотекой. На <a href="https://crates.io/">crates.io</a><!-- ignore --> есть доступные библиотеки, если Вам нужен данный функционал.</p>
<h3 id="Строки-не-так-просты"><a class="header" href="#Строки-не-так-просты">Строки не так просты</a></h3>
<p>Подводя итог, становится ясно, что строки сложны. Различные языки программирования реализуют различные варианты того, как представить эту сложность для программиста. В Rust решили сделать правильную обработку данных <code>String</code> поведением по умолчанию для всех программ Rust, что означает, что программисты должны заранее продумать обработку UTF-8 данных. Этот соглашение раскрывает большую сложность строк, чем в других языках программирования, но это предотвращает от необходимости обрабатывать ошибки, связанные с не-ASCII символами которые могут появиться в ходе разработки позже.</p>
<p>Хорошая новость состоит в том что стандартная библиотека предлагает множество функциональных возможностей, построенных на основе видов <code>String</code> и <code>&amp;str</code>, чтобы помочь правильно обрабатывать эти сложные ситуации. Обязательно ознакомьтесь с документацией для полезных способов, таких как <code>contains</code> для поиска в строке и <code>replace</code> для замены частей строки другой строкой.</p>
<p>Давайте переключимся на что-то немного менее сложное: HashMap!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Хранение-ключей-со-связанными-значениями-в-hashmap"><a class="header" href="#Хранение-ключей-со-связанными-значениями-в-hashmap">Хранение ключей со связанными значениями в HashMap</a></h2>
<p>Последняя собрание, которую мы рассмотрим, будет <em>hash map</em> (хеш-карта). Вид <code>HashMap&lt;K, V&gt;</code> хранит ключи вида <code>K</code> на значения вида <code>V</code>. Данная структура организует и хранит данные с помощью <em>функции хеширования</em>. Во множестве языков программирования реализована данная структура, но часто с разными наименованиями: такими как hash, map, object, hash table, dictionary или ассоциативный массив.</p>
<p>Хеш-карты полезны, когда нужно искать данные не используя порядковый указатель, как это например делается в векторах, а с помощью ключа, который может быть любого вида. Например, в игре вы можете отслеживать счёт каждой приказы в хеш-карте, в которой каждый ключ - это название приказы, а значение - счёт приказы. Имея имя приказы, вы можете получить её счёт из хеш-карты.</p>
<p>В этом разделе мы рассмотрим основной API хеш-карт. Остальной набор полезных функций скрывается в объявлении вида <code>HashMap&lt;K, V&gt;</code>. Как и прежде, советуем обратиться к документации по встроенной библиотеке для получения дополнительной сведений.</p>
<h3 id="Создание-новой-хеш-карты"><a class="header" href="#Создание-новой-хеш-карты">Создание новой хеш-карты</a></h3>
<p>Создать пустую хеш-карту можно с помощью <code>new</code>, а добавить в неё элементы - с помощью <code>insert</code>. В приложении 8-20 мы отслеживаем счёт двух приказов, синей <em>Blue</em> и жёлтой <em>Yellow</em>. Синяя приказ набрала 10 очков, а жёлтая приказ - 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-20: Создание новой хеш-карты и вставка в неё пары ключей и значений</span></p>
<p>Обратите внимание, что нужно сначала указать строку <code>use std::collections::HashMap;</code> для её подключения из собраний встроенной библиотеки. Из трёх собраний данная является наименее используемой, поэтому она не подключается в область видимости функцией самостоятельного импорта (prelude). Хеш-карты также имеют меньшую поддержку со стороны встроенной библиотеки; например, нет встроенного макроса для их конструирования.</p>
<p>Подобно векторам, хеш-карты хранят свои данные в куче. Здесь вид <code>HashMap</code> имеет в качестве вида ключей <code>String</code>, а в качестве вида значений вид <code>i32</code>. Как и векторы, HashMap однородны: все ключи должны иметь одинаковый вид и все значения должны иметь тоже одинаковый вид.</p>
<h3 id="Доступ-к-данным-в-hashmap"><a class="header" href="#Доступ-к-данным-в-hashmap">Доступ к данным в HashMap<a name="accessing-values-in-a-hash-map"></a></a></h3>
<p>Мы можем получить значение из HashMap по ключу, с помощью метода <code>get</code>, как показано в приложении 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-21: Доступ к очкам приказы "Blue", которые хранятся в хеш-карте</span></p>
<p>Здесь <code>score</code> будет иметь количество очков, связанное с приказом "Blue", результат будет <code>10</code>. Способ <code>get</code> возвращает <code>Option&lt;&amp;V&gt;</code>; если для какого-то ключа нет значения в HashMap, <code>get</code> вернёт <code>None</code>. Из-за такого подхода программе следует обрабатывать <code>Option</code>, вызывая <code>copied</code> для получения <code>Option&lt;i32&gt;</code> вместо <code>Option&lt;&amp;i32&gt;</code>, затем <code>unwrap_or</code> для установки <code>score</code> в ноль, если scores не содержит данных по этому ключу.</p>
<p>Мы можем перебирать каждую пару ключ/значение в HashMap таким же образом, как мы делали с векторами, используя цикл <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Этот код будет печатать каждую пару в произвольном порядке:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="Хеш-карты-и-владение"><a class="header" href="#Хеш-карты-и-владение">Хеш-карты и владение</a></h3>
<p>Для видов, которые реализуют типаж <code>Copy</code>, например <code>i32</code>, значения копируются в HashMap. Для значений со владением, таких как <code>String</code>, значения  будут перемещены в хеш-карту и она станет владельцем этих значений, как показано в приложении 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-22: Показывает, что ключи и значения находятся во владении HashMap, как только они были вставлены</span></p>
<p>Мы не можем использовать переменные <code>field_name</code> и <code>field_value</code> после того, как их значения были перемещены в HashMap вызовом метода <code>insert</code>.</p>
<p>Если мы вставим в HashMap ссылки на значения, то они не будут перемещены в HashMap. Значения, на которые указывают ссылки, должны быть действительными хотя бы до тех пор, пока хеш-карта действительна. Мы поговорим подробнее об этих вопросах в разделе <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">"Валидация ссылок при помощи времён жизни"</a><!-- ignore --> главы 10.</p>
<h3 id="Обновление-данных-в-hashmap"><a class="header" href="#Обновление-данных-в-hashmap">Обновление данных в HashMap</a></h3>
<p>Хотя количество ключей и значений может увеличиваться в HashMap, каждый ключ может иметь только одно значение, связанное с ним в один момент времени (обратное утверждение неверно: приказы "Blue" и "Yellow" могут хранить в хеш-карте <code>scores</code> одинаковое количество очков, например 10).</p>
<p>Когда вы хотите изменить данные в хеш-карте, необходимо решить, как обрабатывать случай, когда ключ уже имеет назначенное значение. Можно заменить старое значение новым, полностью пренебрегая старое. Можно сохранить старое значение и пренебрегать новое, или добавлять новое значение, если только ключ <em>ещё не</em> имел значения. Или можно было бы объединить старое значение и новое значение. Давайте посмотрим, как сделать каждый из вариантов!</p>
<h4 id="Перезапись-старых-значений"><a class="header" href="#Перезапись-старых-значений">Перезапись старых значений</a></h4>
<p>Если мы вставим ключ и значение в HashMap, а затем вставим тот же ключ с новым значением, то старое значение связанное с этим ключом, будет заменено на новое. Даже несмотря на то, что код в приложении 8-23 вызывает <code>insert</code> дважды, хеш-карта будет содержать только одну пару ключ/значение, потому что мы вставляем значения для одного и того же ключа - ключа приказы "Blue".</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-23: Замена значения, хранимого в определенном ключе</span></p>
<p>Код напечатает <code>{"Blue": 25}</code>. Начальное значение <code>10</code> было перезаписано.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="Вставка-значения-только-в-том-случае-когда-ключ-не-имеет-значения"><a class="header" href="#Вставка-значения-только-в-том-случае-когда-ключ-не-имеет-значения">Вставка значения только в том случае, когда ключ не имеет значения</a></h4>
<p>Обычно проверяют, существует ли определенный ключ в хеш-карте со значением, а затем предпринимаются следующие действия: если ключ существует в хеш-карте, существующее значение должно оставаться таким, какое оно есть. Если ключ не существует, то вставляют его и значение для него.</p>
<p>Хеш-карты имеют для этого особый API, называемый <code>entry</code> , который принимает ключ для проверки в качестве входного свойства. Возвращаемое значение метода <code>entry</code> - это перечисление <code>Entry</code>, с двумя вариантами: первый представляет значение, которое может существовать, а второй говорит о том, что значение отсутствует. Допустим, мы хотим проверить, имеется ли ключ и связанное с ним значение для приказы "Yellow". Если хеш-карта не имеет значения для такого ключа, то мы хотим вставить значение 50. То же самое мы хотим проделать и для приказы "Blue". Используем API <code>entry</code> в коде приложения 8-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-24: Использование метода <code>entry</code> для вставки значения только в том случае, когда ключ не имеет значения</span></p>
<p>Способ <code>or_insert</code> определён в <code>Entry</code> так, чтобы возвращать изменяемую ссылку на соответствующее значение ключа внутри варианта перечисления <code>Entry</code>, когда этот ключ существует, а если его нет, то вставлять свойство в качестве нового значения этого ключа и возвращать изменяемую ссылку на новое значение. Эта техника намного чище, чем самостоятельное написание логики и, кроме того, она более безопасна и согласуется с правилами заимствования.</p>
<p>При выполнении кода приложения 8-24 будет напечатано <code>{"Yellow": 50, "Blue": 10}</code>. Первый вызов <code>метода entry</code> вставит ключ для приказы "Yellow" со значением 50, потому что для жёлтой приказы ещё не имеется значения в HashMap. Второй вызов <code>entry</code> не изменит хеш-карту, потому что для ключа приказы "Blue" уже имеется значение 10.</p>
<h4 id="Создание-нового-значения-на-основе-старого-значения"><a class="header" href="#Создание-нового-значения-на-основе-старого-значения">Создание нового значения на основе старого значения</a></h4>
<p>Другим распространённым вариантом использования хеш-карт является поиск значения по ключу, а затем обновление этого значения на основе старого значения. Например, в приложении 8-25 показан код, который подсчитывает, сколько раз определённое слово встречается в некотором тексте. Мы используем HashMap со словами в качестве ключей и увеличиваем соответствующее слову значение, чтобы отслеживать, сколько раз мы встретили это слово. Если мы впервые встретили слово, то сначала вставляем значение 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 8-25: Подсчёт количества вхождений слов с использованием хеш-карты, которая хранит слова и счётчики</span></p>
<p>Этот код напечатает <code>{"world": 2, "hello": 1, "wonderful": 1}</code>. Если вы увидите, что пары ключ/значение печатаются в другом порядке, то вспомните, что мы писали в секции <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">"Доступ к данным в HashMap"</a><!-- ignore -->, что повторение по хеш-карте происходит в произвольном порядке.</p>
<p>Способ <code>split_whitespace</code> возвращает повторительпо срезам строки, разделённых пробелам, для строки  <code>text</code>. Способ <code>or_insert</code> возвращает изменяемую ссылку (<code>&amp;mut V</code>) на значение ключа. Мы сохраняем изменяемую ссылку в переменной <code>count</code>, для этого, чтобы присвоить переменной значение, необходимо произвести разыменование с помощью звёздочки (*). Изменяемая ссылка удаляется сразу же после выхода из области видимости цикла <code>for</code>, поэтому все эти изменения безопасны и согласуются с правилами заимствования.</p>
<h3 id="Функция-хеширования"><a class="header" href="#Функция-хеширования">Функция хеширования</a></h3>
<p>По умолчанию <code>HashMap</code> использует функцию хеширования <em>SipHash</em>, которая может противостоять атакам класса отказ в обслуживании, Denial of Service (DoS) с использованием хеш-таблиц <a href="https://en.wikipedia.org/wiki/SipHash">siphash</a><!-- ignore -->. Это не самый быстрый из возможных алгоритмов хеширования, в данном случае производительность идёт на соглашение с обеспечением лучшей безопасности. Если после профилирования вашего кода окажется, что хеш-функция, используемая по умолчанию, очень медленная, вы можете заменить её используя другой hasher. <em>Hasher</em> - это вид, реализующий трейт <code>BuildHasher</code>. Подробнее о типажах мы поговорим в Главе 10. Вам совсем не обязательно реализовывать свою собственную функцию хеширования; <a href="https://crates.io/">crates.io</a><!-- ignore --> имеет достаточное количество библиотек, предоставляющих разные реализации hasher с множеством общих алгоритмов хеширования.</p>
<h2 id="Итоги-5"><a class="header" href="#Итоги-5">Итоги</a></h2>
<p>Векторы, строки и хеш-карты предоставят большое количество функционала для программ, когда необходимо сохранять, получать доступ и модифицировать данные. Теперь вы готовы решить следующие учебные задания:</p>
<ul>
<li>Есть список целых чисел. Создайте функцию, используйте вектор и верните из списка: среднее значение; медиану (значение элемента из середины списка после его сортировки); моду списка (mode of list, то значение которое встречается в списке наибольшее количество раз; HashMap будет полезна в данном случае).</li>
<li>Преобразуйте строку в кодировку "поросячьей латыни" (Pig Latin). Первая согласная каждого слова перемещается в конец и к ней добавляется окончание "ay", так "first" станет "irst-fay". Слову, начинающемуся на гласную, в конец добавляется "hay" ("apple" становится "apple-hay"). Помните о подробностях работы с кодировкой UTF-8!</li>
<li>Используя хеш-карту и векторы, создайте текстовый внешняя оболочка позволяющий пользователю добавлять имена сотрудников к названию отдела компании. Например, "Add Sally to Engineering" или "Add Amir to Sales". Затем позвольте пользователю получить список всех людей из отдела или всех людей в компании, отсортированных по отделам в алфавитном порядке.</li>
</ul>
<p>Документация API встроенной библиотеки описывает методы у векторов, строк и HashMap. Советуем воспользоваться ей при решении упражнений.</p>
<p>Потихоньку мы переходим к более сложным программам, в которых действия могут потерпеть неудачу. Наступило наилучшее время для обсуждения обработки ошибок.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обработка-ошибок"><a class="header" href="#Обработка-ошибок">Обработка ошибок</a></h1>
<p>Возникновение ошибок в ходе выполнения программ — это суровая действительность в жизни программного обеспечения, поэтому Rust имеет ряд функций для обработки ситуаций, в которых что-то идёт не так. Во многих случаях Rust требует, чтобы вы признали возможность ошибки и предприняли некоторые действия, прежде чем ваш код будет собран. Это требование делает вашу программу более надёжной, обеспечивая, что вы обнаружите ошибки и обработаете их надлежащим образом, прежде чем развернёте свой код в производственной среде!</p>
<p>В Rust ошибки группируются на две основные разряды: <em>исправимые</em> (recoverable) и <em>неисправимые</em> (unrecoverable). В случае исправимой ошибки, такой как <em>файл не найден</em>, мы, скорее всего, просто хотим сообщить о проблеме пользователю и повторить действие. Неисправимые ошибки всегда являются симптомами изъянов в коде, например, попытка доступа к ячейке за пределами границ массива, и поэтому мы хотим немедленно остановить программу.</p>
<p>Большинство языков не различают эти два вида ошибок и обрабатывают оба вида одинаково, используя такие механизмы, как исключения. В Rust нет исключений. Вместо этого он имеет вид <code>Result&lt;T, E&gt;</code> для обрабатываемых (исправимых) ошибок и макрос <code>panic!</code>, который останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку. Сначала эта глава расскажет про вызов <code>panic!</code>, а потом расскажет о возврате значений <code>Result&lt;T, E&gt;</code>. Кроме того, мы рассмотрим, что нужно учитывать при принятии решения о том, следует ли попытаться исправить ошибку или остановить выполнение.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Неустранимые-ошибки-с-макросом-panic"><a class="header" href="#Неустранимые-ошибки-с-макросом-panic">Неустранимые ошибки с макросом <code>panic!</code></a></h2>
<p>Иногда в коде происходят плохие вещи, и вы ничего не можете с этим поделать. В этих случаях у Rust есть макрос panic! На практике существует два способа вызвать панику: путём выполнения действия, которое вызывает панику в нашем коде (например, обращение к массиву за пределами его размера) или путём явного вызова макроса <code>panic!</code>. В обоих случаях мы вызываем панику в нашей программе. По умолчанию паника выводит сообщение об ошибке, раскручивает и очищает стек вызовов, и завершают работу. С помощью переменной окружения вы также можете заставить Rust отображать стек вызовов при возникновении паники, чтобы было легче отследить источник паники.</p>
<blockquote>
<h3 id="Раскручивать-стек-или-прерывать-выполнение-программы-в-ответ-на-панику"><a class="header" href="#Раскручивать-стек-или-прерывать-выполнение-программы-в-ответ-на-панику">Раскручивать стек или прерывать выполнение программы в ответ на панику?</a></h3>
<p>По умолчанию, когда происходит паника, программа начинает процесс <em>раскрутки стека</em>, означающий в Rust проход обратно по стеку вызовов и очистку данных для каждой обнаруженной функции.  Тем не менее, этот обратный проход по стеку и очистка генерируют много работы. Rust как иное решение предоставляет вам возможность <em>немедленного прерывания</em> (aborting), которое завершает работу программы без очистки.</p>
<p>Память, которую использовала программа, должна быть очищена операционной системой. Если в вашем проекте нужно насколько это возможно сделать маленьким исполняемый файл, вы можете переключиться с варианта раскрутки стека на вариант прерывания при панике, добавьте <code>panic = 'abort'</code> в раздел [profile] вашего <code>Cargo.toml</code> файла. Например, если вы хотите прервать панику в режиме релиза, добавьте это:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Давайте попробуем вызвать <code>panic!</code> в простой программе:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>При запуске программы, вы увидите что-то вроде этого:</p>
<pre><code class="language-console">{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}

</code></pre>
<p>Выполнение макроса <code>panic!</code> вызывает сообщение об ошибке, содержащееся в двух последних строках. Первая строка показывает сообщение паники и место в исходном коде, где возникла паника: <em>src/main.rs:2:5</em> указывает, что это вторая строка, пятый символ внутри нашего файла <em>src/main.rs</em></p>
<p>В этом случае указанная строка является частью нашего кода, и если мы перейдём к этой строке, мы увидим  вызов макроса <code>panic!</code>. В других случаях вызов <code>panic!</code> мог бы произойти в стороннем коде, который вызывает наш код, тогда имя файла и номер строки для сообщения об ошибке будет из чужого кода, где макрос <code>panic!</code> выполнен, а не из строк нашего кода, которые в конечном итоге привели к выполнению <code>panic!</code>. Мы можем использовать обратную трассировку вызовов функций которые вызвали <code>panic!</code> чтобы выяснить, какая часть нашего кода вызывает проблему. Мы обсудим обратную трассировку более подробно далее.</p>
<h3 id="Использование-обратной-трассировки-panic"><a class="header" href="#Использование-обратной-трассировки-panic">Использование обратной трассировки <code>panic!</code></a></h3>
<p>Давайте посмотрим на другой пример, где, вызов <code>panic!</code> происходит в сторонней библиотеке из-за ошибки в нашем коде (а не как в примере ранее, из-за вызова макроса нашим кодом напрямую). В приложении 9-1 приведён код, который пытается получить доступ по порядковому указателю в векторе за пределами допустимого рядазначений порядкового указателя.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-1: Попытка доступа к элементу за пределами вектора, которая вызовет <code>panic!</code></span></p>
<p>Здесь мы пытаемся получить доступ к 100-му элементу вектора (который находится по порядковому указателю 99, потому что упорядочевание начинается с нуля), но вектор имеет только 3 элемента. В этой ситуации, Rust будет вызывать панику. Использование <code>[]</code> должно возвращать элемент, но вы передаёте неверный порядковый указатель: не существует элемента, который Rust мог бы вернуть.</p>
<p>В языке C, например, попытка прочесть за пределами конца структуры данных (в нашем случае векторе) приведёт к <em>неопределённому поведению, undefined behavior, UB</em>. Вы всё равно получите значение, которое находится в том месте памяти компьютера, которое соответствовало бы этому элементу в векторе, несмотря на то, что память по тому адресу совсем не принадлежит вектору (всё просто: C рассчитал бы место хранения элемента с порядковым казателем 99 и считал бы то, что там хранится, упс). Это называется <em>чтением за пределом буфера, buffer overread,</em> и может привести к уязвимостям безопасности. Если злоумышленник может манипулировать порядковым казателем таким образом, то у него появляется возможность читать данные, которые он не должен иметь возможности читать.</p>
<p>Чтобы защитить вашу программу от такого рода уязвимостей при попытке прочитать элемент с порядковым казателем, которого не существует, Rust остановит выполнение и откажется продолжить работу программы. Давайте попробуем так сделать и посмотрим на поведение Rust:</p>
<pre><code class="language-console">{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}
</code></pre>
<p>Следующая строка говорит, что мы можем установить переменную среды <code>RUST_BACKTRACE</code>, чтобы получить обратную трассировку того, что именно стало причиной ошибки. <em>Обратная трассировка</em> создаёт список всех функций, которые были вызваны до какой-то определённой точки выполнения программы. Обратная трассировка в Rust работает так же, как и в других языках. По этому предлагаем вам читать данные обратной трассировки как и везде - читать сверху вниз, пока не увидите сведения о файлах написанных вами. Это место, где возникла проблема. Другие строки, которые выше над строками с упоминанием наших файлов, - это код, который вызывается нашим кодом; строки ниже являются кодом, который вызывает наш код. Эти строки могут включать основной код Rust, код встроенной библиотеки или используемые крейты. Давайте попробуем получить обратную трассировку с помощью установки переменной среды <code>RUST_BACKTRACE</code> в любое значение, кроме 0. Приложение 9-2 показывает вывод, подобный тому, что вы увидите.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Приложение 9-2: Обратная трассировка, сгенерированная вызовом <code>panic!</code>, когда установлена переменная окружения <code>RUST_BACKTRACE</code></span></p>
<p>Тут много вывода! Вывод, который вы увидите, может отличаться от представленного, в зависимости от вашей операционной системы и исполнения Rust. Для того, чтобы получить обратную трассировку с этой сведениями, должны быть включены <em>символы отладки, debug symbols</em>. Символы отладки включены по умолчанию при использовании <code>cargo build</code> или <code>cargo run</code> без флага <code>--release</code>, как у нас в примере.</p>
<p>В выводе обратной трассировки приложения 9-2, строка #6 указывает на строку в нашем проекте, которая вызывала проблему: строка 4 из файла <em>src/main.rs.</em> Если мы не хотим, чтобы наша программа запаниковала, мы должны начать исследование с места, на которое указывает первая строка с упоминанием нашего файла. В приложении 9-1, где мы для отображения обратной трассировки сознательно написали код, который паникует, способ исправления паники состоит в том, чтобы не запрашивать элемент за пределами ряда значений порядковых указателей вектора. Когда ваш код запаникует в будущем, вам нужно будет выяснить, какое выполняющееся кодом действие, с какими значениями вызывает панику и что этот код должен делать вместо этого.</p>
<p>Мы вернёмся к обсуждению макроса <code>panic!</code>, и того когда нам следует и не следует использовать <code>panic!</code> для обработки ошибок в разделе <a data-md-type="raw_html" href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">"<code>panic!</code> или НЕ <code>panic!</code>"</a><!--  --> этой главы. Далее мы рассмотрим, как восстановить выполнение программы после исправляемых ошибок, использующих вид <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Исправимые-ошибки-с-result"><a class="header" href="#Исправимые-ошибки-с-result">Исправимые ошибки с <code>Result</code></a></h2>
<p>Многие ошибки являются не настолько критичными, чтобы останавливать выполнение программы. Иногда, когда в функции происходит сбой, необходима просто правильная преобразование и обработка ошибки. К примеру, при попытке открыть файл может произойти ошибка из-за отсутствия файла. Вы, возможно, захотите исправить ситуацию и создать новый файл вместо остановки программы.</p>
<p>Вспомните раздел ["Обработка потенциального сбоя с помощью <code>Result</code>"]<!-- ignore --> главы 2: мы использовали там перечисление <code>Result</code>, имеющее два варианта, <code>Ok</code> и <code>Err</code> для обработки сбоев. Само перечисление определено следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Виды <code>T</code> и <code>E</code> являются свойствами обобщённого вида: мы обсудим обобщённые виды более подробно в Главе 10. Все что вам нужно знать прямо сейчас - это то, что <code>T</code> представляет вид значения, которое будет возвращено в случае успеха внутри варианта <code>Ok</code>, а <code>E</code> представляет вид ошибки, которая будет возвращена при сбое внутри варианта <code>Err</code>. Так как вид <code>Result</code> имеет эти обобщённые свойства (generic type parameters), мы можем использовать вид <code>Result</code> и функции, которые определены для него, в разных ситуациях, когда вид успешного значение и значения ошибки, которые мы хотим вернуть, отличаются.</p>
<p>Давайте вызовем функцию, которая возвращает значение <code>Result</code>, потому что может потерпеть неудачу. В приложении 9-3 мы пытаемся открыть файл.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-3: Открытие файла</span></p>
<p><code>File::open</code> возвращает значения вида <code>Result&lt;T, E&gt;</code>. Универсальный вид <code>T</code> в реализации <code>File::open</code> соответствует виду успешно полученного значения, <code>std::fs::File</code>, а именно дескриптору файла. Вид <code>E</code>, используемый для значения в случае возникновения ошибки, - <code>std::io::Error</code>. Такой возвращаемый вид означает, что вызов <code>File::open</code> может быть успешным и вернуть дескриптор файла, из которого мы можем читать или в который можем писать. Также вызов функции может завершиться неудачей: например, файл может не существовать, или у нас может не быть разрешения на доступ к файлу. Функция <code>File::open</code> должна иметь способ сообщить нам об успехе или неудаче и в то же время дать нам либо дескриптор файла, либо сведения об ошибке. Эту возможность как раз и предоставляет перечисление <code>Result</code>.</p>
<p>В случае успеха <code>File::open</code> значением переменной <code>greeting_file_result</code> будет экземпляр <code>Ok</code>, содержащий дескриптор файла. В случае неудачи значение в переменной <code>greeting_file_result</code> будет экземпляром <code>Err</code>, содержащим дополнительную сведения о том, какая именно ошибка произошла.</p>
<p>Необходимо дописать в код приложения 9-3 выполнение разных действий в зависимости от значения, которое вернёт вызов <code>File::open</code>. Приложение 9-4 показывает один из способов обработки <code>Result</code> - пользуясь основным средством языка, таким как выражение <code>match</code>, рассмотренным в Главе 6.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-4: Использование выражения <code>match</code> для обработки возвращаемых вариантов вида <code>Result</code></span></p>
<p>Обратите внимание, что также как перечисление <code>Option</code>, перечисление <code>Result</code> и его варианты, входят в область видимости благодаря авто-импорту (prelude), поэтому не нужно указывать <code>Result::</code> перед использованием вариантов <code>Ok</code> и <code>Err</code> в ветках выражения <code>match</code>.</p>
<p>Если результатом будет <code>Ok</code>, этот код вернёт значение <code>file</code> из варианта <code>Ok</code>, а мы затем присвоим это значение файлового дескриптора переменной <code>greeting_file</code>. После <code>match</code> мы можем использовать дескриптор файла для чтения или записи.</p>
<p>Другая ветвь <code>match</code> обрабатывает случай, где мы получаем значение <code>Err</code> после вызова <code>File::open</code>. В этом примере мы решили вызвать макрос <code>panic!</code>. Если в нашей текущей папки нет файла с именем <em>hello.txt</em> и мы выполним этот код, то мы увидим следующее сообщение от макроса <code>panic!</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
</code></pre>
<p>Как обычно, данное сообщение точно говорит, что пошло не так.</p>
<h3 id="Обработка-различных-ошибок-с-помощью-match"><a class="header" href="#Обработка-различных-ошибок-с-помощью-match">Обработка различных ошибок с помощью match</a></h3>
<p>Код в приложении 9-4 будет вызывать <code>panic!</code> независимо от того, почему вызов <code>File::open</code> не удался. Однако мы хотим предпринять различные действия для разных причин сбоя. Если открытие <code>File::open</code> не удалось из-за отсутствия файла, мы хотим создать файл и вернуть его дескриптор. Если вызов <code>File::open</code> не удался по любой другой причине - например, потому что у нас не было прав на открытие файла, то все равно мы хотим вызвать <code>panic!</code> как у нас сделано в приложении 9-4. Для этого мы добавляем выражение внутреннего <code>match</code>, показанное в приложении 9-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 9-5: Обработка различных ошибок разными способами</span></p>
<p>Видом значения возвращаемого функцией <code>File::open</code> внутри <code>Err</code> варианта является <code>io::Error</code>, структура из встроенной библиотеки. Данная структура имеет способ <code>kind</code>, который можно вызвать для получения значения <code>io::ErrorKind</code>. Перечисление <code>io::ErrorKind</code> из встроенной библиотеки имеет варианты, представляющие различные виды ошибок, которые могут появиться при выполнении действий в <code>io</code>. Вариант, который мы хотим использовать, это <code>ErrorKind::NotFound</code>, который даёт сведения, о том, что файл который мы пытаемся открыть ещё не существует. Итак, во второй строке мы вызываем сопоставление шаблона с переменной <code>greeting_file_result</code> и попадаем в ветку с обработкой ошибки, но также у нас есть внутренняя проверка для сопоставления <code>error.kind()</code> ошибки.</p>
<p>Условие, которое мы хотим проверить во внутреннем <code>match</code>, заключается в том, является ли значение, возвращаемое <code>error.kind()</code>, вариантом <code>NotFound</code> перечисления <code>ErrorKind</code>. Если это так, мы пытаемся создать файл с помощью функции <code>File::create</code>. Однако, поскольку вызов <code>File::create</code> тоже может завершиться ошибкой, нам нужна обработка ещё одной ошибки, теперь уже во внутреннем выражении <code>match</code>. Заметьте: если файл не может быть создан, выводится другое, особое сообщение об ошибке. Вторая же ветка внешнего <code>match</code> (который обрабатывает вызов <code>error.kind()</code>), остаётся той же самой - в итоге программа паникует при любой ошибке, кроме ошибки отсутствия файла.</p>
<blockquote>
<h3 id="Иные-использованию-match-с-resultt-e"><a class="header" href="#Иные-использованию-match-с-resultt-e">Иные использованию <code>match</code> с <code>Result&lt;T, E&gt;</code></a></h3>
<p>Как много <code>match</code>! Выражение <code>match</code> является очень полезным, но в то же время довольно примитивным. В главе 13 вы узнаете о замыканиях (closures), которые используются во многих способах вида <code>Result&lt;T, E&gt;</code>. Эти способы помогают быть более лаконичным, чем использование <code>match</code> при работе со значениями <code>Result&lt;T, E&gt;</code> в вашем коде.</p>
<p>Например, вот другой способ написать ту же логику, что показана в Приложении 9-5, но с использованием замыканий и способа <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}</code></pre>
<p>Несмотря на то, что данный код имеет такое же поведение как в приложении 9-5, он не содержит ни одного выражения <code>match</code> и проще для чтения. Советуем вам вернуться к примеру этого раздела после того как вы прочитаете Главу 13 и изучите способ <code>unwrap_or_else</code> по документации встроенной библиотеки. Многие из способов о которых вы узнаете в документации и Главе 13 могут очистить код от больших, вложенных выражений <code>match</code> при обработке ошибок.</p>
</blockquote>
<h3 id="Лаконичные-способы-обработки-ошибок---unwrap-и-expect"><a class="header" href="#Лаконичные-способы-обработки-ошибок---unwrap-и-expect">Лаконичные способы обработки ошибок - <code>unwrap</code> и <code>expect</code></a></h3>
<p>Использование <code>match</code> работает достаточно хорошо, но может быть довольно многословным и не всегда хорошо передаёт смысл. Вид <code>Result&lt;T, E&gt;</code> имеет множество вспомогательных способов для выполнения различных, более отличительных задач. Способ <code>unwrap</code> - это способ быстрого доступа к значениям, реализованный так же, как и выражение <code>match</code>, которое мы написали в Приложении 9-4. Если значение <code>Result</code> является вариантом <code>Ok</code>, <code>unwrap</code> возвращает значение внутри <code>Ok</code>. Если <code>Result</code> - вариант <code>Err</code>, то <code>unwrap</code> вызовет для нас макрос <code>panic!</code>. Вот пример <code>unwrap</code> в действии:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Если мы запустим этот код при отсутствии файла <em>hello.txt</em>, то увидим сообщение об ошибке из вызова <code>panic!</code> способа <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
</code></pre>
<p>Другой способ, похожий на <code>unwrap</code>, это <code>expect</code>, позволяющий указать сообщение об ошибке для макроса <code>panic!</code>. Использование <code>expect</code> вместо <code>unwrap</code> с предоставлением хорошего сообщения об ошибке выражает ваше намерение и делает более простым отслеживание источника паники. Синтаксис способа <code>expect</code> выглядит так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><code>expect</code> используется так же как и <code>unwrap</code>: либо возвращается дескриптор файла либо вызывается макрос <code>panic!</code>.<br>Наше сообщение об ошибке в <code>expect</code> будет передано в <code>panic!</code> и заменит стандартное используемое сообщение.<br>Вот как это выглядит:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
</code></pre>
<p>В рабочем коде, большинство выбирает <code>expect</code> в угоду <code>unwrap</code> и добавляет описание, почему действие должна закончиться успешно. Но даже если предположение оказалось неверным, сведений для отладки будет больше.</p>
<h3 id="Проброс-ошибок"><a class="header" href="#Проброс-ошибок">Проброс ошибок</a></h3>
<p>Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать. Такой приём известен как <em>распространение ошибки</em> (<em>propagating the error</em>). Благодаря нему мы даём больше управления вызывающему коду, где может быть больше сведений или логики, которая диктует, как ошибка должна обрабатываться, чем было бы в месте появления этой ошибки.</p>
<p>Например, код программы 9-6 читает имя пользователя из файла. Если файл не существует или не может быть прочтён, то функция возвращает ошибку в код, который вызвал данную функцию.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-6: Функция, которая возвращает ошибки в вызывающий код, используя оператор <code>match</code></span></p>
<p>Эта функция может быть написана гораздо более коротким способом, но мы начнём с того, что многое сделаем вручную, чтобы изучить обработку ошибок; а в конце покажем более короткий способ. Давайте сначала рассмотрим вид возвращаемого значения: <code>Result&lt;String, io::Error&gt;</code>. Здесь есть возвращаемое значение функции вида <code>Result&lt;T, E&gt;</code> где шаблонный свойство <code>T</code> был заполнен определенным видом <code>String</code> и шаблонный свойство <code>E</code> был заполнен определенным видом <code>io::Error</code>.</p>
<p>Если эта функция выполнится без проблем, то код, вызывающий эту функцию, получит значение <code>Ok</code>, содержащее <code>String</code> - имя пользователя, которое эта функция прочитала из файла. Если функция столкнётся с какими-либо проблемами, вызывающий код получит значение <code>Err</code>, содержащее экземпляр <code>io::Error</code>, который включает дополнительную сведения о том, какие проблемы возникли. Мы выбрали <code>io::Error</code> в качестве возвращаемого вида этой функции, потому что это вид значения ошибки, возвращаемого из обеих действий, которые мы вызываем в теле этой функции и которые могут завершиться неудачей: функция <code>File::open</code> и способ <code>read_to_string</code>.</p>
<p>Тело функции начинается с вызова <code>File::open</code>. Затем мы обрабатываем значение <code>Result</code> с помощью <code>match</code>, подобно <code>match</code> из приложения 9-4. Если <code>File::open</code> завершается успешно, то дескриптор файла в переменной образца <code>file</code> становится значением в изменяемой переменной <code>username_file</code> и функция продолжит свою работу. В случае <code>Err</code>, вместо вызова <code>panic!</code>, мы используем ключевое слово <code>return</code> для досрочного возврата из функции и передаём значение ошибки из <code>File::open</code>, которое теперь находится в переменной образца <code>e</code>, обратно в вызывающий код как значение ошибки этой функции.</p>
<p>Таким образом, если у нас есть файловый дескриптор в <code>username_file</code>, функция создаёт новую <code>String</code> в переменной <code>username</code> и вызывает способ <code>read_to_string</code> для файлового дескриптора в <code>username_file</code>, чтобы прочитать содержимое файла в <code>username</code>. Способ <code>read_to_string</code> также возвращает <code>Result</code>, потому что он может потерпеть неудачу, даже если <code>File::open</code> завершился успешно. Поэтому нам нужен ещё один <code>match</code> для обработки этого <code>Result</code>: если <code>read_to_string</code> завершится успешно, то наша функция сработала, и мы возвращаем имя пользователя из файла, которое теперь находится в <code>username</code>, обёрнутое в <code>Ok</code>. Если <code>read_to_string</code> потерпит неудачу, мы возвращаем значение ошибки таким же образом, как мы возвращали значение ошибки в <code>match</code>, который обрабатывал возвращаемое значение <code>File::open</code>. Однако нам не нужно явно указывать <code>return</code>, потому что это последнее выражение в функции.</p>
<p>Затем код, вызывающий этот, будет обрабатывать получение либо значения <code>Ok</code>, содержащего имя пользователя, либо значения <code>Err</code>, содержащего <code>io::Error</code>. Вызывающий код должен решить, что делать с этими значениями. Если вызывающий код получает значение <code>Err</code>, он может вызвать <code>panic!</code> и завершить работу программы, использовать имя пользователя по умолчанию или найти имя пользователя, например, не в файле. У нас недостаточно сведений о том, что на самом деле пытается сделать вызывающий код, поэтому мы распространяем всю сведения об успехах или ошибках вверх, чтобы она могла обрабатываться соответствующим образом.</p>
<p>Эта схема передачи ошибок настолько распространена в Rust, что Rust предоставляет оператор вопросительного знака <code>?</code>, чтобы облегчить эту задачу.</p>
<h4 id="Сокращение-для-проброса-ошибок-оператор-"><a class="header" href="#Сокращение-для-проброса-ошибок-оператор-">Сокращение для проброса ошибок: оператор <code>?</code></a></h4>
<p>В приложении 9-7 показана реализация <code>read_username_from_file</code>, которая имеет ту же функциональность, что и в приложении 9-6, но в этой реализации используется оператор <code>?</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-7: Функция, возвращающая ошибки в вызывающий код с помощью оператора <code>?</code></span></p>
<p>Выражение <code>?</code>, расположенное после <code>Result</code>, работает почти так же, как и те выражения <code>match</code>, которые мы использовали для обработки значений <code>Result</code> в приложении 9-6. Если в качестве значения <code>Result</code> будет <code>Ok</code>, то значение внутри <code>Ok</code> будет возвращено из этого выражения, и программа продолжит работу. Если же значение представляет собой <code>Err</code>, то <code>Err</code> будет возвращено из всей функции, как если бы мы использовали ключевое слово <code>return</code>, так что значение ошибки будет передано в вызывающий код.</p>
<p>Существует разница между тем, что делает выражение <code>match</code> из приложения 9-6 и тем, что делает оператор <code>?</code>: значения ошибок, для которых вызван оператор <code>?</code>, проходят через функцию <code>from</code>, определённую в трейте <code>From</code> встроенной библиотеки, которая используется для преобразования значений из одного вида в другой. Когда оператор <code>?</code> вызывает функцию <code>from</code>, полученный вид ошибки преобразуется в вид ошибки, определённый в возвращаемом виде текущей функции. Это полезно, когда функция возвращает только один вид ошибки, для описания всех возможных вариантов сбоев, даже если её отдельные компоненты могут выходить из строя по разным причинам.</p>
<p>Например, мы могли бы изменить функцию <code>read_username_from_file</code> в приложении 9-7, чтобы возвращать пользовательский вид ошибки с именем <code>OurError</code>, который мы определим. Если мы также определим <code>impl From&lt;io::Error&gt; for OurError</code> для создания экземпляра <code>OurError</code> из <code>io::Error</code>, то оператор <code>?</code>, вызываемый в теле <code>read_username_from_file</code>, вызовет <code>from</code> и преобразует виды ошибок без необходимости добавления дополнительного кода в функцию.</p>
<p>В случае приложения 9-7 оператор <code>?</code> в конце вызова <code>File::open</code> вернёт значение внутри <code>Ok</code> в переменную <code>username_file</code>. Если произойдёт ошибка, оператор <code>?</code> выполнит ранний возврат значения <code>Err</code> вызывающему коду. То же самое относится к оператору <code>?</code> в конце вызова <code>read_to_string</code>.</p>
<p>Оператор <code>?</code> позволяет избавиться от большого количества шаблонного кода и упростить реализацию этой функции. Мы могли бы даже ещё больше сократить этот код, если бы использовали цепочку вызовов способов сразу после <code>?</code>, как показано в приложении 9-8.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-8: Цепочка вызовов способов после оператора <code>?</code></span></p>
<p>Мы перенесли создание новой <code>String</code> в <code>username</code> в начало функции; эта часть не изменилась. Вместо создания переменной <code>username_file</code> мы соединили вызов <code>read_to_string</code> непосредственно с результатом <code>File::open("hello.txt")?</code>. У нас по-прежнему есть <code>?</code> в конце вызова <code>read_to_string</code>, и мы по-прежнему возвращаем значение <code>Ok</code>, содержащее <code>username</code>, когда и <code>File::open</code> и <code>read_to_string</code> завершаются успешно, а не возвращают ошибки. Функциональность снова такая же, как в Приложении 9-6 и Приложении 9-7; это просто другой, более эргономичный способ её написания.</p>
<p>Продолжая рассматривать разные способы записи данной функции, приложение 9-9 отображает способ сделать её ещё короче с помощью <code>fs::read_to_string</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-9: Использование <code>fs::read_to_string</code> вместо открытия и последующего чтения файла</span></p>
<p>Чтение файла в строку довольно распространённая действие, так что стандартная библиотека предоставляет удобную функцию <code>fs::read_to_string</code>, которая открывает файл, создаёт новую <code>String</code>, читает содержимое файла, размещает его в <code>String</code> и возвращает её. Конечно, использование функции <code>fs::read_to_string</code> не даёт возможности объяснить обработку всех ошибок, поэтому мы сначала изучили длинный способ.</p>
<h4 id="Где-можно-использовать-оператор-"><a class="header" href="#Где-можно-использовать-оператор-">Где можно использовать оператор <code>?</code></a></h4>
<p>Оператор <code>?</code> может использоваться только в функциях, вид возвращаемого значения которых совместим со значением, для которого используется <code>?</code>. Это потому, что оператор <code>?</code> определён для выполнения раннего возврата значения из функции таким же образом, как и выражение <code>match</code>, которое мы определили в приложении 9-6. В приложении 9-6 <code>match</code> использовало значение <code>Result</code>, а ответвление с ранним возвратом вернуло значение <code>Err(e)</code>. Вид возвращаемого значения функции должен быть <code>Result</code>, чтобы он был совместим с этим <code>return</code>.</p>
<p>В приложении 9-10 давайте посмотрим на ошибку, которую мы получим, если воспользуемся оператором <code>?</code> в функции <code>main</code> с видом возвращаемого значения, несовместимым с видом значения, для которого мы используем <code>?</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 9-10: Попытка использовать <code>?</code> в <code>main</code> функции, которая возвращает <code>()</code> , не будет собираться</span></p>
<p>Этот код открывает файл, что может привести к сбою. <code>?</code> оператор следует за значением <code>Result</code> , возвращаемым <code>File::open</code> , но эта <code>main</code> функция имеет возвращаемый вид <code>()</code> , а не <code>Result</code> . Когда мы собираем этот код, мы получаем следующее сообщение об ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}
</code></pre>
<p>Эта ошибка указывает на то, что оператор <code>?</code> разрешено использовать только в функции, которая возвращает <code>Result</code>, <code>Option</code> или другой вид, реализующий <code>FromResidual</code>.</p>
<p>Для исправления ошибки есть два варианта. Первый - изменить возвращаемый вид вашей функции так, чтобы он был совместим со значением, для которого вы используете оператор <code>?</code>, если у вас нет ограничений, препятствующих этому. Другой способ - использовать <code>match</code> или один из способов <code>Result&lt;T, E&gt;</code> для обработки <code>Result&lt;T, E&gt;</code> любым подходящим способом.</p>
<p>В сообщении об ошибке также упоминалось, что <code>?</code> можно использовать и со значениями <code>Option&lt;T&gt;</code>. Как и при использовании <code>?</code> для <code>Result</code>, вы можете использовать <code>?</code> только для <code>Option</code> в функции, которая возвращает <code>Option</code>. Поведение оператора <code>?</code> при вызове <code>Option&lt;T&gt;</code> похоже на его поведение при вызове <code>Result&lt;T, E&gt;</code>: если значение равно <code>None</code>, то <code>None</code> будет возвращено раньше из функции в этот момент. Если значение <code>Some</code>, значение внутри <code>Some</code> является результирующим значением выражения, и функция продолжает исполняться. В приложении 9-11 приведён пример функции, которая находит последний символ первой строки заданного текста:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-11: Использование оператора <code>?</code> для значения <code>Option&lt;T&gt;</code></span></p>
<p>Эта функция возвращает <code>Option&lt;char&gt;</code>, потому что возможно, что там есть символ, но также возможно, что его нет. Этот код принимает переменная среза <code>text</code> строки и вызывает для него способ <code>lines</code>, который возвращает повторительдля строк в строке. Поскольку эта функция хочет проверить первую строку, она вызывает <code>next</code> у повторителя, чтобы получить первое значение от повторителя. Если <code>text</code> является пустой строкой, этот вызов <code>next</code> вернёт <code>None</code>, и в этом случае мы используем <code>?</code> чтобы остановить и вернуть <code>None</code> из <code>last_char_of_first_line</code>. Если <code>text</code> не является пустой строкой, <code>next</code> вернёт значение <code>Some</code>, содержащее фрагмент строки первой строки в <code>text</code>.</p>
<p>Символ <code>?</code> извлекает фрагмент строки, и мы можем вызвать <code>chars</code> для этого фрагмента строки. чтобы получить повторительсимволов. Нас важно последний символ в первой строке, поэтому мы вызываем <code>last</code>, чтобы вернуть последний элемент в повторителе. Вернётся <code>Option</code>, потому что возможно, что первая строка пустая - например, если <code>text</code> начинается с пустой строки, но имеет символы в других строках, как в <code>"\nhi"</code>. Однако, если в первой строке есть последний символ, он будет возвращён в варианте <code>Some</code>. Оператор <code>?</code> в середине даёт нам лаконичный способ выразить эту логику, позволяя реализовать функцию в одной строке. Если бы мы не могли использовать оператор <code>?</code> в <code>Option</code>, нам пришлось бы реализовать эту логику, используя больше вызовов способов или выражение <code>match</code>.</p>
<p>Обратите внимание, что вы можете использовать оператор <code>?</code> <code>Result</code> в функции, которая возвращает <code>Result</code> , и вы можете использовать оператор <code>?</code> для <code>Option</code> в функции, которая возвращает <code>Option</code> , но вы не можете смешивать и сопоставлять. Оператор <code>?</code> не будет самостоятельно преобразовывать <code>Result</code> в <code>Option</code> или наоборот; в этих случаях вы можете использовать такие способы, как способ <code>ok</code> для <code>Result</code> или способ <code>ok_or</code> для <code>Option</code>, чтобы выполнить преобразование явно.</p>
<p>До сих пор все функции <code>main</code>, которые мы использовали, возвращали <code>()</code>. Функция <code>main</code> - особенная, потому что это точка входа и выхода исполняемых программ, и существуют ограничения на вид возвращаемого значения, чтобы программы вели себя так, как ожидается.</p>
<p>К счастью, <code>main</code> также может возвращать <code>Result&lt;(), E&gt;</code> . В приложении 9-12 используется код из приложения 9-10, но мы изменили возвращаемый вид <code>main</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> и добавили возвращаемое значение <code>Ok(())</code> в конец. Теперь этот код будет собран:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 9-12: Замена <code>main</code> на return <code>Result&lt;(), E&gt;</code> позволяет использовать оператор <code>?</code> оператор над значениями <code>Result</code></span></p>
<p>Вид <code>Box&lt;dyn Error&gt;</code> является <em>трейт-объектом</em>, о котором мы поговорим в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование трейт-объектов, допускающих значения разных видов"</a><!-- ignore --> в главе 17. Пока что вы можете считать, что <code>Box&lt;dyn Error&gt;</code> означает "любой вид ошибки". Использование <code>?</code> для значения <code>Result</code> в функции <code>main</code> с видом ошибки <code>Box&lt;dyn Error&gt;</code> разрешено, так как позволяет вернуть любое значение <code>Err</code> раньше времени. Даже если тело этой функции <code>main</code> будет возвращать только ошибки вида <code>std::io::Error</code>, указав <code>Box&lt;dyn Error&gt;</code>, эта сигнатура останется корректной, даже если в тело <code>main</code> будет добавлен код, возвращающий другие ошибки.</p>
<p>Когда <code>main</code> функция возвращает <code>Result&lt;(), E&gt;</code>, исполняемый файл завершится со значением <code>0</code>, если <code>main</code> вернёт <code>Ok(())</code>, и выйдет с ненулевым значением, если <code>main</code> вернёт значение <code>Err</code>. Исполняемые файлы, написанные на C, при выходе возвращают целые числа: успешно завершённые программы возвращают целое число <code>0</code>, а программы с ошибкой возвращают целое число, отличное от <code>0</code>. Rust также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этим соглашением.</p>
<p>Функция <code>main</code> может возвращать любые виды, реализующие <a href="../std/process/trait.Termination.html">трейт <code>std::process::Termination</code></a><!-- ignore -->, в которых имеется функция <code>report</code>, возвращающая <code>ExitCode</code>. Обратитесь к документации встроенной библиотеки за дополнительной сведениями о порядке реализации трейта <code>Termination</code> для ваших собственных видов.</p>
<p>Теперь, когда мы обсудили подробности вызова <code>panic!</code> или возврата <code>Result</code>, давайте вернёмся к тому, как решить, какой из случаев подходит для какой ситуации.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-или-не-panic"><a class="header" href="#panic-или-не-panic"><code>panic!</code> или не <code>panic!</code></a></h2>
<p>Итак, как принимается решение о том, когда следует вызывать <code>panic!</code>, а когда вернуть <code>Result</code>? При панике код не имеет возможности восстановить своё выполнение. Можно было бы вызывать <code>panic!</code> для любой ошибочной ситуации, независимо от того, имеется ли способ восстановления или нет, но с другой стороны, вы принимаете решение от имени вызывающего вас кода, что ситуация необратима. Когда вы возвращаете значение <code>Result</code>, вы делегируете принятие решения вызывающему коду. Вызывающий код может попытаться выполнить восстановление способом, который подходит в данной ситуации, или же он может решить, что из ошибки в  <code>Err</code> нельзя восстановиться и вызовет <code>panic!</code>, превратив вашу исправимую ошибку в неисправимую. Поэтому возвращение <code>Result</code> является хорошим выбором по умолчанию для функции, которая может дать сбой.</p>
<p>В таких ситуация как примеры, протовиды и тесты, более уместно писать код, который паникует вместо возвращения <code>Result</code>. Давайте рассмотрим почему, а затем мы обсудим ситуации, в которых сборщик не может доказать, что ошибка невозможна, но вы, как человек, можете это сделать. Глава будет заканчиваться некоторыми общими руководящими принципами о том, как решить, стоит ли паниковать в коде библиотеки.</p>
<h3 id="Примеры-прототипирование-и-тесты"><a class="header" href="#Примеры-прототипирование-и-тесты">Примеры, прототипирование и тесты</a></h3>
<p>Когда вы пишете пример, отображающий некоторую концепцию, наличие хорошего кода обработки ошибок может сделать пример менее понятным. Понятно, что в примерах вызов способа <code>unwrap</code>, который может привести к панике, является лишь обозначением способа обработки ошибок в приложении, который может отличаться в зависимости от того, что делает остальная часть кода.</p>
<p>Точно так же способы <code>unwrap</code> и <code>expect</code> являются очень удобными при создании протовида, прежде чем вы будете готовы решить, как обрабатывать ошибки. Они оставляют чёткие маркеры в коде до момента, когда вы будете готовы сделать программу более надёжной.</p>
<p>Если в тесте происходит сбой при вызове способа, то вы бы хотели, чтобы весь тест не прошёл, даже если этот способ не является тестируемой функциональностью. Поскольку вызов <code>panic!</code> это способ, которым тест помечается как провалившийся, использование <code>unwrap</code> или <code>expect</code> - именно то, что нужно.</p>
<h3 id="Случаи-в-которых-у-вас-больше-сведений-чем-у-сборщика"><a class="header" href="#Случаи-в-которых-у-вас-больше-сведений-чем-у-сборщика">Случаи, в которых у вас больше сведений, чем у сборщика</a></h3>
<p>Также было бы целесообразно вызывать <code>unwrap</code> или <code>expect</code> когда у вас есть какая-то другая логика, которая заверяет, что <code>Result</code> будет иметь значение <code>Ok</code>, но вашу логику не понимает сборщик. У вас по-прежнему будет значение <code>Result</code> которое нужно обработать: любая действие, которую вы вызываете, все ещё имеет возможность неудачи в целом, хотя это логически невозможно в вашей именно ситуации. Если, проверяя код вручную, вы можете убедиться, что никогда не будет вариант с <code>Err</code>, то вполне допустимо вызывать <code>unwrap</code>, а ещё лучше задокументировать причину, по которой, по вашему мнению, у вас никогда не будет варианта <code>Err</code> в тексте <code>expect</code>. Вот пример:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы создаём экземпляр <code>IpAddr</code>, анализируя жёстко закодированную строку. Можно увидеть, что <code>127.0.0.1</code> является действительным IP-адресом, поэтому здесь допустимо использование <code>expect</code>. Однако наличие жёстко закодированной допустимой строки не меняет вид возвращаемого значения способа <code>parse</code>: мы все ещё получаем значение <code>Result</code> и сборщик все также заставляет нас обращаться с <code>Result</code>так, будто возможен вариант <code>Err</code>, потому что сборщик недостаточно умён, чтобы увидеть, что эта строка всегда действительный IP-адрес. Если строка IP-адреса пришла от пользователя, то она не является жёстко запрограммированной в программе и, следовательно, <em>может</em> привести к ошибке, мы определённо хотели бы обработать <code>Result</code> более надёжным способом. Упоминание предположения о том, что этот IP-адрес жёстко закодирован, побудит нас изменить <code>expect</code> для лучшей обработки ошибок, если в будущем нам потребуется вместо этого получить IP-адрес из какого-либо другого источника.</p>
<h3 id="Руководство-по-обработке-ошибок"><a class="header" href="#Руководство-по-обработке-ошибок">Руководство по обработке ошибок</a></h3>
<p>Желательно, чтобы код паниковал, если он может оказаться в некорректном состоянии. В этом среде <em>некорректное состояние</em> это когда некоторое допущение, заверение, контракт или инвариант были нарушены. Например, когда недопустимые, противоречивые или пропущенные значения передаются в ваш код - плюс один или несколько пунктов из следующего перечисленного в списке:</p>
<ul>
<li>Некорректное состояние — это что-то неожиданное, отличается от того, что может происходить время от времени, например, когда пользователь вводит данные в неправильном формате.</li>
<li>Ваш код после этой точки должен полагаться на то, что он не находится в некорректном состоянии, вместо проверок наличия проблемы на каждом этапе.</li>
<li>Нет хорошего способа закодировать данную сведения в видах, которые вы используете. Мы рассмотрим пример того, что мы имеем в виду в разделе <a href="ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“Кодирование состояний и поведения на основе видов”</a><!-- ignore --> главы 17.</li>
</ul>
<p>Если кто-то вызывает ваш код и передаёт значения, которые не имеют смысла, лучше всего вернуть ошибку, если вы это можете, чтобы пользователь библиотеки мог решить, что он хочет делать в этом случае. Однако в тех случаях, когда продолжение выполнения программы может быть небезопасным или вредным, лучшим выбором будет вызов <code>panic!</code> и оповещение пользователя, использующего вашу библиотеку, об ошибке в его коде, чтобы он мог исправить её во время разработки. Подобно <code>panic!</code> подходит, если вы вызываете внешний, неподуправлениеный вам код, и он возвращает недопустимое состояние, которое вы не можете исправить.</p>
<p>Однако, когда ожидается сбой, лучше вернуть <code>Result</code>, чем выполнить вызов <code>panic!</code>.  В качестве примера можно привести синтаксический анализатор, которому передали неправильно сформированные данные, или HTTP-запрос, возвращающий статус указывающий на то, что вы достигли ограничения на частоту запросов. В этих случаях возврат <code>Result</code> означает, что ошибка является ожидаемой и вызывающий код должен решить, как её обрабатывать.</p>
<p>Когда ваш код выполняет действие, которая может подвергнуть пользователя риску, если она вызывается с использованием недопустимых значений, ваш код должен сначала проверить допустимость значений и паниковать, если значения недопустимы. Так советуется делать в основном из соображений безопасности: попытка оперировать некорректными данными может привести к уязвимостям. Это основная причина, по которой стандартная библиотека будет вызывать <code>panic!</code>, если попытаться получить доступ к памяти вне границ массива: доступ к памяти, не относящейся к текущей структуре данных, является известной проблемой безопасности. Функции часто имеют контракты: их поведение обеспечивается, только если входные данные отвечают определённым требованиям. Паника при нарушении контракта имеет смысл, потому что это всегда указывает на изъян со стороны вызывающего кода, и это не ошибка, которую вы хотели бы, чтобы вызывающий код явно обрабатывал. На самом деле, нет разумного способа для восстановления вызывающего кода; программисты, вызывающие ваш код, должны исправить свой. Контракты для функции, особенно когда нарушение вызывает панику, следует описать в документации по API функции.</p>
<p>Тем не менее, наличие множества проверок ошибок во всех ваших функциях было бы многословным и раздражительным. К счастью, можно использовать систему видов Rust (следовательно и проверку видов сборщиком), чтобы она сделала множество проверок вместо вас. Если ваша функция имеет определённый вид в качестве свойства, вы можете продолжить работу с логикой кода зная, что сборщик уже обеспечил правильное значение. Например, если используется обычный вид, а не вид <code>Option</code>, то ваша программа ожидает наличие <em>чего-то</em> вместо <em>ничего</em>. Ваш код не должен будет обрабатывать оба варианта <code>Some</code> и <code>None</code>: он будет иметь только один вариант для определённого значения. Код, пытающийся ничего не передавать в функцию, не будет даже собираться, поэтому ваша функция не должна проверять такой случай во время выполнения. Другой пример - это использование целого вида без знака, такого как <code>u32</code>, который заверяет, что свойство никогда не будет отрицательным.</p>
<h3 id="Создание-пользовательских-видов-для-проверки"><a class="header" href="#Создание-пользовательских-видов-для-проверки">Создание пользовательских видов для проверки</a></h3>
<p>Давайте разовьём идею использования системы видов Rust чтобы убедиться, что у нас есть корректное значение, и рассмотрим создание пользовательского вида для валидации. Вспомним игру угадывания числа из Главы 2, в которой наш код просил пользователя угадать число между 1 и 100. Мы никогда не проверяли, что предположение пользователя лежит между этими числами, перед сравнением предположения с загаданным нами числом; мы только проверяли, что оно положительно. В этом случае последствия были не очень страшными: наши сообщения «Слишком много» или «Слишком мало», выводимые в окно вывода, все равно были правильными. Но было бы лучше подталкивать пользователя к правильным догадкам и иметь различное поведение для случаев, когда пользователь предлагает число за пределами ряда, и когда пользователь вводит, например, буквы вместо цифр.</p>
<p>Один из способов добиться этого - пытаться разобрать введённое значение как <code>i32</code>, а не как <code>u32</code>, чтобы разрешить потенциально отрицательные числа, а затем добавить проверку для нахождение числа в ряде, например, так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}</code></pre>
<p>Выражение <code>if</code> проверяет, находится ли наше значение вне ряда, сообщает пользователю о проблеме и вызывает <code>continue</code>, чтобы начать следующую повторение цикла и попросить ввести другое число. После выражения <code>if</code> мы можем продолжить сравнение значения <code>guess</code> с загаданным числом, зная, что <code>guess</code> лежит в ряде от 1 до 100.</p>
<p>Однако это не наилучшее решение: если бы было чрезвычайно важно, чтобы программа работала только со значениями от 1 до 100, существовало бы много функций, требующих этого, то такая проверка в каждой функции была бы утомительной (и могла бы отрицательно повлиять на производительность).</p>
<p>Вместо этого можно создать новый вид и поместить проверки в функцию создания экземпляра этого вида, не повторяя их везде. Таким образом, функции могут использовать новый вид в своих сигнатурах и быть уверены в значениях, которые им передают. Приложение 9-13 показывает один из способов, как определить вид <code>Guess</code>, чтобы экземпляр <code>Guess</code> создавался только при условии, что функция <code>new</code> получает значение от 1 до 100.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../listings/ch09-error-handling/listing-09-13/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 9-13. Вид <code>Guess</code>, который будет создавать экземпляры только для значений от 1 до 100</span></p>
<p>Сначала мы определяем структуру с именем <code>Guess</code>, которая имеет поле с именем <code>value</code> вида <code>i32</code>, в котором будет храниться число.</p>
<p>Затем мы реализуем ассоциированную функцию <code>new</code>, создающую экземпляры значений вида <code>Guess</code>. Функция <code>new</code>  имеет один свойство <code>value</code> вида <code>i32</code>, и возвращает <code>Guess</code>. Код в теле функции <code>new</code> проверяет, что значение <code>value</code> находится между 1 и 100. Если <code>value</code> не проходит эту проверку, мы вызываем <code>panic!</code>, которая оповестит программиста, написавшего вызывающий код, что в его коде есть ошибка, которую необходимо исправить, поскольку попытка создания <code>Guess</code> со значением <code>value</code> вне заданного ряда нарушает контракт, на который полагается <code>Guess::new</code>. Условия, в которых <code>Guess::new</code> паникует, должны быть описаны в документации к API; мы рассмотрим соглашения о документации, указывающие на возможность появления <code>panic!</code> в документации API, которую вы создадите в Главе 14. Если <code>value</code> проходит проверку, мы создаём новый экземпляр <code>Guess</code>, у которого значение поля  <code>value</code> равно значению свойства <code>value</code>, и возвращаем <code>Guess</code>.</p>
<p>Затем мы реализуем способ с названием <code>value</code>, который заимствует <code>self</code>, не имеет других свойств, и возвращает значение вида <code>i32</code>. Этот способ иногда называют <em>извлекатель</em> (getter), потому что его цель состоит в том, чтобы извлечь данные из полей структуры и вернуть их. Этот публичный способ является необходимым, поскольку поле <code>value</code> структуры <code>Guess</code>  является приватным. Важно, чтобы поле <code>value</code> было приватным, чтобы код, использующий структуру <code>Guess</code>, не мог устанавливать <code>value</code> напрямую: код снаружи модуля <em>должен</em> использовать функцию <code>Guess::new</code> для создания экземпляра <code>Guess</code>, таким образом обеспечивая, что у <code>Guess</code> нет возможности получить <code>value</code>, не проверенное условиями в функции <code>Guess::new</code>.</p>
<p>Функция, которая принимает или возвращает только числа от 1 до 100, может объявить в своей сигнатуре, что она принимает или возвращает <code>Guess</code>, вместо <code>i32</code>, таким образом не будет необходимости делать дополнительные проверки в теле такой функции.</p>
<h2 id="Итоги-6"><a class="header" href="#Итоги-6">Итоги</a></h2>
<p>Функции обработки ошибок в Rust призваны помочь написанию более надёжного кода. Макрос <code>panic!</code> сигнализирует, что ваша программа находится в состоянии, которое она не может обработать, и позволяет сказать процессу чтобы он прекратил своё выполнение, вместо попытки продолжить выполнение с некорректными или неверными значениями. Перечисление <code>Result</code> использует систему видов Rust, чтобы сообщить, что действия могут завершиться неудачей, и ваш код мог восстановиться. Можно использовать <code>Result</code>, чтобы сообщить вызывающему коду, что он должен обрабатывать потенциальный успех или потенциальную неудачу. Использование <code>panic!</code> и <code>Result</code> правильным образом сделает ваш код более надёжным перед лицом неизбежных проблем.</p>
<p>Теперь, когда вы увидели полезные способы использования  обобщённых видов <code>Option</code> и <code>Result</code> в встроенной библиотеке, мы поговорим о том, как работают обобщённые виды и как вы можете использовать их в своём коде.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обобщённые-виды-типажи-и-время-жизни"><a class="header" href="#Обобщённые-виды-типажи-и-время-жизни">Обобщённые виды, типажи и время жизни</a></h1>
<p>Каждый язык программирования имеет в своём арсенале эффективные средства борьбы с повторением кода. В Rust одним из таких средств являются обобщённые виды данных - <em>generics</em>. Это абстрактные подставные виды на место которых возможно поставить какой-либо определенный вид или другое свойство. Когда мы пишем код, мы можем выразить поведение обобщённых видов или их связь с другими обобщёнными видами, не зная какой вид будет использован на их месте при сборки и запуске кода.</p>
<p>Функции могут принимать свойства некоторого "обобщённого" вида вместо привычных "определенных" видов, вроде <code>i32</code> или <code>String</code>. Подобно, функция принимает свойства с неизвестными заранее значениями, чтобы выполнять одинаковые действия над несколькими определенными значениями. На самом деле мы уже использовали обобщённые виды данных в Главе 6 (<code>Option&lt;T&gt;</code>), в Главе 8 (<code>Vec&lt;T&gt;</code> и <code>HashMap&lt;K, V&gt;</code>) и в Главе 9 (<code>Result&lt;T, E&gt;</code>). В этой главе вы узнаете, как определить собственные виды данных, функции и способы, используя возможности обобщённых видов.</p>
<p>Прежде всего, мы рассмотрим как для уменьшения повторения извлечь из кода некоторую общую функциональность. Далее, мы будем использовать тот же механизм для создания обобщённой функции из двух функций, которые отличаются только видом их свойств. Мы также объясним, как использовать обобщённые виды данных при определении структур и перечислений.</p>
<p>После этого мы изучим как использовать типажи (traits) для определения поведения в обобщённом виде. Можно комбинировать типажи с обобщёнными видами, чтобы обобщённый вид мог принимать только такие виды, которые имеют определённое поведение, а не все подряд.</p>
<p>В конце мы обсудим <em>времена жизни (lifetimes)</em>, вариации обобщённых видов, которые дают сборщику сведения о том, как сроки жизни ссылок относятся друг к другу. Времена жизни позволяют нам указать дополнительную сведения об "одолженных" (borrowed) значениях, которая позволит сборщику удостовериться в корректности используемых ссылок в тех ситуациях, когда сборщик не может сделать это самостоятельно .</p>
<h2 id="Удаление-повторения-кода-с-помощью-выделения-общей-функциональности"><a class="header" href="#Удаление-повторения-кода-с-помощью-выделения-общей-функциональности">Удаление повторения кода с помощью выделения общей функциональности</a></h2>
<p>В обобщениях мы можем заменить определенный вид на "заполнитель" (placeholder), обозначающую несколько видов, что позволяет удалить повторяющийся код. Прежде чем углубляться в синтаксис обобщённых видов, давайте сначала посмотрим, как удалить повторение, не задействуя универсальные виды, путём извлечения функции, которая заменяет определённые значения заполнителем, представляющим несколько значений. Затем мы применим ту же технику для извлечения универсальной функции! Изучив, как распознать повторяющийся код, который можно извлечь в функцию, вы начнёте распознавать повторяющийся код, который может использовать обобщённые виды.</p>
<p>Начнём с короткой программы в приложении 10-1, которая находит наибольшее число в списке.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-1: Поиск наибольшего числа в списке чисел</span></p>
<p>Сохраним список целых чисел в переменной <code>number_list</code> и поместим первое значение из списка в переменную <code>largest</code>. Далее, переберём все элементы списка, и, если текущий элемент больше числа сохранённого в переменной <code>largest</code>, заменим значение в этой переменной. Если текущий элемент меньше или равен "наибольшему", найденному ранее, значение переменной оставим прежним и перейдём к следующему элементу списка. После перебора всех элементов списка переменная <code>largest</code> должна содержать наибольшее значение, которое в нашем случае будет равно 100.</p>
<p>Теперь перед нами стоит задача найти наибольшее число в двух разных списках. Для этого мы можем повторять код из приложения 10-1 и использовать ту же логику в двух разных местах программы, как показано в приложении 10-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-2: Код для поиска наибольшего числа в <em>двух</em> списках чисел</span></p>
<p>Несмотря на то, что код программы работает, повторение кода утомительно и подвержено ошибкам. При внесении изменений мы должны не забыть обновить каждое место, где код повторяется.</p>
<p>Для устранения повторения мы можем создать дополнительную абстракцию с помощью функции которая сможет работать с любым списком целых чисел переданным ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает код более ясным и позволяет абстрактным образом реализовать алгоритм поиска наибольшего числа в списке.</p>
<p>В приложении 10-3 мы извлекаем код, который находит наибольшее число, в функцию с именем  <code>largest</code>. Затем мы вызываем функцию, чтобы найти наибольшее число в двух списках из приложения 10-2. Мы также можем использовать эту функцию для любого другого списка значений <code>i32</code> , который может встретиться позже.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-3: Абстрактный код для поиска наибольшего числа в двух списках</span></p>
<p>Функция <code>largest</code> имеет свойство с именем <code>list</code>, который представляет любой срез значений вида <code>i32</code>, которые мы можем передать в неё. В результате вызова функции, код выполнится с определенными, переданными в неё значениями.</p>
<p>Итак, вот шаги выполненные для изменения кода из приложения 10-2 в приложение 10-3:</p>
<ol>
<li>Определить повторяющийся код.</li>
<li>Извлечь повторяющийся код и поместить его в тело функции, определив входные и выходные значения этого кода в сигнатуре функции.</li>
<li>Обновить и заменить два участка повторяющегося кода вызовом одной функции.</li>
</ol>
<p>Далее, чтобы уменьшить повторение кода, мы воспользуемся теми же шагами для обобщённых видов. Обобщённые виды позволяют работать над абстрактными видами таким же образом, как тело функции может работать над абстрактным списком <code>list</code> вместо определенных значений.</p>
<p>Например, у нас есть две функции: одна ищет наибольший элемент внутри среза значений вида <code>i32</code>, а другая внутри среза значений вида <code>char</code>. Как уменьшить такое повторение? Давайте выяснять!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обобщённые-виды-данных"><a class="header" href="#Обобщённые-виды-данных">Обобщённые виды данных</a></h2>
<p>Мы используем обобщённые виды данных для объявления функций или структур, которые затем можно использовать с различными определенными видами данных. Давайте сначала посмотрим, как объявлять функции, структуры, перечисления и способы, используя обобщённые виды данных. Затем мы обсудим, как обобщённые виды данных влияют на производительность кода.</p>
<h3 id="В-объявлении-функций"><a class="header" href="#В-объявлении-функций">В объявлении функций</a></h3>
<p>Когда мы объявляем функцию с обобщёнными видами, мы размещаем обобщённые виды в сигнатуре функции, где мы обычно указываем виды данных переменных и возвращаемого значения. Используя обобщённые виды, мы делаем код более гибким и предоставляем большую функциональность при вызове нашей функции, предотвращая повторение кода.</p>
<p>Рассмотрим пример с функцией <code>largest</code>. Приложение 10-4 показывает две функции, каждая из которых находит самое большое значение в срезе своего вида. Позже мы объединим их в одну функцию, использующую обобщённые виды данных.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-4: две функции, отличающиеся только именем и видом обрабатываемых данных</span></p>
<p>Функция <code>largest_i32</code> уже встречалась нам: мы извлекли её в приложении 10-3, когда боролись с повторением кода — она находит наибольшее значение вида <code>i32</code> в срезе. Функция <code>largest_char</code> находит самое большое значение вида <code>char</code> в срезе. Тело у этих функций одинаковое, поэтому давайте избавимся от повторяемлшл кода, используя свойство обобщённого вида в одной функции.</p>
<p>Для свойствоизации видов данных в новой объявляемой функции нам нужно дать имя обобщённому виду — так же, как мы это делаем для переменных функций. Можно использовать любой определитель для имени свойства вида, но мы будем использовать <code>T</code>, потому что по соглашению имена свойств в Rust должны быть короткими (обычно длиной в один символ), а именование видов в Rust делается в нотации UpperCamelCase. Сокращение слова «type» до одной буквы <code>T</code> является стандартным выбором большинства программистов, использующих язык Rust.</p>
<p>Когда мы используем свойство в теле функции, мы должны объявить имя свойства в сигнатуре, чтобы сборщик знал, что означает это имя. Подобно когда мы используем имя вида свойства в сигнатуре функции, мы должны объявить это имя раньше, чем мы его используем. Чтобы определить обобщённую функцию <code>largest</code>, поместим объявление имён свойств в треугольные скобки <code>&lt;&gt;</code> между именем функции и списком свойств, как здесь:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Объявление читается так: функция <code>largest</code> является обобщённой по виду <code>T</code>. Эта функция имеет один свойство с именем <code>list</code>, который является срезом значений с видом данных <code>T</code>. Функция <code>largest</code> возвращает значение этого же вида <code>T</code>.</p>
<p>Приложение 10-5 показывает определение функции <code>largest</code> с использованием обобщённых видов данных в её сигнатуре. Приложение также показывает, как мы можем вызвать функцию со срезом данных вида <code>i32</code> или <code>char</code>. Данный код пока не будет собираться, но мы исправим это к концу раздела.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 10-5: функция <code>largest</code>, использующая свойства обобщённого типа; пока ещё не собирается</span></p>
<p>Если мы соберем программу сейчас, мы получим следующую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
</code></pre>
<p>В подсказке упоминается <code>std::cmp::PartialOrd</code>, который является <em>типажом</em>. Мы поговорим про типажи в следующем разделе. Сейчас ошибка в функции <code>largest</code> указывает, что функция не будет работать для всех возможных видов <code>T</code>. Так как мы хотим сравнивать значения вида <code>T</code> в теле функции, мы можем использовать только те виды, данные которых можно упорядочить: можем упорядочить — значит, можем и сравнить. Чтобы можно было задействовать сравнения, стандартная библиотека имеет типаж <code>std::cmp::PartialOrd</code>, который вы можете реализовать для видов (смотрите дополнение С для большей сведений про данный типаж). Следуя совету в сообщении сборщика, ограничим вид <code>T</code> теми вариантами, которые поддерживают типаж <code>PartialOrd</code>, и тогда пример успешно  ссобирается, так как стандартная библиотека реализует <code>PartialOrd</code> как для вида <code>i32</code>, так и для вида <code>char</code>.</p>
<h3 id="В-определении-структур"><a class="header" href="#В-определении-структур">В определении структур</a></h3>
<p>Мы также можем определить структуры, использующие обобщённые виды в одном или нескольких своих полях, с помощью синтаксиса <code>&lt;&gt;</code>. Приложение 10-6 показывает, как определить структуру <code>Point&lt;T&gt;</code>, чтобы хранить поля координат <code>x</code> и <code>y</code> любого вида данных.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-6: структура <code>Point</code>, содержащая поля <code>x</code> и <code>y</code> вида <code>T</code></span></p>
<p>Синтаксис использования обобщённых видов в определении структуры очень похож на синтаксис в определении функции. Сначала мы объявляем имена видов свойств внутри треугольных скобок сразу после названия структуры. Затем мы можем использовать обобщённые виды в определении структуры в тех местах, где ранее мы указывали бы определенные виды.</p>
<p>Так как мы используем только один обобщённый вид данных для определения структуры <code>Point&lt;T&gt;</code>, это определение означает, что структура <code>Point&lt;T&gt;</code> является обобщённой с видом <code>T</code>, и <em>оба</em> поля <code>x</code> и <code>y</code> имеют одинаковый вид, каким бы он не являлся. Если мы создадим экземпляр структуры <code>Point&lt;T&gt;</code> со значениями разных видов, как показано в приложении 10-7, наш код не ссобирается.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 10-7: поля <code>x</code> и <code>y</code> должны быть одного вида, так как они имеют один и тот же обобщённый вид <code>T</code></span></p>
<p>В этом примере, когда мы присваиваем целочисленное значение 5 переменной <code>x</code> , мы сообщаем сборщику, что обобщённый вид <code>T</code> будет целым числом для этого экземпляра <code>Point&lt;T&gt;</code>. Затем, когда мы указываем значение 4.0 (имеющее вид, отличный от целого числа) для <code>y</code>, который по нашему определению должен иметь тот же вид, что и <code>x</code>, мы получим ошибку несоответствия видов:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
</code></pre>
<p>Чтобы определить структуру <code>Point</code>, где оба значения <code>x</code> и <code>y</code> являются обобщёнными, но различными видами, можно использовать несколько свойств обобщённого вида. Например, в приложении 10-8 мы изменим определение <code>Point</code> таким образом, чтобы оно использовало обобщённые виды <code>T</code> и <code>U</code>, где <code>x</code> имеет вид <code>T</code> а <code>y</code> имеет вид <code>U</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-8: структура <code>Point&lt;T, U&gt;</code> обобщена для двух видов, так что <code>x</code> и <code>y</code> могут быть значениями разных видов</span></p>
<p>Теперь разрешены все показанные экземпляры вида <code>Point</code>! В объявлении можно использовать сколь угодно много свойств обобщённого вида, но если делать это в большом количестве, код будет тяжело читать. Если в вашем коде требуется много обобщённых видов, возможно, стоит разбить его на более мелкие части.</p>
<h3 id="В-определениях-перечислений"><a class="header" href="#В-определениях-перечислений">В определениях перечислений</a></h3>
<p>Как и структуры, перечисления также могут хранить обобщённые виды в своих вариантах. Давайте ещё раз посмотрим на перечисление <code>Option&lt;T&gt;</code>, предоставленное встроенной библиотекой, которое мы использовали в главе 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Это определение теперь должно быть вам более понятно. Как видите,  перечисление <code>Option&lt;T&gt;</code> является обобщённым по виду <code>T</code> и имеет два варианта: вариант <code>Some</code>, который содержит одно значение вида <code>T</code>, и вариант <code>None</code>, который не содержит никакого значения. Используя перечисление <code>Option&lt;T&gt;</code>, можно выразить абстрактную концепцию необязательного значения — и так как <code>Option&lt;T&gt;</code> является обобщённым, можно использовать эту абстракцию независимо от того, каким будет вид необязательного значения.</p>
<p>Перечисления также могут использовать несколько обобщённых видов. Определение перечисления <code>Result</code>, которое мы упоминали в главе 9, является примером такого использования:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Перечисление <code>Result</code> имеет два обобщённых вида: <code>T</code> и <code>E</code> — и два варианта:  <code>Ok</code>, который содержит вид <code>T</code>, и <code>Err</code>, содержащий вид <code>E</code>. С таким определением удобно использовать перечисление <code>Result</code> везде, где действия могут быть выполнены успешно (возвращая значение вида <code>T</code>) или неуспешно (возвращая ошибку вида <code>E</code>). Это то, что мы делали при открытии файла в приложении 9-3, где <code>T</code> заполнялось видом <code>std::fs::File</code>, если файл был открыт успешно, либо <code>E</code> заполнялось видом  <code>std::io::Error</code>, если при открытии файла возникали какие-либо проблемы.</p>
<p>Если вы встречаете в коде ситуации, когда несколько определений структур или перечислений отличаются только видами содержащихся в них значений, вы можете устранить повторение, используя обобщённые виды.</p>
<h3 id="В-определении-способов"><a class="header" href="#В-определении-способов">В определении способов</a></h3>
<p>Мы можем реализовать способы для структур и перечислений (как мы делали в главе 5) и в определениях этих способов также использовать обобщённые виды. В приложении 10-9 показана структура <code>Point&lt;T&gt;</code>, которую мы определили в приложении 10-6, с добавленным для неё способом <code>x</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-9: Реализация способа с именем <code>x</code> у структуры <code>Point&lt;T&gt;</code>, которая будет возвращать ссылку на поле <code>x</code> вида <code>T</code></span></p>
<p>Здесь мы определили способ с именем <code>x</code> у структуры <code>Point&lt;T&gt;</code>, который возвращает ссылку на данные в поле <code>x</code>.</p>
<p>Обратите внимание, что мы должны объявить <code>T</code> сразу после <code>impl</code> .  В этом случае мы можем использовать <code>T</code> для указания на то, что реализуем способ для вида <code>Point&lt;T&gt;</code>. Объявив <code>T</code> универсальным видом сразу после <code>impl</code> , Rust может определить, что вид в угловых скобках в <code>Point</code> является универсальным, а не определенным видом. Мы могли бы выбрать другое имя для этого обобщённого свойства, отличное от имени, использованного в определении структуры, но обычно используют одно и то же имя. Способы, написанные внутри раздела <code>impl</code> , который использует обобщённый вид, будут определены для любого экземпляра вида, независимо от того, какой определенный вид в конечном итоге будет подставлен вместо этого обобщённого.</p>
<p>Мы можем также указать ограничения, какие обобщённые виды разрешено использовать при определении способов. Например, мы могли бы реализовать способы только для экземпляров вида <code>Point&lt;f32&gt;</code>, а не для экземпляров <code>Point&lt;T&gt;</code>, в которых используется произвольный обобщённый вид. В приложении 10-10 мы используем определенный вид <code>f32</code>, что означает, что мы не определяем никакие виды после <code>impl</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-10: раздел<code>impl</code>, который применяется только к структуре, имеющей определенный вид для свойства обобщённого вида <code>T</code></span></p>
<p>Этот код означает, что вид <code>Point&lt;f32&gt;</code> будет иметь способ с именем <code>distance_from_origin</code>, а другие экземпляры <code>Point&lt;T&gt;</code>, где <code>T</code> имеет вид, отличный от <code>f32</code>, не будут иметь этого способа. Способ вычисляет, насколько далеко наша точка находится от точки с координатами (0.0, 0.0), и использует математические действия, доступные только для видов с плавающей точкой.</p>
<p>Свойства обобщённого вида, которые мы используем в определении структуры, не всегда совпадают с подобиями, использующимися в сигнатурах способов этой структуры. Чтобы пример был более очевидным, в приложении 10-11 используются обобщённые виды <code>X1</code> и <code>Y1</code> для определения структуры <code>Point</code> и виды <code>X2</code> <code>Y2</code> для сигнатуры способа <code>mixup</code>. Способ создаёт новый экземпляр структуры <code>Point</code>, где значение <code>x</code> берётся из <code>self</code> <code>Point</code> (имеющей вид <code>X1</code>), а значение <code>y</code> - из переданной структуры <code>Point</code> (где эта переменная имеет вид <code>Y2</code>).</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-11: способ, использующий обобщённые виды, отличающиеся от видов, используемых в определении структуры</span></p>
<p>В функции <code>main</code> мы определили вид <code>Point</code>, который имеет вид <code>i32</code> для <code>x</code> (со значением <code>5</code> ) и вид <code>f64</code> для <code>y</code> (со значением <code>10.4</code>). Переменная <code>p2</code> является структурой <code>Point</code>, которая имеет строковый срез для <code>x</code> (со значением <code>«Hello»</code>) и <code>char</code> для <code>y</code> (со значением <code>c</code>). Вызов <code>mixup</code> на <code>p1</code> с переменнаяом <code>p2</code> создаст для нас экземпляр структуры <code>p3</code>, который будет иметь вид <code>i32</code> для <code>x</code> (потому что <code>x</code> взят из <code>p1</code>). Переменная <code>p3</code> будет иметь вид <code>char</code>  для  <code>y</code> (потому что <code>y</code> взят из <code>p2</code>). Вызов макроса <code>println! </code> выведет <code>p3.x = 5, p3.y = c</code>.</p>
<p>Цель этого примера — отобразить ситуацию, в которой некоторые обобщённые свойства объявлены с помощью <code>impl</code>, а некоторые объявлены в определении способа. Здесь обобщённые свойства <code>X1</code> и <code>Y1</code> объявляются после <code>impl</code>, потому что они относятся к определению структуры. Обобщённые свойства <code>X2</code> и <code>Y2</code> объявляются после <code>fn mixup</code>, так как они относятся только к способу.</p>
<h3 id="Производительность-кода-использующего-обобщённые-виды"><a class="header" href="#Производительность-кода-использующего-обобщённые-виды">Производительность кода, использующего обобщённые виды</a></h3>
<p>Вы могли бы задаться вопросом, возникают ли какие-нибудь дополнительные издержки при использовании свойств обобщённого вида. Хорошая новость в том, что при использовании обобщённых видов ваша программа работает ничуть ни медленнее, чем если бы она работала с использованием определенных видов.</p>
<p>В Rust это достигается во время сборки при помощи мономорфизации кода, использующего обобщённые виды. <em>Мономорфизация</em> — это процесс превращения обобщённого кода в определенный код путём подстановки определенных видов, использующихся при сборки. В этом процессе сборщик выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой функции в приложении 10-5: он просматривает все места, где вызывается обобщённый код, и генерирует код для определенных видов, использовавшихся для вызова в обобщённом.</p>
<p>Давайте посмотрим, как это работает при использовании перечисления <code>Option&lt;T&gt;</code> из встроенной библиотеки:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Когда Rust собирает этот код, он выполняет мономорфизацию. Во время этого процесса сборщик считывает значения, которые были использованы в экземплярах <code>Option&lt;T&gt;</code>, и определяет два вида <code>Option&lt;T&gt;</code>: один для вида <code>i32</code>, а другой — для <code>f64</code>. Таким образом, он разворачивает обобщённое определение <code>Option&lt;T&gt;</code> в два определения, именно для <code>i32</code> и <code>f64</code>, тем самым заменяя обобщённое определение определенными.</p>
<p>Мономорфизированная исполнение кода выглядит примерно так (сборщик использует имена, отличные от тех, которые мы используем здесь для отображения):</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>Обобщённое <code>Option&lt;T&gt;</code> заменяется определенными определениями, созданными сборщиком. Поскольку Rust собирает обобщённый код в код, определяющий вид в каждом экземпляре, мы не платим за использование обобщённых видов во время выполнения. Когда код запускается, он работает точно так же, как если бы мы сделали повторение каждое определение вручную. Процесс мономорфизации делает обобщённые виды Rust чрезвычайно эффективными во время выполнения.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Типажи-определение-общего-поведения"><a class="header" href="#Типажи-определение-общего-поведения">Типажи: определение общего поведения</a></h2>
<p><em>Типаж</em> сообщает сборщику Rust о функциональности, которой обладает определённый вид и которой он может поделиться с другими видами. Можно использовать типажи, чтобы определять общее поведение абстрактным способом. Мы можем использовать <em>ограничение типажа</em> (trait bounds) чтобы указать, что общим видом может быть любой вид, который имеет определённое поведение.</p>
<blockquote>
<p>Примечание: Типажи похожи на функциональность часто называемую <em>внешней оболочкими</em> в других языках программирования, хотя и с некоторыми отличиями.</p>
</blockquote>
<h3 id="Определение-типажа"><a class="header" href="#Определение-типажа">Определение типажа</a></h3>
<p>Поведение вида определяется теми способами, которые мы можем вызвать у данного вида. Различные виды разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов. Определение типажей - это способ сгруппировать сигнатуры способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.</p>
<p>Например, пусть есть несколько структур, которые имеют различный вид и различный размер текста: структура <code>NewsArticle</code>, которая содержит новость, напечатанную в каком-то месте мира; структура <code>Tweet</code>, которая содержит 280 символьную строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.</p>
<p>Мы хотим создать крейт библиотеки медиа-агрегатора <code>aggregator</code>, которая может отображать сводку данных сохранённых в экземплярах структур <code>NewsArticle</code> или <code>Tweet</code>. Чтобы этого достичь, нам необходимо иметь возможность для каждой структуры получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ <code>summarize</code>. Приложение 10-12 показывает определение типажа <code>Summary</code>, который выражает это поведение.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 10-12: Определение типажа <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span></p>
<p>Здесь мы объявляем типаж с использованием ключевого слова <code>trait</code>, а затем его название, которым в нашем случае является <code>Summary</code>. Также мы объявляем крейт как <code>pub</code> что позволяет крейтам, зависящим от нашего крейта, тоже использовать наш крейт, что мы увидим в последующих примерах. Внутри фигурных скобок объявляются сигнатуры способов, которые описывают поведения видов, реализующих данный типаж, в данном случае поведение определяется только одной сигнатурой способа <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>После сигнатуры способа, вместо предоставления реализации в фигурных в скобках, мы используем точку с запятой. Каждый вид, реализующий данный типаж, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид содержащий типаж <code>Summary</code>, будет также иметь и способ <code>summarize</code> объявленный с точно такой же сигнатурой.</p>
<p>Типаж может иметь несколько способов в описании его тела: сигнатуры способов перечисляются по одной на каждой строке и должны закачиваться символом <code>;</code>.</p>
<h3 id="Реализация-типажа-у-вида"><a class="header" href="#Реализация-типажа-у-вида">Реализация типажа у вида</a></h3>
<p>Теперь, после того как мы определили желаемое поведение используя типаж <code>Summary</code>, можно реализовать его у видов в нашем медиа-агрегаторе. Приложение 10-13 показывает реализацию типажа <code>Summary</code> у структуры <code>NewsArticle</code>, которая использует для создания сводки в способе <code>summarize</code> заголовок, автора и место публикации статьи. Для структуры <code>Tweet</code> мы определяем реализацию <code>summarize</code> используя имя пользователя и следующий за ним полный текст твита, полагая что содержание твита уже ограничено 280 символами.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 10-13: Реализация типажа <code>Summary</code> для структур <code>NewsArticle</code> и <code>Tweet</code></span></p>
<p>Реализация типажа у вида подобна реализации обычных способов. Разница в том что после <code>impl</code> мы ставим имя типажа, который мы хотим реализовать, затем используем ключевое слово <code>for</code>, а затем указываем имя вида, для которого мы хотим сделать реализацию типажа. Внутри раздела <code>impl</code> мы помещаем сигнатуру способа объявленную в типаже. Вместо добавления точки с запятой в конце, после каждой сигнатуры используются фигурные скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов типажа для определенного вида.</p>
<p>Теперь когда библиотека реализовала типаж <code>Summary</code> для <code>NewsArticle</code> и <code>Tweet</code>, программисты использующие крейт могут вызывать способы типажа у экземпляров видов <code>NewsArticle</code> и <code>Tweet</code> точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести типаж в область видимости точно так же как и виды. Здесь пример того как двоичный крейт может использовать наш <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}</code></pre>
<p>Данный код напечатает: <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Другие крейты, которые зависят от <code>aggregator</code>, тоже могу включить типаж <code>Summary</code> в область видимости для реализации <code>Summary</code> в их собственных видах. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем реализовать типаж для вида только в том случае, если хотя бы один из типажей вида является местным для нашего крейта. Например, мы можем реализовать стандартный библиотечный типаж <code>Display</code> на собственном виде <code>Tweet</code> как часть функциональности нашего крейта <code>aggregator</code> потому что вид <code>Tweet</code> является местным для крейта <code>aggregator</code>. Также мы можем реализовать <code>Summary</code> для <code>Vec&lt;T&gt;</code> в нашем крейте <code>aggregator</code>, потому что типаж <code>Summary</code> является местным для нашего крейта <code>aggregator</code>.</p>
<p>Но мы не можем реализовать внешние типажи для внешних видов. Например, мы не можем реализовать типаж <code>Display</code> для <code>Vec&lt;T&gt;</code> внутри нашего крейта <code>aggregator</code>, потому что <code>Display</code> и <code>Vec&lt;T&gt;</code> оба определены в встроенной библиотеке а не местно в нашем крейте <code>aggregator</code>. Это ограничение является частью свойства называемого <em>согласованность</em> (coherence), а ещё точнее <em>сиротское правило</em> (orphan rule), которое называется так потому что не представлен родительский вид. Это правило заверяет, что код других людей не может сломать ваш код и наоборот. Без этого правила два крейта могли бы реализовать один типаж для одинакового вида и Rust не сможет понять, какой реализацией нужно пользоваться.</p>
<h3 id="Реализация-поведения-по-умолчанию"><a class="header" href="#Реализация-поведения-по-умолчанию">Реализация поведения по умолчанию</a></h3>
<p>Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в типаже вместо того, чтобы требовать реализации всех способов в каждом виде, реализующим данный типаж. Затем, когда мы реализуем типаж для определённого вида, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов.</p>
<p>В примере 10-14 показано, как указать строку по умолчанию для способа <code>summarize</code> из типажа <code>Summary</code> вместо определения только сигнатуры способа, как мы сделали в примере 10-12.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 10-14: Определение типажа <code>Summary</code> с реализацией способа <code>summarize</code> по умолчанию</span></p>
<p>Для использования реализации по умолчанию при создании сводки у экземпляров <code>NewsArticle</code> вместо определения пользовательской реализации, мы указываем пустой раздел<code>impl</code> с <code>impl Summary for NewsArticle {}</code>.</p>
<p>Хотя мы больше не определяем способ <code>summarize</code> непосредственно в <code>NewsArticle</code>, мы предоставили реализацию по умолчанию и указали, что <code>NewsArticle</code> реализует типаж <code>Summary</code>. В результате мы всё ещё можем вызвать способ <code>summarize</code> у экземпляра <code>NewsArticle</code>, например так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}</code></pre>
<p>Этот код печатает <code>New article available! (Read more...)</code> .</p>
<p>Создание реализации по умолчанию не требует от нас изменений чего-либо в реализации <code>Summary</code> для <code>Tweet</code> в приложении 10-13. Причина заключается в том, что синтаксис для переопределения реализации по умолчанию является таким же, как синтаксис для реализации способа типажа, который не имеет реализации по умолчанию.</p>
<p>Реализации по умолчанию могут вызывать другие способы в том же типаже, даже если эти другие способы не имеют реализации по умолчанию. Таким образом, типаж может предоставить много полезной функциональности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить типаж <code>Summary</code> имеющий способ <code>summarize_author</code>, реализация которого требуется, а затем определить способ <code>summarize</code> который имеет реализацию по умолчанию, которая внутри вызывает способ <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}</code></pre>
<p>Чтобы использовать такую исполнение типажа <code>Summary</code>, нужно только определить способ <code>summarize_author</code>, при реализации типажа для вида:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}</code></pre>
<p>После того, как мы определим <code>summarize_author</code>, можно вызвать <code>summarize</code> для экземпляров структуры <code>Tweet</code> и реализация по умолчанию способа <code>summarize</code> будет вызывать определение <code>summarize_author</code> которое мы уже предоставили. Так как мы реализовали способ <code>summarize_author</code> типажа <code>Summary</code>, то типаж даёт нам поведение способа <code>summarize</code> без необходимости писать код.</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}</code></pre>
<p>Этот код печатает <code>1 new tweet: (Read more from @horse_ebooks...)</code> .</p>
<p>Обратите внимание, что невозможно вызвать реализацию по умолчанию из переопределённой реализации того же способа.</p>
<h3 id="Типажи-как-свойства"><a class="header" href="#Типажи-как-свойства">Типажи как свойства</a></h3>
<p>Теперь, когда вы знаете, как определять и реализовывать типажи, можно изучить, как использовать типажи, чтобы определить функции, которые принимают много различных видов. Мы будем использовать типаж <code>Summary</code>,  реализованный для видов <code>NewsArticle</code> и <code>Tweet</code> в приложении 10-13, чтобы определить функцию <code>notify</code>, которая вызывает способ <code>summarize</code> для его свойства <code>item</code>, который имеет некоторый вид, реализующий типаж <code>Summary</code>. Для этого мы используем синтаксис <code>impl Trait</code> примерно так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}</code></pre>
<p>Вместо определенного вида у свойства <code>item</code> указывается ключевое слово <code>impl</code> и имя типажа. Этот свойство принимает любой вид, который реализует указанный типаж. В теле <code>notify</code> мы можем вызывать любые способы у экземпляра <code>item</code> , которые приходят с типажом <code>Summary</code>, такие как способ <code>summarize</code>. Мы можем вызвать <code>notify</code> и передать в него любой экземпляр <code>NewsArticle</code> или <code>Tweet</code>. Код, который вызывает данную функцию с любым другим видом, таким как <code>String</code> или <code>i32</code>, не будет собираться, потому что эти виды не реализуют типаж <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="Синтаксис-ограничения-типажа"><a class="header" href="#Синтаксис-ограничения-типажа">Синтаксис ограничения типажа</a></h4>
<p>Синтаксис <code>impl Trait</code> работает для простых случаев, но на самом деле является синтаксическим сахаром для более длинной формы, которая называется <em>ограничением типажа</em> (trait bound); это выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>Эта более длинная форма эквивалентна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида с ограничением типажа после двоеточия внутри угловых скобок.</p>
<p>Синтаксис <code>impl Trait</code> удобен и делает код более сжатым в простых случаях, в то время как более полный синтаксис с ограничением типажа в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые реализуют типаж  <code>Summary</code>. Использование синтаксиса  <code>impl Trait</code> выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Использовать <code>impl Trait</code> удобнее если мы хотим разрешить функции иметь разные виды для <code>item1</code> и <code>item2</code> (но оба вида должны реализовывать <code>Summary</code>). Если же мы хотим заставить оба свойства иметь один и тот же вид, то мы должны использовать ограничение типажа так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Обобщённый вид <code>T</code> указан для видов свойств <code>item1</code> и <code>item2</code> и ограничивает функцию так, что определенные значения видов переданные переменнойми для <code>item1</code> и <code>item2</code> должны быть одинаковыми.</p>
<h4 id="Задание-нескольких-границ-типажей-с-помощью-синтаксиса-"><a class="header" href="#Задание-нескольких-границ-типажей-с-помощью-синтаксиса-">Задание нескольких границ типажей с помощью синтаксиса <code>+</code></a></h4>
<p>Также можно указать более одного ограничения типажа. Допустим, мы хотели бы чтобы <code>notify</code> использовал как форматирование вывода так и  <code>summarize</code> для свойства <code>item</code>: <br>тогда мы указываем что в <code>notify</code> свойство <code>item</code> должен реализовывать оба типажа <code>Display</code> и <code>Summary</code>. Мы можем сделать это используя синтаксис <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>Синтаксис <code>+</code> также допустим с ограничениями типажа для обобщённых видов:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>При наличии двух ограничений типажа, тело способа <code>notify</code> может вызывать <code>summarize</code> и использовать <code>{}</code> для форматирования <code>item</code> при его печати.</p>
<h4 id="Более-ясные-границы-типажа-с-помощью-where"><a class="header" href="#Более-ясные-границы-типажа-с-помощью-where">Более ясные границы типажа с помощью <code>where</code></a></h4>
<p>Использование слишком большого количества ограничений типажа имеет свои недостатки. Каждый обобщённый вид имеет свои границы типажа, поэтому функции с несколькими свойствами обобщённого вида могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение сигнатуры. По этой причине в Rust есть иной синтаксис для определения ограничений типажа внутри предложения <code>where</code> после сигнатуры функции. Поэтому вместо того, чтобы писать так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>можно использовать <code>where</code> таким образом:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}</code></pre>
<p>Сигнатура этой функции менее загромождена: название функции, список свойств, и возвращаемый вид находятся рядом, а сигнатура не содержит в себе множество ограничений типажа.</p>
<h3 id="Возврат-значений-вида-реализующего-определённый-типаж"><a class="header" href="#Возврат-значений-вида-реализующего-определённый-типаж">Возврат значений вида реализующего определённый типаж</a></h3>
<p>Также можно использовать синтаксис <code>impl Trait</code> в возвращаемой позиции, чтобы вернуть значение некоторого вида реализующего типаж, как показано здесь:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}</code></pre>
<p>Используя <code>impl Summary</code> для возвращаемого вида, мы указываем, что функция <code>returns_summarizable</code> возвращает некоторый вид, который реализует типаж <code>Summary</code> без обозначения определенного вида. В этом случае <code>returns_summarizable</code> возвращает <code>Tweet</code>, но код, вызывающий эту функцию, этого не знает.</p>
<p>Возможность возвращать вид, который определяется только реализуемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды, которые знает только сборщик или виды, которые очень долго указывать. Синтаксис <code>impl Trait</code> позволяет кратко указать, что функция возвращает некоторый вид, который реализует типаж <code>Iterator</code> без необходимости писать очень длинный вид.</p>
<p>Однако, <code>impl Trait</code> возможно использовать, если возвращаете только один вид. Например, данный код, который возвращает значения или вида <code>NewsArticle</code> или вида <code>Tweet</code>, но в качестве возвращаемого вида объявляет <code>impl Summary</code> , не будет работать:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}</code></pre>
<p>Возврат либо <code>NewsArticle</code> либо <code>Tweet</code> не допускается из-за ограничений того, как реализован синтаксис <code>impl Trait</code> в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование объектов типажей, которые разрешены для значений или разных видов"</a><!--  --> Главы 17.</p>
<h3 id="Использование-ограничений-типажа-для-условной-реализации-способов"><a class="header" href="#Использование-ограничений-типажа-для-условной-реализации-способов">Использование ограничений типажа для условной реализации способов</a></h3>
<p>Используя ограничение типажа с разделом <code>impl</code>, который использует свойства обобщённого вида, можно реализовать способы условно, для тех видов, которые реализуют указанный типаж. Например, вид <code>Pair&lt;T&gt;</code>  в приложении 10-15 всегда реализует функцию  <code>new</code> для возврата нового экземпляра <code>Pair&lt;T&gt;</code> (вспомните раздел <a href="ch05-03-method-syntax.html#defining-methods">“Определение способов”</a><!-- ignore --> Главы 5 где <code>Self</code> является псевдонимом вида для вида раздела <code>impl</code>, который в данном случае является <code>Pair&lt;T&gt;</code>). Но в следующем разделе <code>impl</code> вид <code>Pair&lt;T&gt;</code> реализует способ  <code>cmp_display</code> только если его внутренний вид <code>T</code> реализует типаж <code>PartialOrd</code> (позволяющий сравнивать) <em>и</em> типаж <code>Display</code> (позволяющий выводить на печать).</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 10-15: Условная реализация способов у обобщённых видов в зависимости от ограничений типажа</span></p>
<p>Мы также можем условно реализовать типаж для любого вида, который реализует другой типаж. Реализации типажа для любого вида, который удовлетворяет ограничениям типажа, называются <em>общими реализациями</em> и широко используются в встроенной библиотеке Rust. Например, стандартная библиотека реализует типаж <code>ToString</code> для любого вида, который реализует типаж <code>Display</code>. Раздел<code>impl</code> в встроенной библиотеке выглядит примерно так:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать способ <code>to_string</code> определённый типажом <code>ToString</code> для любого вида, который реализует типаж <code>Display</code>. Например, мы можем превратить целые числа в их соответствующие <code>String</code> значения, потому что целые числа реализуют типаж <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Общие реализации приведены в документации к типажу в разделе "Implementors".</p>
<p>Типажи и ограничения типажей позволяют писать код, который использует свойства обобщённого вида для уменьшения повторения кода, а также указывая сборщику, что мы хотим обобщённый вид, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения типажа, чтобы проверить, что все определенные виды, используемые с нашим кодом, обеспечивают правильное поведение.  В изменяемых типизированных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида, который не реализует вид определяемый способом. Но Rust перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить проблемы, прежде чем наш код начнёт работать. Кроме того, мы не должны писать код, который проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Валидация-ссылок-при-помощи-времён-жизни"><a class="header" href="#Валидация-ссылок-при-помощи-времён-жизни">Валидация ссылок при помощи времён жизни<a name="validating-references-with-lifetimes"></a></a></h2>
<p>Сроки (времена) жизни - ещё один вид обобщений, с которыми мы уже встречались. Если раньше мы использовали обобщения, чтобы убедиться, что вид обладает нужным нам поведением, теперь мы будем использовать сроки жизни для того, чтобы быть уверенными, что ссылки действительны как минимум столько времени в процессе исполнения программы, сколько нам требуется.</p>
<p>В разделе <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">"Ссылки и заимствование"</a> главы 4, мы кое о чём умолчали: у каждой ссылки в Rust есть своё <em>время жизни</em> — область кода, на протяжении которого данная ссылка действительна (valid). В большинстве случаев сроки жизни выводятся неявно — так же, как у видов (нам требуется явно объявлять виды лишь в тех случаях, когда при самостоятельном выведении вида возможны варианты). Точно так же мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены сборщиком по-разному. Rust требует от нас объявлять взаимосвязи посредством обобщённых свойств сроков жизни, чтобы убедиться в том, что во время исполнения все действующие ссылки будут корректными.</p>
<p>Аннотирование времени жизни — это концепция, отсутствующая в большинстве других языков программирования, так что она может показаться незнакомой. Хотя в этой главе мы не будем рассматривать времена жизни во всех подробностях, тем не менее, мы обсудим основные ситуации, в которых вы можете столкнуться с синтаксисом времени жизни, что позволит вам получше ознакомиться с этой концепцией.</p>
<h3 id="Времена-жизни-предотвращают-появление-повисших-ссылок"><a class="header" href="#Времена-жизни-предотвращают-появление-повисших-ссылок">Времена жизни предотвращают появление "повисших" ссылок</a></h3>
<p>Основное предназначение сроков жизни — предотвращать появление так называемых <em>"повисших ссылок"</em> (<em>dangling references</em>), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться. Рассмотрим программу из приложения 10-16, имеющую внешнюю и внутреннюю области видимости.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 10-16: Попытка использования ссылки, значение которой вышло из области видимости</span></p>
<blockquote>
<p>Примечание: примеры в приложениях 10-16, 10-17 и 10-23 объявляют переменные без указания их начального значения, поэтому имя переменной существует во внешней области видимости. На первый взгляд может показаться, что это противоречит отсутствию в Rust нулевых (null) значений. Однако, если мы попытаемся использовать переменную, прежде чем присвоить ей значение, мы получим ошибку сборки, которая показывает, что Rust действительно не разрешает нулевые (null) значения.</p>
</blockquote>
<p>Внешняя область видимости объявляет переменную с именем <code>r</code> без начального значения, а внутренняя область объявляет переменную с именем <code>x</code> с начальным значением <code>5</code>. Во внутренней области мы пытаемся установить значение <code>r</code> как ссылку на <code>x</code>. Затем внутренняя область видимости заканчивается и мы пытаемся напечатать значение из <code>r</code>. Этот код не будет собран, потому что значение на которое ссылается <code>r</code> исчезает из области видимости, прежде чем мы попробуем использовать его. Вот сообщение об ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
</code></pre>
<p>Переменная <code>x</code> «не живёт достаточно долго». Причина в том, что <code>x</code> выйдет из области видимости, когда эта внутренняя область закончится в строке 7. Но <code>r</code> все ещё является действительной во внешней области видимости; поскольку её охват больше, мы говорим, что она «живёт дольше». Если бы Rust позволил такому коду работать, то переменная <code>r</code> смогла бы ссылаться на память, которая уже была освобождена (в тот момент, когда <code>x</code> вышла из внутренней области видимости), и всё что мы попытались бы сделать с <code>r</code> работало бы неправильно. Как же Rust определяет, что этот код некорректен? Он использует для этого анализатор заимствований (<em>borrow checker</em>).</p>
<h3 id="Анализатор-заимствований"><a class="header" href="#Анализатор-заимствований">Анализатор заимствований</a></h3>
<p>Сборщик Rust имеет в своём составе <em>анализатор заимствований</em>, который сравнивает области видимости для определения, являются ли все заимствования действительными. В приложении 10-17 показан тот же код, что и в приложении 10-16, но с изложениями, показывающими времена жизни переменных.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}</code></pre>
<p><span class="caption">Пример 10-17: Изложение времён жизни переменных <code>r</code> и <code>x</code>, с помощью определителей времени жизни <code>'a</code> и <code>'b</code>, соответственно</span></p>
<p>Здесь мы описали время жизни для <code>r</code> с помощью <code>'a</code> и время жизни <code>x</code> с помощью <code>'b</code> . Как видите, время жизни <code>'b</code> внутреннего раздела гораздо меньше, чем время жизни <code>'a</code> внешнего раздела. Во время сборки Rust сравнивает продолжительность двух времён жизни и видит, что <code>r</code> имеет время жизни <code>'a</code>, но ссылается на память со временем жизни <code>'b</code>. Программа отклоняется, потому что <code>'b</code> короче, чем <code>'a</code>: объект ссылки не живёт так же долго, как сама ссылка.</p>
<p>Приложение 10-18 исправляет код, чтобы в нём не было повисшей ссылки, и собирается без ошибок.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-18: Ссылка корректна, так как данные имеют более продолжительное время жизни, чем ссылка на эти данные</span></p>
<p>Здесь переменная <code>x</code> имеет время жизни <code>'b</code>, которое больше, чем время жизни <code>'a</code>. Это означает, что переменная <code>r</code> может ссылаться на переменную <code>x</code> потому что Rust знает, что ссылка в переменной <code>r</code> будет всегда действительной до тех пор, пока переменная <code>x</code> является валидной.</p>
<p>После того, как мы на примерах рассмотрели времена жизни ссылок и обсудили как Rust их анализирует, давайте поговорим об обобщённых временах жизни входных свойств и возвращаемых значений функций.</p>
<h3 id="Обобщённые-времена-жизни-в-функциях"><a class="header" href="#Обобщённые-времена-жизни-в-функциях">Обобщённые времена жизни в функциях</a></h3>
<p>Напишем функцию, которая возвращает более длинный из двух срезов строки. Эта функция принимает два среза строки и возвращает один срез строки. После того как мы реализовали функцию <code>longest</code>, код в приложении 10-19 должен вывести <code>The longest string is abcd</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 10-19: Функция <code>main</code> вызывает функцию <code>longest</code> для поиска наибольшего из двух срезов строки</span></p>
<p>Обратите внимание, что мы хотим чтобы функция принимала строковые срезы, которые являются ссылками, а не строки, потому что мы не хотим, чтобы функция <code>longest</code> забирала во владение свои свойства. Обратитесь к разделу <a href="ch04-03-slices.html#string-slices-as-parameters">"Строковые срезы как свойства"</a><!--  --> Главы 4 для более подробного обсуждения того, почему свойства используемые в приложении 10-19 выбраны именно таким образом.</p>
<p>Если мы попробуем реализовать функцию <code>longest</code> так, как это показано в приложении 10-20, программа не ссобирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 10-20: Реализация функции <code>longest</code>, которая возвращает наибольший срез строки, но пока не собирается</span></p>
<p>Вместо этого мы получим следующую ошибку, говорящую о временах жизни:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}
</code></pre>
<p>Текст ошибки показывает, что возвращаемому виду нужен обобщённый свойство времени жизни, потому что Rust не может определить, относится ли возвращаемая ссылка к <code>x</code> или к <code>y</code>. На самом деле, мы тоже не знаем, потому что раздел<code>if</code> в теле функции возвращает ссылку на <code>x</code>, а раздел<code>else</code> возвращает ссылку на <code>y</code>!</p>
<p>Когда мы определяем эту функцию, мы не знаем определенных значений, которые будут в неё передаваться. Поэтому мы не знаем какая из ветвей оператора <code>if</code> или <code>else</code> будет выполнена. Мы также не знаем определенных времён жизни ссылок, которые будут переданы в функцию, поэтому мы не можем посмотреть на их области видимости, как мы делали в примерах 10-17 и 10-18, чтобы определить, будет ли возвращаемая нами ссылка корректной во всех случаях. Анализатор заимствований также не может этого определить, потому что он не знает как времена жизни переменных <code>x</code> и <code>y</code> соотносятся с временем жизни возвращаемого значения. Чтобы исправить эту ошибку, мы добавим обобщённый свойство времени жизни, который определит отношения между ссылками таким образом, чтобы анализатор заимствований мог провести свой анализ.</p>
<h3 id="Синтаксис-изложении-времени-жизни"><a class="header" href="#Синтаксис-изложении-времени-жизни">Синтаксис изложении времени жизни</a></h3>
<p>Изложения времени жизни не меняют срок, как долго живёт та или иная ссылка. Они скорее описывают, как соотносятся между собой времена жизни нескольких ссылок, не влияя на само время жизни. Точно так же, как функции могут принимать любой вид, когда в сигнатуре указан свойство обобщённого вида, функции могут принимать ссылки с любым временем жизни, указанным с помощью свойства обобщённого времени жизни.</p>
<p>Изложения времени жизни имеют немного необычный синтаксис: имена свойств времени жизни должны начинаться с апострофа (<code>'</code>), пишутся маленькими буквами, и обычно очень короткие, как и имена обобщённых видов. Большинство людей использует имя <code>'a</code> в качестве первой изложении времени жизни. Изложения свойств времени жизни следуют после символа <code>&amp;</code> и отделяются пробелом от названия ссылочного вида.</p>
<p>Приведём несколько примеров: у нас есть ссылка на <code>i32</code> без указания времени жизни, ссылка на <code>i32</code>, с временем жизни имеющим имя <code>'a</code> и изменяемая ссылка на <code>i32</code>, которая также имеет время жизни <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>Одна изложение времени жизни сама по себе не имеет большого значения, поскольку изложении предназначены для того, чтобы уведомить Rust о том, как времена жизни нескольких ссылок соотносятся между собой. Давайте рассмотрим, как изложении времени жизни связаны друг с другом в среде функции <code>longest</code>.</p>
<h3 id="Изложения-времени-жизни-в-сигнатурах-функций"><a class="header" href="#Изложения-времени-жизни-в-сигнатурах-функций">Изложения времени жизни в сигнатурах функций</a></h3>
<p>Чтобы использовать изложении времени жизни в сигнатурах функций, нам нужно объявить свойства обобщённого <em>времени жизни</em> внутри угловых скобок между именем функции и списком свойств, как мы это делали с свойствами обобщённого <em>вида</em> .</p>
<p>Мы хотим, чтобы сигнатура отражала следующее ограничение: возвращаемая ссылка будет действительна до тех пор, пока валидны оба свойства. Это связь между временами жизни свойств и возвращаемого значения. Мы назовём это время жизни <code>'a</code>, а затем добавим его к каждой ссылке, как показано в приложении 10-21.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-21: В определении функции <code>longest</code> указано, что все ссылки должны иметь одинаковое время жизни, обозначенное как <code>'a</code></span></p>
<p>Этот код должен собираться и давать желаемый результат, когда мы вызовем его в функции <code>main</code> приложения 10-19.</p>
<p>Сигнатура функции теперь сообщает Rust, что для некоторого времени жизни <code>'a</code> функция принимает два свойства, оба из которых являются срезами строк, которые живут не меньше, чем время жизни <code>'a</code>. Сигнатура функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как минимум столько, сколько длится время жизни <code>'a</code>. На практике это означает, что время жизни ссылки, возвращаемой функцией <code>longest</code>, равно меньшему времени жизни передаваемых в неё ссылок. Мы хотим, чтобы Rust использовал именно такие отношения при анализе этого кода.</p>
<p>Помните, когда мы указываем свойства времени жизни в этой сигнатуре функции, мы не меняем время жизни каких-либо переданных или возвращённых значений. Скорее, мы указываем, что анализатор заимствований должен отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что самой функции <code>longest</code> не нужно точно знать, как долго будут жить <code>x</code> и <code>y</code>, достаточно  того, что некоторая область может быть заменена на <code>'a</code>, которая будет удовлетворять этой сигнатуре.</p>
<p>При аннотировании времён жизни функций, изложении помещаются в сигнатуру функции, а не в тело функции. Изложения времени жизни становятся частью контракта функции, как и виды в сигнатуре. Наличие сигнатур функций, содержащих контракт времени жизни, означает, что анализ который выполняет сборщик Rust, может быть проще. Если есть проблема с тем, как функция аннотируется или как она вызывается, ошибки сборщика могут указать на часть нашего кода и ограничения более точно. Если бы вместо этого сборщик Rust сделал больше предположений о том, какие отношения времён жизни мы хотели получить, сборщик смог бы указать только на использование нашего кода за много шагов от источника проблемы.</p>
<p>Когда мы передаём определенные ссылки в функцию <code>longest</code>, определенным временем жизни, которое будет заменено на <code>'a</code>, является часть области видимости <code>x</code>, которая пересекается с областью видимости <code>y</code>. Другими словами, обобщённое время жизни <code>'a</code> получит определенное время жизни, равное меньшему из времён жизни <code>x</code> и <code>y</code>. Так как мы аннотировали возвращаемую ссылку тем же свойствоом времени жизни <code>'a</code>, то возвращённая ссылка также будет действительна на протяжении меньшего из времён жизни <code>x</code> и <code>y</code>.</p>
<p>Давайте посмотрим, как изложении времени жизни ограничивают функцию <code>longest</code> путём передачи в неё ссылок, которые имеют разные определенные времена жизни. Приложение 10-22 является очевидным примером.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-22: Использование функции <code>longest</code> со ссылками на значения вида <code>String</code>, имеющими разное время жизни</span></p>
<p>В этом примере переменная <code>string1</code> действительна до конца внешней области, <code>string2</code> действует до конца внутренней области видимости и <code>result</code> ссылается на что-то, что является действительным до конца внутренней области видимости. Запустите этот код, и вы увидите что анализатор заимствований разрешает такой код; он ссобирает и напечатает <code>The longest string is long string is long</code>.</p>
<p>Теперь, давайте попробуем пример, который показывает, что время жизни ссылки <code>result</code> должно быть меньшим временем жизни одного из двух переменных. Мы переместим объявление переменной <code>result</code> за пределы внутренней области видимости, но оставим присвоение значения переменной <code>result</code> в области видимости <code>string2</code>. Затем мы переместим <code>println!</code>, который использует <code>result</code> за пределы внутренней области видимости, после того как внутренняя область видимости закончилась. Код в приложении 10-23 не ссобирается.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 10-23: Попытка использования <code>result</code>, после того как <code>string2</code> вышла из области видимости</span></p>
<p>При попытке собрать этот код, мы получим такую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}
</code></pre>
<p>Эта ошибка говорит о том, что если мы хотим использовать <code>result</code> в указания <code>println!</code>, переменная <code>string2</code> должна бы быть действительной до конца внешней области видимости. Rust знает об этом, потому что мы аннотировали свойства функции и её возвращаемое значение одинаковым временем жизни <code>'a</code>.</p>
<p>Будучи людьми, мы можем посмотреть на этот код и увидеть, что <code>string1</code> длиннее, чем <code>string2</code> и, следовательно, <code>result</code> будет содержать ссылку на <code>string1</code>. Поскольку <code>string1</code> ещё не вышла из области видимости, ссылка на <code>string1</code> будет все ещё действительной в указания <code>println!</code>. Однако сборщик не видит, что ссылка в этом случае валидна. Мы сказали Rust, что время жизни ссылки, возвращаемой из функции <code>longest</code>, равняется меньшему из времён жизни переданных в неё ссылок. Таким образом, анализатор заимствований запрещает код в приложении 10-23, как возможно имеющий недействительную ссылку.</p>
<p>Попробуйте провести больше экспериментов с различными значениями и временами жизни ссылок, передаваемых в функцию <code>longest</code>, а также с тем, как используется возвращаемое значение  Перед сборкой делайте предположения о том, пройдёт ли ваш код анализ заимствований, а затем проверяйте, насколько вы были правы.</p>
<h3 id="Мышление-в-терминах-времён-жизни"><a class="header" href="#Мышление-в-терминах-времён-жизни">Мышление в терминах времён жизни</a></h3>
<p>В зависимости от того, что делает ваша функция, следует использовать разные способы указания свойств времени жизни. Например, если мы изменим реализацию функции <code>longest</code> таким образом, чтобы она всегда возвращала свой первый переменная вместо самого длинного среза строки, то время жизни для свойства <code>y</code> можно совсем не указывать. Этот код ссобирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы указали свойство времени жизни <code>'a</code> для свойства <code>x</code> и возвращаемого значения, но не для свойства <code>y</code>, поскольку время жизни свойства <code>y</code> никак не соотносится с временем жизни свойства <code>x</code> или возвращаемого значения.</p>
<p>При возврате ссылки из функции, свойство времени жизни для возвращаемого вида должен соответствовать свойству времени жизни одного из переменных. Если возвращаемая ссылка <em>не</em> ссылается на один из свойств, она должна ссылаться на значение, созданное внутри функции. Однако, это приведёт к недействительной ссылке, поскольку значение, на которое она ссылается, выйдет из области видимости в конце функции. Посмотрите на попытку реализации функции <code>longest</code>, которая не ссобирается:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}</code></pre>
<p>Здесь, несмотря на то, что мы указали свойство времени жизни <code>'a</code> для возвращаемого вида, реализация не будет собрана, потому что время жизни возвращаемого значения никак не связано с временем жизни свойств. Получаем сообщение об ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}
</code></pre>
<p>Проблема заключается в том, что <code>result</code> выходит за область видимости и очищается в конце функции <code>longest</code>. Мы также пытаемся вернуть ссылку на <code>result</code> из функции. Мы не можем указать свойства времени жизни, которые могли бы изменить недействительную ссылку, а Rust не позволит нам создать недействительную ссылку. В этом случае лучшим решением будет вернуть владеющий вид данных, а не ссылку: в этом случае вызывающая функция будет нести ответственность за очистку полученного ею значения.</p>
<p>В конечном итоге, синтаксис времён жизни реализует связывание времён жизни различных переменных и возвращаемых значений функций. Описывая времена жизни, мы даём Rust достаточно сведений, чтобы разрешить безопасные действия с памятью и запретить действия, которые могли бы создать недействительные ссылки или иным способом нарушить безопасность памяти.</p>
<h3 id="Определение-времён-жизни-при-объявлении-структур"><a class="header" href="#Определение-времён-жизни-при-объявлении-структур">Определение времён жизни при объявлении структур</a></h3>
<p>До сих пор мы объявляли структуры, которые всегда содержали владеющие виды данных. Структуры могут содержать и ссылки, но при этом необходимо добавить изложение времени жизни для каждой ссылки в определении структуры. Приложение 10-24 описывает структуру <code>ImportantExcerpt</code>, содержащую срез строки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-25. Структура, содержащая ссылку, требует изложении времени жизни</span></p>
<p>У структуры имеется одно поле <code>part</code>, хранящее срез строки, который сам по себе является ссылкой. Как и в случае с обобщёнными видами данных, мы объявляем имя обобщённого свойства времени жизни внутри угловых скобок после имени структуры, чтобы иметь возможность использовать его внутри определения структуры. Данная изложение означает, что экземпляр <code>ImportantExcerpt</code> не может пережить ссылку, которую он содержит в своём поле <code>part</code>.</p>
<p>Функция <code>main</code> здесь создаёт экземпляр структуры <code>ImportantExcerpt</code>, который содержит ссылку на первое предложение вида <code>String</code> принадлежащее переменной <code>novel</code>. Данные в <code>novel</code> существуют до  создания экземпляра <code>ImportantExcerpt</code>. Кроме того, <code>novel</code> не выходит из области видимости до тех пор, пока <code>ImportantExcerpt</code> не выйдет за область видимости, поэтому ссылка в внутри экземпляра <code>ImportantExcerpt</code>  является действительной.</p>
<h3 id="Правила-неявного-выведения-времени-жизни"><a class="header" href="#Правила-неявного-выведения-времени-жизни">Правила неявного выведения времени жизни</a></h3>
<p>Вы изучили, что у каждой ссылки есть время жизни и что нужно указывать свойства времени жизни для функций или структур, которые используют ссылки. Однако в Главе 4 у нас была функция в приложении 4-9, которая затем снова показана в приложении 10-25, в которой код собрался без аннотаций времени жизни.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 10-25: Функция, которую мы определили в приложении 4-9  собирается без аннотаций времени жизни, несмотря на то, что входной и возвращаемый вид свойств являются ссылками</span></p>
<p>Причина, по которой этот код собирается — историческая. В ранних (до-1.0) исполнениях Rust этот код не собрался бы, поскольку каждой ссылке нужно было явно назначать время жизни. В те времена, сигнатура функции была бы написана примерно так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>После написания большого количества кода на Rust разработчики языка обнаружили, что в определённых ситуациях программисты описывают одни и те же изложении времён жизни снова и снова. Эти ситуации были предсказуемы и следовали нескольким детерминированным шаблонным моделям. Объединение Rust решила запрограммировать эти шаблоны в код сборщика Rust, чтобы анализатор заимствований мог вывести времена жизни в таких ситуациях без необходимости явного указания аннотаций программистами.</p>
<p>Мы упоминаем этот фрагмент истории Rust, потому что возможно, что в будущем появится больше шаблонов для самостоятельного выведения времён жизни, которые будут добавлены в сборщик. Таким образом, в будущем может понадобится ещё меньшее количество аннотаций.</p>
<p>Шаблоны, запрограммированные в анализаторе ссылок языка Rust, называются <em>правилами неявного выведения времени жизни</em>. Это не правила, которым должны следовать программисты; а набор частных случаев, которые рассмотрит сборщик, и, если ваш код попадает в эти случаи, вам не нужно будет указывать время жизни явно.</p>
<p>Правила выведения не предоставляют полного заключения. Если Rust детерминировано применяет правила, но некоторая неясность относительно времён жизни ссылок все ещё остаётся, сборщик не будет догадываться, какими должны быть времена жизни оставшихся ссылок. В этом случае, вместо угадывания сборщик выдаст ошибку, которую вы можете устранить, добавив изложении времени жизни.</p>
<p>Времена жизни свойств функции или способа называются <em>временем жизни ввода</em>, а времена жизни возвращаемых значений называются <em>временем жизни вывода</em>.</p>
<p>Сборщик использует три правила, чтобы выяснить времена жизни ссылок при отсутствии явных аннотаций. Первое правило относится ко времени жизни ввода, второе и третье правила применяются ко временам жизни вывода. Если сборщик доходит до конца проверки трёх правил и всё ещё есть ссылки, для которых он не может выяснить время жизни, сборщик остановится с ошибкой. Эти правила применяются к объявлениям <code>fn</code>, а также к разделам <code>impl</code>.</p>
<p>Первое правило заключается в том, что каждый свойство являющийся ссылкой, получает свой собственный свойство времени жизни. Другими словами, функция с одним свойствоом получит один свойство времени жизни: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; функция с двумя переменнойми получит два отдельных свойства времени жизни: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, и так далее.</p>
<p>Второе правило говорит, что если есть ровно один входной свойство времени жизни, то его время жизни назначается всем выходным свойствам: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Третье правило о том, что если есть множество входных свойств времени жизни, но один из них является ссылкой <code>&amp;self</code> или <code>&amp;mut self</code>, так как эта функция является способом, то время жизни <code>self</code> назначается временем жизни всем выходным свойствам. Это третье правило делает способы намного приятнее для чтения и записи, потому что требуется меньше символов.</p>
<p>Представим, что мы сборщик и применим эти правила, чтобы вывести времена жизни ссылок в сигнатуре функции <code>first_word</code> приложения 10-25. Сигнатура этой функции начинается без объявления времён жизни ссылок:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Теперь мы (в качестве сборщика) применим первое правило, утверждающее, что каждый свойство функции получает своё собственное время жизни. Как обычно, назовём его <code>'a</code> и теперь сигнатура выглядит так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Далее применяем второе правило, поскольку в функции указан только один входной свойство времени жизни. Второе правило гласит, что время жизни единственного входного свойства назначается выходным свойствам, поэтому сигнатура теперь преобразуется таким образом:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Теперь все ссылки в этой функции имеют свойства времени жизни и сборщик может продолжить свой анализ без необходимости просить у программиста указать изложении времён жизни в сигнатуре этой функции.</p>
<p>Давайте рассмотрим ещё один пример: на этот раз функцию <code>longest</code>, в которой не было свойств времени жизни, когда мы начали с ней работать в приложении 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Применим первое правило: каждому свойству назначается собственное время жизни. На этот раз у функции есть два свойства, поэтому есть два времени жизни:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Можно заметить, что второе правило здесь не применимо, так как в сигнатуре указано больше одного входного свойства времени жизни. Третье правило также не применимо, так как <code>longest</code> — функция, а не способ, следовательно, в ней нет свойства <code>self</code>.  Итак, мы прошли все три правила, но так и не смогли вычислить время жизни выходного свойства. Поэтому мы и получили ошибку при попытке собрать код приложения 10-20: сборщик работал по правилам неявного выведения времён жизни, но не мог выяснить все времена жизни ссылок в сигнатуре.</p>
<p>Так как третье правило применяется только к способам, далее мы рассмотрим времена жизни в этом среде, чтобы понять, почему нам часто не требуется аннотировать времена жизни в сигнатурах способов.</p>
<h3 id="Изложение-времён-жизни-в-определении-способов"><a class="header" href="#Изложение-времён-жизни-в-определении-способов">Изложение времён жизни в определении способов</a></h3>
<p>Когда мы реализуем способы для структур с временами жизни, мы используем тот же синтаксис, который применялся для аннотаций обобщённых видов данных на приложении 10-11. Место, где мы объявляем и используем времена жизни, зависит от того, с чем они связаны — с полями структуры, либо с переменнойми способов и возвращаемыми значениями.</p>
<p>Имена свойств времени жизни для полей структур всегда описываются после ключевого слова <code>impl</code> и затем используются после имени структуры, поскольку эти времена жизни являются частью вида структуры.</p>
<p>В сигнатурах способов внутри раздела <code>impl</code> ссылки могут быть привязаны ко времени жизни ссылок в полях структуры, либо могут быть независимыми. Вдобавок, правила неявного выведения времён жизни часто делают так, что изложении переменных времён жизни являются необязательными в сигнатурах способов. Рассмотрим несколько примеров, использующих структуру с названием <code>ImportantExcerpt</code>, которую мы определили в приложении 10-24.</p>
<p>Сначала, воспользуемся способом <code>level</code>, чей  единственный свойство является ссылкой на <code>self</code>, а возвращаемое значение <code>i32</code>, не является ссылкой ни на что:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}
<span class="boring">}</span></code></pre></pre>
<p>Объявление свойства времени жизни после <code>impl</code> и его использование после имени вида является обязательным, но нам не нужно аннотировать время жизни ссылки на <code>self</code>, благодаря первому правилу неявного выведения времён жизни.</p>
<p>Вот пример, где применяется третье правило неявного выведения времён жизни:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}
<span class="boring">}</span></code></pre></pre>
<p>В этом способе имеется два входных свойства, поэтому Rust применит первое правило и назначит обоим свойствам <code>&amp;self</code> и <code>announcement</code> собственные времена жизни. Далее, поскольку один из свойств является <code>&amp;self</code>, то возвращаемое значение получает время жизни переменой <code>&amp;self</code> и все времена жизни теперь выведены.</p>
<h3 id="Статическое-время-жизни"><a class="header" href="#Статическое-время-жизни">Статическое время жизни</a></h3>
<p>Одно особенное время жизни, которое мы должны обсудить, называется <code>'static</code>. Оно означает, что данная ссылка  <em>может</em> жить всю продолжительность работы программы. Все строковые литералы по умолчанию имеют время жизни <code>'static</code>, но мы можем указать его явным образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>Содержание этой строки сохраняется внутри двоичного файл программы и всегда доступно для использования. Следовательно, время жизни всех строковых литералов равно <code>'static</code>.</p>
<p>Сообщения сборщика об ошибках в качестве решения проблемы могут предлагать вам использовать время жизни <code>'static</code>. Но прежде чем указывать <code>'static</code> как время жизни для ссылки, подумайте, на самом ли деле данная ссылка будет доступна во всё время работы программы. В большинстве случаев, сообщения об ошибках, предлагающие использовать время жизни <code>'static</code> появляются при попытках создания недействительных ссылок или несовпадения имеющихся времён жизни. В таких случаях, решение заключается в исправлении таких проблем, а не в указании статического времени жизни <code>'static</code>.</p>
<h2 id="Обобщённые-виды-свойств-ограничения-типажей-и-времена-жизни-вместе"><a class="header" href="#Обобщённые-виды-свойств-ограничения-типажей-и-времена-жизни-вместе">Обобщённые виды свойств, ограничения типажей и времена жизни вместе</a></h2>
<p>Давайте кратко рассмотрим синтаксис задания свойств обобщённых видов, ограничений типажа и времён жизни совместно в одной функции:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Это функция <code>longest</code>  из приложения 10-21, которая возвращает наибольший из двух срезов строки. Но теперь у неё есть дополнительный свойство с именем <code>ann</code> обобщённого вида <code>T</code>, который может быть представлен любым видом, реализующим типаж <code>Display</code>, как указано в предложении <code>where</code>. Этот дополнительный свойство будет напечатан с использованием <code>{}</code> , поэтому ограничение типажа <code>Display</code> необходимо. Поскольку время жизни является обобщённым видом, то объявления свойства времени жизни <code>'a</code> и свойства обобщённого вида <code>T</code> помещаются в один список внутри угловых скобок после имени функции.</p>
<h2 id="Итоги-7"><a class="header" href="#Итоги-7">Итоги</a></h2>
<p>В этой главе мы рассмотрели много всего! Теперь вы знакомы с свойствами обобщённого вида, типажами и ограничениями типажа, обобщёнными свойствами времени жизни, вы готовы писать код без повторений, который будет работать во множестве различных ситуаций. Свойства обобщённого вида позволяют использовать код для различных видов данных. Типажи и ограничения типажа помогают убедиться, что, хотя виды и обобщённые, они будут вести себя, как этого требует ваш код. Вы изучили, как использовать изложении времени жизни чтобы убедиться, что этот универсальный код не будет генерировать никаких повисших ссылок. И весь этот анализ происходит в момент сборки и не влияет на производительность программы во время работы!</p>
<p>Верите или нет, но в рамках этой темы всё есть ещё чему поучиться: в Главе 17 обсуждаются типажи-объекты, которые являются ещё одним способом использования типажей. Существуют также более сложные сценарии с изложениями времени жизни, которые вам понадобятся только в очень сложных случаях; для этого вам следует прочитать <a href="../reference/index.html">Rust Reference</a>. Далее вы узнаете, как писать тесты на Rust, чтобы убедиться, что ваш код работает так, как задумано.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Написание-автоматизированных-тестов"><a class="header" href="#Написание-автоматизированных-тестов">Написание автоматизированных тестов</a></h1>
<p>В своём эссе 1972 года “The Humble Programmer,” Edsger W. Dijkstra сказал, что «Тестирование программы может быть очень эффективным способом показать наличие ошибок, но это безнадёжно неадекватно для показа их отсутствия». Это не значит, что мы не должны пытаться тестировать столько, сколько мы можем!</p>
<p>Корректностью программы считается то, в какой степени наш код выполняет именно то, что мы задумывали. Rust разработан с учётом большой озабоченности корректностью программ, но корректность сложна и нелегко доказуема. Система типизации Rust берет на себя огромную часть этого бремени, но она не может уловить абсолютно все проблемы. Поэтому в Rust предусмотрена возможность написания автотестов.</p>
<p>Допустим, мы пишем функцию <code>add_two</code>, которая прибавляет 2 к любому переданному ей числу. Сигнатура этой функции принимает целое число в качестве свойства и возвращает целое число в качестве результата. Когда мы реализуем и собираем эту функцию, Rust выполняет всю проверку видов и проверку заимствований, которую вы уже изучили, чтобы убедиться, что, например, мы не передаём значение <code>String</code> или недопустимую ссылку в эту функцию. Но Rust <em>не способен</em> проверить, что эта функция сделает именно то, что мы задумали, то есть вернёт свойство плюс 2, а не, скажем, свойство плюс 10 или свойство минус 50! Вот тут-то и приходят на помощь тесты.</p>
<p>Мы можем написать тесты, которые утверждают, например, что когда мы передаём <code>3</code> в функцию <code>add_two</code>, возвращаемое значение будет <code>5</code>. Мы можем запускать эти тесты всякий раз, когда мы вносим изменения в наш код, чтобы убедиться, что любое существующее правильное поведение не изменилось.</p>
<p>Тестирование - сложный навык: мы не сможем охватить все подробности написания хороших тестов в одной главе, но мы обсудим основные подходы к тестированию в Rust. Мы поговорим об изложениех и макросах, доступных вам для написания тестов, о поведении по умолчанию и свойствах, предусмотренных для запуска тестов, а также о том, как организовать тесты в модульные тесты и встроенные тесты.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Как-писать-тесты"><a class="header" href="#Как-писать-тесты">Как писать тесты</a></h2>
<p>Тесты - это функции Rust, которые проверяют, что не тестовый код работает ожидаемым образом. Содержимое тестовых функций обычно выполняет следующие три действия:</p>
<ol>
<li>Установка любых необходимых данных или состояния.</li>
<li>Запуск кода, который вы хотите проверить.</li>
<li>Утверждение, что результаты являются теми, которые вы ожидаете.</li>
</ol>
<p>Давайте рассмотрим функции предоставляемые в Rust целенаправленно для написания тестов, которые выполнят все эти действия, включая атрибут <code>test</code>, несколько макросов и атрибут <code>should_panic</code>.</p>
<h3 id="Структура-тестирующей-функции"><a class="header" href="#Структура-тестирующей-функции">Структура тестирующей функции<a id="the-anatomy-of-a-test-function"></a></a></h3>
<p>В простейшем случае в Rust тест - это функция, аннотированная атрибутом <code>test</code>. Атрибуты представляют собой метаданные о фрагментах кода Rust; один из примеров атрибут <code>derive</code>, который мы использовали со структурами в главе 5. Чтобы превратить функцию в тестирующую функцию добавьте <code>#[test]</code>  в строку перед <code>fn</code>.  Когда вы запускаете тесты приказом <code>cargo test</code>, Rust создаёт двоичный модуль выполняющий функции аннотированные атрибутом test и сообщающий о том, успешно или нет прошла каждая тестирующая функция.</p>
<p>Когда мы создаём новый проект библиотеки с помощью Cargo, то в нём самостоятельно генерируется тестовый модуль с тест-функцией для нас. Этот модуль даст вам шаблон для написания ваших тестов, так что вам не нужно искать точную структуру и синтаксис тестовых функций каждый раз, когда вы начинаете новый проект. Вы можете добавить столько дополнительных тестовых функций и столько тестовых модулей, сколько захотите!</p>
<p>Мы исследуем некоторые особенности работы тестов, экспериментируя с шаблонным тестом сгенерированным для нас, без реального тестирования любого кода. Затем мы напишем некоторые существующие тесты, которые вызывают некоторый написанный код и убедимся в его правильном поведении. Мы рассмотрим некоторые особенности работы тестов, поэкспериментируем с шаблонным тестом, прежде чем приступать к фактическому тестированию любого кода. Затем мы напишем несколько существующих тестов, которые вызывают некоторый написанный нами код и проверяют, что его поведение правильное.</p>
<p>Давайте создадим новый библиотечный проект под названием <code>adder</code>, который складывает два числа:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Содержимое файла <em>src/lib.rs</em> вашей библиотеки <code>adder</code> должно выглядеть как в приложении 11-1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 11-1: Тестовый модуль и функция, сгенерированные самостоятельно с помощью <code>cargo new</code></span></p>
<p>Сейчас давайте пропренебрегаем первые две строчки кода и сосредоточимся на функции. Обратите внимание на синтаксис изложении <code>#[test]</code>: этот атрибут указывает, что это тестовая функция, поэтому запускающий тестирование знает, что эту функцию следует рассматривать как тестовую. У нас также могут быть не тестируемые функции в модуле <code>tests</code>, которые помогут настроить общие сценарии или выполнить общие действия, поэтому нам всегда нужно указывать, какие функции являются тестами.</p>
<p>В теле функции теста используется макрос <code>assert_eq!</code>, чтобы утверждать, что <code>result</code>, который содержит результат сложения 2 и 2, равен 4. Это утверждение служит примером формата для типичного теста. Давайте запустим его, чтобы убедиться, что этот тест пройден.</p>
<p>Приказ <code>cargo test</code> выполнит все тесты в выбранном проекте и сообщит о результатах как в приложении 11-2:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}
</code></pre>
<p><span class="caption">Приложение 11-2: Вывод сведений о работе самостоятельно сгенерированных тестов</span></p>
<p>Cargo собрал и выполнил тест. Мы видим строку <code>running 1 test</code>. Следующая строка показывает имя сгенерированной тестовой функции, называемой  <code>it_works</code>, и результат запуска этого теста равный <code>ok</code>. Текст <code>test result: ok.</code> означает, что все тесты пройдены успешно и часть вывода <code>1 passed; 0 failed</code> сообщает общее количество тестов, которые прошли или были ошибочными.</p>
<p>Можно пометить тест как пренебрегаемый, чтобы он не выполнялся в определенном случае; мы рассмотрим это в разделе <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“Пренебрежение некоторых тестов, если их целенаправленно не запрашивать”</a><!-- ignore --> позже в этой главе. Поскольку в данный момент мы этого не сделали, в сводке показано, что <code>0 ignored</code>. Мы также можем передать переменная приказу <code>cargo test</code> для запуска только тех тестов, имя которых соответствует строке; это называется <em>фильтрацией</em>, и мы рассмотрим это в разделе <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“Запуск подмножества тестов по имени”</a><!-- ignore -->. Мы также не фильтровали выполняемые тесты, поэтому в конце сводки показано, что <code>0 filtered out</code>.</p>
<p>Статистика <code>0 measured</code> предназначена для тестов производительности. На момент написания этой статьи такие тесты доступны только в ночной сборке Rust. Посмотрите <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">документацию о тестах производительности</a>, чтобы узнать больше.</p>
<p>Следующая часть вывода тестов начинается с <code>Doc-tests adder</code> - это сведения о тестах в документации. У нас пока нет тестов документации, но Rust может собирать любые примеры кода, которые находятся в API документации. Такая возможность помогает поддерживать документацию и код в синхронизированном состоянии. Мы поговорим о написании тестов документации в секции <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">"Комментарии документации как тесты"</a><!-- ignore --> Главы 14. Пока просто пропренебрегаем часть <code>Doc-tests</code> вывода.</p>
<p>Давайте начнём настраивать тест в соответствии с нашими собственными потребностями. Сначала поменяем название нашего теста <code>it_works</code> на <code>exploration</code>, вот так:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}</code></pre>
<p>Снова выполним приказ <code>cargo test</code>. Вывод показывает наименование нашей тест-функции - <code>exploration</code> вместо <code>it_works</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}
</code></pre>
<p>Добавим ещё один тест, но в этот раз целенаправленно сделаем так, чтобы этот новый тест не отработал! Тест терпит неудачу, когда что-то паникует в тестируемой функции. Каждый тест запускается в новом потоке и когда главный поток видит, что тестовый поток упал, то помечает тест как завершившийся аварийно. Мы говорили о простейшем способе вызвать панику в главе 9, используя для этого известный макрос <code>panic!</code>. Введём код тест-функции <code>another</code>, как в файле <em>src/lib.rs</em> из приложения 11-3.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 11-3: Добавление второго теста, который завершится ошибкой, потому что мы вызываем <code>panic!</code> макрос</span></p>
<p>Запустим приказ <code>cargo test</code>. Вывод результатов показан в приложении 11-4, который сообщает, что тест <code>exploration</code> пройден, а <code>another</code> нет:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}
</code></pre>
<p><span class="caption">Приложение 11-4. Результаты теста, когда один тест пройден, а другой нет</span></p>
<p>Вместо <code>ok</code>, строка <code>test tests::another</code> сообщает <code>FAILED</code>. Две новые секции появились между отдельными результатами и сводкой: в первом отображается подробная причина каждого сбоя теста. В данном случае тест <code>another</code> не сработал, потому что <code>panicked at 'Make this test fail'</code>, произошло в строке 10 файла <em>src/lib.rs</em>. В следующем разделе перечисляют имена всех не пройденных тестов, что удобно, когда есть много тестов и много подробных результатов неудачных тестов. Мы можем использовать имя не пройденного теста для его дальнейшей отладки; мы больше поговорим о способах запуска тестов в разделе <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">"Управление хода выполнения тестов"</a><!-- ignore -->.</p>
<p>Итоговая строка отображается в конце: общий результат нашего тестирования <code>FAILED</code>. У нас один тест пройден и один тест завершён аварийно.</p>
<p>Теперь, когда вы увидели, как выглядят результаты теста при разных сценариях, давайте рассмотрим другие макросы полезные в тестах, кроме <code>panic!</code>.</p>
<h3 id="Проверка-результатов-с-помощью-макроса-assert"><a class="header" href="#Проверка-результатов-с-помощью-макроса-assert">Проверка результатов с помощью макроса <code>assert!</code></a></h3>
<p>Макрос <code>assert!</code> доступен из встроенной библиотеки и является удобным, когда вы хотите проверить что некоторое условие в тесте вычисляется в значение <code>true</code>. Мы передаём в макрос <code>assert!</code> переменная, который вычисляется в логическое значение. Если оно <code>true</code>, то ничего не происходит и тест считается пройденным. Если же значение вычисляется в <code>false</code>, то макрос <code>assert!</code> вызывает макрос <code>panic!</code>, чтобы вызвать сбой теста. Использование макроса <code>assert!</code> помогает проверить, что код функционирует как ожидалось.</p>
<p>В главе 5, приложении 5-15, мы использовали структуру <code>Rectangle</code> и способ <code>can_hold</code>, который повторён в приложении 11-5. Давайте поместим этот код в файл <em>src/lib.rs</em> и напишем несколько тестов для него используя макрос <code>assert!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 11-5: Использование структуры <code>Rectangle</code> и её способа can_hold из главы 5</span></p>
<p>Способ <code>can_hold</code> возвращает логическое значение, что означает, что он является наилучшим вариантом использования в макросе <code>assert!</code>. В приложении 11-6 мы пишем тест, который выполняет способ <code>can_hold</code> путём создания экземпляра <code>Rectangle</code> шириной 8 и высотой 7 и убеждаемся, что он может содержать другой экземпляр <code>Rectangle</code> имеющий ширину 5 и высоту 1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 11-6: Тест для способа <code>can_hold</code>, который проверяет что больший прямоугольник действительно может содержать меньший</span></p>
<p>Также, в модуле <code>tests</code> обратите внимание на новую добавленную строку <code>use super::*;</code>. Модуль <code>tests</code> является обычным и подчиняется тем же правилам видимости, которые мы обсуждали в главе 7 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Пути для ссылки на элементы внутри дерева модуля"</a><!--  -->. Так как этот модуль <code>tests</code> является внутренним, нужно подключить тестируемый код из внешнего модуля в область видимости внутреннего модуля с тестами. Для этого используется вездесущеее подключение, так что все что определено во внешнем модуле становится доступным внутри <code>tests</code> модуля.</p>
<p>Мы назвали наш тест <code>larger_can_hold_smaller</code> и создали два нужных экземпляра <code>Rectangle</code>. Затем вызвали макрос <code>assert!</code> и передали результат вызова <code>larger.can_hold(&amp;smaller)</code> в него. Это выражение должно возвращать <code>true</code>, поэтому наш тест должен пройти. Давайте выясним!</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}
</code></pre>
<p>Тест проходит. Теперь добавим другой тест, в этот раз мы попытаемся убедиться, что меньший прямоугольник не может содержать больший прямоугольник:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}</code></pre>
<p>Поскольку правильный результат функции <code>can_hold</code> в этом случае <code>false</code>, то мы должны инвертировать этот результат, прежде чем передадим его в <code>assert!</code> макро. Как результат, наш тест пройдёт, если <code>can_hold</code> вернёт <code>false</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}
</code></pre>
<p>Два теста работают. Теперь проверим, как отреагируют тесты, если мы добавим ошибку в код. Давайте изменим реализацию способа <code>can_hold</code> заменив одно из логических выражений знак сравнения с "больше чем" на противоположный "меньше чем" при сравнении ширины:</p>
<pre><code class="language-rust not_desired_behavior noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}</code></pre>
<p>Запуск тестов теперь производит следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}
</code></pre>
<p>Наши тесты нашли ошибку! Так как в тесте <code>larger.width</code> равно 8 и <code>smaller.width</code> равно 5 сравнение ширины в способе <code>can_hold</code> возвращает результат <code>false</code>, поскольку число 8 не меньше чем 5.</p>
<h3 id="Проверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne"><a class="header" href="#Проверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne">Проверка на равенство с помощью макросов <code>assert_eq!</code> и <code>assert_ne!</code></a></h3>
<p>Общим способом проверки функциональности является использование сравнения результата тестируемого кода и ожидаемого значения, чтобы убедиться в их равенстве. Для этого можно использовать макрос <code>assert!</code>, передавая ему выражение с использованием оператора <code>==</code>. Важно также знать, что кроме этого стандартная библиотека предлагает пару макросов <code>assert_eq!</code> и <code>assert_ne!</code>, чтобы сделать тестирование более удобным. Эти макросы сравнивают два переменной на равенство или неравенство соответственно. Макросы также печатают два значения входных свойств, если тест завершился ошибкой, что позволяет легче увидеть <em>почему</em> тест ошибочен. Противоположно этому, макрос <code>assert!</code> может только отобразить, что он вычислил значение <code>false</code> для выражения <code>==</code>, но не значения, которые привели к результату <code>false</code>.</p>
<p>В приложении 11-7, мы напишем функцию <code>add_two</code>, которая прибавляет к входному свойству <code>2</code> и возвращает значение. Затем, протестируем эту функцию с помощью макроса <code>assert_eq!</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 11-7: Тестирование функции <code>add_two</code> с помощью макроса <code>assert_eq!</code></span></p>
<p>Проверим, что тесты проходят!</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}
</code></pre>
<p>Первый переменная, который мы передаём в макрос <code>assert_eq!</code> число <code>4</code> чей результат вызова равен <code>add_two(2)</code> . Строка для этого теста - <code>test tests::it_adds_two ... ok</code> , а текст <code>ok</code> означает, что наш тест пройден!</p>
<p>Давайте введём ошибку в код, чтобы увидеть, как она выглядит, когда тест, который использует <code>assert_eq!</code> завершается ошибкой. Измените реализацию функции <code>add_two</code>, чтобы добавлять <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}</code></pre>
<p>Попробуем выполнить данный тест ещё раз:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}
</code></pre>
<p>Наш тест нашёл ошибку! Тест <code>it_adds_two</code> не выполнился, отображается сообщение <code>assertion failed: </code>(left == right)`` и показывает, что <code>left</code> было <code>4</code>, а <code>right</code> было <code>5</code>. Это сообщение полезно и помогает начать отладку: это означает <code>left</code> переменная <code>assert_eq!</code> имел значение <code>4</code>, но <code>right</code> переменная для вызова <code>add_two(2)</code> был со значением <code>5</code>.</p>
<p>Обратите внимание, что в некоторых языках (таких как Java) в библиотеках кода для тестирования принято именовать входные свойства проверочных функций как "ожидаемое" (<code>expected</code>) и "фактическое" (<code>actual</code>). В Rust приняты следующие обозначения <code>left</code> и <code>right</code> соответственно, а порядок в котором определяются ожидаемое значение и производимое тестируемым кодом значение не имеют значения. Мы могли бы написать выражение в тесте как <code>assert_eq!(add_two(2), 4)</code>, что приведёт к отображаемому сообщению об ошибке <code>assertion failed: </code>(left == right)``, слева <code>left</code> было бы <code>5</code>, а справа <code>right</code> было бы <code>4</code>.</p>
<p>Макрос <code>assert_ne!</code> сработает успешно, если входные свойства не равны друг другу и завершится с ошибкой, если значения равны. Этот макрос наиболее полезен в тех случаях, когда мы не знаем заранее, каким значение <em>будет</em>, но знаем точно, каким оно <em>не может</em> быть. К примеру, если тестируется функция, которая обязательно изменяет входные данные определённым образом, но способ изменения входного свойства зависит от дня недели, в который запускаются тесты, что лучший способ проверить правильность работы такой функции - это сравнить и убедиться, что выходное значение функции не должно быть равным входному значению.</p>
<p>В своей работе макросы <code>assert_eq!</code> и <code>assert_ne!</code> неявным образом используют операторы <code>==</code> и <code>!=</code> соответственно. Когда проверка не срабатывает, макросы печатают значения переменных с помощью отладочного форматирования и это означает, что значения сравниваемых переменных должны реализовать типажи <code>PartialEq</code> и <code>Debug</code>. Все примитивные и большая часть видов встроенной библиотеки Rust реализуют эти типажи. Для структур и перечислений, которые вы реализуете сами будет необходимо реализовать типаж <code>PartialEq</code> для сравнения значений на равенство или неравенство. Для печати отладочной сведений в виде сообщений в строку вывода окне вывода необходимо реализовать типаж <code>Debug</code>. Так как оба типажа являются выводимыми типажами, как упоминалось в приложении 5-12 главы 5, то эти типажи можно реализовать добавив изложение <code>#[derive(PartialEq, Debug)]</code> к определению структуры или перечисления. Смотрите больше подробностей в Appendix C <a href="appendix-03-derivable-traits.html">"Выводимые типажи"</a><!-- ignore --> про эти и другие выводимые типажи.</p>
<h3 id="Создание-сообщений-об-ошибках"><a class="header" href="#Создание-сообщений-об-ошибках">Создание сообщений об ошибках</a></h3>
<p>Также можно добавить пользовательское сообщение как дополнительный переменная макросов для печати в сообщении об ошибке теста <code>assert!</code>, <code>assert_eq!</code>, и <code>assert_ne!</code>. Любые переменные, указанные после обязательных переменных, далее передаются в макрос <code>format!</code> (он обсуждается в разделе <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">"Конкатенация с помощью оператора <code>+</code> или макроса format!"</a><!-- ignore -->), так что вы можете передать форматированную строку, которая содержит  <code>{}</code> для заполнителей и значения, заменяющие эти заполнители. Пользовательские сообщения полезны для пояснения того, что означает утверждение (assertion); когда тест завершается неудачей, у вас будет лучшее представление о том, в чем проблема с кодом.</p>
<p>Например, есть функция, которая приветствует человека по имени и мы хотим протестировать эту функцию. Мы хотим чтобы передаваемое ей имя выводилось в окно вывода:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}</code></pre>
<p>Требования к этой программе ещё не были согласованы и мы вполне уверены, что текст <code>Hello</code> в начале приветствия ещё изменится. Мы решили, что не хотим обновлять тест при изменении требований, поэтому вместо проверки на точное равенство со значением возвращённым из <code>greeting</code>, мы просто будем проверять, что вывод содержит текст из входного свойства.</p>
<p>Давайте внесём ошибку в этот код, изменив <code>greeting</code> так, чтобы оно не включало <code>name</code> и увидим, как выглядит сбой этого теста:</p>
<pre><code class="language-rust not_desired_behavior noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}</code></pre>
<p>Запуск этого теста выводит следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}
</code></pre>
<p>Сообщение содержит лишь сведения о том что сравнение не было успешным и в какой строке это произошло. В данном случае, более полезный текст сообщения был бы, если бы также выводилось значение из функции <code>greeting</code>. Изменим тестирующую функцию так, чтобы выводились пользовательское сообщение форматированное строкой с заменителем и фактическими данными из кода <code>greeting</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}</code></pre>
<p>После того, как выполним тест ещё раз мы получим подробное сообщение об ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}
</code></pre>
<p>Мы можем увидеть значение, которое мы на самом деле получили в тестовом выводе, что поможет нам отлаживать произошедшее, а не то, что мы ожидали.</p>
<h3 id="Проверка-с-помощью-макроса-should_panic"><a class="header" href="#Проверка-с-помощью-макроса-should_panic">Проверка с помощью макроса <code>should_panic</code></a></h3>
<p>В дополнение к проверке того, что наш код возвращает правильные, ожидаемые значения, важным также является проверить, что наш код обрабатывает ошибки, которые мы ожидаем. Например, рассмотрим вид <code>Guess</code> который мы создали в главе 9, приложения 9-10. Другой код, который использует <code>Guess</code> зависит от заверения того, что <code>Guess</code> экземпляры будут содержать значения только от 1 до 100. Мы можем написать тест, который заверяет, что попытка создать экземпляр <code>Guess</code> со значением вне этого ряда вызывает панику.</p>
<p>Реализуем это с помощью другого атрибута тест-функции <code>#[should_panic]</code>. Этот атрибут сообщает системе тестирования, что тест проходит, когда способ генерирует ошибку. Если ошибка не генерируется - тест считается не пройденным.</p>
<p>Приложение 11-8 показывает тест, который проверяет, что условия ошибки <code>Guess::new</code> произойдут, когда мы их ожидаем их.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 11-8: Проверка того, что условие вызовет макрос <code>panic!</code></span></p>
<p>Атрибут <code>#[should_panic]</code> следует после <code>#[test]</code> и до объявления тестовой функции. Посмотрим на вывод результата, когда тест проходит:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}
</code></pre>
<p>Выглядит хорошо! Теперь давайте внесём ошибку в наш код, убрав условие о том, что функция <code>new</code> будет паниковать если значение больше 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}</code></pre>
<p>Когда мы запустим тест в приложении 11-8, он потерпит неудачу:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}
</code></pre>
<p>Мы получаем не очень полезное сообщение в этом случае, но когда мы смотрим на тестирующую функцию, мы видим, что она <code>#[should_panic]</code>. Аварийное выполнение, которое мы получили означает, что код в тестирующей функции не вызвал паники.</p>
<p>Тесты, которые используют <code>should_panic</code> могут быть неточными, потому что они только указывают, что код вызвал панику. Тест с атрибутом <code>should_panic</code> пройдёт, даже если тест паникует по причине, отличной от той, которую мы ожидали. Чтобы сделать тесты с <code>should_panic</code> более точными, мы можем добавить необязательный свойство <code>expected</code>  для атрибута <code>should_panic</code>. Такая подробностизация теста позволит удостовериться, что сообщение об ошибке содержит предоставленный текст. Например, рассмотрим модифицированный код для <code>Guess</code> в приложении 11-9, где <code>new</code> функция паникует с различными сообщениями в зависимости от того, является ли значение слишком маленьким или слишком большим.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 11-9: Проверка <code>panic!</code> на наличие в его сообщении указанной подстроки</span></p>
<p>Этот тест пройдёт, потому что значение, которое мы поместили для <code>should_panic</code> в свойство атрибута <code>expected</code> является подстрокой сообщения, с которым функция <code>Guess::new</code> вызывает панику. Мы могли бы указать полное, ожидаемое сообщение для паники, в этом случае это будет <code>Guess value must be less than or equal to 100, got 200</code>. То что вы выберите для указания как ожидаемого свойства у <code>should_panic</code> зависит от того, какая часть сообщения о панике уникальна или динамична, насколько вы хотите, чтобы ваш тест был точным. В этом случае достаточно подстроки из сообщения паники, чтобы обеспечить выполнение кода в тестовой функции <code>else if value &gt; 100</code> .</p>
<p>Чтобы увидеть, что происходит, когда тест <code>should_panic</code> неуспешно завершается с сообщением <code>expected</code>, давайте снова внесём ошибку в наш код, поменяв местами <code>if value &lt; 1</code> и <code>else if value &gt; 100</code> блоки:</p>
<pre><code class="language-rust ignore not_desired_behavior">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}</code></pre>
<p>На этот раз, когда мы выполним <code>should_panic</code> тест, он потерпит неудачу:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}
</code></pre>
<p>Сообщение об ошибке указывает, что этот тест действительно вызвал панику, как мы и ожидали, но сообщение о панике не включено ожидаемую строку <code>'Guess value must be less than or equal to 100'</code>. Сообщение о панике, которое мы получили в этом случае, было <code>Guess value must be greater than or equal to 1, got 200.</code> Теперь мы можем начать выяснение, где ошибка!</p>
<h3 id="Использование-resultt-e-в-тестах"><a class="header" href="#Использование-resultt-e-в-тестах">Использование <code>Result&lt;T, E&gt;</code> в тестах</a></h3>
<p>Пока что мы написали тесты, которые паникуют, когда терпят неудачу. Мы также можем написать тесты которые используют <code>Result&lt;T, E&gt;</code>! Вот тест из приложения 11-1, переписанный с использованием <code>Result&lt;T, E&gt;</code> и возвращающий <code>Err</code> вместо паники:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs}}</code></pre>
<p>Функция <code>it_works</code> теперь имеет возвращаемый вид <code>Result&lt;(), String&gt;</code>. В теле функции, вместо вызова макроса <code>assert_eq!</code>, мы возвращаем <code>Ok(())</code> когда тест успешно выполнен и <code>Err</code> со <code>String</code> внутри, когда тест не проходит.</p>
<p>Написание тестов так, чтобы они возвращали <code>Result&lt;T, E&gt;</code> позволяет использовать оператор "вопросительный знак"  в теле тестов, который может быть удобным способом писать тесты, которые должны выполниться не успешно, если какая-либо действие внутри них возвращает вариант ошибки <code>Err</code>.</p>
<p>Вы не можете использовать изложение <code>#[should_panic]</code> в тестах, использующих <code>Result&lt;T, E&gt;</code>. Чтобы утверждать, что действие возвращает вариант <code>Err</code>, <em>не</em> используйте оператор вопросительного знака для значения <code>Result&lt;T, E&gt;</code>. Вместо этого используйте <code>assert!(value.is_err())</code>.</p>
<p>Теперь, когда вы знаете несколько способов написания тестов, давайте взглянем на то, что происходит при запуске тестов и исследуем разные опции используемые с приказом <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Управление-хода-выполнения-тестов"><a class="header" href="#Управление-хода-выполнения-тестов">Управление хода выполнения тестов</a></h2>
<p>Подобно тому, как <code>cargo run</code> выполняет сборку вашего кода, а затем запускает полученный двоичный файл, <code>cargo test</code> собирает ваш код в режиме тестирования и запускает полученный двоичный файл с тестами. Двоичный файл, создаваемый <code>cargo test</code>, по умолчанию запускает все тесты параллельно и перехватывает вывод, генерируемый во время выполнения тестов, предотвращая их вывод на экран для облегчения чтения вывода, относящегося к результатам тестирования. Однако вы можете указать свойства приказной строки, чтобы изменить это поведение по умолчанию.</p>
<p>Часть свойств приказной строки передаётся в <code>cargo test</code>, а часть - в итоговый двоичный файл с тестами. Чтобы разделить эти два вида переменных, нужно сначала указать переменные, которые идут в <code>cargo test</code>, затем использовать разделитель <code>--</code>, а потом те, которые попадут в двоичный файл теста. Выполнение <code>cargo test --help</code> выводит опции, которые вы можете использовать с <code>cargo test</code>, а выполнение <code>cargo test -- --help</code> выводит опции, которые вы можете использовать за разделителем.</p>
<h3 id="Выполнение-тестов-параллельно-или-последовательно"><a class="header" href="#Выполнение-тестов-параллельно-или-последовательно">Выполнение тестов параллельно или последовательно</a></h3>
<p>Когда вы запускаете несколько тестов, по умолчанию они выполняются параллельно с использованием потоков, что означает, что они завершатся быстрее, и вы быстрее получите результаты. Поскольку тесты выполняются параллельно, вы должны убедиться, что ваши тесты не зависят друг от друга или от какого-либо общего состояния, включая общее окружение, например, текущий рабочий каталог или переменные окружения.</p>
<p>Например, допустим, каждый из ваших тестов запускает код, который создаёт файл на диске с именем <em>test-output.txt</em> и записывает некоторые данные в этот файл. Затем каждый тест считывает данные из этого файла и утверждает, что файл содержит определённое значение, которое в каждом тесте разное. Поскольку все тесты выполняются одновременно, один из тестов может перезаписать файл в промежутке между записью и чтением файла другим тестом. Тогда второй тест потерпит неудачу, но не потому, что код неверен, а потому, что эти тесты мешали друг другу при параллельном выполнении. Одно из решений - убедиться, что каждый тест пишет в свой отдельный файл; другое решение - запускать тесты по одному.</p>
<p>Если вы не хотите запускать тесты параллельно или хотите более подробный управление над количеством используемых потоков, можно установить флаг <code>--test-threads</code> и то количество потоков, которое вы хотите использовать для теста. Взгляните на следующий пример:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Мы устанавливаем количество тестовых потоков равным <code>1</code> , указывая программе не использовать параллелизм. Выполнение тестов с использованием одного потока займёт больше времени, чем их параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют состояние.</p>
<h3 id="Отображение-результатов-работы-функции"><a class="header" href="#Отображение-результатов-работы-функции">Отображение результатов работы функции</a></h3>
<p>По умолчанию, если тест пройден, система управления запуска тестов блокирует вывод на печать, т.е. если вы вызовете макрос <code>println!</code> внутри кода теста и тест будет пройден, вы не увидите вывода на окно вывода результатов вызова <code>println!</code>. Если же тест не был пройден, все несущие сведения сообщения, а также описание ошибки будут выведены на окно вывода.</p>
<p>Например, в коде (11-10) функция выводит значение свойства с поясняющим текстовым сообщением, а также возвращает целочисленное константное значение <code>10</code>. Далее следует тест, который имеет правильный входной свойство и тест, который имеет ошибочный входной свойство:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-10/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 11-10: Тест функции, которая использует макрос <code>println!</code></span></p>
<p>Результат вывода на окно вывода приказы <code>cargo test</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-10/output.txt}}
</code></pre>
<p>Обратите внимание, что нигде в этом выводе мы не видим сообщения <code>I got the value 4</code> , которое печатается при выполнении пройденного теста. Этот вывод был записан. Результат неудачного теста, <code>I got the value 8</code> , появляется в разделе итоговых результатов теста, который также показывает причину неудачного теста.</p>
<p>Если мы хотим видеть напечатанные результаты прохождения тестов, мы можем сказать Rust, чтобы он также показывал результаты успешных тестов с помощью <code>--show-output</code>.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Когда мы снова запускаем тесты из Приложения 11-10 с флагом <code>--show-output</code> , мы видим следующий результат:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/output-only-01-show-output/output.txt}}
</code></pre>
<h3 id="Запуск-подмножества-тестов-по-имени"><a class="header" href="#Запуск-подмножества-тестов-по-имени">Запуск подмножества тестов по имени</a></h3>
<p>Бывают случаи, когда в запуске всех тестов нет необходимости и нужно запустить только несколько тестов. Если вы работаете над функцией и хотите запустить тесты, которые исследуют её работу - это было бы удобно. Вы можете это сделать, используя приказ <code>cargo test</code>, передав в качестве переменной имена тестов.</p>
<p>Для отображения, как запустить группу тестов, мы создадим группу тестов для функции <code>add_two</code> function, как показано в Приложении 11-11, и постараемся выбрать какие из них запускать.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-11/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 11-11: Три теста с различными именами</span></p>
<p>Если вы выполните приказ <code>cargo test</code> без уточняющих переменных, все тесты выполнятся параллельно:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-11/output.txt}}
</code></pre>
<h4 id="Запуск-одного-теста"><a class="header" href="#Запуск-одного-теста">Запуск одного теста</a></h4>
<p>Мы можем запустить один тест с помощью указания его имени в приказу <code>cargo test</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/output-only-02-single-test/output.txt}}
</code></pre>
<p>Был запущен только тест с названием <code>one_hundred</code>; два других теста не соответствовали этому названию. Результаты теста с помощью вывода <code>2 filtered out</code> дают нам понять, что у нас было больше тестов, но они не были запущены.</p>
<p>Таким образом мы не можем указать имена нескольких тестов; будет использоваться только первое значение, указанное для <code>cargo test</code> . Но есть способ запустить несколько тестов.</p>
<h4 id="Использование-фильтров-для-запуска-нескольких-тестов"><a class="header" href="#Использование-фильтров-для-запуска-нескольких-тестов">Использование фильтров для запуска нескольких тестов</a></h4>
<p>Мы можем указать часть имени теста, и будет запущен любой тест, имя которого соответствует этому значению. Например, поскольку имена двух наших тестов содержат <code>add</code>, мы можем запустить эти два, запустив <code>cargo test add</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/output-only-03-multiple-tests/output.txt}}
</code></pre>
<p>Этот приказ запускала все тесты с <code>add</code> в имени и отфильтровывала тест с именем <code>one_hundred</code> . Также обратите внимание, что модуль, в котором появляется тест, становится частью имени теста, поэтому мы можем запускать все тесты в модуле, фильтруя имя модуля.</p>
<h3 id="Пренебрежение-тестов"><a class="header" href="#Пренебрежение-тестов">Пренебрежение тестов</a></h3>
<p>Бывает, что некоторые тесты требуют продолжительного времени для своего исполнения, и вы хотите исключить их из исполнения при запуске <code>cargo test</code>. Вместо перечисления в приказной строке всех тестов, которые вы хотите запускать, вы можете аннотировать тесты, требующие много времени для прогона, атрибутом <code>ignore</code>, чтобы исключить их, как показано здесь:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/src/lib.rs}}</code></pre>
<p>После <code>#[test]</code> мы добавляем строку <code>#[ignore]</code> в тест, который хотим исключить. Теперь, когда мы запускаем наши тесты, <code>it_works</code> запускается, а <code>expensive_test</code> пренебрегается:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/output.txt}}
</code></pre>
<p>Функция <code>expensive_test</code> помечена как <code>ignored</code>. Если вы хотите выполнить только пренебреженные тесты, вы можете воспользоваться приказом <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/output-only-04-running-ignored/output.txt}}
</code></pre>
<p>Управляя тем, какие тесты запускать, вы можете быть уверены, что результаты вашего <code>cargo test</code> будут быстрыми. Когда вы дойдёте до момента, где имеет смысл проверить результаты тестов <code>ignored</code>, и у вас есть время дождаться их результатов, вы можете запустить их с помощью <code>cargo test -- --ignored</code>. Если вы хотите запустить все тесты независимо от того, пренебрегаются они или нет, выполните <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Организация-тестов"><a class="header" href="#Организация-тестов">Организация тестов</a></h2>
<p>Как упоминалось в начале главы, тестирование является сложной дисциплиной и разные люди используют разную терминологию и организацию. Сообщество Rust думает о тестах с точки зрения двух основных разрядов: <em>модульные тесты</em> и <em>встроенные тесты</em>. Модульные тесты это небольшие и более сфокусированные на тестировании одного модуля в отдельности или могут тестироваться приватные внешние оболочки. Встраиваемые тесты являются полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные внешние оболочки и потенциально выполняя тестирование нескольких модулей в одном тесте.</p>
<p>Написание обоих видов тестов важно для обеспечения того, чтобы кусочки вашей библиотеки по отдельности и вместе делали то, что вы ожидаете.</p>
<h3 id="Модульные-тесты"><a class="header" href="#Модульные-тесты">Модульные тесты</a></h3>
<p>Целью модульных тестов является тестирование каждого раздела кода, изолированное от остального функционала, чтобы можно было быстро понять, что работает некорректно или не так как ожидается. Мы разместим модульные тесты в папке <em>src</em>, в каждый тестируемый файл. Но в Rust принято создавать тестирующий модуль <code>tests</code> и код теста сохранять в файлы с таким же именем, как компоненты которые предстоит тестировать. Также необходимо добавить изложение <code>cfg(test)</code> к этому модулю.</p>
<h4 id="Модуль-тестов-и-изложение-cfgtest"><a class="header" href="#Модуль-тестов-и-изложение-cfgtest">Модуль тестов и изложение <code>#[cfg(test)]</code></a></h4>
<p>Изложение <code>#[cfg(test)]</code> у модуля с тестами указывает Rust собирать и запускать только код тестов, когда выполняется приказ <code>cargo test</code>, а не когда запускается <code>cargo build</code>. Это экономит время сборки, если вы только хотите собрать библиотеку и сэкономить место для результирующих собранных артефактов, потому что тесты не будут включены. Вы увидите что, по причине того, что встроенные тесты помещаются в другой каталог им не нужна изложение <code>#[cfg(test)]</code>. Тем не менее, так как модульные тесты идут в тех же файлах что и основной код, вы будете использовать <code>#[cfg(test)]</code> чтобы указать, что они не должны быть включены в собранный результат.</p>
<p>Напомним, что когда мы генерировали новый проект <code>adder</code> в первом разделе этой главы, то Cargo сгенерировал для нас код ниже:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}</code></pre>
<p>Этот код является самостоятельно сгенерированным тестовым модулем. Атрибут <code>cfg</code> предназначен для <em>настройке</em> и говорит Rust, что следующий элемент должен быть включён только учитывая определённую опцию настройке. В этом случае опцией настройке является <code>test</code>, который предоставлен в Rust для сборки и запуска текущих тестов. Используя атрибут <code>cfg</code>, Cargo собирает только тестовый код при активном запуске тестов приказом <code>cargo test</code>. Это включает в себя любые вспомогательные функции, которые могут быть в этом модуле в дополнение к функциям помеченным <code>#[test]</code>.</p>
<h4 id="Тестирование-приватных-функций-private"><a class="header" href="#Тестирование-приватных-функций-private">Тестирование приватных функций (private)</a></h4>
<p>Сообщество программистов не имеет однозначного мнения по поводу тестировать или нет приватные функции. В некоторых языках весьма сложно или даже невозможно тестировать такие функции. Независимо от того, какой технологии тестирования вы придерживаетесь, в Rust приватные функции можно тестировать. Рассмотрим приложение 11-12 с приватной функцией <code>internal_adder</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 11-12: Тестирование приватных функций</span></p>
<p>Обратите внимание, что функция <code>internal_adder</code> не помечена как <code>pub</code>. Тесты — это просто Rust код, а модуль <code>tests</code> — это ещё один модуль. Как мы обсуждали в разделе <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Пути для ссылки на элемент в дереве модулей“</a><!--  -->, элементы в дочерних модулях могут использовать элементы из своих родительских модулей. В этом тесте мы помещаем все элементы родительского модуля <code>test</code> в область видимости с помощью <code>use super::*</code> и затем тест может вызывать <code>internal_adder</code>. Если вы считаете, что приватные функции не нужно тестировать, то Rust не заставит вас это сделать.</p>
<h3 id="Встраиваемые-тесты"><a class="header" href="#Встраиваемые-тесты">Встраиваемые тесты</a></h3>
<p>В Rust встроенные тесты являются полностью внешними по отношению к вашей библиотеке. Они используют вашу библиотеку так же, как любой другой код, что означает, что они могут вызывать только функции, которые являются частью публичного API библиотеки. Их целью является проверка, много ли частей вашей библиотеки работают вместе правильно. У модулей кода правильно работающих самостоятельно, могут возникнуть проблемы при встраивани, поэтому тестовое покрытие встроенного кода также важно. Для создания встроенных тестов сначала нужен каталог <em>tests</em> .</p>
<h4 id="Каталог-tests"><a class="header" href="#Каталог-tests">Каталог <em>tests</em></a></h4>
<p>Мы создаём папку <em>tests</em> в корневой папке вашего проекта, рядом с папкой <em>src</em>. Cargo знает, что искать файлы с встроенными тестами нужно в этой папки. После этого мы можем создать столько тестовых файлов, сколько захотим, и Cargo ссобирает каждый из файлов в отдельный крейт.</p>
<p>Давайте создадим встроенный тест. Рядом с кодом из приложения 11-12, который всё ещё в файле <em>src/lib.rs</em>, создайте каталог <em>tests</em>, создайте новый файл с именем <em>tests/integration_test.rs</em>. Структура папок должна выглядеть так:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Введите код из приложения 11-13 в файл <em>tests/integration_test.rs</em> file:</p>
<p><span class="filename">Файл: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}</code></pre>
<p><span class="caption">Приложение 11-13: Встраиваемая тест функция из крейта <code>adder</code></span></p>
<p>Каждый файл в каталоге <code>tests</code> представляет собой отдельный крейт, поэтому нам нужно подключить нашу библиотеку в область видимости каждого тестового крейта. По этой причине мы добавляем <code>use adder</code> в верхней части кода, что не нужно нам делать в модульных тестах.</p>
<p>Нам не нужно комментировать код в <em>tests/integration_test.rs</em> с помощью <code>#[cfg(test)]</code>. Cargo особым образом обрабатывает каталог <code>tests</code> и собирает файлы в этом каталоге только тогда, когда мы запускаем приказ <code>cargo test</code>. Запустите <code>cargo test</code> сейчас:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
</code></pre>
<p>Выходные данные представлены тремя разделами: модульные тесты, встроенные тесты и тесты документации. Обратите внимание, что если какой-нибудь тест в одной из секций не пройдёт, последующие секции выполняться не будут. Например, если модульный тест провалился, не будет выведено результатов встроенных и документационных тестов, потому что эти тесты будут выполняться только в том случае, если все модульные тесты завершатся успешно.</p>
<p>Первый раздел для модульных тестов такой же, как мы видели: одна строка для каждого модульного теста (один с именем <code>internal</code>, который мы добавили в приложении 11-12), а затем сводная строка для модульных тестов.</p>
<p>Раздел встроенных тестов начинается со строки <code>Running tests/integration_test.rs</code>. Далее идёт строка для каждой тестовой функции в этом встроенном тесте и итоговая строка для результатов встроенного теста непосредственно перед началом раздела <code>Doc-tests adder</code>.</p>
<p>Каждый файл встроенного теста имеет свой собственный раздел, поэтому, если мы добавим больше файлов в каталог <em>tests</em>, то здесь будет больше разделов встроенного теста.</p>
<p>Мы всё ещё можем запустить определённую функцию в встроенных тестах, указав имя тест функции в качестве переменной в <code>cargo test</code>. Чтобы запустить все тесты в определенном файле встроенных тестов, используйте переменная <code>--test</code> сопровождаемый именем файла у приказы <code>cargo test</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
</code></pre>
<p>Этот приказ запускает только тесты в файле <em>tests/integration_test.rs</em>.</p>
<h4 id="Подмодули-в-встроенных-тестах"><a class="header" href="#Подмодули-в-встроенных-тестах">Подмодули в встроенных тестах</a></h4>
<p>По мере добавления большего количества встроенных тестов, можно создать более одного файла в каталоге  <em>tests</em>, чтобы легче организовывать их; например, вы можете сгруппировать функции тестирования по функциональности, которую они проверяют. Как упоминалось ранее, каждый файл в каталоге <em>tests</em> собран как отдельный крейт, что полезно для создания отдельных областей видимости, чтобы более точно создавать видимость то, как конечные пользователи будут использовать ваш крейт. Однако это означает, что файлы в каталоге <em>tests</em> ведут себя не так, как файлы в <em>src</em>, как вы узнали в Главе 7 относительно того как разделить код на модули и файлы.</p>
<p>Различное поведение файлов в каталоге <em>tests</em> наиболее заметно, когда у вас есть набор вспомогательных функций, которые будут полезны в нескольких встроенных тестовых файлах. Представим, что вы пытаетесь выполнить действия, описанные в разделе <a href="ch07-05-separating-modules-into-different-files.html">«Разделение модулей в разные файлы»</a><!--  --> главы 7, чтобы извлечь их в общий модуль. Например, вы создали файл <em>tests/common.rs</em> и поместили в него функцию <code>setup</code>, содержащую некоторый код, который вы будете вызывать из разных тестовых функций в нескольких тестовых файлах</p>
<p><span class="filename">Файл: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}</code></pre>
<p>Когда мы снова запустим тесты, мы увидим новый раздел в результатах тестов для файла <em>common.rs</em>, хотя этот файл не содержит никаких тестовых функций, более того, мы даже не вызывали функцию <code>setup</code> откуда либо:</p>
<pre><code class="language-console">{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
</code></pre>
<p>Упоминание файла <code>common</code> и появление в результатах выполнения тестов сообщения вида <code>running 0 tests</code> - это не то, чего мы хотели. Мы только хотели выделить некоторый общий код, который будет использоваться другими файлами встроенных тестов.</p>
<p>Чтобы модуль <code>common</code> больше не появлялся в результатах выполнения тестов, вместо файла <em>tests/common.rs</em> мы создадим файл <em>tests/common/mod.rs</em>. Директория проекта теперь выглядит следующим образом:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>Здесь используется более раннее соглашение об именовании файлов, которое Rust также понимает. Мы говорили об этом в разделе <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“Иные пути к файлам”</a> главы 7. Именование файла таким образом говорит, что Rust не должен рассматривать модуль <code>common</code> как файл встроенных тестов. Когда мы перемещаем код функции <code>setup</code> в файл <em>tests/common/mod.rs</em> и удаляем файл <em>tests/common.rs</em>, дополнительный раздел больше не будет отображаться в результатах тестов. Файлы в подкаталогах каталога <em>tests</em> не собираются как отдельные крейты или не появляются в результатах выполнения тестов.</p>
<p>После того, как мы создали файл <em>tests/common/mod.rs</em>, мы можем использовать его в любых файлах встроенных тестов как обычный модуль. Вот пример вызова функции <code>setup</code> из теста <code>it_adds_two</code> в файле <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Файл: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}</code></pre>
<p>Обратите внимание, что  объявление <code>mod common;</code> совпадает с объявлением модуля, которое отображено в приложении 7-21. Затем в тестовой функции мы можем вызвать функцию <code>common::setup()</code>.</p>
<h4 id="Встраиваемые-тесты-для-двоичных-крейтов"><a class="header" href="#Встраиваемые-тесты-для-двоичных-крейтов">Встраиваемые тесты для двоичных крейтов</a></h4>
<p>Если наш проект является двоичным крейтом, который содержит только <em>src/main.rs</em> и не содержит <em>src/lib.rs</em>, мы не сможем создать встроенные тесты в папке <em>tests</em> и подключить функции определённые в файле <em>src/main.rs</em> в область видимости с помощью указания <code>use</code>. Только библиотечные крейты могут предоставлять функции, которые можно использовать в других крейтах; двоичные крейты предназначены только для самостоятельного запуска.</p>
<p>Это одна из причин, почему проекты на Rust, которые генерируют исполняемые модули, обычно имеют простой файл <em>src/main.rs</em>, который в свою очередь вызывает логику, которая находится в файле <em>src/lib.rs</em>. Используя такую структуру, встроенные тесты <em>могут</em> проверить библиотечный крейт, используя оператор <code>use</code> для подключения важного функционала. Если этот важный функционал работает, то и небольшое количество кода в файле <em>src/main.rs</em> также будет работать, а значит этот небольшой объём кода не нуждается в проверке.</p>
<h2 id="Итоги-8"><a class="header" href="#Итоги-8">Итоги</a></h2>
<p>Средства тестирования языка Rust предоставляют способ задать ожидаемое поведение кода, чтобы убедиться, что он всё ещё соответствует вашим ожиданиям даже после внесения изменений. Модульные тесты проверяют различные части библиотеки по отдельности и могут тестировать приватные подробности реализации. Встраиваемые тесты проверяют, что части библиотеки работают корректно сообща. Эти тесты используют для тестирования кода открытый API библиотеки, таким же образом, как его будет использовать внешний код. Хотя система видов Rust и правила владения помогают предотвратить некоторые виды ошибок, тесты по-прежнему важны для уменьшения количества логических ошибок, связанных с поведением вашего кода.</p>
<p>Давайте объединим  знания, полученные в этой и предыдущей главах, чтобы поработать над проектом!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Проект-с-вводомвыводом-io-создание-окно-выводаного-приложения"><a class="header" href="#Проект-с-вводомвыводом-io-создание-окно-выводаного-приложения">Проект с вводом/выводом (I/O): создание окно выводаного приложения</a></h1>
<p>В этой главе вы примените многие знания, полученные ранее, а также познакомитесь с ещё неизученными API встроенной библиотеки. Мы создадим окно выводаное приложение, которое будет взаимодействовать с файлом и с окно выводаным вводом / выводом, чтобы попрактиковаться в некоторых концепциях Rust, с которыми вы уже знакомы.</p>
<p>Скорость, безопасность, сборка в один исполняемый файл и кроссплатформенность делают Rust наилучшим языком для создания окно выводаных средств, так что в нашем проекте мы создадим свою собственную исполнение классической утилиты поиска <code>grep</code>, что расшифровывается, как "вездесущеее средство поиска и печати" (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). В простейшем случае <code>grep</code> используется для поиска в выбранном файле указанного текста. Для этого утилита <code>grep</code> получает имя файла и текст в качестве переменных. Далее она читает файл, находит и выводит строки, содержащие искомый текст.</p>
<p>Попутно мы покажем, как сделать так, чтобы наше окно выводаное приложение использовало возможности окна вызова, которые используются многими другими окно выводаными средствами. Мы будем читать значение переменной окружения, чтобы позволить пользователю настроить поведение нашего средства. Мы также будем печатать сообщения об ошибках в стандартный окно выводаный поток ошибок ( <code>stderr</code> ) вместо принятого вывода ( <code>stdout</code> ), чтобы, к примеру, пользователь мог перенаправить успешный вывод в файл, в то время, как сообщения об ошибках останутся на экране.</p>
<p>Один из участников Rust-сообщества, Andrew Gallant, уже реализовал полнофункциональный, очень быстрый подобие программы <code>grep</code> и назвал его <code>ripgrep</code>. По сравнению с ним, наша исполнение будет довольно простой, но эта глава даст вам знания, которые нужны для понимания существующих проектов, таких как <code>ripgrep</code>.</p>
<p>Наш проект <code>grep</code> будет использовать ранее изученные концепции:</p>
<ul>
<li>Организация кода (используя то, что вы узнали о модулях в <a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"> главе 7</a><!--  -->)</li>
<li>Использование векторов и строк (собрания, <a href="ch08-00-common-collections.html">глава 8</a><!--  -->)</li>
<li>Обработка ошибок (<a href="ch09-00-error-handling.html">Глава 9</a><!--  -->)</li>
<li>Использование типажей и времени жизни там, где это необходимо (<a href="ch10-00-generics.html">глава 10</a><!--  -->)</li>
<li>Написание тестов ( <a href="ch11-00-testing.html">Глава 11</a><!--  -->)</li>
</ul>
<p>Мы также кратко представим замыкания, повторители и объекты типажи, которые будут объяснены подробно в главах <a href="ch13-00-functional-features.html">13</a><!--  --> и <a href="ch17-00-oop.html">17</a><!--  -->.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Принятие-переменных-приказной-строки"><a class="header" href="#Принятие-переменных-приказной-строки">Принятие переменных приказной строки</a></h2>
<p>Создадим новый проект окно выводаного приложения как обычно с помощью приказы <code>cargo new</code>. Мы назовём проект <code>minigrep</code>, чтобы различать наше приложение от <code>grep</code>, которое возможно уже есть в вашей системе.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Первая задача - заставить <code>minigrep</code> принимать два переменной приказной строки: путь к файлу и строку для поиска. То есть мы хотим иметь возможность запускать нашу программу через <code>cargo run</code>, с использованием двойного дефиса, чтобы указать, что следующие переменные предназначены для нашей программы, а не для <code>cargo</code>, строки для поиска и пути к файлу в котором нужно искать, как описано ниже:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>В данный момент программа сгенерированная <code>cargo new</code> не может обрабатывать переменные, которые мы ей передаём. Некоторые существующие библиотеки на <a href="https://crates.io/">crates.io</a> могут помочь с написанием программы, которая принимает переменные приказной строки, но так как вы просто изучаете эту концепцию, давайте реализуем эту возможность сами.</p>
<h3 id="Чтение-значений-переменных"><a class="header" href="#Чтение-значений-переменных">Чтение значений переменных</a></h3>
<p>Чтобы <code>minigrep</code> мог воспринимать значения переменных приказной строки, которые мы ему передаём, нам понадобится функция <code>std::env::args</code>, входящая в стандартную библиотеку Rust. Эта функция возвращает повторительпеременных приказной строки, переданных в <code>minigrep</code>. Мы подробно рассмотрим повторители в <a href="ch13-00-functional-features.html">главе 13</a><!-- ignore -->. Пока вам достаточно знать две вещи об повторителях: повторители генерируют серию значений, и мы можем вызвать способ <code>collect</code> у повторителя, чтобы создать из него собрание, например вектор, который будет содержать все элементы, произведённые повторителем.</p>
<p>Код представленный в Приложении 12-1 позволяет вашей программе <code>minigrep</code> читать любые переданные ей переменные приказной строки, а затем собирать значения в вектор.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 12-1: Собираем переменные приказной строки в вектор и выводим их на печать</span></p>
<p>Сначала мы вводим модуль <code>std::env</code> в область видимости с помощью указания <code>use</code>, чтобы мы могли использовать его функцию <code>args</code>. Обратите внимание, что функция <code>std::env::args</code> вложена в два уровня модулей. Как мы обсуждали в <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">главе 7</a><!-- ignore -->, в случаях, когда нужная функция оказывается вложенной в более чем один модуль, советуется выносить в область видимости родительский модуль, а не функцию. Таким образом, мы можем легко использовать другие функции из <code>std::env</code>. Это менее двусмысленно, чем добавление <code>use std::env::args</code> и последующий вызов функции только с <code>args</code>, потому что <code>args</code> может быть легко принят за функцию, определённую в текущем модуле.</p>
<blockquote>
<h3 id="Функция-args-и-недействительный-Юникод-символ-unicode"><a class="header" href="#Функция-args-и-недействительный-Юникод-символ-unicode">Функция <code>args</code> и недействительный Юникод символ (Unicode)</a></h3>
<p>Обратите внимание, что <code>std::env::args</code> вызовет панику, если какой-либо переменная содержит недопустимый символ Юникода. Если вашей программе необходимо принимать переменные, содержащие недопустимые символы Unicode, используйте вместо этого <code>std::env::args_os</code>. Эта функция возвращает повторитель, который выдаёт значения <code>OsString</code> вместо значений <code>String</code>. Мы решили использовать <code>std::env::args</code> здесь для простоты, потому что значения <code>OsString</code> отличаются для каждой платформы и с ними сложнее работать, чем со значениями <code>String</code>.</p>
</blockquote>
<p>В первой строке кода функции <code>main</code> мы вызываем <code>env::args</code> и сразу используем способ <code>collect</code>, чтобы превратить повторительв вектор содержащий все полученные значения. Мы можем использовать функцию <code>collect</code> для создания многих видов собраний, поэтому мы явно аннотируем вид <code>args</code> чтобы указать, что мы хотим вектор строк. Хотя нам очень редко нужно аннотировать виды в Rust, <code>collect</code> - это одна из функций, с которой вам часто нужна изложение вида, потому что Rust не может сам вывести какую собрание вы хотите.</p>
<p>И в заключение мы печатаем вектор с помощью отладочного макроса. Попробуем запустить код сначала без переменных, а затем с двумя переменнойми:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
</code></pre>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
</code></pre>
<p>Обратите внимание, что первое значение в векторе <code>"target/debug/minigrep"</code> является названием нашего двоичного файла. Это соответствует поведению списка переменных в Си, позволяя программам использовать название с которым они были вызваны при выполнении. Часто бывает удобно иметь доступ к имени программы, если вы хотите распечатать его в сообщениях или изменить поведение программы в зависимости от того, какой псевдоним приказной строки был использован для вызова программы. Но для целей этой главы, мы пропренебрегаем его и сохраним только два переменной, которые нам нужны.</p>
<h3 id="Сохранения-значений-переменных-в-переменные"><a class="header" href="#Сохранения-значений-переменных-в-переменные">Сохранения значений переменных в переменные</a></h3>
<p>На текущий момент программа может получить доступ к значениям, указанным в качестве переменных приказной строки. Теперь нам требуется сохранять значения этих двух переменных в переменных, чтобы мы могли использовать их в остальных частях программы. Мы сделаем это в приложении 12-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 12-2: Создание переменных для хранения значений переменных искомой подстроки и пути к файлу</span></p>
<p>Как видно из распечатки вектора, имя программы занимает первое значение в векторе по адресу <code>args[0]</code>, значит, переменные начинаются с порядкового казателя <code>1</code>. Первый переменная <code>minigrep</code> - это строка, которую мы ищем, поэтому мы помещаем ссылку на первый переменная в переменную <code>query</code>. Вторым переменнаяом является путь к файлу, поэтому мы помещаем ссылку на второй переменная в переменную <code>file_path</code>.</p>
<p>Для проверки корректности работы нашей программы, значения переменных выводятся в окно вывода. Далее, запустим нашу программу со следующими переменнойми: <code>test</code> и <code>sample.txt</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
</code></pre>
<p>Отлично, программа работает! Нам нужно чтобы значения переменных были сохранены в правильных переменных. Позже мы добавим обработку ошибок с некоторыми потенциальными ошибочными ситуациями, например, когда пользователь не предоставляет переменные; сейчас мы пропренебрегаем эту ситуацию и поработаем над добавлением возможности чтения файла.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Чтение-файла"><a class="header" href="#Чтение-файла">Чтение файла</a></h2>
<p>Теперь добавим возможность чтения файла, указанного как переменная приказной строки <code>file_path</code>. Во-первых, нам нужен пример файла для тестирования: мы будем использовать файл с небольшим объёмом текста в несколько строк с несколькими повторяющимися словами. В приложении 12-3 представлено стихотворение Эмили Дикинсон, которое будет хорошо работать! Создайте файл с именем <em>poem.txt</em> в корне вашего проекта и введите стихотворение "I’m nobody! Who are you?"</p>
<p><span class="filename">Файл: poem.txt</span></p>
<pre><code class="language-text">{{#include ../listings/ch12-an-io-project/listing-12-03/poem.txt}}
</code></pre>
<p><span class="caption">Приложение 12-3: Стихотворение Эмили Дикинсон - хороший пример для проверки</span></p>
<p>Текст на месте, изменените <em>src/main.rs</em> и добавьте код для чтения файла, как показано в приложении 12-4.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-04/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-4: Чтение содержимого файла указанного во втором переменной</span></p>
<p>Во-первых, мы добавляем ещё одну указанию <code>use</code> чтобы подключить соответствующую часть встроенной библиотеки: нам нужен <code>std::fs</code> для обработки файлов.</p>
<p>В <code>main</code> мы добавили новую указанию: функция <code>fs::read_to_string</code> принимает <code>file_path</code>, открывает этот файл и возвращает содержимое файла как <code>std::io::Result&lt;String&gt;</code>.</p>
<p>После этого, мы снова добавили временную указанию <code>println!</code> для печати значения <code>contents</code> после чтения файла, таким образом мы можем проверить, что программа отрабатывает до этого места.</p>
<p>Давайте запустим этот код с любой строкой в качестве первого переменной приказной строки (потому что мы ещё не реализовали поисковую часть) и файл <em>poem.txt</em> как второй переменная:</p>
<pre><code class="language-console">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-04/output.txt}}
</code></pre>
<p>Отлично! Этот код прочитал и затем напечатал содержимое файла. Но у программы есть несколько недостатков. Прежде всего, функция <code>main</code> решает слишком много задач: как правило функция понятнее и проще в обслуживании если она воплощает только одну идею. Другая проблема заключается в том, что мы не обрабатываем ошибки так хорошо, как могли бы. Пока наша программа небольшая, то эти недостатки не являются большой проблемой, но по мере роста программы эти недостатки будет всё труднее исправлять. Хорошей практикой является начинать рефакторинг на ранней стадии разработки программы, потому что гораздо проще рефакторить меньшие объёмы кода. Мы сделаем это далее.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Рефакторинг-для-улучшения-модульности-и-обработки-ошибок"><a class="header" href="#Рефакторинг-для-улучшения-модульности-и-обработки-ошибок">Рефакторинг для улучшения модульности и обработки ошибок</a></h2>
<p>Для улучшения программы мы исправим 4 имеющихся проблемы, связанных со структурой программы и тем как обрабатываются потенциальные ошибки. Во-первых, функция <code>main</code> на данный момент решает две задачи:  анализирует переменные приказной строки и читает файлы. По мере роста программы количество отдельных задач, которые обрабатывает функция <code>main</code>, будет увеличиваться. Поскольку эта функция получает больше обязанностей, то становится все труднее понимать её, труднее тестировать и труднее изменять, не сломав одну из её частей. Лучше всего разделить функциональность, чтобы каждая функция отвечала за одну задачу.</p>
<p>Эта проблема также связана со второй проблемой: хотя переменные <code>query</code> и <code>file_path</code> являются переменными настройке нашей программы, переменные вида <code>contents</code> используются для выполнения логики программы. Чем длиннее становится <code>main</code>, тем больше переменных нам нужно будет добавить в область видимости; чем больше у нас переменных в области видимости, тем сложнее будет отслеживать назначение каждой переменной. Лучше всего сгруппировать переменные настройке в одну структуру, чтобы сделать их назначение понятным.</p>
<p>Третья проблема заключается в том, что мы используем <code>expect</code> для вывода сведений об ошибке при проблеме с чтением файла, но сообщение об ошибке просто выведет текст<code>Should have been able to read the file</code>. Чтение файла может не сработать по разным причинам, например: файл не найден или у нас может не быть разрешения на его чтение. Сейчас же, независимо от ситуации, мы напечатаем одно и то же сообщение об ошибке, что не даст пользователю никакой сведений!</p>
<p>В-четвёртых, мы используем <code>expect</code> неоднократно для обработки различных ошибок и если пользователь запускает нашу программу без указания достаточного количества переменных он получит ошибку <code>index out of bounds</code> из Rust, что не совсем понятно описывает проблему. Было бы лучше, если бы весь код обработки ошибок находился в одном месте, чтобы тем, кто будет поддерживать наш код в дальнейшем, нужно было бы вносить изменения только здесь, если потребуется изменить логику обработки ошибок. Наличие всего кода обработки ошибок в одном месте заверяет, что мы напечатаем сообщения, которые будут иметь смысл для наших конечных пользователей.</p>
<p>Давайте решим эти четыре проблемы путём рефакторинга нашего проекта.</p>
<h3 id="Разделение-ответственности-для-двоичных-проектов"><a class="header" href="#Разделение-ответственности-для-двоичных-проектов"><a name="separation-of-concerns-for-binary-projects"></a>Разделение ответственности для двоичных проектов</a></h3>
<p>Организационная проблема распределения ответственности за выполнение нескольких задач функции <code>main</code>  является общей для многих двоичных проектов. В результате Rust сообщество разработало процесс для использования в качестве руководства по разделению ответственности двоичной программы, когда код в <code>main</code> начинает увеличиваться. Процесс имеет следующие шаги:</p>
<ul>
<li>Разделите код программы на два файла <em>main.rs</em> и <em>lib.rs</em>. Перенесите всю логику работы программы в файл <em>lib.rs</em>.</li>
<li>Пока ваша логика синтаксического анализа приказной строки мала, она может оставаться в файле <em>main.rs</em>.</li>
<li>Когда логика синтаксического анализа приказной строки становится сложной, извлеките её из <em>main.rs</em> и переместите в <em>lib.rs.</em></li>
</ul>
<p>Функциональные обязанности, которые остаются в функции <code>main</code> после этого процесса должно быть ограничено следующим:</p>
<ul>
<li>Вызов логики разбора приказной строки со значениями переменных</li>
<li>Настройка любой другой настройке</li>
<li>Вызов функции <code>run</code> в <em>lib.rs</em></li>
<li>Обработка ошибки, если <code>run</code> возвращает ошибку</li>
</ul>
<p>Этот шаблон о разделении ответственности: <em>main.rs</em> занимается запуском программы, а <em>lib.rs</em> обрабатывает всю логику задачи. Поскольку нельзя проверить функцию <code>main</code> напрямую, то такая структура позволяет проверить всю логику программы путём перемещения её в функции внутри <em>lib.rs</em>. Единственный код, который остаётся в <em>main.rs</em> будет достаточно маленьким, чтобы проверить его корректность прочитав код. Давайте переработаем нашу программу, следуя этому процессу.</p>
<h4 id="Извлечение-парсера-переменных"><a class="header" href="#Извлечение-парсера-переменных">Извлечение парсера переменных</a></h4>
<p>Мы извлечём функциональность для разбора переменных в функцию, которую вызовет <code>main</code> для подготовки к перемещению логики разбора приказной строки в файл <em>src/lib.rs</em>. Приложение 12-5 показывает новый запуск <code>main</code>, который вызывает новую функцию <code>parse_config</code>, которую мы определим сначала в <em>src/main.rs.</em></p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-5: Выделение функции <code>parse_config</code> из <code>main</code></span></p>
<p>Мы все ещё собираем переменные приказной строки в вектор, но вместо присваивания значение переменной с порядковым казателем 1 переменной <code>query</code> и значение переменной с порядковым казателем 2 переменной с именем <code>file_path</code> в функции <code>main</code>, мы передаём весь вектор в функцию <code>parse_config</code>. Функция <code>parse_config</code> затем содержит логику, которая определяет, какой переменная идёт в какую переменную и передаёт значения обратно в <code>main</code>. Мы все ещё создаём переменные <code>query</code> и <code>file_path</code> в <code>main</code>, но <code>main</code> больше не несёт ответственности за определение соответствия переменной приказной строки и соответствующей переменной.</p>
<p>Эта доработка может показаться излишней для нашей маленькой программы, но мы проводим рефакторинг небольшими, постепенными шагами. После внесения этого изменения снова запустите программу и убедитесь, что анализ переменных все ещё работает. Также хорошо часто проверять прогресс, чтобы помочь определить причину проблем, когда они возникают.</p>
<h4 id="Группировка-настроечных-переменных"><a class="header" href="#Группировка-настроечных-переменных">Группировка настроечных переменных</a></h4>
<p>Мы можем сделать ещё один маленький шаг для улучшения функции <code>parse_config</code>. На данный момент мы возвращаем кортеж, но затем мы немедленно разделяем его снова на отдельные части. Это признак того, что, возможно,  пока у нас нет правильной абстракции.</p>
<p>Ещё один индикатор, который показывает, что есть место для улучшения, это часть <code>config</code> из <code>parse_config</code>, что подразумевает, что два значения, которые мы возвращаем, связаны друг с другом и оба являются частью одного настроечного значения. В настоящее время мы не отражаем этого смысла в структуре данных, кроме группировки двух значений в кортеж; мы могли бы поместить оба значения в одну структуру и дать каждому из полей структуры понятное имя. Это облегчит будущую поддержку этого кода, чтобы понять, как различные значения относятся друг к другу и какое их назначение.</p>
<p>В приложении 12-6 показаны улучшения функции <code>parse_config</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-6: Рефакторинг функции <code>parse_config</code>, чтобы возвращать экземпляр структуры <code>Config</code></span></p>
<p>Мы добавили структуру с именем <code>Config</code> объявленную с полями назваными как <code>query</code> и <code>file_path</code>. Сигнатура <code>parse_config</code> теперь указывает, что она возвращает значение <code>Config</code>. В теле <code>parse_config</code>, где мы возвращали срезы строк, которые ссылаются на значения <code>String</code> в <code>args</code>, теперь мы определяем <code>Config</code> как содержащие собственные <code>String</code> значения. Переменная <code>args</code> в <code>main</code> является владельцем значений переменной и позволяют функции <code>parse_config</code> только одалживать их, что означает, что мы бы нарушили правила заимствования Rust, если бы <code>Config</code> попытался бы взять во владение значения в <code>args</code> .</p>
<p>Мы можем управлять данными <code>String</code> разным количеством способов, но самый простой, хотя и отчасти неэффективный это вызвать способ <code>clone</code> у значений. Он сделает полную копию данных для экземпляра <code>Config</code> для владения, что занимает больше времени и памяти, чем сохранение ссылки на строку данных. Однако клонирование данных также делает наш код очень простым, потому что нам не нужно управлять временем жизни ссылок; в этом обстоятельстве, отказ от небольшой производительности, чтобы получить простоту, стоит небольших соглашениеа.</p>
<blockquote>
<p><h>К при использовании способа <code>clone</code></h>Существует тенденция в среде программистов Rust избегать использования <code>clone</code>, т.к. это понижает эффективность работы кода. В <a href="ch13-00-functional-features.html">Главе 13</a><!-- ignore -->, вы изучите более эффективные способы, которые могут подойти в подобной ситуации. Но сейчас можно копировать несколько строк, чтобы продолжить работу, потому что вы сделаете эти копии только один раз, а ваше имя файла и строка запроса будут очень маленькими. Лучше иметь работающую программу, которая немного неэффективна, чем пытаться заранее оптимизировать код при первом написании. По мере приобретения опыта работы с Rust вам будет проще начать с наиболее эффективного решения, но сейчас вполне приемлемо вызвать <code>clone</code>.</p>
</blockquote>
<p>Мы обновили код в <code>main</code> поэтому он помещает экземпляр <code>Config</code> возвращённый из <code>parse_config</code> в переменную с именем <code>config</code>, и мы обновили код, в котором ранее использовались отдельные переменные <code>query</code> и <code>file_path</code>, так что теперь он использует вместо этого поля в структуре <code>Config</code>.</p>
<p>Теперь наш код более чётко передаёт то, что <code>query</code> и <code>file_path</code> связаны и что цель из использования состоит в том, чтобы настроить, как программа будет работать. Любой код, который использует эти значения знает, что может найти их в именованных полях экземпляра <code>config</code> по их назначению.</p>
<h4 id="Создание-конструктора-для-структуры-config"><a class="header" href="#Создание-конструктора-для-структуры-config">Создание конструктора для структуры <code>Config</code></a></h4>
<p>Пока что мы извлекли логику, отвечающую за синтаксический анализ переменных приказной строки из <code>main</code> и поместили его в функцию <code>parse_config</code>. Это помогло нам увидеть, что значения <code>query</code> и <code>file_path</code> были связаны и что их отношения должны быть отражены в нашем коде. Затем мы добавили структуру <code>Config</code> в качестве названия связанных общей целью <code>query</code> и <code>file_path</code> и чтобы иметь возможность вернуть именованные значения как имена полей структуры из функции <code>parse_config</code>.</p>
<p>Итак, теперь целью функции <code>parse_config</code> является создание экземпляра <code>Config</code>, мы можем изменить <code>parse_config</code> из простой функции на функцию названную <code>new</code>, которая связана со структурой <code>Config</code>. Выполняя это изменение мы сделаем код более идиоматичным. Можно создавать экземпляры видов в встроенной библиотеке, такие как <code>String</code> с помощью вызова <code>String::new</code>. Точно так же изменив название <code>parse_config</code> на название функции <code>new</code>, связанную с <code>Config</code>, мы будем уметь создавать экземпляры <code>Config</code>, вызывая <code>Config::new</code>. Приложение 12-7 показывает изменения, которые мы должны сделать.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-07/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-7: Переименование <code>parse_config</code> в <code>Config::new</code></span></p>
<p>Мы обновили <code>main</code> где вызывали <code>parse_config</code>, чтобы вместо этого вызывалась <code>Config::new</code>. Мы изменили имя <code>parse_config</code> на <code>new</code> и перенесли его внутрь раздела <code>impl</code>, который связывает функцию <code>new</code> с <code>Config</code>. Попробуйте снова собрать код, чтобы убедиться, что он работает.</p>
<h3 id="Исправление-ошибок-обработки"><a class="header" href="#Исправление-ошибок-обработки">Исправление ошибок обработки</a></h3>
<p>Теперь мы поработаем над исправлением обработки ошибок. Напомним, что попытки получить доступ к значениям в векторе <code>args</code> с порядковым казателем 1 или порядковым казателем 2 приведут к панике, если вектор содержит менее трёх элементов. Попробуйте запустить программу без каких-либо переменных; это будет выглядеть так:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-07/output.txt}}
</code></pre>
<p>Строка <code>index out of bounds: the len is 1 but the index is 1</code> является сообщением об ошибке предназначенной для программистов. Она не поможет нашим конечным пользователям понять, что случилось и что они должны сделать вместо этого. Давайте исправим это сейчас.</p>
<h4 id="Улучшение-сообщения-об-ошибке"><a class="header" href="#Улучшение-сообщения-об-ошибке">Улучшение сообщения об ошибке</a></h4>
<p>В приложении 12-8 мы добавляем проверку в функцию <code>new</code>, которая будет проверять, что срез достаточно длинный, перед попыткой доступа по порядковым указателям 1 и 2. Если срез не достаточно длинный, программа паникует и отображает улучшенное сообщение об ошибке.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-08/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-8: Добавление проверки количества переменных</span></p>
<p>Этот код похож на <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">функцию <code>Guess::new</code> написанную в приложении 9-13</a>, где мы вызывали <code>panic!</code>, когда <code>value</code> переменной вышло за пределы допустимых значений. Здесь вместо проверки на рядзначений, мы проверяем, что длина <code>args</code> не менее 3 и остальная часть функции может работать при условии, что это условие было выполнено. Если в <code>args</code> меньше трёх элементов, это условие будет истинным и мы вызываем макрос <code>panic!</code> для немедленного завершения программы.</p>
<p>Имея нескольких лишних строк кода в <code>new</code>, давайте запустим программу снова без переменных, чтобы увидеть, как выглядит ошибка:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-08/output.txt}}
</code></pre>
<p>Этот вывод лучше: у нас теперь есть разумное сообщение об ошибке. Тем не менее, мы также имеем постороннюю сведения, которую мы не хотим предоставлять нашим пользователям. Возможно, использованная техника, которую мы использовали в приложении 9-13, не является лучшей для использования: вызов <code>panic!</code> больше подходит для программирования проблемы, чем решения проблемы, <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">как обсуждалось в главе 9</a><!-- ignore -->. Вместо этого мы можем использовать другую технику, о которой вы узнали в главе 9 [возвращая <code>Result</code>]<!-- ignore -->, которая указывает либо на успех, либо на ошибку.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="Возвращение-result-вместо-вызова-panic"><a class="header" href="#Возвращение-result-вместо-вызова-panic">Возвращение <code>Result</code> вместо вызова <code>panic!</code></a></h4>
<p>Мы можем вернуть значение <code>Result</code>, которое будет содержать экземпляр <code>Config</code> в успешном случае и опишет проблему в случае ошибки. Мы так же изменим функцию <code>new</code> на <code>build</code> потому что многие программисты ожидают что <code>new</code> никогда не завершится неудачей. Когда <code>Config::build</code> взаимодействует с <code>main</code>, мы можем использовать вид <code>Result</code> как сигнал возникновения проблемы. Затем мы можем изменить <code>main</code>, чтобы преобразовать вариант <code>Err</code> в более практичную ошибку для наших пользователей без окружающего текста вроде <code>thread 'main'</code> и <code>RUST_BACKTRACE</code>, что происходит при вызове <code>panic!</code>.</p>
<p>Приложение 12-9 показывает изменения, которые нужно внести в возвращаемое значения функции <code>Config::build</code>, и в тело функции, необходимые для возврата вида <code>Result</code>. Заметьте, что этот код не ссобирается, пока мы не обновим <code>main</code>, что мы и сделаем в следующем приложении.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-09/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-9. Возвращение вида <code>Result</code> из <code>Config::build</code></span></p>
<p>Наша функция <code>build</code> теперь возвращает <code>Result</code> с экземпляром <code>Config</code> в случае успеха и <code>&amp;'static str</code> в случае ошибки. Значения ошибок всегда будут строковыми литералами, которые имеют время жизни <code>'static</code>.</p>
<p>Мы внесли два изменения в тело функции <code>build</code>: вместо вызова <code>panic!</code>, когда пользователь не передаёт достаточно переменных, мы теперь возвращаем <code>Err</code> значение и мы завернули возвращаемое значение <code>Config</code> в <code>Ok</code> . Эти изменения заставят функцию соответствовать своей новой сигнатуре вида.</p>
<p>Возвращение значения <code>Err</code> из <code>Config::build</code> позволяет функции <code>main</code> обработать значение <code>Result</code> возвращённое из функции <code>build</code> и выйти из процесса более чисто в случае ошибки.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="Вызов-configbuild-и-обработка-ошибок"><a class="header" href="#Вызов-configbuild-и-обработка-ошибок">Вызов <code>Config::build</code> и обработка ошибок</a></h4>
<p>Чтобы обработать ошибку и вывести более дружественное сообщение об ошибке, нам нужно обновить код <code>main</code> для обработки <code>Result</code>, возвращаемого из <code>Config::build</code> как показано в приложении 12-10. Мы также возьмём на себя ответственность за выход из программы приказной строки с ненулевым кодом ошибки <code>panic!</code> и реализуем это вручную. Не нулевой статус выхода - это соглашение, которое сигнализирует процессу, который вызывает нашу программу, что программа завершилась с ошибкой.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-10/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-10. Выход с кодом ошибки если создание новой <code>Config</code> терпит неудачу</span></p>
<p>В этом приложении мы использовали способ, который мы ещё не рассматривали подробно: <code>unwrap_or_else</code>, который в встроенной библиотеке определён как <code>Result&lt;T, E&gt;</code>. Использование <code>unwrap_or_else</code> позволяет нам определить некоторые пользовательские ошибки обработки, не содержащие <code>panic!</code>. Если <code>Result</code> является значением <code>Ok</code>, поведение этого способа подобно <code>unwrap</code>: возвращает внутреннее значение из обёртки <code>Ok</code>. Однако, если значение является значением <code>Err</code>, то этот способ вызывает код <em>замыкания</em>, которое является анонимной функцией, определённой заранее и передаваемую в качестве переменной в <code>unwrap_or_else</code>. Мы рассмотрим замыкания более подробно в <a href="ch13-00-functional-features.html">главе 13</a>. В данный момент, вам просто нужно знать, что <code>unwrap_or_else</code> передаст внутреннее значение <code>Err</code>, которое в этом случае является статической строкой <code>not enough arguments</code>, которое мы добавили в приложении 12-9, в наше замыкание как переменная <code>err</code> указанное между вертикальными линиями. Код в замыкании может затем использовать значение <code>err</code> при выполнении.</p>
<p>Мы добавили новую строку <code>use</code>, чтобы подключить <code>process</code> из встроенной библиотеки в область видимости. Код в замыкании, который будет запущен в случае ошибки содержит только две строчки: мы печатаем значение <code>err</code> и затем вызываем <code>process::exit</code>. Функция <code>process::exit</code> немедленно остановит программу и вернёт номер, который был передан в качестве кода состояния выхода. Это похоже на обработку с помощью макроса <code>panic!</code>, которую мы использовали в приложении 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-10/output.txt}}
</code></pre>
<p>Замечательно! Этот вывод намного дружелюбнее для наших пользователей.</p>
<h3 id="Извлечение-логики-из-main"><a class="header" href="#Извлечение-логики-из-main">Извлечение логики из <code>main</code></a></h3>
<p>Теперь, когда мы закончили рефакторинг разбора настройке, давайте обратимся к логике программы. Как мы указали в разделе <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">«Разделение ответственности в двоичных проектах»</a><!-- ignore -->, мы извлечём функцию с именем <code>run</code>, которая будет содержать всю логику, присутствующую в настоящее время в функции <code>main</code> и которая не связана с настройкой настройке или обработкой ошибок. Когда мы закончим, то <code>main</code> будет краткой, легко проверяемой и мы сможем написать тесты для всей остальной логики.</p>
<p>Код 12-11 отображает извлечённую логику в функцию <code>run</code>. Мы делаем маленькое, инкрементальное приближение к извлечению функции. Код всё ещё сосредоточен в файле <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-11/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-11. Извлечение функции <code>run</code>, содержащей остальную логику программы</span></p>
<p>Функция <code>run</code> теперь содержит всю оставшуюся логику из <code>main</code>, начиная от чтения файла. Функция <code>run</code> принимает экземпляр <code>Config</code> как переменная.</p>
<h4 id="Возврат-ошибок-из-функции-run"><a class="header" href="#Возврат-ошибок-из-функции-run">Возврат ошибок из функции <code>run</code></a></h4>
<p>Оставшаяся логика программы выделена в функцию <code>run</code>, где мы можем улучшить обработку ошибок как мы уже делали с <code>Config::build</code> в приложении 12-9. Вместо того, чтобы позволить программе паниковать с помощью вызова <code>expect</code>, функция <code>run</code> вернёт <code>Result&lt;T, E&gt;</code>, если что-то пойдёт не так. Это позволит далее окне выводадировать логику обработки ошибок в <code>main</code> удобным способом. Приложение 12-12 показывает изменения, которые мы должны внести в сигнатуру и тело <code>run</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-12. Изменение функции <code>run</code> для возврата <code>Result</code></span></p>
<p>Здесь мы сделали три значительных изменения. Во-первых, мы изменили вид возвращаемого значения функции <code>run</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> . Эта функция ранее возвращала вид <code>()</code> и мы сохраняли его как значение, возвращаемое в случае <code>Ok</code>.</p>
<p>Для вида ошибки мы использовали <em>объект типаж</em> <code>Box&lt;dyn Error&gt;</code> (и вверху мы подключили вид <code>std::error::Error</code> в область видимости с помощью указания <code>use</code>). Мы рассмотрим типажи объектов в <a href="ch17-00-oop.html">главе 17</a><!-- ignore -->. Сейчас просто знайте, что <code>Box&lt;dyn Error&gt;</code> означает, что функция будет возвращать вид реализующий типаж <code>Error</code>, но не нужно указывать, какой именно будет вид возвращаемого значения. Это даёт возможность возвращать значения ошибок, которые могут быть разных видов в разных случаях. Ключевое слово <code>dyn</code> сокращение для слова «изменяемый».</p>
<p>Во-вторых, мы убрали вызов <code>expect</code> в пользу использования оператора <code>?</code>, как мы обсудили в <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">главе 9</a><!-- ignore -->. Скорее, чем вызывать <code>panic!</code> в случае ошибки, оператор <code>?</code> вернёт значение ошибки из текущей функции для вызывающего, чтобы он её обработал.</p>
<p>В-третьих, функция <code>run</code> теперь возвращает значение <code>Ok</code> в случае успеха. В сигнатуре функции <code>run</code> успешный вид объявлен как <code>()</code>, который означает, что нам нужно обернуть значение единичного вида в значение <code>Ok</code>. Данный синтаксис <code>Ok(())</code> поначалу может показаться немного странным, но использование <code>()</code> выглядит как идиоматический способ указать, что мы вызываем <code>run</code> для его побочных эффектов; он не возвращает значение, которое нам нужно.</p>
<p>Когда вы запустите этот код, он ссобирается, но отобразит предупреждение:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-12/output.txt}}
</code></pre>
<p>Rust говорит, что наш код пренебрег <code>Result</code> значение и значение <code>Result</code> может указывать на то, что произошла ошибка. Но мы не проверяем, была ли ошибка и сборщик напоминает нам, что мы, вероятно, хотели здесь выполнить некоторый код обработки ошибок! Давайте исправим эту проблему сейчас.</p>
<h4 id="Обработка-ошибок-возвращённых-из-run-в-main"><a class="header" href="#Обработка-ошибок-возвращённых-из-run-в-main">Обработка ошибок, возвращённых из <code>run</code> в <code>main</code></a></h4>
<p>Мы будем проверять и обрабатывать ошибки используя способику, подобную той, которую мы использовали для <code>Config::build</code> в приложении 12-10, но с небольшой разницей:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}</code></pre>
<p>Мы используем <code>if let</code> вместо <code>unwrap_or_else</code> чтобы проверить, возвращает ли <code>run</code> значение <code>Err</code> и вызывается <code>process::exit(1)</code>, если это так. Функция <code>run</code> не возвращает значение, которое мы хотим развернуть способом <code>unwrap</code>, таким же образом как <code>Config::build</code> возвращает экземпляр <code>Config</code>. Так как <code>run</code> возвращает <code>()</code> в случае успеха и мы заботимся только об обнаружении ошибки, то нам не нужно вызывать <code>unwrap_or_else</code>, чтобы вернуть развёрнутое значение, потому что оно будет только <code>()</code>.</p>
<p>Тело функций <code>if let</code> и <code>unwrap_or_else</code> одинаковы в обоих случаях: мы печатаем ошибку и выходим.</p>
<h3 id="Разделение-кода-на-библиотечный-крейт"><a class="header" href="#Разделение-кода-на-библиотечный-крейт">Разделение кода на библиотечный крейт</a></h3>
<p>Наш проект <code>minigrep</code> пока выглядит хорошо! Теперь мы разделим файл <em>src/main.rs</em> и поместим некоторый код в файл <em>src/lib.rs</em>. Таким образом мы сможем его тестировать и чтобы в файле <em>src/main.rs</em> было меньшее количество функциональных обязанностей.</p>
<p>Давайте перенесём весь код не относящийся к функции <code>main</code> из файла <em>src/main.rs</em> в новый файл <em>src/lib.rs</em>:</p>
<ul>
<li>Определение функции <code>run</code></li>
<li>Соответствующие указания <code>use</code></li>
<li>Определение структуры <code>Config</code></li>
<li>Определение функции <code>Config::build</code></li>
</ul>
<p>Содержимое <em>src/lib.rs</em> должно иметь сигнатуры, показанные в приложении 12-13 (мы опустили тела функций для краткости). Обратите внимание, что код не будет собираться пока мы не изменим <em>src/main.rs</em> в приложении 12-14.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-13. Перемещение <code>Config</code> и <code>run</code> в <em>src/lib.rs</em></span></p>
<p>Мы добавили спецификатор доступа <code>pub</code> к структуре <code>Config</code>, а также её полям, к способу <code>build</code> и функции <code>run</code>. Теперь у нас есть библиотечный крейт, который содержит публичный API, который мы можем протестировать!</p>
<p>Теперь нам нужно подключить код, который мы переместили в <em>src/lib.rs,</em> в область видимости двоичного крейта внутри <em>src/main.rs</em>, как показано в приложении 12-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-14. Использование крейта библиотеки <code>minigrep</code> внутри <em>src/main.rs</em></span></p>
<p>Мы добавляем <code>use minigrep::Config</code> для подключения вида <code>Config</code> из крейта библиотеки в область видимости двоичного крейта и добавляем к имени функции <code>run</code> префикс нашего крейта. Теперь все функции должны быть подключены и должны работать. Запустите программу с <code>cargo run</code> и убедитесь, что все работает правильно.</p>
<p>Уф! Было много работы, но мы настроены на будущий успех. Теперь проще обрабатывать ошибки и мы сделали код более модульным. С этого момента почти вся наша работа будет выполняться внутри <em>src/lib.rs</em>.</p>
<p>Давайте воспользуемся этой новой модульностью, сделав что-то, что было бы трудно со старым кодом, но легко с новым кодом: мы напишем несколько тестов!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Развитие-функциональности-библиотеки-разработкой-на-основе-тестов"><a class="header" href="#Развитие-функциональности-библиотеки-разработкой-на-основе-тестов">Развитие функциональности библиотеки разработкой на основе тестов</a></h2>
<p>Теперь, когда мы извлекли логику в <em>src/lib.rs</em> и оставили разбор переменных приказной строки и обработку ошибок в <em>src/main.rs</em>, стало гораздо проще писать тесты для основной функциональности нашего кода. Мы можем вызывать функции напрямую с различными переменнойми и проверить возвращаемые значения без необходимости вызова нашего двоичного файла из приказной строки.</p>
<p>В этом разделе в программу <code>minigrep</code> мы добавим логику поиска с использованием процесса разработки через тестирование (TDD), который следует этим шагам:</p>
<ol>
<li>Напишите тест, который завершается неудачей, и запустите его, чтобы убедиться, что он не сработал именно по той причине, которую вы ожидаете.</li>
<li>Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый тест.</li>
<li>Выполните рефакторинг кода, который вы только что добавили или изменили, и убедитесь, что тесты продолжают проходить.</li>
<li>Повторите с шага 1!</li>
</ol>
<p>Хотя это всего лишь один из многих способов написания программного обеспечения, TDD может помочь в разработке кода. Написание теста перед написанием кода, обеспечивающего прохождение теста, помогает поддерживать высокое покрытие тестами на протяжении всего процесса разработки.</p>
<p>Мы протестируем реализацию функциональности, которая делает поиск строки запроса в содержимом файла и создание списка строк, соответствующих запросу. Мы добавим эту функциональность в функцию под названием <code>search</code>.</p>
<h3 id="Написание-теста-с-ошибкой"><a class="header" href="#Написание-теста-с-ошибкой">Написание теста с ошибкой</a></h3>
<p>Поскольку они нам больше не нужны, давайте удалим указания с <code>println!</code>, которые мы использовали для проверки поведения программы в <em>src/lib.rs</em> и <em>src/main.rs</em>. Затем в <em>src/lib.rs</em> мы добавим модуль <code>tests</code> с тестовой функцией, как делали это в <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">главе 11</a><!-- ignore -->. Тестовая функция определяет поведение, которое мы хотим проверить в функции <code>search</code>: она должна принимать запрос и текст для поиска, а возвращать только те строки из текста, которые содержат запрос. В приложении 12-15 показан этот тест, который пока не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-15: Создание безуспешного теста для функции <code>search</code>, которую мы хотим создать</span></p>
<p>Этот тест ищет строку <code>"duct"</code>. Текст, в котором мы ищем, состоит из трёх строк, только одна из которых содержит <code>"duct"</code> (обратите внимание, что обратная косая черта после открывающей двойной кавычки говорит Rust не помещать символ новой строки в начало содержимого этого строкового литерала). Мы проверяем, что значение, возвращаемое функцией <code>search</code>, содержит только ожидаемую нами строку.</p>
<p>Мы не можем запустить этот тест и увидеть сбой, потому что тест даже не собирается: функции <code>search</code> ещё не существует! В соответствии с принципами TDD мы добавим ровно столько кода, чтобы тест собирался и запускался, добавив определение функции <code>search</code>, которая всегда возвращает пустой вектор, как показано в приложении 12-16. Потом тест должен собраться и потерпеть неудачу при запуске, потому что пустой вектор не равен вектору, содержащему строку <code>"safe, fast, productive."</code></p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-16. Определение функции <code>search</code>, достаточное, чтобы тест собрался</span></p>
<p>Заметьте, что в сигнатуре <code>search</code> нужно явно указать время жизни <code>'a</code> для переменной <code>contents</code> и возвращаемого значения. Напомним из <a href="ch10-03-lifetime-syntax.html">Главы 10</a><!-- ignore -->, что свойства времени жизни указывают с временем жизни какого переменной связано время жизни возвращаемого значения. В данном случае мы говорим, что возвращаемый вектор должен содержать срезы строк, ссылающиеся на содержимое переменной <code>contents</code> (а не переменной <code>query</code>).</p>
<p>Другими словами, мы говорим Rust, что данные, возвращаемые функцией <code>search</code>, будут жить до тех пор, пока живут данные, переданные в функцию <code>search</code> через переменная <code>contents</code>. Это важно! Чтобы ссылки были действительными, данные, на которые ссылаются <em>с помощью</em> срезов тоже должны быть действительными; если сборщик предполагает, что мы делаем строковые срезы переменной <code>query</code>, а не переменной <code>contents</code>, он неправильно выполнит проверку безопасности.</p>
<p>Если мы забудем изложении времени жизни и попробуем собрать эту функцию, то получим следующую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
</code></pre>
<p>Rust не может понять, какой из двух переменных нам нужен, поэтому нужно сказать ему об этом. Так как <code>contents</code> является тем переменнаяом, который содержит весь наш текст, и мы хотим вернуть части этого текста, которые совпали при поиске, мы понимаем, что <code>contents</code> является переменнаяом, который должен быть связан с возвращаемым значением временем жизни.</p>
<p>Другие языки программирования не требуют от вас связывания в сигнатуре переменных с возвращаемыми значениями, но после определённой практики вам станет проще. Можете сравнить этот пример с разделом <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">«Проверка ссылок с временами жизни»</a><!-- ignore --> главы 10.</p>
<p>Запустим тест:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
</code></pre>
<p>Отлично. Наш тест не сработал, как мы и ожидали. Давайте сделаем так, чтобы он срабатывал!</p>
<h3 id="Написание-кода-для-прохождения-теста"><a class="header" href="#Написание-кода-для-прохождения-теста">Написание кода для прохождения теста</a></h3>
<p>Сейчас наш тест не проходит, потому что мы всегда возвращаем пустой вектор. Чтобы исправить это и реализовать <code>search</code>, наша программа должна выполнить следующие шаги:</p>
<ul>
<li>Повторение по каждой строке содержимого.</li>
<li>Проверить, содержит ли данная строка искомую.</li>
<li>Если это так, добавить её в список значений, которые мы возвращаем.</li>
<li>Если это не так, ничего не делать.</li>
<li>Вернуть список результатов.</li>
</ul>
<p>Давайте проработаем каждый шаг, начиная с перебора строк.</p>
<h4 id="Перебор-строк-с-помощью-способа-lines"><a class="header" href="#Перебор-строк-с-помощью-способа-lines">Перебор строк с помощью способа <code>lines</code></a></h4>
<p>В Rust есть полезный способ для построчной повторения строк, удобно названный <code>lines</code>, как показано в приложении 12-17. Обратите внимание, код пока не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-17: Повторение по каждой строке из <code>contents</code></span></p>
<p>Способ <code>lines</code> возвращает повторитель. Мы подробно поговорим об повторителях в <a href="ch13-02-iterators.html">Главе 13</a><!-- ignore -->, но вспомните, что вы видели этот способ использования повторителя в <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Приложении 3-5</a><!-- ignore -->, где мы использовали цикл <code>for</code> с повторителем, чтобы выполнить некоторый код для каждого элемента в собрания.</p>
<h4 id="Поиск-в-каждой-строке-текста-запроса"><a class="header" href="#Поиск-в-каждой-строке-текста-запроса">Поиск в каждой строке текста запроса</a></h4>
<p>Далее мы проверяем, содержит ли текущая строка нашу искомую строку. К счастью, у строк есть полезный способ <code>contains</code>, который именно это и делает! Добавьте вызов способа <code>contains</code> в функции <code>search</code>, как показано в приложении 12-18. Обратите внимание, что это все ещё не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-18. Добавление проверки, содержится ли <code>query</code> в строке</span></p>
<p>На данный момент мы наращиваем функциональность. Чтобы заставить это собираться, нам нужно вернуть значение из тела функции, как мы указали в сигнатуре функции.</p>
<h4 id="Сохранение-совпавшей-строки"><a class="header" href="#Сохранение-совпавшей-строки">Сохранение совпавшей строки</a></h4>
<p>Чтобы завершить эту функцию, нам нужен способ сохранить совпадающие строки, которые мы хотим вернуть. Для этого мы можем создать изменяемый вектор перед циклом <code>for</code> и вызывать способ <code>push</code> для сохранения <code>line</code> в векторе. После цикла <code>for</code> мы возвращаем вектор, как показано в приложении 12-19.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-19: Сохраняем совпавшие строки, чтобы впоследствии их можно было вернуть</span></p>
<p>Теперь функция <code>search</code> должна возвратить только строки, содержащие <code>query</code>, и тест должен пройти. Запустим его:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
</code></pre>
<p>Наш тест пройден, значит он работает!</p>
<p>На этом этапе мы могли бы рассмотреть возможности изменения реализации функции поиска, сохраняя прохождение тестов и поддерживая имеющуюся функциональность. Код в функции поиска не так уж плох, но он не использует некоторые полезные функции повторителей. Вернёмся к этому примеру в <a href="ch13-02-iterators.html">главе 13</a><!-- ignore -->, где будем исследовать повторители подробно, и посмотрим как его улучшить.</p>
<h4 id="Использование-функции-search-в-функции-run"><a class="header" href="#Использование-функции-search-в-функции-run">Использование функции <code>search</code> в функции <code>run</code></a></h4>
<p>Теперь, когда функция <code>search</code> работает и протестирована, нужно вызвать <code>search</code> из нашей функции <code>run</code>. Нам нужно передать значение <code>config.query</code> и <code>contents</code>, которые <code>run</code> читает из файла, в функцию <code>search</code>. Тогда <code>run</code> напечатает каждую строку, возвращаемую из <code>search</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}</code></pre>
<p>Мы по-прежнему используем цикл <code>for</code> для возврата каждой строки из функции <code>search</code> и её печати.</p>
<p>Теперь вся программа должна работать! Давайте попробуем сначала запустить её со словом «frog», которое должно вернуть только одну строчку из стихотворения Эмили Дикинсон:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
</code></pre>
<p>Здорово! Теперь давайте попробуем слово, которое будет соответствовать нескольким строкам, например «body»:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
</code></pre>
<p>И наконец, давайте удостоверимся, что мы не получаем никаких строк, когда ищем слово, отсутствующее в стихотворении, например «monomorphization»:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
</code></pre>
<p>Отлично! Мы создали собственную мини-исполнение классического средства и научились тому, как структурировать приложения. Мы также немного узнали о файловом вводе и выводе, временах жизни, тестировании и разборе переменных приказной строки.</p>
<p>Чтобы завершить этот проект, мы кратко выполним пару вещей: как работать с переменными окружения и как печатать в стандартный поток ошибок, обе из которых полезны при написании окно выводаных программ.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Работа-с-переменными-окружения"><a class="header" href="#Работа-с-переменными-окружения">Работа с переменными окружения</a></h2>
<p>Мы улучшим <code>minigrep</code>, добавив дополнительную функцию: опцию для поиска без учёта регистра, которую пользователь может включить с помощью переменной среды окружения. Мы могли бы сделать эту функцию свойствоом приказной строки и потребовать, чтобы пользователи вводили бы её каждый раз при её применении, но вместо этого мы будем использовать переменную среды окружения, что позволит нашим пользователям устанавливать переменную среды один раз и все поиски будут не чувствительны к регистру в этом окно вызоваьном сеансе.</p>
<h3 id="Написание-ошибочного-теста-для-функции-search-с-учётом-регистра"><a class="header" href="#Написание-ошибочного-теста-для-функции-search-с-учётом-регистра">Написание ошибочного теста для функции <code>search</code> с учётом регистра</a></h3>
<p>Мы, во-первых, добавим новую функцию <code>search_case_insensitive</code>, которую мы будем вызывать, когда переменная окружения содержит значение. Мы продолжим следовать процессу TDD, поэтому первый шаг - это снова написать не проходящий тест. Мы добавим новый тест для новой функции <code>search_case_insensitive</code> и переименуем наш старый тест из <code>one_result</code> в <code>case_sensitive</code>, чтобы прояснить различия между двумя тестами, как показано в приложении 12-20.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-20. Добавление нового не проходящего теста для функции поиска нечувствительной к регистру, которую мы собираемся добавить</span></p>
<p>Обратите внимание, что мы также отредактировали содержимое переменной <code>contents</code> из старого теста. Мы добавили новую строку с текстом <code>"Duct tape."</code>, используя заглавную D, которая не должна соответствовать запросу <code>"duct"</code> при поиске с учётом регистра. Такое изменение старого теста помогает избежать случайного нарушения функциональности поиска чувствительного к регистру, который мы уже реализовали. Этот тест должен пройти сейчас и должен продолжать выполняться успешно, пока мы работаем над поиском без учёта регистра.</p>
<p>Новый тест для поиска <em>нечувствительного</em> к регистру использует <code>"rUsT"</code> качестве строки запроса. В функции <code>search_case_insensitive</code>, которую мы собираемся реализовать, запрос <code>"rUsT"</code> должен соответствовать строке содержащей <code>"Rust:"</code> с большой буквы R и соответствовать строке <code>"Trust me."</code>, хотя обе имеют разные регистры из запроса. Это наш не проходящий тест, он не собирается, потому что мы ещё не определили функцию <code>search_case_insensitive</code>. Не стесняйтесь добавлять скелет реализация, которая всегда возвращает пустой вектор, подобно тому, как мы это делали для функции <code>search</code> в приложении 12-16, чтобы увидеть сборку теста и его сбой.</p>
<h3 id="Реализация-функции-search_case_insensitive"><a class="header" href="#Реализация-функции-search_case_insensitive">Реализация функции <code>search_case_insensitive</code></a></h3>
<p>Функция <code>search_case_insensitive</code>, показанная в приложении 12-21, будет почти такая же, как функция <code>search</code>. Разница лишь в том, что текст будет в нижнем регистре для <code>query</code> и для каждой <code>line</code>, так что для любого регистра входных переменных это будет тот же случай, когда мы проверяем, содержит ли строка запрос.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-21. Определение функции <code>search_case_insensitive</code> с уменьшением регистра строки запроса и строки содержимого перед их сравнением</span></p>
<p>Сначала преобразуем в нижний регистр строку <code>query</code> и сохраняем её в затенённой переменной с тем же именем. Вызов <code>to_lowercase</code> для строки запроса необходим, так что независимо от того, будет ли пользовательский запрос <code>"rust"</code> , <code>"RUST"</code>, <code>"Rust"</code> или <code>"rUsT"</code>, мы будем преобразовывать запрос к <code>"rust"</code> и делать значение нечувствительным к регистру. Хотя <code>to_lowercase</code> будет обрабатывать Unicode, он не будет точным на 100%. Если бы мы писали реальное приложение, мы бы хотели проделать здесь немного больше работы, но этот раздел посвящён переменным среды, а не Unicode, поэтому мы оставим это здесь.</p>
<p>Обратите внимание, что <code>query</code> теперь имеет вид <code>String</code>, а не срез строки, потому что вызов <code>to_lowercase</code> создаёт новые данные, а не ссылается на существующие.  К примеру, запрос: <code>"rUsT"</code> это срез строки не содержащий строчных букв <code>u</code> или <code>t</code>, которые мы можем использовать, поэтому мы должны выделить новую <code>String</code>, содержащую <code>«rust»</code>. Когда мы передаём запрос <code>query</code> в качестве переменной способа <code>contains</code>, нам нужно добавить знак, поскольку сигнатура <code>contains</code>, определена для приёмы среза строки.</p>
<p>Затем мы добавляем вызов <code>to_lowercase</code> для каждой строки <code>line</code> для преобразования к нижнему регистру всех символов. Теперь, когда мы преобразовали <code>line</code> и <code>query</code> в нижний регистр, мы найдём совпадения независимо от того, в каком регистре находится переменная с запросом.</p>
<p>Давайте посмотрим, проходит ли эта реализация тесты:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}
</code></pre>
<p>Отлично! Тесты прошли. Теперь давайте вызовем новую функцию <code>search_case_insensitive</code> из функции <code>run</code>. Во-первых, мы добавим свойство настройке в структуру <code>Config</code> для переключения между поиском с учётом регистра и без учёта регистра. Добавление этого поля приведёт к ошибкам сборщика, потому что мы ещё нигде не объявим это поле:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}</code></pre>
<p>Мы добавили поле <code>ignore_case</code>, которое содержит логическое значение. Далее нам нужна функция <code>run</code>, чтобы проверить значение поля <code>ignore_case</code> и использовать его, чтобы решить, вызывать ли функцию <code>search</code> или функцию <code>search_case_insensitive</code>, как показано в приложении 12-22. Этот код все ещё не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}</code></pre>
<p><span class="caption">Приложение 12-22. Вызов либо <code>search</code>, либо <code>search_case_insensitive</code> на основе значения в <code>config.ignore_case</code></span></p>
<p>Наконец, нам нужно проверить переменную среды. Функции для работы с переменными среды находятся в модуле <code>env</code> встроенной библиотеки, поэтому мы хотим подключить этот модуль в область видимости в верхней части <em>src/lib.rs</em>. Затем мы будем использовать функцию <code>var</code> из модуля <code>env</code> для проверки установлено ли любое значение в переменной среды с именем <code>IGNORE_CASE</code>, как показано в приложении 12-23.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 12-23. Проверка переменной среды с именем <code>IGNORE_CASE</code></span></p>
<p>Здесь мы создаём новую переменную <code>ignore_case</code>. Чтобы установить её значение, мы вызываем функцию <code>env::var</code> и передаём ей имя переменной окружения <code>IGNORE_CASE</code>. Функция <code>env::var</code> возвращает <code>Result</code>, который будет успешным вариантом <code>Ok</code> содержащий значение переменной среды, если переменная среды установлена. Он вернёт вариант <code>Err</code>, если переменная окружения не установлена.</p>
<p>Мы используем способ <code>is_ok</code> у <code>Result</code>, чтобы проверить установлена ли переменная окружения, что будет означать, что программа должна выполнить поиск без учёта регистра. Если переменная среды <code>IGNORE_CASE</code> не содержит любого значения, то <code>is_ok</code> вернёт значение false и программа выполнит поиск c учётом регистра. Мы не заботимся о <em>значении</em> переменной среды, нас важно только установлена она или нет, поэтому мы проверяем <code>is_ok</code>, а не используем <code>unwrap</code>, <code>expect</code> или любой другой способ, который мы видели у <code>Result</code>.</p>
<p>Мы передаём значение переменной <code>ignore_case</code> экземпляру <code>Config</code>, чтобы функция <code>run</code> могла прочитать это значение и решить, следует ли вызывать <code>search</code> или <code>search_case_insensitive</code>, как мы реализовали в приложении 12-22.</p>
<p>Давайте попробуем! Во-первых, мы запустим нашу программу без установленной переменной среды и с помощью значения запроса <code>to</code>, который должен соответствовать любой строке, содержащей слово «to» в нижнем регистре:</p>
<pre><code class="language-console">{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}
</code></pre>
<p>Похоже, все ещё работает! Теперь давайте запустим программу с <code>IGNORE_CASE</code>, установленным в <code>1</code>, но с тем же значением запроса <code>to</code>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Если вы используете PowerShell, вам нужно установить переменную среды и запустить программу двумя приказми, а не одной:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Это заставит переменную окружения <code>IGNORE_CASE</code> сохраниться до конца сеанса работы окне вывода. Переменную можно отключить с помощью приказы <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Мы должны получить строки, содержащие «to», которые могут иметь заглавные буквы:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Отлично, мы также получили строки, содержащие «To»! Наша программа <code>minigrep</code> теперь может выполнять поиск без учёта регистра, управляемая переменной среды. Теперь вы знаете, как управлять свойствами, заданными с помощью переменных приказной строки или переменных среды.</p>
<p>Некоторые программы допускают использование переменных <em>и</em> переменных среды для одной и той же настройке. В таких случаях программы решают, что из них имеет больший приоритет. Для другого самостоятельного упражнения попробуйте управлять чувствительностью к регистру с помощью переменной приказной строки или переменной окружения. Решите, переменная приказной строки или переменная среды будет иметь приоритет, если программа выполняется со значениями "учитывать регистр" в одном случае, и "пренебрегать регистр" в другом.</p>
<p>Модуль <code>std::env</code> содержит много других полезных функций для работы с переменными среды: ознакомьтесь с его документацией, чтобы узнать доступные.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Запись-сообщений-ошибок-в-поток-ошибок-вместо-принятого-потока-вывода"><a class="header" href="#Запись-сообщений-ошибок-в-поток-ошибок-вместо-принятого-потока-вывода">Запись сообщений ошибок в поток ошибок вместо принятого потока вывода</a></h2>
<p>В данный момент мы записываем весь наш вывод в окно вызова, используя функцию <code>println!</code>. В большинстве окно вызоваов предоставлено два вида вывода: <em>стандартный поток вывода</em> ( <code>stdout</code> ) для общей сведений и <em>стандартный поток ошибок</em> ( <code>stderr</code> ) для сообщений об ошибках. Это различие позволяет пользователям выбирать, направлять ли успешный вывод программы в файл, но при этом выводить сообщения об ошибках на экран.</p>
<p>Функция  <code>println!</code> может печатать только в стандартный вывод, поэтому мы должны использовать что-то ещё для печати в стандартный поток ошибок.</p>
<h3 id="Проверка-куда-записываются-ошибки"><a class="header" href="#Проверка-куда-записываются-ошибки">Проверка, куда записываются ошибки</a></h3>
<p>Во-первых, давайте посмотрим, как содержимое, напечатанное из <code>minigrep</code> в настоящее время записывается в стандартный вывод, включая любые сообщения об ошибках, которые мы хотим вместо этого записать в стандартный поток ошибок. Мы сделаем это, перенаправив стандартный поток вывода в файл и намеренно вызовем ошибку. Мы не будем перенаправлять стандартный поток ошибок, поэтому любой контент, отправленный в поток принятых ошибок будет продолжать отображаться на экране.</p>
<p>Ожидается, что программы приказной строки будут отправлять сообщения об ошибках в стандартный поток ошибок, поэтому мы все равно можем видеть сообщения об ошибках на экране, даже если мы перенаправляем стандартный поток вывода в файл. Наша программа в настоящее время не ведёт себя правильно: мы увидим, что она сохраняет вывод сообщения об ошибке в файл!</p>
<p>Чтобы отобразить это поведение, мы запустим программу с помощью <code>&gt;</code> и именем файла <em>output.txt</em> в который мы хотим перенаправить стандартный поток вывода. Мы не будем передавать никаких переменных, что должно вызвать ошибку:</p>
<pre><code class="language-console">$  cargo run &gt; output.txt
</code></pre>
<p>Синтаксис <code>&gt;</code> указывает оболочке записывать содержимое принятого вывода в <em>output.txt</em> вместо экрана. Мы не увидели сообщение об ошибке, которое мы ожидали увидеть на экране, так что это означает, что оно должно быть в файле. Вот что содержит <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Да, наше сообщение об ошибке выводится в стандартный вывод. Гораздо более полезнее, чтобы подобные сообщения об ошибках печатались в встроенной поток ошибок, поэтому в файл попадают только данные из успешного запуска. Мы поменяем это.</p>
<h3 id="Печать-ошибок-в-поток-ошибок"><a class="header" href="#Печать-ошибок-в-поток-ошибок">Печать ошибок в поток ошибок</a></h3>
<p>Мы будем использовать код в приложении 12-24, чтобы изменить способ вывода сообщений об ошибках. Из-за рефакторинга, который мы делали ранее в этой главе, весь код, который печатает сообщения об ошибках, находится в одной функции: <code>main</code>. Стандартная библиотека предоставляет макрос <code>eprintln!</code>который печатает в стандартный поток ошибок, поэтому давайте изменим два места, где мы вызывали <code>println!</code> для печати ошибок, чтобы использовать <code>eprintln!</code> вместо этого.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}</code></pre>
<p><span class="caption">Запись сообщений об ошибках в Standard Error вместо Standard Output используя <code>eprintln!</code></span></p>
<p>Давайте снова запустим программу таким же образом, без каких-либо переменных и перенаправим стандартный вывод с помощью <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Теперь мы видим ошибку на экране и <em>output.txt</em> не содержит ничего, что мы ожидаем от программы приказной строки.</p>
<p>Давайте снова запустим программу с переменнойми, которые не вызывают ошибку, но все же перенаправляют стандартный вывод в файл, например так:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Мы не увидим никакого вывода в окно вызова, а <em>output.txt</em> будет содержать наши результаты:</p>
<p><span class="filename">Файл: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Это отображает, что в зависимости от ситуации мы теперь используем стандартный поток вывода для успешного текста и стандартный поток ошибок для вывода ошибок.</p>
<h2 id="Итоги-9"><a class="header" href="#Итоги-9">Итоги</a></h2>
<p>В этой главе были повторены некоторые основные концепции, которые вы изучили до сих пор и было рассказано, как выполнять обычные действия ввода-вывода в Rust. Используя переменные приказной строки, файлы, переменные среды и макрос<code>eprintln!</code> для печати ошибок и вы теперь готовы писать приложения приказной строки. В сочетании с  концепциями из предыдущих главах, ваш код будет хорошо организован, будет эффективно хранить данные в соответствующих структурах, хорошо обрабатывать ошибки и хорошо тестироваться.</p>
<p>Далее мы рассмотрим некоторые возможности Rust, на которые повлияли функциональные языки: замыкания и повторители.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Функциональные-возможности-языка-повторители-и-замыкания"><a class="header" href="#Функциональные-возможности-языка-повторители-и-замыкания">Функциональные возможности языка: повторители и замыкания</a></h1>
<p>Дизайн языка Rust черпал вдохновение из многих других языков и техник, среди которых значительное влияние оказало <em>функциональное программирование</em>. Программирование в функциональном стиле подразумевает использование функций в роли объектов, передавая их в качестве переменных, возвращая их из других функций, присваивая их переменным для последующего выполнения и так далее.</p>
<p>В этой главе мы не будем рассуждать о том, что из себя представляет функциональное программирование, а обсудим возможности Rust, присущие многим языкам, которые принято называть функциональными.</p>
<p>Более подробно мы поговорим про:</p>
<ul>
<li><em>Замыкания</em> - конструкции, подобные функциям, которые можно помещать в переменные</li>
<li><em>Повторители</em> — способ обработки последовательности элементов,</li>
<li>То, как, используя замыкания и повторители, улучшить работу с действиеми ввода-вывода в проекте из главы 12</li>
<li>Производительность замыканий и повторителей (спойлер: они быстрее, чем вы думаете!)</li>
</ul>
<p>Мы уже рассмотрели другие возможности Rust, такие как сопоставление с образцом и перечисления, которые также появились под влиянием функционального стиля. Поскольку освоение замыканий и повторителей — важная часть написания идиоматичного, быстрого кода на Rust, мы посвятим им всю эту главу.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="Замыкания-анонимные-функции-которые-запечатлевают-захватывают-своё-окружение"><a class="header" href="#Замыкания-анонимные-функции-которые-запечатлевают-захватывают-своё-окружение">Замыкания: анонимные функции, которые запечатлевают ("захватывают") своё окружение</a></h2>
<p>Замыкания в Rust - это анонимные функции, которые можно сохранять в переменных или передавать в качестве переменных другим функциям. Вы можете создать замыкание в одном месте, а затем вызвать его в каком-нибудь другом, чтобы выполнить обработку в ином среде. В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены. Мы выполним, как эти функции замыканий открывают возможности для повторного использования кода и изменения его поведения.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="Захват-переменных-окружения-с-помощью-замыкания"><a class="header" href="#Захват-переменных-окружения-с-помощью-замыкания">Захват переменных окружения с помощью замыкания</a></h3>
<p>Сначала мы рассмотрим, как с помощью замыканий можно использовать объекты из области, в которой они вместе были определены, для их последующего использования. Вот сценарий: Время от времени наша компания по производству футболок в качестве акции дарит эксклюзивные футболки, выпущенные ограниченным тиражом, каким-нибудь пользователям из нашего списка рассылки. Люди из списка рассылки при желании могут выбрать любимый цвет в своём профиле. Если человек, выбранный для получения бесплатной футболки, указал свой любимый цвет, он получает футболку этого цвета. Если человек не указал свой любимый цвет, он получит рубашку того цвета, которых у компании на данный момент больше всего.</p>
<p>Существует множество способов реализовать это. В данном примере мы будем использовать перечисление <code>ShirtColor</code>, которое может быть двух вариантов <code>Red</code> и <code>Blue</code> (для простоты ограничим количество доступных цветов этими двумя). Запасы компании мы представим структурой <code>Inventory</code>, которая состоит из поля <code>shirts</code>, содержащего <code>Vec&lt;ShirtColor&gt;</code>, в котором перечислены рубашки тех цветов, которые есть в наличии. Способ <code>giveaway</code>, определённый в <code>Inventory</code>, принимает необязательный свойство - цвет, предпочитаемый пользователем, выбранным для получения бесплатной рубашки, и возвращает тот цвет рубашки, который он получит фактически. Эта схема показана в приложении 13-1:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 13-1: Ситуация с раздачей рубашек компанией</span></p>
<p>В магазине <code>store</code>, определённом в <code>main</code>, осталось две синие и одна красная рубашки для этой ограниченной акции. Мы вызываем способ <code>giveaway</code> для пользователя предпочитающего красную рубашку и для пользователя без каких-либо предпочтений.</p>
<p>Опять же, этот код мог быть реализован множеством способов, но в данном случае, чтобы сосредоточиться на замыканиях, мы придерживались изученных ранее концепций, за исключением тела способа <code>giveaway</code>, в котором используется замыкание. В способе <code>giveaway</code> мы получаем пользовательское предпочтение цвета как свойство вида <code>Option&lt;ShirtColor&gt;</code> и вызываем способ <code>unwrap_or_else</code> на <code>user_preference</code>. Способ <a data-md-type="raw_html" href="../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> перечисления <code>Option&lt;T&gt;</code></a><!-- ignore --> определён встроенной библиотекой. Он принимает один переменная: замыкание без переменных, которое возвращает значение <code>T</code> (преобразуется в вид значения, которое окажется в варианте <code>Some</code> перечисления <code>Option&lt;T&gt;</code>, в нашем случае <code>ShirtColor</code>). Если <code>Option&lt;T&gt;</code> окажется вариантом <code>Some</code>, <code>unwrap_or_else</code> вернёт значение из <code>Some</code>. А если <code>Option&lt;T&gt;</code> будет является вариантом <code>None</code>, <code>unwrap_or_else</code> вызовет замыкание и вернёт значение, возвращённое замыканием.</p>
<p>В качестве переменной <code>unwrap_or_else</code> мы передаём замыкание <code>|| self.most_stocked()</code>. Это замыкание, которое не принимает никаких свойств (если бы у замыкания были свойства, они были бы перечислены между двумя вертикальными полосами). В теле замыкания вызывается <code>self.most_stocked()</code>. Здесь мы определили замыкание, а реализация <code>unwrap_or_else</code> такова, что выполнится оно позднее, когда потребуется получить результат.</p>
<p>Выполнение этого кода выводит:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
</code></pre>
<p>Важной особенностью здесь является то, что мы передали замыкание, которое вызывает <code>self.most_stocked()</code> текущего экземпляра <code>Inventory</code>. Стандартной библиотеке не нужно знать ничего о видах <code>Inventory</code> или <code>ShirtColor</code>, которые мы определили, или о логике, которую мы хотим использовать в этом сценарии. Замыкание фиксирует неизменяемую ссылку на <code>self</code> <code>Inventory</code> и передаёт её с указанным нами кодом в способ <code>unwrap_or_else</code>. А вот функции не могут фиксировать своё окружение таким образом.</p>
<h3 id="Выведение-и-изложение-видов-замыкания"><a class="header" href="#Выведение-и-изложение-видов-замыкания">Выведение и изложение видов замыкания</a></h3>
<p>Есть и другие различия между функциями и замыканиями. Замыкания обычно не требуют аннотирования видов входных свойств или возвращаемого значения, как это делается в функциях <code>fn</code>. Изложения видов требуются для функций, потому что виды являются частью явного внешней оболочки, предоставляемого пользователям. Жёсткое определение таких внешних оболочек важно для того, чтобы все были согласованы в том, какие виды значений использует и возвращает функция. А вот замыкания, напротив, не употребляются в роли подобных публичных внешних оболочек: они хранятся в переменных, используются не имея имени и незримо для пользователей нашей библиотеки.</p>
<p>Замыкания, как правило, небольшие и уместны в каком-то узконаправленном среде, а не в произвольных случаях. В этих ограниченных средах сборщик может вывести виды свойств и возвращаемого вида, подобно тому, как он может вывести виды большинства переменных (есть редкие случаи, когда сборщику также нужны изложении видов замыканий).</p>
<p>Как и в случае с переменными, мы можем добавить изложении видов, если хотим повысить ясность и чёткость описания ценой увеличения многословности, большей чем это необходимо. Аннотирование видов для замыкания будет выглядеть как определение, показанное в приложении 13-2. В этом примере мы определяем замыкание и храним его в переменной, а не определяем замыкание в том месте, куда мы передаём его в качестве переменной, как это было в приложении 13-1.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-2: Добавление необязательных аннотаций видов свойств и возвращаемых значений в замыкании</span></p>
<p>С добавлением аннотаций видов синтаксис замыканий выглядит более похожим на синтаксис функций. Здесь мы, для сравнения, определяем функцию, которая добавляет 1 к своему свойству, и замыкание, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, что синтаксис замыкания похож на синтаксис функции, за исключением использования труб (вертикальная черта) и количества необязательного синтаксиса:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>В первой строке показано определение функции, а во второй - полностью аннотированное определение замыкания. В третьей строке мы удаляем изложении видов из определения замыкания. В четвёртой строке мы убираем скобки, которые являются необязательными, поскольку тело замыкания содержит только одну действие. Это всё правильные определения, которые будут иметь одинаковое поведение при вызове. Строки <code>add_one_v3</code> и <code>add_one_v4</code> требуют, чтобы замыкания были вычислены до сборки, поскольку виды будут выведены из их использования. Это похоже на <code>let v = Vec::new();</code>, когда в <code>Vec</code> необходимо вставить либо изложении видов, либо значения некоторого вида, чтобы Rust смог вывести вид.</p>
<p>Для определений замыкания сборщик выводит определенные виды для каждого из свойств и возвращаемого значения. Например, в приложении 13-3 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве свойства. Это замыкание не очень полезно, кроме как для целей данного примера. Обратите внимание, что мы не добавили в определение никаких аннотаций видов. Поскольку аннотаций видов нет, мы можем вызвать замыкание для любого вида, что мы и сделали в первый раз с <code>String</code>. Если затем мы попытаемся вызвать <code>example_closure</code> для целого числа, мы получим ошибку.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-3: Попытка вызова замыкания, виды которого выводятся из двух разных видов</span></p>
<p>Сборщик вернёт нам вот такую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
</code></pre>
<p>При первом вызове <code>example_closure</code> со значением <code>String</code> сборщик определяет вид <code>x</code> и возвращаемый вид замыкания как <code>String</code>. Эти виды затем фиксируются в замыкании в <code>example_closure</code>, и мы получаем ошибку вида при следующей попытке использовать другой вид с тем же замыканием.</p>
<h3 id="Захват-ссылок-или-передача-владения"><a class="header" href="#Захват-ссылок-или-передача-владения">Захват ссылок или передача владения</a></h3>
<p>Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать свойства: заимствование неизменяемых, заимствование изменяемых и получение владения. Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело функции делает с полученными значениями.</p>
<p>В приложении 13-4 мы определяем замыкание, которое захватывает неизменяемую ссылку на вектор с именем <code>list</code>, поскольку неизменяемой ссылки достаточно для печати значения:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-4: Определение и вызов замыкания, которое захватывает неизменяемую ссылку</span></p>
<p>Этот пример также отображает, то что переменная может быть привязана к определению замыкания, и в дальнейшем мы можем вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем функции.</p>
<p>Поскольку мы можем иметь несколько неизменяемых ссылок на <code>list</code> одновременно, <code>list</code> остаётся доступным из кода до определения замыкания, после определения замыкания, а также до вызова замыкания и после. Этот код собирается, выполняется и печатает:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
</code></pre>
<p>В следующем приложении 13-5 мы изменили тело замыкания так, чтобы оно добавляло элемент в вектор <code>list</code>. Теперь замыкание захватывает изменяемую ссылку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-5. Определение и вызов замыкания, захватывающего изменяемую ссылку</span></p>
<p>Этот код собирается, запускается и печатает:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
</code></pre>
<p>Обратите внимание, что между определением и вызовом замыкания <code>borrows_mutably</code> больше нет <code>println!</code>: когда определяется <code>borrows_mutably</code>, оно захватывает изменяемую ссылку на <code>list</code>. После вызова замыкания мы больше не используем его, поэтому изменяемое заимствование заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для печати недоступно, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда <code>println!</code> и посмотрите, какое сообщение об ошибке вы получите!</p>
<p>Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет кода, требующего владения, вы можете использовать ключевое слово <code>move</code> перед списком свойств.</p>
<p>Эта техника в основном полезна при передаче замыкания новому потоку, чтобы переместить данные так, чтобы они принадлежали новому потоку. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о параллелизме, а пока давайте вкратце рассмотрим порождение нового потока с помощью замыкания, в котором используется ключевое слово <code>move</code>. В приложении 13-6 показан код из приложения 13-4, модифицированный для печати вектора в новом потоке, а не в основном потоке:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-6: Использование <code>move</code> для принуждения замыкания потока принять на себя владение <code>list</code></span></p>
<p>Мы порождаем новый поток, передавая ему в качестве переменной замыкание для выполнения. Тело замыкания распечатывает список. В приложении 13-4 замыкание захватило <code>list</code> только с помощью неизменяемой ссылки, потому что это минимально необходимый доступ к <code>list</code> для его печати. В этом примере, несмотря на то, что тело замыкания по-прежнему требует только неизменяемой ссылки, нам нужно указать, что <code>list</code> должен быть перемещён в замыкание, поместив ключевое слово <code>move</code> в начало определения замыкания. Новый поток может завершиться раньше, чем завершится основной поток, или основной поток может завершиться первым. Если основной поток сохранил владение <code>list</code>, но завершился раньше нового потока и удалил <code>list</code>, то неизменяемая ссылка в потоке будет недействительной. Поэтому сборщик требует, чтобы <code>list</code> был перемещён в замыкание, переданное новому потоку, чтобы ссылка была действительной. Попробуйте убрать ключевое слово <code>move</code> или использовать <code>list</code> в основном потоке после определения замыкания и посмотрите, какие ошибки сборщика вы получите!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="Перемещение-захваченных-значений-из-замыканий-и-трейты-fn"><a class="header" href="#Перемещение-захваченных-значений-из-замыканий-и-трейты-fn">Перемещение захваченных значений из замыканий и трейты <code>Fn</code></a></h3>
<p>После того, как замыкание захватило ссылку или владение значением из среды, в которой оно определено (тем самым влияя на то, что перемещается <em>в</em> замыкание), код в теле замыкания определяет, что происходит со ссылками или значениями, в момент последующего выполнения замыкания (тем самым влияя на то, что перемещается <em>из</em> замыкания). Тело замыкания может делать любое из следующих действий: перемещать захваченное значение из замыкания, изменять захваченное значение, не перемещать и не изменять значение или вообще ничего не захватывать из среды.</p>
<p>То, как замыкание получает и обрабатывает значения из своего окружения, указывает на то, какие трейты реализует замыкание, а с помощью трейтов функции и структуры могут определять, какие виды замыканий они могут использовать. Замыканиям самостоятельно присваивается реализация одного, двух или всех трёх из нижеперечисленных трейтов <code>Fn</code>, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:</p>
<ol>
<li><code>FnOnce</code> применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания реализуют по крайней мере этот трейт, потому что все замыкания могут быть вызваны. Замыкание, которое перемещает захваченные значения из своего тела, реализует только <code>FnOnce</code> и ни один из других признаков <code>Fn</code>, потому что оно может быть вызвано только один раз.</li>
<li><code>FnMut</code> применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но могут изменять захваченные значения. Такие замыкания могут вызываться более одного раза.</li>
<li><code>Fn</code> применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не модифицируют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения. Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.</li>
</ol>
<p>Давайте рассмотрим определение способа <code>unwrap_or_else</code> у <code>Option&lt;T&gt;</code>, который мы использовали в приложении 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Напомним, что <code>T</code> - это универсальный вид, отображающий вид значения в <code>Some</code> варианте <code>Option</code>. Этот вид <code>T</code> также является возвращаемым видом функции <code>unwrap_or_else</code>: например, код, вызывающий <code>unwrap_or_else</code> у <code>Option&lt;String&gt;</code>, получит <code>String</code>.</p>
<p>Далее, обратите внимание, что функция <code>unwrap_or_else</code> имеет дополнительный свойство универсального вида <code>F</code>. Здесь <code>F</code> - это вид входного свойства <code>f</code>, который является замыканием, заданным нами при вызове <code>unwrap_or_else</code>.</p>
<p>Ограничением трейта, заданным для обобщённого вида <code>F</code>, является <code>FnOnce() -&gt; T</code>, что означает, что <code>F</code> должен вызываться один раз, не принимать никаких переменных и возвращать <code>T</code>. Использование <code>FnOnce</code> в ограничении трейта говорит о том, что <code>unwrap_or_else</code> должен вызывать <code>f</code> не более одного раза. В теле <code>unwrap_or_else</code> мы видим, что если <code>Option</code> будет равен <code>Some</code>, то <code>f</code> не будет вызван. Если же значение <code>Option</code> будет равным <code>None</code>, то <code>f</code> будет вызван один раз. Поскольку все замыкания реализуют <code>FnOnce</code>, <code>unwrap_or_else</code> принимает самые разные виды замыканий и является настолько гибким, насколько это возможно.</p>
<blockquote>
<p>Примечание: Функции также могут реализовывать все три трейта <code>Fn</code>. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем передавать имя какой-либо функции, а не замыкания, когда нам нужно что-то, реализующее один из трейтов <code>Fn</code>. Например, для значения <code>Option&lt;Vec&lt;T&gt;&gt;</code> мы можем вызвать <code>unwrap_or_else(Vec::new)</code>, чтобы получить новый пустой вектор, если значение окажется <code>None</code>.</p>
</blockquote>
<p>Теперь рассмотрим способ встроенной библиотеки <code>sort_by_key</code>, определённый у срезов, чтобы увидеть, чем он отличается от <code>unwrap_or_else</code> и почему <code>sort_by_key</code> использует <code>FnMut</code> вместо <code>FnOnce</code> для ограничения трейта. Замыкание принимает единственный переменная в виде ссылки на текущий элемент в рассматриваемом срезе и возвращает значение вида <code>K</code>, к которому применима сортировка. Эта функция полезна, когда вы хотите отсортировать срез по определённому атрибуту каждого элемента. В приложении 13-7 у нас есть список экземпляров <code>Rectangle</code>, и мы используем <code>sort_by_key</code>, чтобы упорядочить их по атрибуту <code>width</code> от меньшего к большему:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-7: Использование <code>sort_by_key</code> для сортировки прямоугольников по ширине</span></p>
<p>Этот код печатает:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
</code></pre>
<p>Причина, по которой <code>sort_by_key</code> определена как принимающая замыкание <code>FnMut</code>, заключается в том, что она вызывает замыкание несколько раз: по одному разу для каждого элемента в срезе. Замыкание <code>|r| r.width</code> не захватывает, не изменяет и не перемещает ничего из своего окружения, поэтому оно удовлетворяет требованиям связанности признаков.</p>
<p>И наоборот, в приложении 13-8 показан пример замыкания, которое реализует только признак <code>FnOnce</code>, потому что оно перемещает значение из среды. Сборщик не позволит нам использовать это замыкание с <code>sort_by_key</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 13-8: Попытка использовать замыкание <code>FnOnce</code> с <code>sort_by_key</code></span></p>
<p>Это надуманный, замысловатый способ (который не работает) подсчёта количества вызовов <code>sort_by_key</code> при сортировке <code>list</code>. Этот код пытается выполнить подсчёт, перемещая <code>value</code> - <code>String</code> из окружения замыкания - в вектор <code>sort_operations</code>. Замыкание захватывает <code>value</code>, затем перемещает <code>value</code> из замыкания, передавая владение на <code>value</code> вектору <code>sort_operations</code>. Это замыкание можно вызвать один раз; попытка вызвать его второй раз не сработает, потому что <code>value</code> уже не будет находиться в той среде, из которой его можно будет снова поместить в <code>sort_operations</code>! Поэтому это замыкание реализует только <code>FnOnce</code>. Когда мы попытаемся собрать этот код, мы получим ошибку сообщающую о том что <code>value</code> не может быть перемещено из замыкания, потому что замыкание должно реализовывать <code>FnMut</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
</code></pre>
<p>Ошибка указывает на строку в теле замыкания, которая перемещает <code>value</code> из окружения. Чтобы исправить это, нужно изменить тело замыкания так, чтобы оно не перемещало значения из окружения. Для подсчёта количества вызовов <code>sort_by_key</code> более простым способом является хранение счётчика в окружении и увеличение его значения в теле замыкания. Замыкание в приложении 13-9 работает с <code>sort_by_key</code>, поскольку оно фиксирует только изменяемую ссылку на счётчик <code>num_sort_operations</code> и поэтому может быть вызвано более одного раза:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-9: Использование замыкания <code>FnMut</code> с <code>sort_by_key</code> разрешено</span></p>
<p>Трейты <code>Fn</code> важны при определении или использовании функций или видов, использующих замыкания. В следующем разделе мы обсудим повторители. Многие способы повторителей принимают переменные в виде замыканий, поэтому не забывайте об этих подробностях, пока мы продвигаемся дальше!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обработка-последовательности-элементов-с-помощью-повторителей"><a class="header" href="#Обработка-последовательности-элементов-с-помощью-повторителей">Обработка последовательности элементов с помощью повторителей</a></h2>
<p>Использование паттерна Повторитель помогает при необходимости поочерёдного выполнения какой-либо действия над элементами последовательности. Повторитель отвечает за логику перебора элементов и определение момента завершения последовательности. Используя повторители, вам не нужно самостоятельно реализовывать всю эту логику.</p>
<p>В Rust повторители <em>ленивые (lazy)</em>, то есть они не делают ничего, пока вы не вызовете особые способы, потребляющие повторитель, чтобы задействовать его. Например, код в приложении 13-10 создаёт повторительэлементов вектора <code>v1</code>, вызывая способ <code>iter</code>, определённый у <code>Vec&lt;T&gt;</code>. Сам по себе этот код не делает ничего полезного.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-10: Создание повторителя</span></p>
<p>Повторитель хранится в переменной <code>v1_iter</code>. Создав повторитель, мы можем использовать его различными способами. В приложении 3-5 главы 3 мы совершали обход элементов массива используя цикл <code>for</code> для выполнения какого-то кода над каждым из его элементов. Под капотом это неявно создавало, а затем потребляло повторитель, но до сих пор мы не касались того, как именно это работает.</p>
<p>В примере из приложения 13-11 мы отделили создание повторителя от его использования в цикле for. В цикле for, использующем повторительв v1_iter, каждый элемент повторителя участвует только в одной повторения цикла, в ходе которой выводится на экран его значение.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-11: Использование повторителя в цикле <code>for</code></span></p>
<p>В языках, стандартные библиотеки которых не предоставляют повторители, вы, скорее всего, напишите эту же функциональность так: создадите переменную со значением 0 затем, в цикле, использовав её для получения элемента вектора по порядковому казателю, будете увеличивать её значение, и так, пока оно не достигнет числа равного количеству элементов в векторе.</p>
<p>Повторители выполняют всю эту логику за вас, сокращая количество повторяющегося кода, который потенциально может быть написан неправильно. Повторители дают вам гибкость, позволяя использовать одинаковые принципы работы с различными видами последовательностей, а не только со структурами данных, которые можно упорядочивать, например, векторами. Давайте рассмотрим, как повторители это делают.</p>
<h3 id="Типаж-iterator-и-способ-next"><a class="header" href="#Типаж-iterator-и-способ-next">Типаж <code>Iterator</code> и способ <code>next</code></a></h3>
<p>Все повторители реализуют типаж <code>Iterator</code>, который определён в встроенной библиотеке. Его определение выглядит так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Обратите внимание данное объявление использует новый синтаксис: <code>type Item</code> и <code>Self::Item</code>, которые определяют <em>ассоциированный вид</em> (associated type) с этим типажом. Мы подробнее поговорим о ассоциированных видах в главе 19. Сейчас вам нужно знать, что этот код требует от реализаций типажа <code>Iterator</code> определить требуемый им вид <code>Item</code> и данный вид <code>Item</code> используется в способе <code>next</code>. Другими словами, вид <code>Item</code> будет являться видом элемента, который возвращает повторитель.</p>
<p>Типаж <code>Iterator</code> требует, чтобы разработчики определяли только один способ: способ <code>next</code>, который возвращает один элемент повторителя за раз обёрнутый в вариант <code>Some</code> и когда повторение завершена, возвращает <code>None</code>.</p>
<p>Мы можем вызывать способ <code>next</code> у повторителей напрямую; в приложении 13-12 показано, какие значения возвращаются при повторных вызовах <code>next</code> у повторителя, созданного из вектора.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-12: Вызов способа <code>next</code> повторителя</span></p>
<p>Обратите внимание, что нам нужно сделать переменную <code>v1_iter</code> изменяемой: вызов способа <code>next</code> повторителя изменяет внутреннее состояние повторителя, которое повторительиспользует для отслеживания того, где он находится в последовательности. Другими словами, этот код <em>потребляет</em> (consume) или использует повторитель. Каждый вызов <code>next</code> потребляет элемент из повторителя. Нам не нужно было делать изменяемой <code>v1_iter</code> при использовании цикла <code>for</code>, потому что цикл забрал во владение <code>v1_iter</code> и сделал её изменяемой неявно для нас.</p>
<p>Заметьте также, что значения, которые мы получаем при вызовах <code>next</code> являются неизменяемыми ссылками на значения в векторе. Способ <code>iter</code> создаёт повторительпо неизменяемым ссылкам. Если мы хотим создать повторитель, который становится владельцем <code>v1</code> и возвращает принадлежащие ему значения, мы можем вызвать <code>into_iter</code> вместо <code>iter</code>. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать <code>iter_mut</code> вместо <code>iter</code>.</p>
<h3 id="Способы-которые-потребляют-повторитель"><a class="header" href="#Способы-которые-потребляют-повторитель">Способы, которые потребляют повторитель</a></h3>
<p>У типажа <code>Iterator</code> есть несколько способов, реализация которых по умолчанию предоставляется встроенной библиотекой; вы можете узнать об этих способах, просмотрев документацию API встроенной библиотеки для <code>Iterator</code>. Некоторые из этих способов вызывают <code>next</code> в своём определении, поэтому вам необходимо реализовать способ <code>next</code> при реализации типажа <code>Iterator</code>.</p>
<p>Способы, вызывающие <code>next</code>, называются <em>потребляющими адаптерами</em>, поскольку их вызов потребляет повторитель. Примером может служить способ <code>sum</code>, который забирает во владение повторительи перебирает элементы, многократно вызывая <code>next</code>, тем самым потребляя повторитель. В процессе повторения он добавляет каждый элемент к текущей сумме и возвращает итоговое значение по завершении повторения. В приложении 13-13 приведён тест, отображающий использование способа <code>sum</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-13: Вызов способа <code>sum</code> для получения суммы всех элементов в повторителе</span></p>
<p>Мы не можем использовать <code>v1_iter</code> после вызова способа <code>sum</code>, потому что <code>sum</code> забирает во владение повторительу которого вызван способ.</p>
<h3 id="Способы-которые-создают-другие-повторители"><a class="header" href="#Способы-которые-создают-другие-повторители">Способы, которые создают другие повторители</a></h3>
<p><em>Адаптеры повторителей</em> - это способы, определённые для трейта <code>Iterator</code>, которые не потребляют повторитель. Вместо этого они создают различные повторители, изменяя некоторые особенности исходного повторителя.</p>
<p>В приложении 13-14 показан пример вызова способа адаптера повторителя <code>map</code>, который принимает замыкание и вызывает его для каждого элемента по мере повторения элементов. Способ <code>map</code> возвращает новый повторитель, который создаёт изменённые элементы. Замыкание здесь создаёт новый повторитель, в котором каждый элемент из вектора будет увеличен на 1:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-14: Вызов адаптера повторителя <code>map</code> для создания нового повторителя</span></p>
<p>Однако этот код выдаёт предупреждение:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
</code></pre>
<p>Код в приложении 13-14 ничего не делает; указанное нами замыкание никогда не вызывается. Предупреждение напоминает нам, почему: адаптеры повторителей ленивы, и здесь нам нужно потребить повторитель.</p>
<p>Чтобы устранить это предупреждение и потребить повторитель, мы воспользуемся способом <code>collect</code>, который мы использовали в главе 12 с <code>env::args</code> в приложении 12-1. Этот способ потребляет повторительи собирает полученные значения в собрание указанного вида.</p>
<p>В приложении 13-15 мы собираем в вектор результаты перебора повторителя, который возвращается в результате вызова <code>map</code>. Этот вектор в итоге будет содержать каждый элемент исходного вектора, увеличенный на 1.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 13-15: Вызов способа <code>map</code> для создания нового повторителя, а затем вызов способа <code>collect</code> для потребления нового повторителя и создания вектора</span></p>
<p>Поскольку <code>map</code> принимает замыкание, мы можем указать любую действие, которую хотим выполнить над каждым элементом. Это отличный пример того, как замыкания позволяют задавать желаемое поведение, используя при этом особенности повторения, которые обеспечивает трейт <code>Iterator</code>.</p>
<p>Вы можете выстроить цепочку из нескольких вызовов адаптеров повторителя для выполнения сложных действий в удобочитаемом виде. Но поскольку все повторители являются "ленивыми", для получения результатов вызовов адаптеров повторителя необходимо вызвать один из способов потребляющего адаптера.</p>
<h3 id="Использование-замыканий-которые-захватывают-переменные-окружения"><a class="header" href="#Использование-замыканий-которые-захватывают-переменные-окружения">Использование замыканий, которые захватывают переменные окружения</a></h3>
<p>Многие адаптеры повторителей принимают замыкания в качестве переменных, и обычно замыкания, которые мы будем указывать в качестве переменных адаптерам повторителей, это замыкания, которые фиксируют (захватывают) своё окружение.</p>
<p>В этом примере мы будем использовать способ <code>filter</code>, который принимает замыкание. Замыкание получает элемент из повторителя и возвращает <code>bool</code>. Если замыкание возвращает <code>true</code>, значение будет включено в повторение, создаваемую <code>filter</code>. Если замыкание возвращает <code>false</code>, значение не будет включено.</p>
<p>В приложении 13-16 мы используем <code>filter</code> с замыканием, которое захватывает переменную <code>shoe_size</code> из своего окружения для повторения по собрания экземпляров структуры <code>Shoe</code>. Он будет возвращать обувь только указанного размера.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 13-16. Использование способа <code>filter</code> с замыканием, фиксирующим <code>shoe_size</code></span></p>
<p>Функция <code>shoes_in_size</code> принимает в качестве свойств вектор с экземплярами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера.</p>
<p>В теле <code>shoes_in_my_size</code> мы вызываем <code>into_iter</code> чтобы создать повторитель, который становится владельцем вектора. Затем мы вызываем <code>filter</code>, чтобы превратить этот повторительв другой, который содержит только элементы, для которых замыкание возвращает <code>true</code>.</p>
<p>Замыкание захватывает свойство <code>shoe_size</code> из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов <code>collect</code> собирает значения, возвращаемые адаптированным повторителем, в вектор, возвращаемый функцией.</p>
<p>Тест показывает, что когда мы вызываем <code>shoes_in_my_size</code>, мы возвращаем только туфли, размер которых совпадает с указанным нами значением.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Улучшение-нашего-проекта-с-вводомвыводом"><a class="header" href="#Улучшение-нашего-проекта-с-вводомвыводом">Улучшение нашего проекта с вводом/выводом</a></h2>
<p>Вооружившись полученными знаниями об повторителях, мы можем улучшить реализацию работы с вводом/выводом в проекте главы 12, применяя повторители для того, чтобы сделать некоторые места в коде более понятными и лаконичными. Давайте рассмотрим, как повторители могут улучшить нашу реализацию функции <code>Config::build</code> и функции <code>search</code>.</p>
<h3 id="Удаляем-clone-используем-повторитель"><a class="header" href="#Удаляем-clone-используем-повторитель">Удаляем <code>clone</code>, используем повторитель</a></h3>
<p>В приложении 12-6 мы добавили код, который принимает срез значений <code>String</code> и создаёт экземпляр структуры <code>Config</code> путём упорядочевания среза и клонирования значений, позволяя структуре <code>Config</code> владеть этими значениями. В приложении 13-17 мы воспроизвели реализацию функции <code>Config::build</code>, как это было в приложении 12-23:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/lib.rs:ch13}}</code></pre>
<p><span class="caption">Приложение 13-17: Репродукция функции <code>Config::build</code> из приложения 12-23</span></p>
<p>Ранее мы говорили, что не стоит беспокоиться о неэффективных вызовах <code>clone</code>, потому что мы удалим их в будущем. Ну что же, время пришло!</p>
<p>Нам понадобился здесь <code>clone</code>, потому что в свойстве <code>args</code> у нас срез с элементами <code>String</code>, но функция <code>build</code> не владеет <code>args</code>. Чтобы экземпляр <code>Config</code> владел значениями, нам пришлось клонировать их из <code>args</code> в переменные <code>query</code> и <code>file_path</code>.</p>
<p>Благодаря нашим новым знаниям об повторителях мы можем изменить функцию <code>build</code>, чтобы вместо заимствования среза она принимала в качестве переменной повторитель. Мы будем использовать функциональность повторителя вместо кода, который проверяет длину среза и обращается по порядковому указателю к определённым значениям. Это позволит лучше понять, что делает функция <code>Config::build</code>, поскольку повторительбудет обращаться к значениям.</p>
<p>Как только <code>Config::build</code> получит в своё распоряжение повторительи перестанет использовать действия упорядочевания с заимствованием, мы сможем переместить значения <code>String</code> из повторителя в <code>Config</code> вместо того, чтобы вызывать <code>clone</code> и создавать новое выделение памяти.</p>
<h4 id="Использование-возвращённого-повторителя-напрямую"><a class="header" href="#Использование-возвращённого-повторителя-напрямую">Использование возвращённого повторителя напрямую</a></h4>
<p>Откройте файл <em>src/main.rs</em> проекта ввода-вывода, который должен выглядеть следующим образом:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}</code></pre>
<p>Сначала мы изменим начало функции <code>main</code>, которая была в приложении 12-24, на код в приложении 13-18, который теперь использует повторитель. Это не будет собираться, пока мы не обновим <code>Config::build</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-18: Передача возвращаемого значения из <code>env::args</code> в <code>Config::build</code></span></p>
<p>Функция <code>env::args</code> возвращает повторитель! Вместо того чтобы собирать значения повторителя в вектор и затем передавать срез в <code>Config::build</code>, теперь мы передаём владение повторителем, возвращённым из <code>env::args</code> в <code>Config::build</code> напрямую.</p>
<p>Далее нам нужно обновить определение <code>Config::build</code>. В файле <em>src/lib.rs</em> вашего проекта ввода-вывода изменим сигнатуру <code>Config::build</code> так, чтобы она выглядела как в приложении 13-19. Это все ещё не ссобирается, потому что нам нужно обновить тело функции.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-19: Обновление сигнатуры <code>Config::build</code> для определения повторителя как ожидаемого свойства</span></p>
<p>Документация встроенной библиотеки для функции <code>env::args</code> показывает, что вид возвращаемого ею повторителя - <code>std::env::Args</code>, и этот вид реализует признак <code>Iterator</code> и возвращает значения <code>String</code>.</p>
<p>Мы обновили сигнатуру функции <code>Config::build</code>, чтобы свойство <code>args</code> имел универсальный вид ограниченный трейтом <code>impl Iterator&lt;Item = String&gt;</code> вместо <code>&amp;[String]</code>. Такое использование синтаксиса <code>impl Trait</code>, который мы обсуждали в разделе <a href="ch10-02-traits.html#traits-as-parameters">" Трейты как свойства"</a><!-- ignore --> главы 10, означает, что <code>args</code> может быть любым видом, реализующим вид <code>Iterator</code> и возвращающим элементы <code>String</code>.</p>
<p>Поскольку мы владеем <code>args</code> и будем изменять <code>args</code> в процессе повторения над ним, мы можем добавить ключевое слово <code>mut</code> в спецификацию свойства <code>args</code>, чтобы сделать его изменяемым.</p>
<h4 id="Использование-способов-типажа-iterator-вместо-порядковых-указателей"><a class="header" href="#Использование-способов-типажа-iterator-вместо-порядковых-указателей">Использование способов типажа <code>Iterator</code> вместо порядковых указателей</a></h4>
<p>Далее мы подправим содержимое <code>Config::build</code>. Поскольку <code>args</code> реализует признак <code>Iterator</code>, мы знаем, что можем вызвать у него способ <code>next</code>! В приложении 13-20 код из приложения 12-23 обновлён для использования способа <code>next</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-20: Изменяем тело <code>Config::build</code> так, чтобы использовать способы повторителя</span></p>
<p>Помните, что первое значение в возвращаемых данных <code>env::args</code> - это имя программы. Мы хотим пропренебрегать его и перейти к следующему значению, поэтому сперва мы вызываем <code>next</code> и ничего не делаем с возвращаемым значением. Затем мы вызываем <code>next</code>, чтобы получить значение, которое мы хотим поместить в поле <code>query</code> в <code>Config</code>. Если <code>next</code> возвращает <code>Some</code>, мы используем <code>match</code> для извлечения значения. Если возвращается <code>None</code>, это означает, что было задано недостаточно переменных, и мы досрочно возвращаем значение <code>Err</code>. То же самое мы делаем для значения <code>file_path</code>.</p>
<h3 id="Делаем-код-понятнее-с-помощью-адаптеров-повторителей"><a class="header" href="#Делаем-код-понятнее-с-помощью-адаптеров-повторителей">Делаем код понятнее с помощью адаптеров повторителей</a></h3>
<p>Мы также можем воспользоваться преимуществами повторителей в функции <code>search</code> в нашем проекте с действиеми ввода-вывода, которая воспроизведена здесь в приложении 13-21 так же, как и в приложении 12-19:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}</code></pre>
<p><span class="caption">Приложение 13-21: Реализация функции <code>search</code> из приложения 12-19</span></p>
<p>Мы можем написать этот код в более сжатом виде, используя способы адаптера повторителя. Это также позволит нам избежать наличия изменяемого временного вектора <code>results</code>. Функциональный стиль программирования предпочитает минимизировать количество изменяемого состояния, чтобы сделать код более понятным. Удаление изменяемого состояния может позволить в будущем сделать поиск параллельным, поскольку нам не придётся управлять одновременным доступом к вектору <code>results</code>. В приложении 13-22 показано это изменение:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 13-22: Использование способов адаптера повторителя в реализации функции <code>search</code></span></p>
<p>Напомним, что назначение функции <code>search</code> - вернуть все строки в <code>contents</code>, которые содержат <code>query</code>. Подобно примеру <code>filter</code> в приложении 13-16, этот код использует адаптер <code>filter</code>, чтобы сохранить только те строки, для которых <code>line.contains(query)</code> возвращает <code>true</code>. Затем мы собираем совпадающие строки в другой вектор с помощью <code>collect</code>. Так гораздо проще! Не стесняйтесь сделать такое же изменение для использования способов повторителя в функции <code>search_case_insensitive</code>.</p>
<h3 id="Выбор-между-циклами-или-повторителями"><a class="header" href="#Выбор-между-циклами-или-повторителями">Выбор между циклами или повторителями</a></h3>
<p>Следующий логичный вопрос - какой стиль вы должны выбрать в своём коде и почему: оригинальную реализацию в приложении 13-21 или исполнение с использованием повторителей в приложении 13-22. Большинство программистов на языке Rust предпочитают использовать стиль повторителей. Сначала разобраться с ним немного сложно, но как только вы почувствуете, что такое различные адаптеры повторителей и что они делают, понять повторители станет проще. Вместо того чтобы возиться с различными элементами цикла и создавать новые векторы, код фокусируется на высокоуровневой цели цикла. Это абстрагирует часть обычного кода, поэтому легче увидеть концепции, уникальные для этого кода, такие как условие фильтрации, которое должен пройти каждый элемент в повторителе.</p>
<p>Но действительно ли эти две реализации эквивалентны? Интуитивно можно предположить, что более низкоуровневый цикл будет быстрее. Давайте поговорим о производительности.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Сравнение-производительности-циклов-и-повторителей"><a class="header" href="#Сравнение-производительности-циклов-и-повторителей">Сравнение производительности циклов и повторителей</a></h2>
<p>Чтобы определить, что лучше использовать циклы или повторители, нужно знать, какая реализация быстрее: исполнение функции <code>search</code> с явным циклом <code>for</code> или исполнение с повторителями.</p>
<p>Мы выполнили тест производительности, разместив всё содержимое книги <em>(“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)</em> в строку вида <code>String</code> и поискали слово <em>the</em> в её содержимом. Вот результаты теста функции <code>search</code> с использованием цикла <code>for</code> и с использованием повторителей:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Исполнение с использованием повторителей была немного быстрее! Мы не будем приводить здесь непосредственно код теста, поскольку мысль не в том, чтобы доказать, что решения в точности эквивалентны, а в том, чтобы получить общее представление о том, как эти две реализации близки по производительности.</p>
<p>Для более исчерпывающего теста, вам нужно проверить различные тексты разных размеров в качестве содержимого для <code>contents</code>, разные слова и слова различной длины в качестве <code>query</code> и всевозможные другие варианты. Дело в том, что повторители, будучи высокоуровневой абстракцией, собираются примерно в тот же код, как если бы вы написали его низкоуровневый вариант самостоятельно. Повторители - это одна из <em>абстракций с нулевой стоимостью</em> ( zero-cost abstractions ) в Rust, под которой мы подразумеваем, что использование абстракции не накладывает дополнительных расходов во время выполнения. Подобно тому, как Бьёрн Страуструп, дизайнер и разработчик C++, определяет <em>нулевые накладные расходы</em> ( zero-overhead ) в книге “Foundations of C++” (2012):</p>
<blockquote>
<p>В целом, реализация C++ подчиняется принципу отсутствия накладных расходов: за то, чем вы не пользуетесь, платить не нужно. И далее: тот код, что вы используете, нельзя сделать ещё лучше.</p>
</blockquote>
<p>В качестве другого примера приведём код, взятый из аудио декодера. Алгоритм декодирования использует математическую действие линейного предсказания для оценки будущих значений на основе линейной функции предыдущих выборок. Код использует комбинирование вызовов повторителя для выполнения математических вычислений для трёх переменных в области видимости: срез данных <code>buffer</code>, массив из 12 коэффициентов <code>coefficients</code> и число для сдвига данных в переменной <code>qlp_shift</code>. Переменные определены в примере, но не имеют начальных значений. Хотя этот код не имеет большого значения вне среды, он является кратким, существующим примером того, как Rust переводит идеи высокого уровня в код низкого уровня.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>Чтобы вычислить значение переменной <code>prediction</code>, этот код перебирает каждое из 12 значений в переменной <code>coefficients</code> и использует способ <code>zip</code> для объединения значений коэффициентов с предыдущими 12 значениями в переменной <code>buffer</code>. Затем, для каждой пары мы перемножаем значения, суммируем все результаты и у суммы сдвигаем биты вправо в переменную <code>qlp_shift</code>.</p>
<p>Для вычислений в таких приложениях, как аудио декодеры, часто требуется производительность. Здесь мы создаём повторитель, используя два адаптера, впоследствии потребляющих значение. В какой ассемблерный код будет собираться этот код на Rust? На момент написания этой главы он собирается в то же самое, что вы написали бы руками. Не существует цикла, соответствующего повторения по значениям в «коэффициентах»<code>coefficients</code>: Rust знает, что существует двенадцать повторений, поэтому он «разворачивает» цикл. <em>Разворачивание</em> - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой повторения цикла.</p>
<p>Все коэффициенты сохраняются в регистрах, что означает очень быстрый доступ к значениям. Нет никаких проверок границ доступа к массиву во время выполнения. Все эти оптимизации, которые может применить Rust, делают полученный код чрезвычайно эффективным. Теперь, когда вы это знаете, используйте повторители и замыкания без страха! Они представляют код в более высокоуровневом виде, но без потери производительности во время выполнения.</p>
<h2 id="Итоги-10"><a class="header" href="#Итоги-10">Итоги</a></h2>
<p>Замыкания (closures) и повторители (iterators) это возможности Rust, вдохновлённые идеями функциональных языков. Они позволяют Rust ясно выражать идеи высокого уровня с производительностью низкоуровневого кода. Реализации замыканий и повторителей таковы, что нет влияния на производительность выполнения кода. Это одна из целей Rust, направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).</p>
<p>Теперь, когда мы улучшили представление кода в нашем проекте, рассмотрим некоторые возможности, которые нам предоставляет <code>cargo</code> для публикации нашего кода в репозитории.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Больше-о-cargo-и-cratesio"><a class="header" href="#Больше-о-cargo-и-cratesio">Больше о Cargo и Crates.io</a></h1>
<p>До сих пор мы использовали только самые основные возможности Cargo для сборки, запуска и тестирования нашего кода, но он может гораздо больше. В этой главе мы обсудим некоторые другие, более продвинутые возможности, чтобы показать вам, как делать следующее:</p>
<ul>
<li>Настройка сборки с помощью релизных профилей</li>
<li>Публикация библиотеки на <a href="https://crates.io/">crates.io</a><!--  --></li>
<li>Управление крупными проектами с помощью рабочих пространств</li>
<li>Установка двоичных файлов с <a href="https://crates.io/">crates.io</a><!--  --></li>
<li>Расширение возможностей Cargo с помощью возможности добавления собственных приказов</li>
</ul>
<p>Cargo может делать значительно больше того, что мы рассмотрим в этой главе, полное описание всех его функций см. в <a href="https://doc.rust-lang.org/cargo/">документации</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Настройка-сборок-с-профилями-релизов"><a class="header" href="#Настройка-сборок-с-профилями-релизов">Настройка сборок с профилями релизов</a></h2>
<p>В Rust <em>профили выпуска</em> — это предопределённые и настраиваемые профили с различными настройками, которые позволяют программисту лучше управлять различные свойства сборки кода. Каждый профиль настраивается независимо от других.</p>
<p>Cargo имеет два основных профиля: профиль <code>dev</code>, используемый Cargo при запуске <code>cargo build</code>, и профиль <code>release</code>, используемый Cargo при запуске <code>cargo build --release</code>. Профиль <code>dev</code> определён со значениями по умолчанию для разработки, а профиль <code>release</code> имеет значения по умолчанию для сборок в релиз.</p>
<p>Эти имена профилей могут быть знакомы по результатам ваших сборок:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p><code>dev</code> и <code>release</code> — это разные профили, используемые сборщиком.</p>
<p>Cargo содержит настройки по умолчанию для каждого профиля, которые применяются, если вы явно не указали секции <code>[profile.*]</code> в файле проекта <em>Cargo.toml</em>. Добавляя секции <code>[profile.*]</code> для любого профиля, который вы хотите настроить, вы переопределяете любое подмножество свойств по умолчанию. Например, вот значения по умолчанию для свойства <code>opt-level</code> для профилей <code>dev</code> и <code>release</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Свойство <code>opt-level</code> управляет количеством оптимизаций, которые Rust будет применять к вашему коду, в ряде от 0 до 3. Использование большего количества оптимизаций увеличивает время сборки, поэтому если вы находитесь в процессе разработки и часто собираете свой код, целесообразно использовать меньшее количество оптимизаций, чтобы сборка происходила быстрее, даже если в результате код будет работать медленнее. Поэтому <code>opt-level</code> по умолчанию для <code>dev</code> установлен в <code>0</code>. Когда вы готовы опубликовать свой код, то лучше потратить больше времени на сборку. Вы ссобираете программу в режиме релиза только один раз, но выполняться она будет многократно, так что использование режима релиза позволяет увеличить скорость выполнения кода за счёт времени сборки. Вот почему по умолчанию <code>opt-level</code> для профиля <code>release</code> равен <code>3</code>.</p>
<p>Вы можете переопределить настройки по умолчанию, добавив другое значение для них в <em>Cargo.toml</em>. Например, если мы хотим использовать уровень оптимизации 1 в профиле разработки, мы можем добавить эти две строки в файл <em>Cargo.toml</em> нашего проекта:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Этот код переопределяет настройку по умолчанию <code>0</code>. Теперь, когда мы запустим <code>cargo build</code>, Cargo будет использовать значения по умолчанию для профиля <code>dev</code> плюс нашу настройку для <code>opt-level</code>. Поскольку мы установили для <code>opt-level</code> значение <code>1</code>, Cargo будет применять больше оптимизаций, чем было задано по умолчанию, но не так много, как при сборке релиза.</p>
<p>Полный список свойств настройке и значений по умолчанию для каждого профиля вы можете найти в <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">документации Cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Публикация-библиотеки-в-cratesio"><a class="header" href="#Публикация-библиотеки-в-cratesio">Публикация библиотеки в Crates.io</a></h2>
<p>Мы использовали пакеты из <a href="https://crates.io/">crates.io</a><!--  --> в качестве зависимостей нашего проекта, но вы также можете поделиться своим кодом с другими людьми, опубликовав свои собственные пакеты. Реестр библиотек по адресу <a href="https://crates.io/">crates.io</a><!--  --> распространяет исходный код ваших пакетов, поэтому он в основном размещает код с открытым исходным кодом.</p>
<p>В Rust и Cargo есть функции, которые облегчают поиск и использование опубликованного пакета. Далее мы поговорим о некоторых из этих функций, а затем объясним, как опубликовать пакет.</p>
<h3 id="Создание-полезных-комментариев-к-документации"><a class="header" href="#Создание-полезных-комментариев-к-документации">Создание полезных комментариев к документации</a></h3>
<p>Правильноное документирование ваших пакетов поможет другим пользователям знать, как и когда их использовать, поэтому стоит потратить время на написание документации. В главе 3 мы обсуждали, как комментировать код Rust, используя две косые черты, <code>//</code>. В Rust также есть особый вид комментариев к документации, который обычно называется <em>комментарием к документации</em>, который генерирует документацию HTML. HTML-код отображает содержимое комментариев к документации для публичных элементов API, предназначенных для программистов, увлеченных в знании того, как <em>использовать</em> вашу библиотеку, в отличие от того, как она <em>реализована</em>.</p>
<p>Комментарии к документации используют три слеша, <code>///</code> вместо двух и поддерживают нотацию Markdown для форматирования текста. Размещайте комментарии к документации непосредственно перед элементом, который они документируют. В приложении 14-1 показаны комментарии к документации для функции <code>add_one</code> в библиотеке с именем <code>my_crate</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-01/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 14-1: Комментарий к документации для функции</span></p>
<p>Здесь мы даём описание того, что делает функция <code>add_one</code>, начинаем раздел с заголовка <code>Examples</code>, а затем предоставляем код, который отображает, как использовать функцию <code>add_one</code>. Мы можем сгенерировать документацию HTML из этого комментария к документации, запустив <code>cargo doc</code>. Этот приказ запускает средство <code>rustdoc</code>, поставляемый с Rust, и помещает сгенерированную HTML-документацию в каталог <em>target/doc</em>.</p>
<p>Для удобства, запустив <code>cargo doc --open</code>, мы создадим HTML для документации вашей текущей библиотеки (а также документацию для всех зависимостей вашей библиотеки) и откроем результат в веб-браузере. Перейдите к функции <code>add_one</code> и вы увидите, как отображается текст в комментариях к документации, что показано на рисунке 14-1:</p>
 <img alt="HTML-документация для функции `add_one`` my_crate`" src="img/trpl14-01.png" class="center">
<p><span class="caption">Рисунок 14-1: HTML документация для функции <code>add_one</code></span></p>
<h4 id="Часто-используемые-разделы"><a class="header" href="#Часто-используемые-разделы">Часто используемые разделы</a></h4>
<p>Мы использовали Markdown заголовок <code># Examples</code> в приложении 14-1 для создания раздела в HTML с заголовком "Examples". Вот некоторые другие разделы, которые авторы библиотек обычно используют в своей документации:</p>
<ul>
<li><strong>Panics</strong>: Сценарии, в которых документированная функция может вызывать панику. Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих ситуациях.</li>
<li><strong>Ошибки</strong>: Если функция возвращает <code>Result</code>, описание видов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных видов ошибок разными способами.</li>
<li><strong>Безопасность</strong>: Если функция является <code>unsafe</code> для вызова (мы обсуждаем безопасность в главе 19), должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты, которые функция ожидает от вызывающих сторон.</li>
</ul>
<p>В подавляющем большинстве случаев комментарии к документации не нуждаются во всех этих разделах, но это хорошая подсказка, напоминающая вам о тех особенностях вашего кода, о которых пользователям будет важно узнать.</p>
<h4 id="Комментарии-к-документации-как-тесты"><a class="header" href="#Комментарии-к-документации-как-тесты">Комментарии к документации как тесты</a></h4>
<p>Добавление примеров кода в комментарии к документации может помочь отобразить, как использовать вашу библиотеку, и это даёт дополнительный бонус: запуск <code>cargo test</code> запустит примеры кода в вашей документации как тесты! Нет ничего лучше, чем документация с примерами. Но нет ничего хуже, чем примеры, которые не работают, потому что код изменился с момента написания документации. Если мы запустим <code>cargo test</code> с документацией для функции <code>add_one</code> из приложения 14-1, мы увидим раздел результатов теста, подобный этому:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Теперь, если мы изменим либо функцию, либо пример, так что <code>assert_eq!</code> в примере паникует, и снова запустим <code>cargo test</code>, мы увидим, что тесты документации обнаруживают, что пример и код не синхронизированы друг с другом!</p>
<h4 id="Комментирование-содержащихся-элементов"><a class="header" href="#Комментирование-содержащихся-элементов">Комментирование содержащихся элементов</a></h4>
<p>Стиль комментариев к документам <code>//!</code> добавляет документацию к элементу, содержащему комментарии, а не к элементам, следующим за комментариями. Обычно мы используем эти комментарии внутри корневого файла крейта (по соглашению <em>src/lib.rs</em> ) или внутри модуля для документирования крейта или модуля в целом.</p>
<p>Например, чтобы добавить документацию, описывающую назначение <code>my_crate</code> , содержащего функцию <code>add_one</code> , мы добавляем комментарии к документации, начинающиеся с <code>//!</code> в начало файла <em>src/lib.rs</em> , как показано в приложении 14-2:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-02/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 14-2: Документация для крейта <code>my_crate</code> в целом</span></p>
<p>Обратите внимание, что после последней строки, начинающейся с <code>//!</code>, нет никакого кода. Поскольку мы начали комментарии с <code>//!</code> вместо <code>///</code>, мы документируем элемент, который содержит этот комментарий, а не элемент, который следует за этим комментарием. В данном случае таким элементом является файл <em>src/lib.rs</em>, который является корнем crate. Эти комментарии описывают весь крейт.</p>
<p>Когда мы запускаем <code>cargo doc --open</code>, эти комментарии будут отображаться на первой странице документации для <code>my_crate</code> над списком публичных элементов в библиотеке, как показано на рисунке 14-2:</p>
 <img alt="Документация для библиотеки `art`, в которой перечислены модули `types` и `utils`" src="img/trpl14-02.png" class="center">
<p><span class="caption">Рисунок 14-2: Предоставленная документация для <code>my_crate</code>, включая комментарий, описывающие крейт в целом</span></p>
<p>Комментарии к документации внутри элементов полезны для описания крейтов и модулей особенно. Используйте их, чтобы объяснить общую цель дополнения, чтобы помочь вашим пользователям понять организацию крейта.</p>
<h3 id="Экспорт-удобного-общедоступного-api-с-pub-use"><a class="header" href="#Экспорт-удобного-общедоступного-api-с-pub-use">Экспорт удобного общедоступного API с <code>pub use</code><a id="exporting-a-convenient-public-api-with-pub-use"></a></a></h3>
<p>Структура вашего публичного API является основным фактором при публикации крейта. Люди, которые используют вашу библиотеку, менее знакомы со структурой, чем вы и могут столкнуться с трудностями при поиске частей, которые они хотят использовать, если ваша библиотека имеет большую упорядочевание модулей.</p>
<p>В главе 7 мы рассмотрели, как сделать элементы общедоступными с помощью ключевого слова <code>pub</code> и ввести элементы в область видимости с помощью ключевого слова <code>use</code>. Однако структура, которая имеет смысл для вас при разработке крейта, может быть не очень удобной для пользователей. Вы можете организовать структуру в виде упорядочевания с несколькими уровнями, но тогда люди, желающие использовать вид, который вы определили в глубине упорядочевания, могут столкнуться с проблемой его поиска. Их также может раздражать необходимость вводить <code>use</code> <code>my_crate::some_module::another_module::UsefulType;</code> вместо <code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>Хорошей новостью является то, что если структура <em>не</em> удобна для использования другими из другой библиотеки, вам не нужно перестраивать внутреннюю организацию: вместо этого вы можете реэкспортировать элементы, чтобы сделать публичную структуру, отличную от вашей внутренней структуры, используя <code>pub use</code>. Реэкспорт берет открытый элемент в одном месте и делает его публичным в другом месте, как если бы он был определён в другом месте.</p>
<p>Например, скажем, мы создали библиотеку с именем <code>art</code> для моделирования художественных концепций. Внутри этой библиотеки есть два модуля: модуль <code>kinds</code> содержащий два перечисления с именами <code>PrimaryColor</code> и <code>SecondaryColor</code> и модуль <code>utils</code>, содержащий функцию с именем <code>mix</code>, как показано в приложении 14-3:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-03/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 14-3: Библиотека <code>art</code> с элементами, организованными в модули <code>kinds</code> и <code>utils</code></span></p>
<p>На рисунке 14-3 показано, как будет выглядеть титульная страница документации для этого крейта, сгенерированный <code>cargo doc</code>:</p>
 <img alt="Предоставлена Документация для библиотеки `art` с реэкспортом на первой странице" src="img/trpl14-03.png" class="center">
<p><span class="caption">Рисунок 14-3: Первая страница документации для <code>art</code>, в которой перечислены модули <code>kinds</code> и <code>utils</code></span></p>
<p>Обратите внимание, что виды <code>PrimaryColor</code> и <code>SecondaryColor</code> не указаны на главной странице, равно как и функция <code>mix</code>. Мы должны нажать <code>kinds</code> и <code>utils</code>, чтобы увидеть их.</p>
<p>В другой библиотеке, которая зависит от этой библиотеки, потребуются операторы <code>use</code>, которые подключают элементы из <code>art</code> в область видимости, определяя структуру модуля, которая определена в данный момент. В приложении 14-4 показан пример крейта, в котором используются элементы <code>PrimaryColor</code> и <code>mix</code> из крейта <code>art</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-04/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 14-4: Крейт использующий элементы из крейта <code>art</code> с экспортированной внутренней структурой</span></p>
<p>Автору кода в приложении 14-4, который использует крейт <code>art</code>, пришлось выяснить, что <code>PrimaryColor</code> находится в модуле <code>kinds</code>, а <code>mix</code> - в модуле <code>utils</code>. Структура модуля <code>art</code> крейта больше подходит для разработчиков, работающих над <code>art</code> крейтом, чем для тех, кто его использует. Внутренняя структура не содержит никакой полезной сведений для того, кто пытается понять, как использовать крейт <code>art</code>, а скорее вызывает путаницу, поскольку разработчики, использующие его, должны понять, где искать, и должны указывать имена модулей в выражениях <code>use</code>.</p>
<p>Чтобы удалить внутреннюю организацию из общедоступного API, мы можем изменить код крейта <code>art</code> в приложении 14-3, чтобы добавить операторы <code>pub use</code> для повторного реэкспорта элементов на верхнем уровне, как показано в приложении 14-5:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-05/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 14-5: Добавление операторов <code>pub use</code> для реэкспорта элементов</span></p>
<p>Документация API, которую <code>cargo doc</code> генерирует для этой библиотеки, теперь будет перечислять и связывать реэкспорты на главной странице, как показано на рисунке 14-4, упрощая поиск видов <code>PrimaryColor</code>, <code>SecondaryColor</code> и функции <code>mix</code>.</p>
 <img alt="HTML-документация с комментарием для библиотеки в целом" src="img/trpl14-04.png" class="center">
<p><span class="caption">Рисунок 14-4: Первая страница документации для <code>art</code>,  которая перечисляет реэкспорт</span></p>
<p>Пользователи крейта <code>art</code> могут по-прежнему видеть и использовать внутреннюю структуру из приложения 14-3, как показано в приложении 14-4, или они могут использовать более удобную структуру в приложении 14-5, как показано в приложении 14-6:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-06/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 14-6: Программа, использующая реэкспортированные элементы из крейта <code>art</code></span></p>
<p>В случаях, когда имеется много вложенных модулей, реэкспорт видов на верхнем уровне с помощью <code>pub use</code> может существенно повысить удобство работы для людей, использующих крейт. Ещё одно распространённое использование <code>pub use</code> - это реэкспорт определений зависимого модуля в текущем крейте, чтобы сделать определения этого крейта частью публичного API вашего крейта.</p>
<p>Создание полезной публичной структуры API - это больше искусство чем наука, и вы можете повторять, чтобы найти API, который лучше всего подойдёт вашим пользователям. Использование <code>pub use</code> даёт вам гибкость в том, как вы структурируете свою библиотеку внутри и отделяете эту внутреннюю структуру от того, что вы предоставляете пользователям. Посмотрите на код некоторых установленных крейтов, чтобы увидеть отличается ли их внутренняя структура от их публичного API.</p>
<h3 id="Настройка-учётной-записи-cratesio"><a class="header" href="#Настройка-учётной-записи-cratesio">Настройка учётной записи Crates.io</a></h3>
<p>Прежде чем вы сможете опубликовать любые библиотеки, вам необходимо создать учётную запись на <a href="https://crates.io/">crates.io</a><!--  --> и получить API токен. Для этого зайдите на домашнюю страницу <a href="https://crates.io/">crates.io</a><!--  --> и войдите в систему через учётную запись GitHub. (В настоящее время требуется наличие учётной записи GitHub, но сайт может поддерживать другие способы создания учётной записи в будущем.) Сразу после входа в систему перейдите в настройки своей учётной записи по адресу <a href="https://crates.io/me/">https://crates.io/me/</a><!--  --> и получите свой ключ API. Затем выполните приказ <code>cargo login</code> с вашим ключом API, например:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Этот приказ сообщит Cargo о вашем API token и сохранит его местно в <em>~/.cargo/credentials</em>. Обратите внимание, что этот токен является <em>секретным</em>: не делитесь им ни с кем другим. Если вы по какой-либо причине поделитесь им с кем-либо, вы должны отозвать его и сгенерировать новый токен на <a href="https://crates.io/">crates.io</a>.</p>
<h3 id="Добавление-метаданных-в-новую-библиотеку"><a class="header" href="#Добавление-метаданных-в-новую-библиотеку">Добавление метаданных в новую библиотеку</a></h3>
<p>Допустим, у вас есть крейт, который вы хотите опубликовать. Перед публикацией вам нужно добавить некоторые метаданные в раздел <code>[package]</code> файла <em>Cargo.toml</em> крейта.</p>
<p>Вашему крейту понадобится уникальное имя. Пока вы работаете над крейтом местно, вы можете назвать его как угодно. Однако названия крейтов на <a href="https://crates.io/">crates.io</a><!-- ignore --> фиксируются в момент первой публикации. Как только крейту присвоено название, никто другой не сможет опубликовать крейт с таким же именем. Перед тем как опубликовать крейт, поищите название, которое вы хотите использовать. Если такое имя уже используется, вам придётся подобрать другое и отредактировать поле <code>name</code> в файле <em>Cargo.toml</em> в разделе <code>[package]</code>, чтобы использовать новое имя в качестве публикуемого, например, так:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Даже если вы выбрали уникальное имя, когда вы запустите <code>cargo publish</code> чтобы опубликовать крейт, вы получите предупреждение, а затем ошибку:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Это ошибка, потому что вам не хватает важной сведений: необходимы описание и лицензия, чтобы люди знали, что делает ваш крейт и на каких условиях они могут его использовать. В поле <em>Cargo.toml</em> добавьте описание, состоящее из одного-двух предложений, поскольку оно будет появляться вместе с вашим крейтом в результатах поиска. Для поля <code>license</code> нужно указать значение <em>определителя лицензии</em>. В <a href="http://spdx.org/licenses/">Linux Foundation's Software Package Data Exchange (SPDX)</a> перечислены определители, которые можно использовать для этого значения. Например, чтобы указать, что вы лицензировали свой crate, используя лицензию MIT, добавьте определитель <code>MIT</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>Если вы хотите использовать лицензию, которая отсутствует в SPDX, вам нужно поместить текст этой лицензии в файл, включите файл в свой проект, а затем используйте <code>license-file</code>, чтобы указать имя этого файла вместо использования ключа <code>license</code>.</p>
<p>Руководство по выбору лицензии для вашего проекта выходит за рамки этой книги. Многие люди в сообществе Rust лицензируют свои проекты так же, как и Rust, используя двойную лицензию <code>MIT OR Apache 2.0</code>. Эта практика отображает, что вы также можете указать несколько определителей лицензий, разделённых <code>OR</code>, чтобы иметь несколько лицензий для вашего проекта.</p>
<p>С добавлением уникального имени, исполнения, вашего описания и лицензии, файл <em>Cargo.toml</em> для проекта, который готов к публикации может выглядеть следующим образом:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Документация Cargo</a> описывает другие метаданные, которые вы можете указать, чтобы другие могли легче находить и использовать ваш крейт.</p>
<h3 id="Публикация-на-cratesio"><a class="header" href="#Публикация-на-cratesio">Публикация на Crates.io</a></h3>
<p>Теперь, когда вы создали учётную запись, сохранили свой токен API, выбрали имя для своего крейта и указали необходимые метаданные, вы готовы к публикации! Публикация библиотеки загружает определённую исполнение в <a href="https://crates.io/">crates.io</a><!--  --> для использования другими.</p>
<p>Будьте осторожны, потому что публикация является <em>перманентной</em> операцией. Исполнение никогда не сможет быть перезаписана, а код не подлежит удалению. Одна из основных целей <a href="https://crates.io/">crates.io</a><!-- ignore --> - служить постоянным архивом кода, чтобы сборки всех проектов, зависящих от crates из <a href="https://crates.io/">crates.io</a><!-- ignore --> продолжали работать. Предоставление возможности удаления исполнений сделало бы выполнение этой цели невозможным. При этом количество исполнений крейтов, которые вы можете опубликовать, не ограничено.</p>
<p>Запустите приказ <code>cargo publish</code> ещё раз. Сейчас эта приказ должна выполниться успешно:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Поздравляем! Теперь вы поделились своим кодом с сообществом Rust и любой может легко добавить вашу библиотеку в качестве зависимости их проекта.</p>
<h3 id="Публикация-новой-исполнения-существующей-библиотеки"><a class="header" href="#Публикация-новой-исполнения-существующей-библиотеки">Публикация новой исполнения существующей библиотеки</a></h3>
<p>Когда вы внесли изменения в свой крейт и готовы выпустить новую исполнение, измените значение <code>version</code>, указанное в вашем файле <em>Cargo.toml</em> и повторите публикацию. Воспользуйтесь <a href="http://semver.org/">Semantic Versioning rules</a>, чтобы решить, какой номер следующей исполнения подходит для ваших изменений. Затем запустите <code>cargo publish</code>, чтобы загрузить новую исполнение.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="Устранение-устаревших-исполнений-с-cratesio-с-помощью-cargo-yank"><a class="header" href="#Устранение-устаревших-исполнений-с-cratesio-с-помощью-cargo-yank">Устранение устаревших исполнений с Crates.io с помощью <code>cargo yank</code></a></h3>
<p>Хотя вы не можете удалить предыдущие исполнения крейта, вы можете помешать любым будущим проектам добавлять его в качестве новой зависимости. Это полезно, когда исполнение крейта сломана по той или иной причине. В таких ситуациях Cargo поддерживает <em>выламывание</em> (yanking) исполнения крейта.</p>
<p>Вычёркивание исполнения не позволяет новым проектам зависеть от этой исполнения, но при этом позволяет всем существующим проектам, зависящим от неё, продолжать работу. По сути, исключение означает, что все проекты с <em>Cargo.lock</em> не сломаются, а любые файлы <em>Cargo.lock</em>, которые будут генерироваться в будущем, не смогут использовать исключённую исполнение.</p>
<p>Чтобы вычеркнуть исполнение крейта, в папки крейта, который вы опубликовали ранее, выполните приказ <code>cargo yank</code> и укажите, какую исполнение вы хотите вычеркнуть. Например, если мы опубликовали крейт под названием <code>guessing_game</code> исполнения 1.0.1 и хотим вычеркнуть её, в каталоге проекта для <code>guessing_game</code> мы выполним:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Добавив в приказ <code>--undo</code>, вы также можете отменить выламывание и разрешить проектам начать зависеть от исполнения снова:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Вычёркивание <em>не удаляет</em> код. Оно не может, например, удалить случайно загруженные пароли. Если это произойдёт, вы должны немедленно сбросить эти пароли.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Рабочие-пространства-cargo"><a class="header" href="#Рабочие-пространства-cargo">Рабочие пространства Cargo</a></h2>
<p>В главе 12 мы создали пакет, который включал в себя двоичный и библиотечный крейты. По мере развития вашего проекта может возникнуть ситуация, когда библиотечный крейт будет становиться все больше, и вы захотите разделить ваш пакет на несколько библиотечных крейтов. Cargo предоставляет функциональность под названием <em>workspaces</em>, которая помогает управлять несколькими взаимосвязанными пакетами, которые разрабатываются в тандеме.</p>
<h3 id="Создание-рабочего-пространства"><a class="header" href="#Создание-рабочего-пространства">Создание рабочего пространства</a></h3>
<p><em>Workspace</em> - это набор пакетов, которые используют один и тот же <em>Cargo.lock</em> и папку для хранения результатов сборки. Давайте создадим проект с использованием <em>workspace</em> - мы будем использовать тривиальный код, чтобы сосредоточиться на структуре рабочего пространства. Существует несколько способов структурировать рабочую область, но мы покажем только один из них. У нас будет рабочая область, содержащая двоичный файл и две библиотеки. Двоичный файл, который обеспечивает основную функциональность, будет зависеть от двух библиотек. Одна библиотека предоставит функцию <code>add_one</code>, а вторая - <code>add_two</code>. Эти три крейта будут частью одного <em>workspace</em>. Начнём с создания каталога для рабочего окружения:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Далее в каталоге <em>add</em> мы создадим файл <em>Cargo.toml</em>, который будет определять настройку всего рабочего окружения. В этом файле не будет секции <code>[package]</code>. Вместо этого он будет начинаться с секции <code>[workspace]</code>, которая позволит нам добавить модули в рабочее пространство, указав путь к пакету с нашим двоичным крейтом; в данном случае этот путь - <em>adder</em>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch14-more-about-cargo/no-listing-01-workspace-with-adder-crate/add/Cargo.toml}}
</code></pre>
<p>Затем мы создадим исполняемый крейт <code>adder</code>, запустив приказ <code>cargo new</code> в каталоге <em>add</em>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>На этом этапе мы можем создать рабочее пространство, запустив  приказ <code>cargo build</code>. Файлы в каталоге <em>add</em> должны выглядеть следующим образом:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Рабочая область содержит на верхнем уровне один каталог <em>target</em>, в который будут помещены собранные артефакты; пакет <code>adder</code> не имеет собственного каталога <em>target</em>. Даже если мы запустим <code>cargo build</code> из каталога <em>adder</em>, собранные артефакты все равно окажутся в <em>add/target</em>, а не в <em>add/adder/target</em>. Cargo так определил папку <em>target</em> в рабочем пространстве, потому что крейты в рабочем пространстве должны зависеть друг от друга. Если бы каждый крейт имел свой собственный каталог <em>target</em>, каждому крейту пришлось бы пересобирать каждый из других крейтов в рабочем пространстве, чтобы поместить артефакты в свой собственный каталог <em>target</em>. Благодаря совместному использованию единого каталога <em>target</em> крейты могут избежать ненужной пересборки.</p>
<h3 id="Добавление-второго-крейта-в-рабочее-пространство"><a class="header" href="#Добавление-второго-крейта-в-рабочее-пространство">Добавление второго крейта в рабочее пространство</a></h3>
<p>Далее давайте создадим ещё одного участника пакета в рабочей области и назовём его <code>add_one</code>. Внесите изменения в <em>Cargo.toml</em> верхнего уровня так, чтобы указать путь <em>add_one</em> в списке <code>members</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch14-more-about-cargo/no-listing-02-workspace-with-two-crates/add/Cargo.toml}}
</code></pre>
<p>Затем сгенерируйте новый крейт библиотеки с именем <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Ваш каталог <em>add</em> должен теперь иметь следующие каталоги и файлы:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>В файле <em>add_one/src/lib.rs</em> добавим функцию <code>add_one</code>:</p>
<p><span class="filename">Файл: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch14-more-about-cargo/no-listing-02-workspace-with-two-crates/add/add_one/src/lib.rs}}</code></pre>
<p>Теперь мы можем сделать так, чтобы пакет <code>adder</code> с нашим исполняемым файлом зависел от пакета <code>add_one</code>, содержащего нашу библиотеку. Сначала нам нужно добавить зависимость пути от <code>add_one</code> в <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Файл: adder/Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch14-more-about-cargo/no-listing-02-workspace-with-two-crates/add/adder/Cargo.toml:6:7}}
</code></pre>
<p>Cargo не исходит из того, что крейты в рабочем пространстве могут зависеть друг от друга, поэтому нам необходимо явно указать отношения зависимости.</p>
<p>Далее, давайте используем функцию <code>add_one</code> (из крейта <code>add_one</code>) в крейте <code>adder</code>. Откройте файл <em>adder/src/main.rs</em> и добавьте строку <code>use</code> в верхней части, чтобы ввести в область видимости новый библиотечный крейт <code>add_one</code>. Затем измените функцию <code>main</code> для вызова функции <code>add_one</code>, как показано в приложении 14-7.</p>
<p><span class="filename">Файл: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-07/add/adder/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 14-7: Использование функционала библиотечного крейта <code>add-one</code> в крейте <code>adder</code></span></p>
<p>Давайте соберём  рабочее пространство, запустив приказ <code>cargo build</code> в каталоге верхнего уровня <em>add</em>!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Чтобы запустить двоичный крейт из каталога <em>add</em>, нам нужно указать какой пакет из рабочей области мы хотим использовать с помощью переменной <code>-p</code> и названия пакета в приказу <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Запуск кода из <em>adder/src/main.rs</em>, который зависит от <code>add_one</code>.</p>
<h4 id="Зависимость-от-внешних-крейтов-в-рабочем-пространстве"><a class="header" href="#Зависимость-от-внешних-крейтов-в-рабочем-пространстве">Зависимость от внешних крейтов в рабочем пространстве</a></h4>
<p>Обратите внимание, что рабочая область имеет один единственный файл <em>Cargo.lock</em> на верхнем уровне, а не содержит <em>Cargo.lock</em> в каталоге каждого крейта. Это заверяет, что все крейты используют одну и ту же исполнение всех зависимостей. Если мы добавим пакет <code>rand</code> в файлы <em>adder/Cargo.toml</em> и <em>add_one/Cargo.toml</em>, Cargo сведёт их оба к одной исполнения <code>rand</code> и запишет её в один <em>Cargo.lock</em>. Если заставить все крейты в рабочей области использовать одни и те же зависимости, то это будет означать, что крейты всегда будут совместимы друг с другом. Давайте добавим крейт <code>rand</code> в раздел <code>[dependencies]</code> в файле <em>add_one/Cargo.toml</em>, чтобы мы могли использовать крейт <code>rand</code> в крейте <code>add_one</code>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Файл: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add/add_one/Cargo.toml:6:7}}
</code></pre>
<p>Теперь мы можем добавить <code>use rand;</code> в файл  <em>add_one/src/lib.rs</em> и сделать сборку рабочего пространства, запустив <code>cargo build</code> в каталоге <em>add</em>, что загрузит и ссобирает <code>rand</code> крейт:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>Файл <em>Cargo.lock</em> верхнего уровня теперь содержит сведения о зависимости <code>add_one</code> к крейту <code>rand</code>. Тем не менее, не смотря на то что <code>rand</code> использован где-то в рабочем пространстве, мы не можем использовать его в других крейтах рабочего пространства, пока не добавим крейт <code>rand</code> в отдельные <em>Cargo.toml</em> файлы. Например, если мы добавим <code>use rand;</code> в файл <em>adder/src/main.rs</em> крейта  <code>adder</code>, то получим ошибку:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Чтобы исправить это, изменените файл <em>Cargo.toml</em> для пакета <code>adder</code> и укажите, что <code>rand</code> также является его зависимостью. При сборке пакета <code>adder</code> <code>rand</code> будет добавлен в список зависимостей для <code>adder</code> в <em>Cargo.lock</em>, но никаких дополнительных копий <code>rand</code> загружено не будет. Cargo позаботился о том, чтобы все крейты во всех пакетах рабочей области, использующих пакет <code>rand</code>, использовали одну и ту же исполнение, экономя нам место и обеспечивая, что все крейты в рабочей области будут совместимы друг с другом.</p>
<h4 id="Добавление-теста-в-рабочее-пространство"><a class="header" href="#Добавление-теста-в-рабочее-пространство">Добавление теста в рабочее пространство</a></h4>
<p>В качестве ещё одного улучшения давайте добавим тест функции <code>add_one::add_one</code> в <code>add_one</code>:</p>
<p><span class="filename">Файл: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add/add_one/src/lib.rs}}</code></pre>
<p>Теперь запустите <code>cargo test</code> в каталоге верхнего уровня <em>add</em>. Запуск <code>cargo test</code> в рабочем пространстве, структурированном подобно этому, запустит тесты для всех крейтов в рабочем пространстве:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Первая секция вывода показывает, что тест <code>it_works</code> в крейте <code>add_one</code> прошёл. Следующая секция показывает, что в крейте <code>adder</code> не было обнаружено ни одного теста, а последняя секция показывает, что в крейте <code>add_one</code> не было найдено ни одного теста документации.</p>
<p>Мы также можем запустить тесты для одного определенного крейта в рабочем пространстве из каталог верхнего уровня с помощью флага <code>-p</code> и указанием имени крейта для которого мы хотим запустить тесты:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Эти выходные данные показывают, что выполнение <code>cargo test</code> запускает только тесты для крейта <code>add-one</code> и не запускает тесты крейта <code>adder</code>.</p>
<p>Если вы соберётесь опубликовать крейты из рабочего пространства на <a href="https://crates.io/">crates.io</a>, каждый крейт будет необходимо будет опубликовать отдельно. Подобно <code>cargo test</code>, мы можем опубликовать определенный крейт из нашей рабочей области, используя флаг <code>-p</code> и указав имя крейта, который мы хотим опубликовать.</p>
<p>Для дополнительной практики добавьте крейт <code>add_two</code> в данное рабочее пространство подобным способом, как делали с крейт <code>add_one</code> !</p>
<p>По мере роста проекта рассмотрите возможность использования рабочих областей: легче понять небольшие, отдельные компоненты, чем один большой кусок кода. Кроме того, хранение крейтов в рабочем пространстве может облегчить координацию между крейтами, если они часто изменяются параллельно.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="Установка-двоичных-файлов-с-помощью-cargo-install"><a class="header" href="#Установка-двоичных-файлов-с-помощью-cargo-install">Установка двоичных файлов с помощью <code>cargo install</code></a></h2>
<p>Приказ <code>cargo install</code> позволяет местно устанавливать и использовать исполняемые крейты. Она не предназначена для замены системных пакетов; она используется как удобный способ Rust разработчикам устанавливать средства, которыми другие разработчики поделились на сайте <a href="https://crates.io/">crates.io</a>. Заметьте, можно устанавливать только пакеты, имеющие исполняемые целевые крейты. <em>Исполняемой целью</em> (binary target) является запускаемая программа, созданная и имеющая в составе крейта файл <em>src/main.rs</em> или другой файл, указанный как исполняемый, в отличии от библиотечных крейтов, которые не могут запускаться сами по себе, но подходят для включения в другие программы. Обычно крейт содержит сведения в файле <em>README</em>, является ли он библиотекой, исполняемым файлом или обоими вместе.</p>
<p>Все исполняемые файлы установленные приказом <code>cargo install</code> сохранены в корневой установочной папке <em>bin</em>. Если вы установили Rust с помощью <em>rustup.rs</em> и у вас его нет в пользовательских настройках, то этим каталогом будет <em>$HOME/.cargo/bin</em>. Он заверяет, что каталог находится в вашем окружении <code>$PATH</code>, чтобы вы имели возможность запускать программы, которые вы установили приказом <code>cargo install</code>.</p>
<p>Так, например, в главе 12 мы упоминали, что для поиска файлов существует реализация утилиты <code>grep</code> на Rust под названием <code>ripgrep</code>. Чтобы установить <code>ripgrep</code>, мы можем выполнить следующее:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>Последняя строка вывода показывает местоположение и название установленного исполняемого файла, который в случае <code>ripgrep</code> называется <code>rg</code>. Если вашей установочной папкой является <code>$PATH</code>, как уже упоминалось ранее, вы можете запустить <code>rg --help</code> и начать использовать более быстрый и грубый средство для поиска файлов!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Расширение-cargo-пользовательскими-приказми"><a class="header" href="#Расширение-cargo-пользовательскими-приказми">Расширение Cargo пользовательскими приказми</a></h2>
<p>Cargo спроектирован так, что вы можете расширять его новыми субприказми без необходимости изменения самого Cargo. Если исполняемый файл доступен через переменную окружения <code>$PATH</code> и назван по шаблону <code>cargo-something</code>, то его можно запускать как субприказ Cargo <code>cargo something</code>. Пользовательские приказы подобные этой также перечисляются в списке доступных через <code>cargo --list</code>. Возможность использовать <code>cargo install</code> для установки расширений и затем запускать их так же, как встроенные в Cargo средства, это очень удобное следствие продуманного дизайна Cargo!</p>
<h2 id="Итоги-11"><a class="header" href="#Итоги-11">Итоги</a></h2>
<p>Совместное использование кода с Cargo и <a href="https://crates.io/">crates.io</a><!-- --> является частью того, что делает экосистему Rust полезной для множества различных задач. Стандартная библиотека Rust небольшая и безотказная, но крейты легко распространять, использовать и улучшать независимо от самого языка. Не стесняйтесь делиться кодом, который был вам полезен, через <a href="https://crates.io/">crates.io</a><!-- -->; скорее всего, он будет полезен и кому-то ещё!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Умные-указатели"><a class="header" href="#Умные-указатели">Умные указатели</a></h1>
<p><em>Указатель</em> — это общая концепция для переменной, которая содержит адрес участка памяти. Этот адрес «относится к», или «указывает на» некоторые другие данные. Наиболее общая разновидность указателя в Rust — это ссылка, о которой вы узнали из главы 4. Ссылки обозначаются символом <code>&amp;</code> и заимствуют значение, на которое указывают. Они не имеют каких-либо особых возможностей, кроме как ссылаться на данные, и не имеют никаких накладных расходов.</p>
<p><em>Умные указатели</em>, с другой стороны, являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности. Концепция умных указателей не уникальна для Rust: умные указатели возникли в C++ и существуют в других языках. В Rust есть разные умные указатели, определённые в встроенной библиотеке, которые обеспечивают функциональность, выходящую за рамки ссылок. Одним из примеров, который мы рассмотрим в этой главе, является вид умного указателя <em>reference counting</em> (подсчёт ссылок). Этот указатель позволяет иметь несколько владельцев с помощью отслеживания количества владельцев и, когда владельцев не остаётся, очищает данные.</p>
<p>Rust с его концепцией владения и заимствования имеет дополнительное различие между ссылками и умными указателями: в то время, как ссылки только заимствуют данные, умные указатели часто <em>владеют</em> данными, на которые указывают.</p>
<p>Ранее мы уже сталкивались с умными указателями в этой книге, хотя и не называли их так, например <code>String</code> и <code>Vec&lt;T&gt;</code> в главе 8. Оба этих вида считаются умными указателями, потому что они владеют некоторой областью памяти и позволяют ею манипулировать. У них также есть метаданные и дополнительные возможности или заверения. <code>String</code>, например, хранит свой размер в виде метаданных и заверяет, что содержимое строки всегда будет в кодировке UTF-8.</p>
<p>Умные указатели обычно реализуются с помощью структур. Характерной чертой, которая отличает умный указатель от обычной структуры, является то, что для умных указателей реализованы типажи <code>Deref</code> и <code>Drop</code>. Типаж <code>Deref</code> позволяет экземпляру умного указателя вести себя как ссылка, так что вы можете написать код, работающий с ним как со ссылкой, так и как с умным указателем. Типаж <code>Drop</code> позволяет написать код, который будет запускаться когда экземпляр умного указателя выйдет из области видимости. В этой главе мы обсудим оба типажа и выясним, почему они важны для умных указателей.</p>
<p>Учитывая, что паттерн умного указателя является общим паттерном проектирования, часто используемым в Rust, эта глава не описывает все существующие умные указатели. Множество библиотек имеют свои умные указатели, и вы также можете написать свои. Мы охватим наиболее распространённые умные указатели из встроенной библиотеки:</p>
<ul>
<li><code>Box&lt;T&gt;</code> для распределения значений в куче (памяти)</li>
<li><code>Rc&lt;T&gt;</code> вид счётчика ссылок, который допускает множественное владение</li>
<li>Виды <code>Ref&lt;T&gt;</code> и <code>RefMut&lt;T&gt;</code>, доступ к которым осуществляется через вид <code>RefCell&lt;T&gt;</code>, который обеспечивает правила заимствования во время выполнения вместо времени сборки</li>
</ul>
<p>Дополнительно мы рассмотрим паттерн <em>внутренней изменчивости (interior mutability)</em>, где неизменяемый вид предоставляет API для изменения своего внутреннего значения. Мы также обсудим <em>ссылочные зацикленности (reference cycles)</em>: как они могут приводить к утечке памяти и как это предотвратить.</p>
<p>Приступим!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-boxt-для-ссылки-на-данные-в-куче"><a class="header" href="#Использование-boxt-для-ссылки-на-данные-в-куче">Использование <code>Box&lt;T&gt;</code> для ссылки на данные в куче</a></h2>
<p>Наиболее простой умный указатель - это <em>box</em>, чей вид записывается как <code>Box&lt;T&gt;</code>. Такие переменные позволяют хранить данные в куче, а не в стеке. То, что остаётся в стеке, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между стеком и кучей.</p>
<p>У Box нет проблем с производительностью, кроме хранения данных в куче вместо стека. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих ситуациях:</p>
<ul>
<li>Когда у вас есть вид, размер которого невозможно определить во время сборки, а вы хотите использовать значение этого вида в среде, требующем точного размера.</li>
<li>Когда у вас есть большой объем данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут скопированы</li>
<li>Когда вы хотите получить значение во владение и вас важно только то, что оно относится к виду, реализующему определённый трейт, а не то, является ли оно значением какого-то определенного вида</li>
</ul>
<p>Мы выясним первую ситуацию в разделе <a href="ch15-01-box.html#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-Boxes">"Реализация рекурсивных видов с помощью Box"</a><!-- ignore -->. Во втором случае, передача владения на большой объем данных может занять много времени, потому что данные копируются через стек. Для повышения производительности в этой ситуации, мы можем хранить большое количество данных в куче с помощью Box. Затем только небольшое количество данных указателя копируется в стеке, в то время как данные, на которые он ссылается, остаются в одном месте кучи. Третий случай известен как <em>типаж объект</em> (trait object) и глава 17 посвящает целый раздел <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование типаж объектов, которые допускают значения разных видов"</a><!-- ignore --> только этой теме. Итак, то, что вы узнаете здесь, вы примените снова в Главе 17!</p>
<h3 id="Использование-boxt-для-хранения-данных-в-куче"><a class="header" href="#Использование-boxt-для-хранения-данных-в-куче">Использование <code>Box&lt;T&gt;</code> для хранения данных в куче</a></h3>
<p>Прежде чем мы обсудим этот вариант использования <code>Box&lt;T&gt;</code>, мы рассмотрим синтаксис и то, как взаимодействовать со значениями, хранящимися в <code>Box&lt;T&gt;</code>.</p>
<p>В приложении 15-1 показано, как использовать поле для хранения значения <code>i32</code> в куче:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-1: Сохранение значения <code>i32</code> в куче с использованием box</span></p>
<p>Мы объявляем переменную <code>b</code> со значением <code>Box</code>, указывающим на число <code>5</code>, размещённое в куче. Эта программа выведет <code>b = 5</code>; в этом случае мы получаем доступ к данным в box так же, как если бы эти данные находились в стеке. Как и любое другое значение, когда box выйдет из области видимости, как <code>b</code> в конце <code>main</code>, он будет удалён. Деаллокация происходит как для box ( хранящегося в стеке), так и для данных, на которые он указывает (хранящихся в куче).</p>
<p>Размещать одиночные значения в куче не слишком целесообразно, поэтому вряд ли вы будете часто использовать box'ы таким образом. В большинстве ситуаций более уместно размещать такие значения, как <code>i32</code>, в стеке, где они и сохраняются по умолчанию. Давайте рассмотрим ситуацию, когда box позволяет нам определить виды, которые мы не могли бы иметь, если бы у нас не было box.</p>
<h3 id="Включение-рекурсивных-видов-с-помощью-boxes"><a class="header" href="#Включение-рекурсивных-видов-с-помощью-boxes">Включение рекурсивных видов с помощью Boxes</a></h3>
<p>Значение <em>рекурсивного вида</em> может иметь другое значение такого же вида как свой компонент. Рекурсивные виды представляют собой проблему, поскольку во время сборки Rust должен знать, сколько места занимает вид. Однако вложенность значений рекурсивных видов теоретически может продолжаться бесконечно, поэтому Rust не может определить, сколько места потребуется. Поскольку box имеет известный размер, мы можем включить рекурсивные виды, добавив box в определение рекурсивного вида.</p>
<p>В качестве примера рекурсивного вида рассмотрим <em>cons list</em>. Это вид данных, часто встречающийся в функциональных языках программирования. Вид cons list, который мы определим, достаточно прост, за исключением наличия рекурсии; поэтому концепции, заложенные в примере, с которым мы будем работать, пригодятся вам в любой более сложной ситуации, связанной с рекурсивными видами.</p>
<h4 id="Больше-сведений-о-cons-списке"><a class="header" href="#Больше-сведений-о-cons-списке">Больше сведений о cons списке</a></h4>
<p><em>cons list</em> - это структура данных из языка программирования Lisp и его диалектов, представляющая собой набор вложенных пар и являющаяся Lisp-исполнением связного списка. Его название происходит от функции <code>cons</code> (сокращение от "construct function") в Lisp, которая формирует пару из двух своих переменных. Вызывая <code>cons</code> для пары, которая состоит из некоторого значения и другой пары, мы можем конструировать списки cons, состоящие из рекурсивных пар.</p>
<p>Вот, пример cons list в виде псевдокода, содержащий список 1, 2, 3, где каждая пара заключена в круглые скобки:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Каждый элемент в cons списке содержит два элемента: значение текущего элемента и следующий элемент. Последний элемент в списке содержит только значение называемое <code>Nil</code> без следующего элемента. Cons список создаётся путём рекурсивного вызова функции <code>cons</code>. Каноничное имя для обозначения основного случая рекурсии - <code>Nil</code>. Обратите внимание, что это не то же самое, что понятие “null” или “nil” из главы 6, которая является недействительным или отсутствующим значением.</p>
<p>Cons list не является часто используемой структурой данных в Rust. В большинстве случаев, когда вам нужен список элементов при использовании Rust, лучше использовать <code>Vec&lt;T&gt;</code>. Другие, более сложные рекурсивные виды данных <em>полезны</em> в определённых ситуациях, но благодаря тому, что в этой главе мы начнём с cons list, мы сможем выяснить, как box позволяет нам определить рекурсивный вид данных без особого напряжения.</p>
<p>Приложение 15-2 содержит объявление перечисления cons списка. Обратите внимание, что этот код не будет собираться, потому что вид <code>List</code> не имеет известного размера, что мы и выясним.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-2: Первая попытка определить перечисление в качестве структуры данных cons list, состоящей из <code>i32</code> значений.</span></p>
<blockquote>
<p>Примечание: В данном примере мы реализуем cons list, который содержит только значения <code>i32</code>. Мы могли бы реализовать его с помощью generics, о которых мы говорили в главе 10, чтобы определить вид cons list, который мог бы хранить значения любого вида.</p>
</blockquote>
<p>Использование вида <code>List</code> для хранения списка <code>1, 2, 3</code> будет выглядеть как код в приложении 15-3:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-3: Использование перечисления <code>List</code> для хранения списка <code>1, 2, 3</code></span></p>
<p>Первое значение <code>Cons</code> содержит <code>1</code> и другой <code>List</code>. Это значение <code>List</code> является следующим значением <code>Cons</code>, которое содержит <code>2</code> и другой <code>List</code>. Это значение <code>List</code> является ещё один значением <code>Cons</code>, которое содержит <code>3</code> и значение <code>List</code>, которое наконец является <code>Nil</code>, не рекурсивным вариантом, сигнализирующим об окончании списка.</p>
<p>Если мы попытаемся собрать код в приложении 15-3, мы получим ошибку, показанную в приложении 15-4:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
</code></pre>
<p><span class="caption">Приложение 15-4: Ошибка, которую мы получаем при попытке определить рекурсивное перечисление</span></p>
<p>Ошибка говорит о том, что этот вид "имеет бесконечный размер". Причина в том, что мы определили <code>List</code> в форме, которая является рекурсивной: она непосредственно хранит другое значение своего собственного вида. В результате Rust не может определить, сколько места ему нужно для хранения значения <code>List</code>. Давайте разберёмся, почему мы получаем эту ошибку. Сначала мы рассмотрим, как Rust решает, сколько места ему нужно для хранения значения нерекурсивного вида.</p>
<h4 id="Вычисление-размера-нерекурсивного-вида"><a class="header" href="#Вычисление-размера-нерекурсивного-вида">Вычисление размера нерекурсивного вида</a></h4>
<p>Вспомните перечисление <code>Message</code> определённое в приложении 6-2, когда обсуждали объявление enum  в главе 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Чтобы определить, сколько памяти выделять под значение <code>Message</code>, Rust проходит каждый из вариантов, чтобы увидеть, какой вариант требует наибольшее количество памяти. Rust видит, что для <code>Message::Quit</code> не требуется места, <code>Message::Move</code> хватает места для хранения двух значений <code>i32</code> и т.д. Так как будет использоваться только один вариант, то наибольшее пространство, которое потребуется для значения <code>Message</code>, это пространство, которое потребуется для хранения самого большого из вариантов перечисления.</p>
<p>Сравните это с тем, что происходит, когда Rust пытается определить, сколько места необходимо рекурсивному виду, такому как перечисление <code>List</code> в приложении 15-2. Сборщик смотрит на вариант <code>Cons</code>, который содержит значение вида <code>i32</code> и значение вида <code>List</code>. Следовательно, <code>Cons</code> нужно пространство, равное размеру <code>i32</code> плюс размер <code>List</code>. Чтобы выяснить, сколько памяти необходимо виду <code>List</code>, сборщик смотрит на варианты, начиная с <code>Cons</code>. Вариант <code>Cons</code> содержит значение вида <code>i32</code> и значение вида <code>List</code>, и этот процесс продолжается бесконечно, как показано на рисунке 15-1.</p>
 <img alt="Бесконечный список Cons" src="img/trpl15-01.svg" class="center" style="width: 50%;">
<p><span class="caption">Рисунок 15-1: Бесконечный <code>List</code>, состоящий из нескончаемого числа вариантов <code>Cons</code></span></p>
<h4 id="Использование-boxt-для-получения-рекурсивного-вида-с-известным-размером"><a class="header" href="#Использование-boxt-для-получения-рекурсивного-вида-с-известным-размером">Использование <code>Box&lt;T&gt;</code> для получения рекурсивного вида с известным размером</a></h4>
<p>Поскольку Rust не может определить, сколько места нужно выделить для видов с рекурсивным определением, сборщик выдаёт ошибку с этим полезным предложением:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>В данном предложении "перенаправление" означает, что вместо того, чтобы непосредственно хранить само значение, мы должны изменить структуру данных, так чтобы хранить его косвенно - хранить указатель на это значение.</p>
<p>Поскольку <code>Box&lt;T&gt;</code> является указателем, Rust всегда знает, сколько места нужно <code>Box&lt;T&gt;</code>: размер указателя не меняется в зависимости от объёма данных, на которые он указывает. Это означает, что мы можем поместить <code>Box&lt;T&gt;</code> внутрь экземпляра <code>Cons</code> вместо значения <code>List</code> напрямую. <code>Box&lt;T&gt;</code> будет указывать на значение очередного <code>List</code>, который будет находиться в куче, а не внутри экземпляра <code>Cons</code>. Концептуально у нас все ещё есть список, созданный из списков, содержащих другие списки, но эта реализация теперь больше похожа на размещение элементов рядом друг с другом, а не внутри друг друга.</p>
<p>Мы можем изменить определение перечисления <code>List</code> в приложении 15-2 и использование <code>List</code> в приложении 15-3 на код из приложения 15-5, который будет собираться:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-5: Определение <code>List</code>, которое использует <code>Box&lt;T&gt;</code> для того, чтобы иметь вычисляемый размер</span></p>
<p><code>Cons</code> требуется объём <code>i32</code> плюс место для хранения данных указателя box. <code>Nil</code> не хранит никаких значений, поэтому ему нужно меньше места, чем <code>Cons</code>. Теперь мы знаем, что любое значение <code>List</code> займёт размер <code>i32</code> плюс размер данных указателя box. Используя box, мы разорвали бесконечную рекурсивную цепочку, поэтому сборщик может определить размер, необходимый для хранения значения <code>List</code>. На рисунке 15-2 показано, как теперь выглядит <code>Cons</code>.</p>
 <img alt="Бесконечный список Cons" src="img/trpl15-02.svg" class="center" style="width: 50%;">
<p><span class="caption">Рисунок 15-2: <code>List</code>, который не является бесконечно большим, потому что <code>Cons</code> хранит <code>Box</code>.</span></p>
<p>Box-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других особых возможностей, подобных тем, которые мы увидим у других видов умных указателей. У них также нет накладных расходов на производительность, которые несут эти особые возможности, поэтому они могут быть полезны в таких случаях, как cons list, где перенаправление - единственная функция, которая нам нужна. В главе 17 мы также рассмотрим другие случаи использования box.</p>
<p>Вид <code>Box&lt;T&gt;</code> является умным указателем, поскольку он реализует трейт <code>Deref</code>, который позволяет обрабатывать значения <code>Box&lt;T&gt;</code> как ссылки. Когда значение <code>Box&lt;T&gt;</code> выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря реализации типажа <code>Drop</code>. Эти два трейта будут ещё более значимыми для функциональности, предоставляемой другими видами умных указателей, которые мы обсудим в оставшейся части этой главы. Давайте рассмотрим эти два типажа более подробно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обращение-с-умными-указателями-как-с-обычными-ссылками-с-помощью-deref-типажа"><a class="header" href="#Обращение-с-умными-указателями-как-с-обычными-ссылками-с-помощью-deref-типажа">Обращение с умными указателями как с обычными ссылками с помощью <code>Deref</code> типажа</a></h2>
<p>Используя трейт <code>Deref</code>, вы можете изменить поведение <em>оператора разыменования</em> <code>*</code> (не путать с операторами умножения или вездесущего подключения). Реализовав <code>Deref</code> таким образом, что умный указатель может рассматриваться как обычная ссылка, вы можете писать код, оперирующий ссылками, а также использовать этот код с умными указателями.</p>
<p>Давайте сначала посмотрим, как работает оператор разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский вид, который ведёт себя как <code>Box&lt;T&gt;</code> и посмотрим, почему оператор разыменования не работает как ссылка для нового объявленного вида. Мы рассмотрим, как реализация типажа <code>Deref</code> делает возможным работу умных указателей подобно ссылкам. Затем посмотрим на <em>разыменованное приведение</em> (deref coercion) в Rust и как оно позволяет работать с любыми ссылками или умными указателями.</p>
<blockquote>
<p>Примечание: есть одна большая разница между видом <code>MyBox&lt;T&gt;</code>, который мы собираемся создать и существующим <code>Box&lt;T&gt;</code>: наша исполнение не будет хранить свои данные в куче. В примере мы сосредоточимся на типаже <code>Deref</code>, поэтому менее важно то, где данные хранятся, чем поведение подобное указателю.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="Следуя-за-указателем-на-значение"><a class="header" href="#Следуя-за-указателем-на-значение">Следуя за указателем на значение</a></h3>
<p>Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте. В приложении 15-6 мы создаём ссылку на значение <code>i32</code>, а затем используем оператор разыменования для перехода от ссылки к значению:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-6: Использование оператора разыменования для следования по ссылке к значению <code>i32</code></span></p>
<p>Переменной <code>x</code> присвоено значение<code>5</code> вида <code>i32</code>. Мы установили в качестве значения <code>y</code> ссылку на <code>x</code>. Мы можем утверждать, что значение <code>x</code> равно <code>5</code>. Однако, если мы хотим сделать утверждение о значении в <code>y</code>, мы должны использовать <code>*y</code>, чтобы перейти по ссылке к значению, на которое она указывает (таким образом, происходит <em>разыменование</em>), для того чтобы сборщик при сравнении мог использовать фактическое значение. Как только мы разыменуем <code>y</code>, мы получим доступ к целочисленному значению, на которое указывает <code>y</code>, которое и будем сравнивать с <code>5</code>.</p>
<p>Если бы мы попытались написать <code>assert_eq!(5, y);</code>, то получили ошибку сборки:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}
</code></pre>
<p>Сравнение числа и ссылки на число не допускается, потому что они различных видов. Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.</p>
<h3 id="Использование-boxt-как-ссылку"><a class="header" href="#Использование-boxt-как-ссылку">Использование <code>Box&lt;T&gt;</code> как ссылку</a></h3>
<p>Мы можем переписать код в приложении 15-6, чтобы использовать <code>Box&lt;T&gt;</code> вместо ссылки; оператор разыменования, используемый для <code>Box&lt;T&gt;</code> в приложении 15-7, работает так же, как оператор разыменования, используемый для ссылки в приложении 15-6:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-7: Использование оператора разыменования с видом <code>Box&lt;i32&gt;</code></span></p>
<p>Основное различие между приложением 15-7 и приложением 15-6 заключается в том, что здесь мы устанавливаем <code>y</code> как экземпляр <code>Box&lt;T&gt;</code>, указывающий на скопированное значение <code>x</code>, а не как ссылку, указывающую на значение <code>x</code>. В последнем утверждении мы можем использовать оператор разыменования, чтобы проследовать за указателем <code>Box&lt;T&gt;</code> так же, как мы это делали, когда <code>y</code> был ссылкой. Далее мы рассмотрим, что особенного в <code>Box&lt;T&gt;</code>, что позволяет нам использовать оператор разыменования, определяя наш собственный вид.</p>
<h3 id="Определение-собственного-умного-указателя"><a class="header" href="#Определение-собственного-умного-указателя">Определение собственного умного указателя</a></h3>
<p>Давайте создадим умный указатель, похожий на вид <code>Box&lt;T&gt;</code> предоставляемый встроенной библиотекой, чтобы понять как поведение умных указателей отличается от поведения обычной ссылки. Затем мы рассмотрим вопрос, как добавить возможность использовать оператор разыменования.</p>
<p>Вид <code>Box&lt;T&gt;</code> в конечном итоге определяется как структура кортежа с одним элементом, поэтому в приложении 15-8 подобным образом определяется <code>MyBox&lt;T&gt;</code>. Мы также определим функцию <code>new</code>, чтобы она соответствовала функции <code>new</code>, определённой в <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-8: Определение вида <code>MyBox&lt;T&gt;</code></span></p>
<p>Мы определяем структуру с именем <code>MyBox</code> и объявляем обобщённый свойство <code>T</code>, потому что мы хотим, чтобы наш вид хранил значения любого вида. Вид <code>MyBox</code> является структурой кортежа с одним элементом вида <code>T</code>. Функция <code>MyBox::new</code> принимает один свойство вида <code>T</code> и возвращает экземпляр <code>MyBox</code>, который содержит переданное значение.</p>
<p>Давайте попробуем добавить функцию <code>main</code> из приложения 15-7 в приложение 15-8 и изменим её на использование вида <code>MyBox&lt;T&gt;</code>, который мы определили вместо <code>Box&lt;T&gt;</code>. Код в приложении 15-9 не будет собираться, потому что Rust не знает, как разыменовывать <code>MyBox</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-9. Попытка использовать <code>MyBox&lt;T&gt;</code> таким же образом, как мы использовали ссылки и <code>Box&lt;T&gt;</code></span></p>
<p>Вот результат ошибки сборки:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}
</code></pre>
<p>Наш вид <code>MyBox&lt;T&gt;</code> не может быть разыменован, потому что мы не реализовали эту возможность. Чтобы включить разыменование с помощью оператора <code>*</code>, мы реализуем типаж <code>Deref</code>.</p>
<h3 id="Трактование-вида-как-ссылки-реализуя-типаж-deref"><a class="header" href="#Трактование-вида-как-ссылки-реализуя-типаж-deref">Трактование вида как ссылки реализуя типаж <code>Deref</code></a></h3>
<p>Как обсуждалось в разделе <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“Реализация трейта для типа”</a><!--  --> Главы 10, для реализации типажа нужно предоставить реализации требуемых способов типажа. Типаж <code>Deref</code>, предоставляемый встроенной библиотекой требует от нас реализации одного способа с именем <code>deref</code>, который заимствует <code>self</code> и возвращает ссылку на внутренние данные. Приложение 15-10 содержит реализацию <code>Deref</code> добавленную к определению <code>MyBox</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-10: Реализация <code>Deref</code> для вида <code>MyBox&lt;T&gt;</code></span></p>
<p>Синтаксис <code>type Target = T;</code> определяет связанный вид для использования у типажа <code>Deref</code>. Связанные виды - это немного другой способ объявления обобщённого свойства, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.</p>
<p>Мы заполним тело способа <code>deref</code> оператором <code>&amp;self.0 </code>, чтобы <code>deref</code> вернул ссылку на значение, к которому мы хотим получить доступ с помощью оператора <code>*</code>; вспомним из раздела <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">"Using Tuple Structs without Named Fields to Create Different Types"</a><!-- ignore --> главы 5, что <code>.0</code> получает доступ к первому значению в кортежной структуре. Функция <code>main</code> в приложении 15-9, которая вызывает <code>*</code> для значения <code>MyBox&lt;T&gt;</code>, теперь собирается, и проверки проходят!</p>
<p>Без типажа <code>Deref</code> сборщик может только разыменовывать <code>&amp;</code> ссылки. Способ <code>deref</code> даёт сборщику возможность принимать значение любого вида, реализующего <code>Deref</code> и вызывать способ <code>deref</code> чтобы получить ссылку <code>&amp;</code>, которую он знает, как разыменовывать.</p>
<p>Когда мы ввели <code>*y</code> в приложении 15-9, Rust фактически выполнил за кулисами такой код:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust заменяет оператор <code>*</code> вызовом способа <code>deref</code> и затем простое разыменование, поэтому нам не нужно думать о том, нужно ли нам вызывать способ <code>deref</code>. Эта функция Rust позволяет писать код, который функционирует одинаково, независимо от того, есть ли у нас обычная ссылка или вид, реализующий типаж <code>Deref</code>.</p>
<p>Причина, по которой способ <code>deref</code> возвращает ссылку на значение, и что простое разыменование вне круглых скобок в <code>*(y.deref())</code> все ещё необходимо, связана с системой владения. Если бы способ <code>deref</code> возвращал значение напрямую, а не ссылку на него, значение переместилось бы из <code>self</code>. Мы не хотим передавать владение внутренним значением внутри <code>MyBox&lt;T&gt;</code> в этом случае и в большинстве случаев, когда мы используем оператор разыменования.</p>
<p>Обратите внимание, что оператор <code>*</code> заменён вызовом способа <code>deref</code>, а затем вызовом оператора <code>*</code> только один раз, каждый раз, когда мы используем <code>*</code> в коде. Поскольку замена оператора <code>*</code> не повторяется бесконечно, мы получаем данные вида <code>i32</code>, которые соответствуют <code>5</code> в <code>assert_eq!</code> приложения 15-9.</p>
<h3 id="Неявные-разыменованные-приведения-с-функциями-и-способами"><a class="header" href="#Неявные-разыменованные-приведения-с-функциями-и-способами">Неявные разыменованные приведения с функциями и способами<a id="implicit-deref-coercions-with-functions-and-methods"></a></a></h3>
<p><em>Разыменованное приведение</em> преобразует ссылку на вид, который реализует признак <code>Deref</code>, в ссылку на другой вид. Например, deref coercion может преобразовать <code>&amp;String</code> в <code>&amp;str</code>, потому что <code>String</code> реализует признак <code>Deref</code>, который возвращает <code>&amp;str</code>. Deref coercion - это удобный механизм, который Rust использует для переменных функций и способов, и работает только для видов, реализующих признак <code>Deref</code>. Это происходит самостоятельно , когда мы передаём в качестве переменной функции или способа ссылку на значение определённого вида, которое не соответствует виду свойства в определении функции или способа. В результате серии вызовов способа <code>deref</code> вид, который мы передали, преобразуется в вид, необходимый для свойства.</p>
<p>Разыменованное приведение было добавлено в Rust, так что программистам, пишущим вызовы функций и способов, не нужно добавлять множество явных ссылок и разыменований с помощью использования <code>&amp;</code> и <code>*</code>. Функциональность разыменованного приведения также позволяет писать больше кода, который может работать как с ссылками, так и с умными указателями.</p>
<p>Чтобы увидеть разыменованное приведение в действии, давайте воспользуемся видом <code>MyBox&lt;T&gt;</code> определённым в приложении 15-8, а также реализацию <code>Deref</code> добавленную в приложении 15-10. Приложение 15-11 показывает определение функции, у которой есть свойство вида срез строки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-11: Функция <code>hello</code> имеющая свойство  <code>name</code> вида <code>&amp;str</code></span></p>
<p>Можно вызвать функцию <code>hello</code> со срезом строки в качестве переменной, например <code>hello("Rust");</code>. Разыменованное приведение делает возможным вызов <code>hello</code> со ссылкой на значение вида <code>MyBox&lt;String&gt;</code>, как показано в приложении 15-12.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-12: Вызов <code>hello</code> со ссылкой на значение <code>MyBox&lt;String&gt;</code>, которое работает из-за разыменованного приведения</span></p>
<p>Здесь мы вызываем функцию <code>hello</code> с переменнаяом <code>&amp;m</code>, который является ссылкой на значение <code>MyBox&lt;String&gt;</code>. Поскольку мы реализовали типаж <code>Deref</code> для <code>MyBox&lt;T&gt;</code> в приложении 15-10, то Rust может преобразовать <code>&amp;MyBox&lt;String&gt;</code> в <code>&amp;String</code> вызывая <code>deref</code>. Стандартная библиотека предоставляет реализацию типажа <code>Deref</code> для вида <code>String</code>, которая возвращает срез строки, это описано в документации API типажа <code>Deref</code>. Rust снова вызывает <code>deref</code>, чтобы превратить <code>&amp;String</code> в <code>&amp;str</code>, что соответствует определению функции <code>hello</code>.</p>
<p>Если бы Rust не реализовал разыменованное приведение, мы должны были бы написать код в приложении 15-13 вместо кода в приложении 15-12 для вызова способа <code>hello</code> со значением вида <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-13: Код, который нам пришлось бы написать, если бы в Rust не было разыменованного приведения ссылок</span></p>
<p>Код <code>(*m)</code> разыменовывает <code>MyBox&lt;String&gt;</code> в <code>String</code>. Затем <code>&amp;</code> и <code>[..]</code> принимают строковый срез <code>String</code>, равный всей строке, чтобы соответствовать сигнатуре <code>hello</code>. Код без разыменованного приведения сложнее читать, писать и понимать со всеми этими символами. Разыменованное приведение позволяет Rust обрабатывать эти преобразования для нас самостоятельно .</p>
<p>Когда типаж <code>Deref</code> определён для задействованных видов, Rust проанализирует виды и будет использовать <code>Deref::deref</code> столько раз, сколько необходимо, чтобы получить ссылку, соответствующую виду свойства. Количество раз, которое нужно вставить <code>Deref::deref</code> определяется во время сборки, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!</p>
<h3 id="Как-разыменованное-приведение-взаимодействует-с-изменяемостью"><a class="header" href="#Как-разыменованное-приведение-взаимодействует-с-изменяемостью">Как разыменованное приведение взаимодействует с изменяемостью</a></h3>
<p>Подобно тому, как вы используете типаж <code>Deref</code> для переопределения оператора <code>*</code> у неизменяемых ссылок, вы можете использовать типаж <code>DerefMut</code> для переопределения оператора <code>*</code> у изменяемых ссылок.</p>
<p>Rust выполняет разыменованное приведение, когда находит виды и реализации типажей в трёх случаях:</p>
<ul>
<li>Из вида <code>&amp;T</code> в вид <code>&amp;U</code> когда верно <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Из вида <code>&amp;mut T</code> в вид <code>&amp;mut U</code> когда верно <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Из вида <code>&amp;mut T</code> в вид <code>&amp;U</code> когда верно <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Первые два случая равноценны друг другу, за исключением того, что второй реализует изменяемость. В первом случае говорится, что если у вас есть <code>&amp;T</code>, а <code>T</code> реализует <code>Deref</code> для некоторого вида <code>U</code>, вы сможете прозрачно получить <code>&amp;U</code>. Во втором случае говорится, что такое же разыменованное приведение происходит и для изменяемых ссылок.</p>
<p>Третий случай хитрее: Rust также приводит изменяемую ссылку к неизменяемой. Но обратное <em>не</em> представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на данные (в противном случае программа не будет собираться). Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, и правила заимствования не заверяют этого. Следовательно, Rust не может сделать предположение, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Запуск-кода-при-очистке-с-помощью-типажа-drop"><a class="header" href="#Запуск-кода-при-очистке-с-помощью-типажа-drop">Запуск кода при очистке с помощью типажа <code>Drop</code></a></h2>
<p>Вторым важным типажом умного указателя является Drop, который позволяет регулировать, что происходит, когда значение вот-вот выйдет из области видимости. Вы можете реализовать типаж Drop для любого вида, а также использовать этот код для высвобождения ресурсов, таких как файлы или сетевые соединения.</p>
<p>Мы рассматриваем <code>Drop</code> в среде умных указателей, потому что функциональность свойства <code>Drop</code> практически всегда используется при реализации умного указателя. Например, при сбросе <code>Box&lt;T&gt;</code> происходит деаллокация пространства на куче, на которое указывает box.</p>
<p>В некоторых языках для некоторых видов программист должен вызывать код для освобождения памяти или ресурсов каждый раз, когда он завершает использование экземпляров этих видов. Примерами могут служить дескрипторы файлов, сокеты или блокировки. Если забыть об этом, система окажется перегруженной и может упасть. В Rust вы можете указать, что определённый фрагмент кода должен выполняться всякий раз, когда значение выходит из области видимости, и сборщик самостоятельно будет его вставлять. Как следствие, вам не нужно заботиться о размещении кода очистки везде в программе, где завершается работа экземпляра определённого вида - утечки ресурсов все равно не будет!</p>
<p>Вы можете задать определённую логику, которая будет выполняться, когда значение выходит за пределы области видимости, реализовав признак <code>Drop</code>. Типаж <code>Drop</code> требует от вас реализации одного способа <code>drop</code>, который принимает изменяемую ссылку на <code>self</code>. Чтобы увидеть, когда Rust вызывает <code>drop</code>, давайте реализуем <code>drop</code> с помощью указаний <code>println!</code>.</p>
<p>В приложении 15-14 показана структура <code>CustomSmartPointer</code>, единственной уникальной функциональностью которой является печать <code>Dropping CustomSmartPointer!</code>, когда экземпляр выходит из области видимости, чтобы показать, когда Rust выполняет функцию <code>drop</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-14/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-14: Структура <code>CustomSmartPointer</code>, реализующая типаж <code>Drop</code>, куда мы поместим наш код очистки</span></p>
<p>Типаж <code>Drop</code> включён в прелюдию, поэтому нам не нужно вводить его в область видимости. Мы реализуем типаж <code>Drop</code> для <code>CustomSmartPointer</code> и реализуем способ <code>drop</code>, который будет вызывать <code>println!</code>. Тело функции <code>drop</code> - это место, где должна располагаться вся логика, которую вы захотите выполнять, когда экземпляр вашего вида выйдет из области видимости. Мы печатаем здесь текст, чтобы наглядно отобразить, когда Rust вызовет <code>drop</code>.</p>
<p>В <code>main</code> мы создаём два экземпляра <code>CustomSmartPointer</code> и затем печатаем <code>CustomSmartPointers created</code> . В конце <code>main</code> наши экземпляры <code>CustomSmartPointer</code> выйдут из области видимости и Rust вызовет код, который мы добавили в способ <code>drop</code>, который и напечатает наше окончательное сообщение. Обратите внимание, что нам не нужно вызывать способ <code>drop</code> явно.</p>
<p>Когда мы запустим эту программу, мы увидим следующий вывод:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-14/output.txt}}
</code></pre>
<p>Rust самостоятельно вызывал <code>drop</code> в момент выхода наших экземпляров из области видимости, тем самым выполнив заданный нами код. Переменные удаляются в обратном порядке их создания, поэтому <code>d</code> была удалена до <code>c</code>. Цель этого примера — дать вам наглядное представление о том, как работает способ <code>drop</code>; в типичных случаях вы будете задавать код очистки, который должен выполнить ваш вид, а не печатать сообщение.</p>
<h3 id="Раннее-удаление-значения-с-помощью-stdmemdrop"><a class="header" href="#Раннее-удаление-значения-с-помощью-stdmemdrop">Раннее удаление значения с помощью <code>std::mem::drop</code></a></h3>
<p>К сожалению, отключение функции самостоятельного удаления с помощью <code>drop</code> является не простым. Отключение <code>drop</code> обычно не требуется; весь смысл типажа <code>Drop</code> в том, чтобы о функции позаботились самостоятельно . Иногда, однако, вы можете захотеть очистить значение рано. Одним из примеров является использование умных указателей, которые управляют блокировками: вы могли бы потребовать принудительный вызов способа <code>drop</code> который снимает блокировку, чтобы другой код в той же области видимости мог получить блокировку. Rust не позволяет вызвать способ типажа <code>Drop</code> вручную; вместо этого вы должны вызвать функцию <code>std::mem::drop</code> предоставляемую встроенной библиотекой, если хотите принудительно удалить значение до конца области видимости.</p>
<p>Если попытаться вызвать способ <code>drop</code> типажа <code>Drop</code> вручную, изменяя функцию <code>main</code> приложения 15-14 так, как показано в приложении 15-15, мы получим ошибку сборщика:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-15/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-15: Попытка вызвать способ <code>drop</code> из трейта <code>Drop</code> вручную для досрочной очистки</span></p>
<p>Когда мы попытаемся собрать этот код, мы получим ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-15/output.txt}}
</code></pre>
<p>Это сообщение об ошибке говорит, что мы не можем явно вызывать <code>drop</code>. В сообщении об ошибке используется термин <em>деструктор (destructor)</em>, который является общим термином программирования для функции, которая очищает экземпляр. <em>Деструктор</em> подобен <em>конструктору</em>, который создаёт экземпляр. Функция <code>drop</code> в Rust является определённым деструктором.</p>
<p>Rust не позволяет обращаться к <code>drop</code> напрямую, потому что он все равно самостоятельно вызовет <code>drop</code> в конце <code>main</code>. Это вызвало бы ошибку <em>double free</em>, потому что в этом случае Rust попытался бы дважды очистить одно и то же значение.</p>
<p>Невозможно отключить самостоятельную подстановку вызова <code>drop</code>, когда значение выходит из области видимости, и нельзя вызвать способ <code>drop</code> напрямую. Поэтому, если нам нужно принудительно избавиться от значения раньше времени, следует использовать функцию <code>std::mem::drop</code>.</p>
<p>Функция <code>std::mem::drop</code> отличается от способа <code>drop</code> трейта <code>Drop</code>. Мы вызываем её, передавая в качестве переменной значение, которое хотим принудительно уничтожить. Функция находится в прелюдии, поэтому мы можем изменить <code>main</code> в приложении 15-15 так, чтобы вызвать функцию <code>drop</code>, как показано в приложении 15-16:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-16/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-16: Вызов <code>std::mem::drop</code> для принудительного удаления значения до того, как оно выйдет из области видимости</span></p>
<p>Выполнение данного кода выведет следующий результат::</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-16/output.txt}}
</code></pre>
<p>Текст <code>Dropping CustomSmartPointer with data </code>some data<code>!</code>, напечатанный между <code>CustomSmartPointer created.</code> и текстом <code>CustomSmartPointer dropped before the end of main.</code>, показывает, что код способа <code>drop</code> вызывается для удаления <code>c</code> в этой точке.</p>
<p>Вы можете использовать код, указанный в реализации типажа <code>Drop</code>, чтобы сделать очистку удобной и безопасной: например, вы можете использовать её для создания своего собственного менеджера памяти! С помощью типажа <code>Drop</code> и системы владения Rust не нужно целенаправленно заботиться о том, чтобы освобождать ресурсы, потому что Rust делает это самостоятельно .</p>
<p>Также не нужно беспокоиться о проблемах, возникающих в результате случайной очистки значений, которые всё ещё используются: система владения, которая заверяет, что ссылки всегда действительны, также заверяет, что <code>drop</code> вызывается только один раз, когда значение больше не используется.</p>
<p>После того, как мы познакомились с <code>Box&lt;T&gt;</code> и характеристиками умных указателей, познакомимся с другими умными указателями, определёнными в встроенной библиотеке.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-умный-указатель-с-подсчётом-ссылок"><a class="header" href="#rct-умный-указатель-с-подсчётом-ссылок"><code>Rc&lt;T&gt;</code>, умный указатель с подсчётом ссылок</a></h2>
<p>В большинстве ситуаций владение является однозначным: вы точно знаете, какая переменная владеет данным значением. Однако бывают случаи, когда у одного значения может быть несколько владельцев. Например, в Графовых структурах может быть несколько рёбер, указывающих на один и тот же узел — таким образом, этот узел становится фактически собственностью всех этих рёбер. Узел не подлежит удалению, за исключением тех случаев, когда на него не указывает ни одно ребро и, соответственно, у него нет владельцев.</p>
<p>Вы должны включить множественное владение явно, используя вид Rust <code>Rc&lt;T&gt;</code>, который является аббревиатурой для <em>подсчёта ссылок</em>. Вид <code>Rc&lt;T&gt;</code> отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё. Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет недействительной.</p>
<p>Представьте себе <code>Rc&lt;T&gt;</code> как телевизор в гостиной. Когда один человек входит, чтобы смотреть телевизор, он включает его. Другие могут войти в комнату и посмотреть телевизор. Когда последний человек покидает комнату, он выключает телевизор, потому что он больше не используется. Если кто-то выключит телевизор во время его просмотра другими, то оставшиеся телезрители устроят шум!</p>
<p>Вид <code>Rc&lt;T&gt;</code> используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время сборки, какая из частей завершит использование данных последней. Если бы мы знали, какая часть завершит использование последней то, мы могли бы сделать эту часть владельцем данных и вступили бы в силу обычные правила владения, применяемые во время сборки.</p>
<p>Обратите внимание, что <code>Rc&lt;T&gt;</code> используется только в однопоточных сценариях. Когда мы обсудим состязательность в главе 16, мы рассмотрим, как выполнять подсчёт ссылок во многопоточных программах.</p>
<h3 id="Использование-rct-для-совместного-использования-данных"><a class="header" href="#Использование-rct-для-совместного-использования-данных">Использование <code>Rc&lt;T&gt;</code> для совместного использования данных</a></h3>
<p>Давайте вернёмся к нашему примеру с cons списком в приложении 15-5. Напомним, что мы определили его с помощью вида <code>Box&lt;T&gt;</code>. В этот раз мы создадим два списка, оба из которых будут владеть третьим списком. Концептуально это похоже на рисунок 15-3:</p>
 <img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg">
<p><span class="caption">Рисунок 15-3: Два списка, <code>b</code> и <code>c</code>, делят владение над третьим списком, <code>a</code></span></p>
<p>Мы создадим список <code>a</code>, содержащий 5 и затем 10. Затем мы создадим ещё два списка: <code>b</code> начинающийся с 3 и <code>c</code> начинающийся с 4. Оба списка <code>b</code> и <code>c</code> затем продолжать первый список <code>a</code>, содержащий 5 и 10. Другими словами, оба списка будут разделять первый список, содержащий 5 и 10.</p>
<p>Попытка реализовать этот сценарий, используя определение <code>List</code> с видом <code>Box&lt;T&gt;</code> не будет работать, как показано в приложении 15-17:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 15-17: Отображение того, что нельзя иметь два списка, использующих <code>Box&lt;T&gt;</code>, которые пытаются совместно владеть третьим списком</span></p>
<p>При сборки этого кода, мы получаем эту ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
</code></pre>
<p>Варианты <code>Cons</code> владеют данными, которые они содержат, поэтому, когда мы создаём список <code>b</code>, то <code>a</code> перемещается в <code>b</code>, а <code>b</code> становится владельцем <code>a</code>. Затем, мы пытаемся использовать <code>a</code> снова при создании <code>c</code>, но нам не разрешают, потому что <code>a</code> был перемещён.</p>
<p>Мы могли бы изменить определение <code>Cons</code>, чтобы вместо этого хранить ссылки, но тогда нам пришлось бы указывать свойства времени жизни. Указывая свойства времени жизни, мы бы указали, что каждый элемент в списке будет жить как минимум столько же, сколько и весь список. Это относится к элементам и спискам в приложении 15.17, но не во всех сценариях.</p>
<p>Вместо этого мы изменим наше определение вида <code>List</code> так, чтобы использовать <code>Rc&lt;T&gt;</code> вместо <code>Box&lt;T&gt;</code>, как показано в приложении 15-18. Каждый вариант <code>Cons</code> теперь будет содержать значение и вид <code>Rc&lt;T&gt;</code>, указывающий на <code>List</code>. Когда мы создадим <code>b</code> то, вместо того чтобы стал владельцем <code>a</code>, мы будем клонировать <code>Rc&lt;List&gt;</code> который содержит <code>a</code>, тем самым увеличивая количество ссылок с единицы до двойки и позволяя переменным <code>a</code> и <code>b</code> разделять владение на данные в виде <code>Rc&lt;List&gt;</code>. Мы также клонируем <code>a</code> при создании <code>c</code>, увеличивая количество ссылок с двух до трёх. Каждый раз, когда мы вызываем <code>Rc::clone</code>, счётчик ссылок на данные внутри <code>Rc&lt;List&gt;</code> будет увеличиваться и данные не будут очищены, если на них нет нулевых ссылок.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-18: Определение <code>List</code>, использующее <code>Rc&lt;T&gt;</code></span></p>
<p>Нам нужно добавить указанию <code>use</code>, чтобы подключить вид <code>Rc&lt;T&gt;</code> в область видимости, потому что он не входит в список самостоятельного импорта прелюдии. В <code>main</code>, мы создаём список владеющий 5 и 10, сохраняем его в новом <code>Rc&lt;List&gt;</code> переменной <code>a</code>. Затем при создании <code>b</code> и <code>c</code>, мы называем функцию <code>Rc::clone</code> и передаём ей ссылку на <code>Rc&lt;List&gt;</code> как переменная <code>a</code>.</p>
<p>Мы могли бы вызвать <code>a.clone()</code>, а не <code>Rc::clone(&amp;a)</code>, но в Rust принято использовать <code>Rc::clone</code> в таком случае. Внутренняя реализация <code>Rc::clone</code> не делает глубокого копирования всех данных, как это происходит в видах большинства реализаций <code>clone</code>. Вызов <code>Rc::clone</code> только увеличивает счётчик ссылок, что не занимает много времени. Глубокое копирование данных может занимать много времени. Используя <code>Rc::clone</code> для подсчёта ссылок, можно визуально различать виды клонирования с глубоким копированием и клонирования, которые увеличивают количество ссылок. При поиске  в коде проблем с производительностью нужно рассмотреть только  клонирование с глубоким копированием и пренебрегать вызовы <code>Rc::clone</code> .</p>
<h3 id="Клонирование-rct-увеличивает-количество-ссылок"><a class="header" href="#Клонирование-rct-увеличивает-количество-ссылок">Клонирование <code>Rc&lt;T&gt;</code> увеличивает количество ссылок</a></h3>
<p>Давайте изменим рабочий пример в приложении 15-18, чтобы увидеть как изменяется число ссылок при создании и удалении ссылок на <code>Rc&lt;List&gt;</code> внутри переменной <code>a</code>.</p>
<p>В приложении 15-19 мы изменим <code>main</code> так, чтобы она имела внутреннюю область видимости вокруг списка <code>c</code>; тогда мы сможем увидеть, как меняется счётчик ссылок при выходе <code>c</code> из внутренней области видимости.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-19: Печать количества ссылок</span></p>
<p>В каждой части программы, где количество ссылок меняется, мы выводим количество ссылок, которое получаем, вызывая функцию <code>Rc::strong_count</code>. Эта функция названа <code>strong_count</code>, а не <code>count</code>, потому что вид <code>Rc&lt;T&gt;</code> также имеет <code>weak_count</code>; мы увидим, для чего используется <code>weak_count</code> в разделе <a data-md-type="raw_html" href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">"Предотвращение циклических ссылок: Превращение <code>Rc&lt;T&gt;</code> в <code data-md-type="raw_html">Weak&lt;T&gt;</code>"</a><!-- ignore -->.</p>
<p>Код выводит в окно вывода:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
</code></pre>
<p>Можно увидеть, что <code>Rc&lt;List&gt;</code> в переменной <code>a</code> имеет начальный счётчик ссылок равный 1; затем каждый раз при вызове <code>clone</code> счётчик увеличивается на 1. Когда <code>c</code> выходит из области видимости, счётчик уменьшается на 1. Нам не нужно вызывать функцию уменьшения счётчика ссылок, как при вызове <code>Rc::clone</code> для увеличения счётчика ссылок: реализация <code>Drop</code> самостоятельно уменьшает счётчик ссылок, когда значение <code>Rc&lt;T&gt;</code> выходит из области видимости.</p>
<p>В этом примере мы не наблюдаем того, что когда <code>b</code>, а затем <code>a</code> выходят из области видимости в конце <code>main</code>, счётчик становится равным 0, и <code>Rc&lt;List&gt;</code> полностью очищается. Использование <code>Rc&lt;T&gt;</code> позволяет одному значению иметь несколько владельцев, а счётчик заверяет, что значение остаётся действительным до тех пор, пока любой из владельцев ещё существует.</p>
<p>С помощью неизменяемых ссылок, вид <code>Rc&lt;T&gt;</code> позволяет обмениваться данными между несколькими частями вашей программы только для чтения данных. Если вид <code>Rc&lt;T&gt;</code> позволял бы иметь несколько изменяемых ссылок, вы могли бы нарушить одно из правил заимствования, описанных в главе 4: множественные изменяемые заимствования в одном и том же месте могут вызвать гонки данных (data races) и несогласованность данных. Но возможность изменять данные очень полезна! В следующем разделе мы обсудим шаблон внутренней изменчивости и вид <code>RefCell&lt;T&gt;</code>, который можно использовать вместе с <code>Rc&lt;T&gt;</code> для работы с этим ограничением.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-и-шаблон-внутренней-изменяемости"><a class="header" href="#refcellt-и-шаблон-внутренней-изменяемости"><code>RefCell&lt;T&gt;</code> и шаблон внутренней изменяемости</a></h2>
<p><em>Внутренняя изменяемость</em> - это паттерн проектирования Rust, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования. Для изменения данных паттерн использует <code>unsafe</code> код внутри структуры данных, чтобы обойти обычные правила Rust, регулирующие изменяемость и заимствование. Небезопасный (unsafe) код даёт понять сборщику, что мы самостоятельно следим за соблюдением этих правил, а не полагаемся на то, что сборщик будет делать это для нас; подробнее о небезопасном коде мы поговорим в главе 19.</p>
<p>Мы можем использовать виды, в которых применяется паттерн внутренней изменяемости, только если мы можем обеспечить, что правила заимствования будут соблюдаться во время выполнения, несмотря на то, что сборщик не сможет этого обеспечить. В этом случае <code>небезопасный</code> код оборачивается безопасным API, и внешне вид остаётся неизменяемым.</p>
<p>Давайте изучим данную концепцию с помощью вида данных <code>RefCell&lt;T&gt;</code>, который реализует этот шаблон.</p>
<h3 id="Применение-правил-заимствования-во-время-выполнения-с-помощью-refcellt"><a class="header" href="#Применение-правил-заимствования-во-время-выполнения-с-помощью-refcellt">Применение правил заимствования во время выполнения с помощью <code>RefCell&lt;T&gt;</code></a></h3>
<p>В отличие от <code>Rc&lt;T&gt;</code> вид <code>RefCell&lt;T&gt;</code> предоставляет единоличное владение данными, которые он содержит. В чем же отличие вида <code>RefCell&lt;T&gt;</code> от <code>Box&lt;T&gt;</code>? Давайте вспомним правила заимствования из Главы 4:</p>
<ul>
<li>В любой момент времени вы можете иметь <em>либо</em> одну изменяемую ссылку либо сколько угодно неизменяемых ссылок (но не оба вида ссылок одновременно).</li>
<li>Ссылки всегда должны быть действительными.</li>
</ul>
<p>С помощью ссылок и вида <code>Box&lt;T&gt;</code> инварианты правил заимствования применяются на этапе сборки. С помощью <code>RefCell&lt;T&gt;</code> они применяются <em>во время работы программы</em>. Если вы нарушите эти правила, работая с ссылками, то будет ошибка сборки. Если вы работаете с <code>RefCell&lt;T&gt;</code> и нарушите эти правила, то программа вызовет панику и завершится.</p>
<p>Преимущества проверки правил заимствования во время сборки заключаются в том, что ошибки будут обнаруживаться раньше - ещё в процессе разработки, а производительность во время выполнения не пострадает, поскольку весь анализ завершён заранее. По этим причинам проверка правил заимствования во время сборки является лучшим выбором в большинстве случаев, и именно поэтому она используется в Rust по умолчанию.</p>
<p>Преимущество проверки правил заимствования во время выполнения заключается в том, что определённые сценарии, безопасные для памяти, разрешаются там, где они были бы запрещены проверкой во время сборки. Статический анализ, как и сборщик Rust, по своей сути консервативен. Некоторые свойства кода невозможно обнаружить, анализируя код: самый известный пример - проблема остановки, которая выходит за рамки этой книги, но является важной темой для исследования.</p>
<p>Поскольку некоторый анализ невозможен, то если сборщик Rust не может быть уверен, что код соответствует правилам владения, он может отклонить корректную программу; таким образом он является консервативным. Если Rust принял некорректную программу, то пользователи не смогут доверять заверениям, которые даёт Rust. Однако, если Rust отклонит корректную программу, то программист будет испытывать неудобства, но ничего катастрофического не произойдёт. Вид <code>RefCell&lt;T&gt;</code> полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но сборщик не может понять и обеспечить этого.</p>
<p>Подобно виду <code>Rc&lt;T&gt;</code>, вид <code>RefCell&lt;T&gt;</code> предназначен только для использования в однопоточных сценариях и выдаст ошибку времени сборки, если вы попытаетесь использовать его в многопоточном среде. Мы поговорим о том, как получить функциональность <code>RefCell&lt;T&gt;</code> во многопоточной программе в главе 16.</p>
<p>Вот список причин выбора видов <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> или <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>Вид <code>Rc&lt;T&gt;</code> разрешает множественное владение одними и теми же данными; виды <code>Box&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code> разрешают иметь единственных владельцев.</li>
<li>Вид <code>Box&lt;T&gt;</code> разрешает неизменяемые или изменяемые владения, проверенные при сборки; вид <code>Rc&lt;T&gt;</code> разрешает только неизменяемые владения, проверенные при сборки; вид <code>RefCell&lt;T&gt;</code> разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.</li>
<li>Поскольку <code>RefCell&lt;T&gt;</code> разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри <code>RefCell&lt;T&gt;</code> даже если <code>RefCell&lt;T&gt;</code> является неизменным.</li>
</ul>
<p>Изменение значения внутри неизменного значения является шаблоном <em>внутренней изменяемости</em> (interior mutability). Давайте посмотрим на ситуацию, в которой внутренняя изменяемость полезна и рассмотрим, как это возможно.</p>
<h3 id="Внутренняя-изменяемость-изменяемое-заимствование-неизменяемого-значения"><a class="header" href="#Внутренняя-изменяемость-изменяемое-заимствование-неизменяемого-значения">Внутренняя изменяемость: изменяемое заимствование неизменяемого значения</a></h3>
<p>Следствием правил заимствования является то, что когда у вас есть неизменяемое значение, вы не можете заимствовать его с изменением. Например, этот код не будет собираться:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}</code></pre>
<p>Если вы попытаетесь собрать этот код, вы получите следующую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}
</code></pre>
<p>Однако бывают ситуации, в которых было бы полезно, чтобы объект мог изменять себя при помощи своих методов, но казался неизменным для прочего кода. Код вне методов этого объекта не должен иметь возможности изменять его содержимое. Использование <code>RefCell&lt;T&gt;</code> - один из способов получить возможность внутренней изменяемости, но при этом <code>RefCell&lt;T&gt;</code> не позволяет полностью обойти правила заимствования: средство проверки правил заимствования в сборщике позволяет эту внутреннюю изменяемость, однако правила заимствования проверяются во время выполнения. Если вы нарушите правила, то вместо ошибки сборки вы получите <code>panic!</code>.</p>
<p>Давайте разберём практический пример, в котором мы можем использовать <code>RefCell&lt;T&gt;</code> для изменения неизменяемого значения и посмотрим, почему это полезно.</p>
<h4 id="Вариант-использования-внутренней-изменяемости-мок-объекты"><a class="header" href="#Вариант-использования-внутренней-изменяемости-мок-объекты">Вариант использования внутренней изменяемости: мок объекты</a></h4>
<p>Иногда во время тестирования программист использует один вид вместо другого для того, чтобы проверить определённое поведение и убедиться, что оно реализовано правильно. Такой вид-заместитель называется <em>тестовым повторителем</em>. Воспринимайте его как «каскадёра» в кинематографе, когда повторитель заменяет актёра для выполнения определённой сложной сцены. Тестовые повторители заменяют другие виды при выполнении тестов. <em>Инсценировочные (mock) объекты</em> — это особый вид тестовых повторителей, которые сохраняют данные происходящих во время теста действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.</p>
<p>В Rust нет объектов в том же смысле, в каком они есть в других языках и в Rust нет функциональности мок объектов, встроенных в стандартную библиотеку, как в некоторых других языках. Однако вы определённо можете создать структуру, которая будет служить тем же целям, что и мок объект.</p>
<p>Вот сценарий, который мы будем тестировать: мы создадим библиотеку, которая отслеживает значение по отношению к заранее определённому максимальному значению и отправляет сообщения в зависимости от того, насколько текущее значение находится близко к такому максимальному значению. Эта библиотека может использоваться, например, для отслеживания квоты количества вызовов API пользователя, которые ему разрешено делать.</p>
<p>Наша библиотека будет предоставлять только функции отслеживания того, насколько близко к максимальному значению находится значение и какие сообщения должны быть внутри в этот момент. Ожидается, что приложения, использующие нашу библиотеку, предоставят механизм для отправки сообщений: приложение может поместить сообщение в приложение, отправить электронное письмо, отправить текстовое сообщение или что-то ещё. Библиотеке не нужно знать эту подробность. Все что ему нужно - это что-то, что реализует типаж, который мы предоставим с названием <code>Messenger</code>. Приложение 15-20 показывает код библиотеки:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 15-20: Библиотека для отслеживания степени приближения того или иного значения к максимально допустимой величине и предупреждения, в случае если значение достигает определённого уровня</span></p>
<p>Одна важная часть этого кода состоит в том, что типаж <code>Messenger</code> имеет один способ <code>send</code>, принимающий переменнойми неизменяемую ссылку на <code>self</code> и текст сообщения. Он является внешней оболочкой, который должен иметь наш мок объект. Другой важной частью является то, что мы хотим проверить поведение метода <code>set_value</code> у вида <code>LimitTracker</code>. Мы можем изменить значение, которое передаём свойствоом <code>value</code>, но <code>set_value</code> ничего не возвращает и нет основания, чтобы мы могли бы проверить утверждения о выполнении метода. Мы хотим иметь возможность  сказать, что если мы создаём <code>LimitTracker</code> с чем-то, что реализует типаж <code>Messenger</code> и с определённым значением для <code>max</code>, то когда мы передаём разные числа в переменной <code>value</code> экземпляр self.messenger отправляет соответствующие сообщения.</p>
<p>Нам нужен мок объект, который вместо отправки электронного письма или текстового сообщения будет отслеживать сообщения, которые были ему поручены для отправки через <code>send</code>. Мы можем создать новый экземпляр мок объекта, создать <code>LimitTracker</code> с использованием мок объект для него, вызвать способ <code>set_value</code> у экземпляра <code>LimitTracker</code>, а затем проверить, что мок объект имеет ожидаемое сообщение. В приложении 15-21 показана попытка реализовать мок объект, чтобы сделать именно то что хотим, но анализатор заимствований не разрешит такой код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-21: Попытка реализовать <code>MockMessenger</code>, которая не была принята механизмом проверки заимствований</span></p>
<p>Этот тестовый код определяет структуру <code>MockMessenger</code>, в которой есть поле <code>sent_messages</code> со значениями вида <code>Vec</code> из <code>String</code> для отслеживания сообщений, которые поручены структуре для отправки. Мы также определяем ассоциированную функцию <code>new</code>, чтобы было удобно создавать новые экземпляры <code>MockMessenger</code>, которые создаются с пустым списком сообщений. Затем мы реализуем типаж <code>Messenger</code> для вида <code>MockMessenger</code>, чтобы передать <code>MockMessenger</code> в <code>LimitTracker</code>. В сигнатуре метода <code>send</code> мы принимаем сообщение для передачи в качестве свойства и сохраняем его в <code>MockMessenger</code> внутри списка <code>sent_messages</code>.</p>
<p>В этом тесте мы проверяем, что происходит, когда <code>LimitTracker</code> сказано установить <code>value</code> в значение, превышающее 75 процентов от значения <code>max</code>. Сначала мы создаём новый <code>MockMessenger</code>, который будет иметь пустой список сообщений. Затем мы создаём новый <code>LimitTracker</code> и передаём ему ссылку на новый <code>MockMessenger</code> и <code>max</code> значение равное 100. Мы вызываем способ <code>set_value</code> у <code>LimitTracker</code> со значением 80, что составляет более 75 процентов от 100. Затем мы с помощью утверждения проверяем, что <code>MockMessenger</code> должен содержать одно сообщение из списка внутренних сообщений.</p>
<p>Однако с этим тестом есть одна проблема, показанная ниже:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}
</code></pre>
<p>Мы не можем изменять <code>MockMessenger</code> для отслеживания сообщений, потому что способ <code>send</code> принимает неизменяемую ссылку на <code>self</code>. Мы также не можем принять предложение из текста ошибки, чтобы использовать <code>&amp;mut self</code>, потому что тогда сигнатура <code>send</code> не будет соответствовать сигнатуре в определении типажа <code>Messenger</code> (не стесняйтесь попробовать и посмотреть, какое сообщение об ошибке получите вы).</p>
<p>Это ситуация, в которой внутренняя изменяемость может помочь! Мы сохраним <code>sent_messages</code> внутри вида <code>RefCell&lt;T&gt;</code>, а затем в методе <code>send</code> сообщение сможет изменить список <code>sent_messages</code> для хранения сообщений, которые мы видели. Приложение 15-22 показывает, как это выглядит:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-22: Использование <code>RefCell&lt;T&gt;</code> для изменения внутреннего значения, в то время как внешнее значение считается неизменяемым</span></p>
<p>Поле <code>sent_messages</code> теперь имеет вид <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> вместо <code>Vec&lt;String&gt;</code>. В функции <code>new</code> мы создаём новый экземпляр <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> для пустого вектора.</p>
<p>Для реализации метода <code>send</code> первый свойство по-прежнему является неизменяемым для заимствования <code>self</code>, которое соответствует определению типажа. Мы вызываем <code>borrow_mut</code> для <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> в <code>self.sent_messages</code>, чтобы получить изменяемую ссылку на значение внутри <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, которое является вектором. Затем мы можем вызвать <code>push</code> у изменяемой ссылки на вектор, чтобы отслеживать сообщения, отправленные во время теста.</p>
<p>Последнее изменение, которое мы должны сделать, заключается в утверждении для проверки: чтобы увидеть, сколько элементов находится во внутреннем векторе, мы вызываем способ <code>borrow</code> у <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, чтобы получить неизменяемую ссылку на внутренний вектор сообщений.</p>
<p>Теперь, когда вы увидели как использовать <code>RefCell&lt;T&gt;</code>, давайте изучим как он работает!</p>
<h4 id="Отслеживание-заимствований-во-время-выполнения-с-помощью-refcellt"><a class="header" href="#Отслеживание-заимствований-во-время-выполнения-с-помощью-refcellt">Отслеживание заимствований во время выполнения с помощью <code>RefCell&lt;T&gt;</code></a></h4>
<p>При создании неизменных и изменяемых ссылок мы используем синтаксис <code>&amp;</code> и <code>&amp;mut</code> соответственно. У вида <code>RefCell&lt;T&gt;</code>, мы используем методы <code>borrow</code> и <code>borrow_mut</code>, которые являются частью безопасного API, который принадлежит <code>RefCell&lt;T&gt;</code>. Способ <code>borrow</code> возвращает вид умного указателя <code>Ref&lt;T&gt;</code>, способ <code>borrow_mut</code> возвращает вид умного указателя <code>RefMut&lt;T&gt;</code>. Оба вида реализуют типаж <code>Deref</code>, поэтому мы можем рассматривать их как обычные ссылки.</p>
<p>Вид <code>RefCell&lt;T&gt;</code> отслеживает сколько умных указателей <code>Ref&lt;T&gt;</code> и <code>RefMut&lt;T&gt;</code> активны в данное время. Каждый раз, когда мы вызываем <code>borrow</code>, вид <code>RefCell&lt;T&gt;</code> увеличивает количество активных заимствований. Когда значение <code>Ref&lt;T&gt;</code> выходит из области видимости, то количество неизменяемых заимствований уменьшается на единицу. Как и с правилами заимствования во время сборки, <code>RefCell&lt;T&gt;</code> позволяет иметь много неизменяемых заимствований или одно изменяемое заимствование в любой момент времени.</p>
<p>Если попытаться нарушить эти правила, то вместо получения ошибки сборщика, как это было бы со ссылками, реализация <code>RefCell&lt;T&gt;</code> будет вызывать панику во время выполнения. В приложении 15-23 показана модификация реализации <code>send</code> из приложения 15-22. Мы намеренно пытаемся создать два изменяемых заимствования активных для одной и той же области видимости, чтобы показать как <code>RefCell&lt;T&gt;</code> не позволяет нам делать так во время выполнения.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-23: Создание двух изменяемых ссылок в одной области видимости, чтобы убедиться, что <code>RefCell&lt;T&gt;</code> вызовет панику</span></p>
<p>Мы создаём переменную <code>one_borrow</code> для умного указателя <code>RefMut&lt;T&gt;</code> возвращаемого из метода <code>borrow_mut</code>. Затем мы создаём другое изменяемое заимствование таким же образом в переменной <code>two_borrow</code>. Это создаёт две изменяемые ссылки в одной области видимости, что недопустимо. Когда мы запускаем тесты для нашей библиотеки, код в приложении 15-23 собирается без ошибок, но тест завершится неудачно:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}
</code></pre>
<p>Обратите внимание, что код вызвал панику с сообщением <code>already borrowed: BorrowMutError</code>. Вот так вид <code>RefCell&lt;T&gt;</code> обрабатывает нарушения правил заимствования во время выполнения.</p>
<p>Решение отлавливать ошибки заимствования во время выполнения, а не во время сборки, как мы сделали здесь, означает, что вы потенциально будете находить ошибки в своём коде на более поздних этапах разработки: возможно, не раньше, чем ваш код будет развернут в рабочем окружении. Кроме того, ваш код будет иметь небольшие потери производительности в процессе работы, поскольку заимствования будут отслеживаться во время выполнения, а не во время сборки. Однако использование <code>RefCell&lt;T&gt;</code> позволяет написать объект-имитатор, который способен изменять себя, чтобы сохранять сведения о тех значениях, которые он получал, пока вы использовали его в среде, где разрешены только неизменяемые значения. Вы можете использовать <code>RefCell&lt;T&gt;</code>, несмотря на его недостатки, чтобы получить больше функциональности, чем дают обычные ссылки.</p>
<h3 id="Наличие-нескольких-владельцев-изменяемых-данных-путём-объединения-видов-rct-и-refcellt"><a class="header" href="#Наличие-нескольких-владельцев-изменяемых-данных-путём-объединения-видов-rct-и-refcellt">Наличие нескольких владельцев изменяемых данных путём объединения видов <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code></a></h3>
<p>Обычный способ использования <code>RefCell&lt;T&gt;</code> заключается в его сочетании с видом <code>Rc&lt;T&gt;</code>. Напомним, что вид <code>Rc&lt;T&gt;</code> позволяет иметь нескольких владельцев некоторых данных, но даёт только неизменяемый доступ к этим данным. Если у вас есть <code>Rc&lt;T&gt;</code>, который внутри содержит вид <code>RefCell&lt;T&gt;</code>, вы можете получить значение, которое может иметь несколько владельцев <em>и</em> которое можно изменять!</p>
<p>Например, вспомните пример cons списка приложения 15-18, где мы использовали <code>Rc&lt;T&gt;</code>, чтобы несколько списков могли совместно владеть другим списком. Поскольку <code>Rc&lt;T&gt;</code> содержит только неизменяемые значения, мы не можем изменить ни одно из значений в списке после того, как мы их создали. Давайте добавим вид <code>RefCell&lt;T&gt;</code>, чтобы получить возможность изменять значения в списках. В приложении 15-24 показано использование <code>RefCell&lt;T&gt;</code> в определении <code>Cons</code> так, что мы можем изменить значение хранящееся во всех списках:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-24/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-24: Использование <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> для создания <code>List</code>, который мы можем изменять</span></p>
<p>Мы создаём значение, которое является экземпляром <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> и сохраняем его в переменной с именем <code>value</code>, чтобы получить к ней прямой доступ позже. Затем мы создаём <code>List</code> в переменной <code>a</code> с вариантом <code>Cons</code>, который содержит <code>value</code>. Нам нужно вызвать клонирование <code>value</code>, так как обе переменные <code>a</code> и <code>value</code> владеют внутренним значением <code>5</code>, а не передают владение из <code>value</code> в переменную <code>a</code> или не выполняют заимствование с помощью <code>a</code> переменной <code>value</code>.</p>
<p>Мы оборачиваем список у переменной <code>a</code> в вид <code>Rc&lt;T&gt;</code>, поэтому при создании списков в переменные <code>b</code> и <code>c</code> они оба могут ссылаться на <code>a</code>, что мы и сделали в приложении 15-18.</p>
<p>После создания списков <code>a</code>, <code>b</code> и <code>c</code> мы хотим добавить 10 к значению в <code>value</code>. Для этого вызовем <code>borrow_mut</code> у <code>value</code>, который использует функцию самостоятельного разыменования, о которой мы говорили в главе 5 (см. раздел <a href="ch05-03-method-syntax.html#wheres-the---operator">"Где находится оператор <code>-&gt;</code>?"</a><!-- ignore -->) во внутреннее значение <code>RefCell&lt;T&gt;</code>. Способ <code>borrow_mut</code> возвращает умный указатель <code>RefMut&lt;T&gt;</code>, и мы используя оператор разыменования, изменяем внутреннее значение.</p>
<p>Когда мы печатаем <code>a</code>, <code>b</code> и <code>c</code> то видим, что все они имеют изменённое значение равное 15, а не 5:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}
</code></pre>
<p>Эта техника довольно изящна! Используя <code>RefCell&lt;T&gt;</code>, мы получаем внешне неизменяемое значение <code>List</code>. Но мы можем использовать методы <code>RefCell&lt;T&gt;</code>, которые предоставляют доступ к его внутренностям, чтобы мы могли изменять наши данные, когда это необходимо. Проверка правил заимствования во время выполнения защищает нас от гонок данных, и иногда стоит немного пожертвовать производительностью ради такой гибкости наших структур данных. Обратите внимание, что <code>RefCell&lt;T&gt;</code> не работает для многопоточного кода! <code>Mutex&lt;T&gt;</code> - это thread-safe исполнение <code>RefCell&lt;T&gt;</code>, а <code>Mutex&lt;T&gt;</code> мы обсудим в главе 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Ссылочные-зацикливания-могут-приводить-к-утечке-памяти"><a class="header" href="#Ссылочные-зацикливания-могут-приводить-к-утечке-памяти">Ссылочные зацикливания могут приводить к утечке памяти</a></h2>
<p>Заверения безопасности памяти в Rust затрудняют, но не делают невозможным случайное выделение памяти, которое никогда не очищается (известное как <em>утечка памяти</em> ). Полное предотвращение утечек памяти не является одной из заверений Rust, а это означает, что утечки памяти безопасны в Rust. Мы видим, что Rust допускает утечку памяти с помощью <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code>: можно создавать ссылки, в которых элементы ссылаются друг на друга в цикле. Это создаёт утечки памяти, потому что счётчик ссылок каждого элемента в цикле никогда не достигнет 0, а значения никогда не будут удалены.</p>
<h3 id="Создание-ссылочного-зацикливания"><a class="header" href="#Создание-ссылочного-зацикливания">Создание ссылочного зацикливания</a></h3>
<p>Давайте посмотрим, как может произойти ситуация ссылочного зацикливания и как её предотвратить, начиная с определения перечисления <code>List</code> и способа <code>tail</code> в приложении 15-25:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-25/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-25: Объявление cons list, который содержит <code>RefCell&lt;T&gt;</code>, чтобы мы могли изменять то, на что ссылается экземпляр <code>Cons</code></span></p>
<p>Мы используем другую вариацию определения <code>List</code> из приложения 15-5. Второй элемент в  варианте <code>Cons</code> теперь <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, что означает, что вместо возможности менять значение <code>i32</code>, как мы делали в приложении 15-24, мы хотим менять значение <code>List</code>, на которое указывает вариант <code>Cons</code>. Мы также добавляем способ <code>tail</code>, чтобы нам было удобно обращаться ко второму элементу, если у нас есть вариант <code>Cons</code>.</p>
<p>В приложении 15-26 мы добавляем <code>main</code> функцию, которая использует определения приложения 15-25. Этот код создаёт список в переменной <code>a</code> и список <code>b</code>, который указывает на список <code>a</code>. Затем он изменяет список внутри <code>a</code> так, чтобы он указывал на <code>b</code>, создавая ссылочное зацикливание. В коде есть  указания <code>println!</code>, чтобы показать значения счётчиков ссылок в различных точках этого процесса.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-26/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-26: Создание ссылочного цикла из двух значений <code>List</code>, указывающих друг на друга</span></p>
<p>Мы создаём экземпляр <code>Rc&lt;List&gt;</code> содержащий значение <code>List</code> в переменной <code>a</code> с начальным списком <code>5, Nil</code>. Затем мы создаём экземпляр <code>Rc&lt;List&gt;</code> содержащий другое значение <code>List</code> в переменной <code>b</code>, которое содержит значение 10 и указывает на список в <code>a</code>.</p>
<p>Мы меняем <code>a</code> так, чтобы он указывал на <code>b</code> вместо <code>Nil</code>, создавая зацикленность. Мы делаем это с помощью способа <code>tail</code>, чтобы получить ссылку на <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> из переменной <code>a</code>, которую мы помещаем в переменную <code>link</code>. Затем мы используем способ <code>borrow_mut</code> из вида <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, чтобы изменить внутреннее значение вида <code>Rc&lt;List&gt;</code>, содержащего начальное значение <code>Nil</code> на значение вида <code>Rc&lt;List&gt;</code> взятое из переменной <code>b</code>.</p>
<p>Когда мы запускаем этот код, оставив последний <code>println!</code> закомментированным в данный момент, мы получим вывод:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-26/output.txt}}
</code></pre>
<p>Количество ссылок на экземпляры <code>Rc&lt;List&gt;</code> как в <code>a</code>, так и в <code>b</code> равно 2 после того, как мы заменили список в <code>a</code> на ссылку на <code>b</code>. В конце <code>main</code> Rust уничтожает переменную <code>b</code>, что уменьшает количество ссылок на <code>Rc&lt;List&gt;</code> из <code>b</code> с 2 до 1. Память, которую <code>Rc&lt;List&gt;</code> занимает в куче, не будет освобождена в этот момент, потому что количество ссылок на неё равно 1, а не 0. Затем Rust удаляет <code>a</code>, что уменьшает количество ссылок экземпляра <code>Rc&lt;List&gt;</code> в <code>a</code> с 2 до 1. Память этого экземпляра также не может быть освобождена, поскольку другой экземпляр <code>Rc&lt;List&gt;</code> по-прежнему ссылается на него. Таким образом, память, выделенная для списка не будет освобождена никогда. Чтобы наглядно представить этот цикл ссылок, мы создали диаграмму на рисунке 15-4.</p>
<img src="img/trpl15-04.svg" class="center" alt="Reference cycle of lists">
<p><span class="caption">Рисунок 15-4: Ссылочный цикл списков <code>a</code> и <code>b</code>, указывающих друг на друга</span></p>
<p>Если вы удалите последний комментарий с <code>println!</code> и запустите программу, Rust будет пытаться печатать зацикленность в <code>a</code>, указывающей на <code>b</code>, указывающей на <code>a</code> и так далее, пока не переполниться стек.</p>
<p>По сравнению с существующей программой, последствия создания цикла ссылок в этом примере не так страшны: сразу после создания цикла ссылок программа завершается. Однако если более сложная программа выделит много памяти в цикле и будет удерживать её в течение длительного времени, программа будет потреблять больше памяти, чем ей нужно, и может перенапрячь систему, что приведёт к исчерпанию доступной памяти.</p>
<p>Вызвать образование ссылочной зацикленности не просто, но и не невозможно. Если у вас есть значения <code>RefCell&lt;T&gt;</code> которые содержат значения <code>Rc&lt;T&gt;</code> или подобные вложенные сочетания видов с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте зацикленность; Вы не можете полагаться на то, что Rust их обнаружит. Создание ссылочной зацикленности являлось бы логической ошибкой в программе, для которой вы должны использовать самостоятельно е тесты, проверку кода и другие практики разработки программного обеспечения для её минимизации.</p>
<p>Другое решение для избежания ссылочной зацикленности - это реорганизация ваших структур данных, чтобы некоторые ссылки выражали владение, а другие - отсутствие владения. В результате можно иметь циклы, построенные на некоторых отношениях владения и некоторые не основанные на отношениях владения, тогда только отношения владения влияют на то, можно ли удалить значение. В приложении 15-25 мы всегда хотим, чтобы варианты <code>Cons</code> владели своим списком, поэтому реорганизация структуры данных невозможна. Давайте рассмотрим пример с использованием графов, состоящих из родительских и дочерних узлов, чтобы увидеть, когда отношения владения не являются подходящим способом предотвращения ссылочной зацикленности.</p>
<h3 id="Предотвращение-ссылочной-зацикленности-замена-умного-указателя-rct-на-weakt"><a class="header" href="#Предотвращение-ссылочной-зацикленности-замена-умного-указателя-rct-на-weakt">Предотвращение ссылочной зацикленности: замена умного указателя <code>Rc&lt;T&gt;</code> на <code>Weak&lt;T&gt;</code></a></h3>
<p>До сих пор мы выясняли, что вызов <code>Rc::clone</code> увеличивает <code>strong_count</code> экземпляра <code>Rc&lt;T&gt;</code>, а экземпляр <code>Rc&lt;T&gt;</code> удаляется, только если его <code>strong_count</code> равен 0. Вы также можете создать <em>слабую ссылку</em> на значение внутри экземпляра <code>Rc&lt;T&gt;</code>, вызвав <code>Rc::downgrade</code> и передав ссылку на <code>Rc&lt;T&gt;</code>. Сильные ссылки - это то с помощью чего вы можете поделиться владением экземпляра <code>Rc&lt;T&gt;</code>. Слабые ссылки не отражают связи владения, и их подсчёт не влияет на то, когда экземпляр <code>Rc&lt;T&gt;</code> будет очищен. Они не приведут к ссылочному циклу, потому что любой цикл, включающий несколько слабых ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет равным 0.</p>
<p>Когда вы вызываете <code>Rc::downgrade</code>, вы получаете умный указатель вида <code>Weak&lt;T&gt;</code>. Вместо того чтобы увеличить <code>strong_count</code> в экземпляре <code>Rc&lt;T&gt;</code> на 1, вызов <code>Rc::downgrade</code> увеличивает <code>weak_count</code> на 1. Вид <code>Rc&lt;T&gt;</code> использует <code>weak_count</code> для отслеживания количества существующих ссылок <code>Weak&lt;T&gt;</code>, подобно <code>strong_count</code>. Разница в том, что <code>weak_count</code> не должен быть равен 0, чтобы экземпляр <code>Rc&lt;T&gt;</code> мог быть удалён.</p>
<p>Поскольку значение, на которое ссылается <code>Weak&lt;T&gt;</code> могло быть удалено, то необходимо убедиться, что это значение все ещё существует, чтобы сделать что-либо со значением на которое указывает <code>Weak&lt;T&gt;</code>. Делайте это вызывая способ <code>upgrade</code> у экземпляра вида <code>Weak&lt;T&gt;</code>, который вернёт <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Вы получите результат <code>Some</code>, если значение <code>Rc&lt;T&gt;</code> ещё не было удалено и результат <code>None</code>, если значение <code>Rc&lt;T&gt;</code> было удалено. Поскольку <code>upgrade</code> возвращает вид <code>Option&lt;T&gt;</code>, Rust обеспечит обработку обоих случаев <code>Some</code> и <code>None</code> и не будет некорректного указателя.</p>
<p>В качестве примера, вместо того чтобы использовать список чей элемент знает только о следующем элементе, мы создадим дерево, чьи элементы знают о своих дочерних элементах <em>и</em> о своих родительских элементах.</p>
<h4 id="Создание-древовидной-структуры-данных-node-с-дочерними-узлами"><a class="header" href="#Создание-древовидной-структуры-данных-node-с-дочерними-узлами">Создание древовидной структуры данных: <code>Node</code> с дочерними узлами</a></h4>
<p>Для начала мы построим дерево с узлами, которые знают о своих дочерних узлах. Мы создадим структуру с именем <code>Node</code>, которая будет содержать собственное значение <code>i32</code>, а также ссылки на его дочерние значения <code>Node</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы хотим, чтобы <code>Node</code> владел своими дочерними узлами и мы хотим поделиться этим владением с переменными так, чтобы мы могли напрямую обращаться к каждому <code>Node</code> в дереве. Для этого мы определяем внутренние элементы вида <code>Vec&lt;T&gt;</code> как значения вида <code>Rc&lt;Node&gt;</code>. Мы также хотим изменять те узлы, которые являются дочерними по отношению к другому узлу, поэтому у нас есть вид <code>RefCell&lt;T&gt;</code> в поле <code>children</code> оборачивающий вид <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Далее мы будем использовать наше определение структуры и создадим один экземпляр <code>Node</code> с именем <code>leaf</code> со значением 3 и без дочерних элементов, а другой экземпляр с именем <code>branch</code> со значением 5 и <code>leaf</code> в качестве одного из его дочерних элементов, как показано в приложении 15-27:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:there}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-27: Создание узла <code>leaf</code> без дочерних элементов и узла <code>branch</code> с <code>leaf</code> в качестве одного из дочерних элементов</span></p>
<p>Мы клонируем  содержимое <code>Rc&lt;Node&gt;</code> из переменной  <code>leaf</code> и сохраняем его в переменной <code>branch</code>, что означает, что <code>Node</code> в  <code>leaf</code> теперь имеет двух владельцев: <code>leaf</code> и <code>branch</code>. Мы можем получить доступ из <code>branch</code> к <code>leaf</code> через обращение <code>branch.children</code>, но нет способа добраться из  <code>leaf</code> к <code>branch</code>. Причина в том, что <code>leaf</code> не имеет ссылки на <code>branch</code> и не знает, что они связаны. Мы хотим, чтобы <code>leaf</code> знал, что <code>branch</code> является его родителем. Мы сделаем это далее.</p>
<h4 id="Добавление-ссылки-от-ребёнка-к-его-родителю"><a class="header" href="#Добавление-ссылки-от-ребёнка-к-его-родителю">Добавление ссылки от ребёнка к его родителю</a></h4>
<p>Для того, чтобы дочерний узел знал о своём родительском узле нужно добавить поле <code>parent</code> в наше определение структуры <code>Node</code>. Проблема в том, чтобы решить, каким должен быть вид <code>parent</code>. Мы знаем, что он не может содержать <code>Rc&lt;T&gt;</code>, потому что это создаст ссылочную зацикленность с <code>leaf.parent</code> указывающей на <code>branch</code> и <code>branch.children</code>, указывающей на <code>leaf</code>, что приведёт к тому, что их значения <code>strong_count</code> никогда не будут равны 0.</p>
<p>Подумаем об этих отношениях по-другому, родительский узел должен владеть своими потомками: если родительский узел удаляется, его дочерние узлы также должны быть удалены. Однако дочерний элемент не должен владеть своим родителем: если мы удаляем дочерний узел то родительский элемент все равно должен существовать. Это случай для использования слабых ссылок!</p>
<p>Поэтому вместо <code>Rc&lt;T&gt;</code> мы сделаем так, чтобы поле <code>parent</code> использовало вид <code>Weak&lt;T&gt;</code>, а именно <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Теперь наше определение структуры <code>Node</code> выглядит так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Узел сможет ссылаться на свой родительский узел, но не владеет своим родителем. В приложении 15-28 мы обновляем <code>main</code> на использование нового определения так, чтобы у узла <code>leaf</code> был бы способ ссылаться на его родительский узел <code>branch</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:there}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-28: Узел <code>leaf</code> со слабой ссылкой на его родительский узел <code>branch</code></span></p>
<p>Создание узла <code>leaf</code> выглядит подобно примеру из Приложения 15-27, за исключением поля <code>parent</code>: <code>leaf</code> изначально не имеет родителя, поэтому мы создаём новый, пустой экземпляр ссылки <code>Weak&lt;Node&gt;</code>.</p>
<p>На этом этапе, когда мы пытаемся получить ссылку на родительский узел у узла <code>leaf</code> с помощью способа <code>upgrade</code>, мы получаем значение <code>None</code>. Мы видим это в выводе первой указания <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Когда мы создаём узел <code>branch</code> у него также будет новая ссылка вида <code>Weak&lt;Node&gt;</code> в поле <code>parent</code>, потому что узел <code>branch</code> не имеет своего родительского узла. У нас все ещё есть <code>leaf</code> как один из потомков узла <code>branch</code>. Когда мы получили экземпляр <code>Node</code> в переменной <code>branch</code>, мы можем изменить переменную <code>leaf</code> чтобы дать ей <code>Weak&lt;Node&gt;</code> ссылку на её родителя. Мы используем способ <code>borrow_mut</code> у вида <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> поля <code>parent</code> у <code>leaf</code>, а затем используем функцию <code>Rc::downgrade</code> для создания <code>Weak&lt;Node&gt;</code> ссылки на <code>branch</code> из <code>Rc&lt;Node&gt;</code> в <code>branch</code>.</p>
<p>Когда мы снова напечатаем родителя <code>leaf</code> то в этот раз мы получим вариант <code>Some</code> содержащий <code>branch</code>, теперь <code>leaf</code> может получить доступ к своему родителю! Когда мы печатаем <code>leaf</code>, мы также избегаем цикла, который в конечном итоге заканчивался переполнением стека, как в приложении 15-26; ссылки вида <code>Weak&lt;Node&gt;</code>  печатаются как <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Отсутствие бесконечного вывода означает, что этот код не создал ссылочной зацикленности. Мы также можем сказать это, посмотрев на значения, которые мы получаем при вызове <code>Rc::strong_count</code> и <code>Rc::weak_count</code>.</p>
<h4 id="Визуализация-изменений-в-strong_count-и-weak_count"><a class="header" href="#Визуализация-изменений-в-strong_count-и-weak_count">Визуализация изменений в <code>strong_count</code> и <code>weak_count</code></a></h4>
<p>Давайте посмотрим, как изменяются значения <code>strong_count</code> и <code>weak_count</code> экземпляров вида <code>Rc&lt;Node&gt;</code> с помощью создания новой внутренней области видимости и перемещая создания экземпляра <code>branch</code> в эту область. Таким образом можно увидеть, что происходит, когда <code>branch</code> создаётся и затем удаляется при выходе из области видимости. Изменения показаны в приложении 15-29:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-29/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-29: Создание <code>branch</code> во внутренней области видимости и подсчёт сильных и слабых ссылок</span></p>
<p>После того, как <code>leaf</code> создан его <code>Rc&lt;Node&gt;</code> имеет значения strong count равное 1 и weak count равное 0. Во внутренней области мы создаём <code>branch</code> и связываем её с <code>leaf</code>, после чего при печати значений счётчиков <code>Rc&lt;Node&gt;</code> в <code>branch</code> они будет иметь strong count 1 и weak count 1 (для <code>leaf.parent</code> указывающего на <code>branch</code> с <code>Weak&lt;Node&gt;</code> ). Когда мы распечатаем счётчики из <code>leaf</code>, мы увидим, что они будут иметь strong count 2, потому что <code>branch</code> теперь имеет клон <code>Rc&lt;Node&gt;</code> переменной <code>leaf</code> хранящийся в <code>branch.children</code>, но все равно будет иметь weak count 0.</p>
<p>Когда заканчивается внутренняя область видимости,  <code>branch</code> выходит из области видимости и strong count <code>Rc&lt;Node&gt;</code> уменьшается до 0, поэтому его <code>Node</code> удаляется. Weak count 1 из <code>leaf.parent</code> не имеет никакого отношения к тому, был ли <code>Node</code> удалён, поэтому не будет никаких утечек памяти!</p>
<p>Если мы попытаемся получить доступ к родителю переменной <code>leaf</code> после окончания области видимости, мы снова получим значение <code>None</code>. В конце программы <code>Rc&lt;Node&gt;</code> внутри <code>leaf</code> имеет strong count 1 и weak count 0 потому что переменная <code>leaf</code> снова является единственной ссылкой на <code>Rc&lt;Node&gt;</code>.</p>
<p>Вся логика, которая управляет счётчиками и сбросом их значений, встроена внутри <code>Rc&lt;T&gt;</code> и <code>Weak&lt;T&gt;</code> и их реализаций типажа <code>Drop</code>. Указав, что отношение из дочернего к родительскому элементу должно быть ссылкой вида  <code>Weak&lt;T&gt;</code> в определении <code>Node</code>, делает возможным иметь родительские узлы, указывающие на дочерние узлы и наоборот, не создавая ссылочной зацикленности и утечек памяти.</p>
<h2 id="Итоги-12"><a class="header" href="#Итоги-12">Итоги</a></h2>
<p>В этой главе рассказано как использовать умные указатели для обеспечения различных заверений и соглашений по сравнению с обычными ссылками, которые Rust использует по умолчанию. Вид <code>Box&lt;T&gt;</code> имеет известный размер и указывает на данные размещённые в куче. Вид <code>Rc&lt;T&gt;</code> отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев. Вид <code>RefCell&lt;T&gt;</code> с его внутренней изменяемостью предоставляет вид, который можно использовать при необходимости неизменного вида, но необходимости изменить внутреннее значение этого типа; он также обеспечивает соблюдение правил заимствования во время выполнения, а не во время сборки.</p>
<p>Мы обсудили также типажи <code>Deref</code> и <code>Drop</code>, которые обеспечивают большую функциональность умных указателей. Мы исследовали ссылочную зацикленность, которая может вызывать утечки памяти и как это предотвратить с помощью вида <code>Weak&lt;T&gt;</code>.</p>
<p>Если эта глава вызвала у вас влечение и вы хотите реализовать свои собственные умные указатели, обратитесь к <a href="https://doc.rust-lang.org/nomicon/index.html">"The Rustonomicon"</a> за более полезной сведениями.</p>
<p>Далее мы поговорим о параллелизме в Rust. Вы даже узнаете о нескольких новых умных указателях.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Многопоточность-без-страха"><a class="header" href="#Многопоточность-без-страха">Многопоточность без страха</a></h1>
<p>Безопасное и эффективное управление многопоточным программированием — ещё одна из основных целей Rust. <em>Многопоточное программирование</em>, когда разные части программы выполняются независимо, и <em>параллельное программирование</em>, когда разные части программы выполняются одновременно, становятся всё более важными, поскольку всё больше компьютеров используют преимущества нескольких процессоров. Исторически программирование в этих условиях было сложным и подверженным ошибкам: Rust надеется изменить это.</p>
<p>Первоначально приказ Rust считала, что обеспечение безопасности памяти и предотвращение проблем многопоточности — это две отдельные проблемы, которые необходимо решать различными способами. Со временем приказ обнаружила, что системы владения и система видов являются мощным набором средств, помогающих управлять безопасностью памяти <em>и</em> проблемами многопоточного параллелизма! Используя владение и проверку видов, многие ошибки многопоточности являются ошибками времени сборки в Rust, а не ошибками времени выполнения. Поэтому вместо того, чтобы тратить много времени на попытки воспроизвести точные обстоятельства, при которых возникает ошибка многопоточности во время выполнения, некорректный код будет отклонён с ошибкой. В результате вы можете исправить свой код во время работы над ним, а не после развёртывания на рабочем сервере. Мы назвали этот особенность Rust <em>бесстрашной</em> <em>многопоточностью</em>. Бесстрашная многопоточность позволяет вам писать код, который не содержит скрытых ошибок и легко реорганизуется без внесения новых.</p>
<blockquote>
<p>Примечание: для простоты мы будем называть многие проблемы <em>многопоточными</em>, хотя более точный термин здесь <em> — многопоточные и/или параллельные</em>. Если бы эта книга была о многопоточности и/или параллелизме, мы были бы более определены. В этой главе, пожалуйста, всякий раз, когда мы используем термин <em>«многопоточный»</em>, мысленно замените на понятие <em>«многопоточный и/или параллельный»</em>.</p>
</blockquote>
<p>Многие языки предлагают довольно консервативные решения проблем многопоточности. Например, Erlang обладает элегантной функциональностью для многопоточности при передаче сообщений, но не определяет ясных способов совместного использования состояния между потоками. Поддержка только подмножества возможных решений является разумной стратегией для языков более высокого уровня, поскольку язык более высокого уровня обещает выгоду при отказе от некоторого управления над получением абстракций. Однако ожидается, что языки низкого уровня обеспечат решение с наилучшей производительностью в любой именно ситуации и будут иметь меньше абстракций по сравнению с аппаратным обеспечением. Поэтому Rust предлагает множество средств для моделирования проблем любым способом, который подходит для вашей ситуации и требований.</p>
<p>Вот темы, которые мы рассмотрим в этой главе:</p>
<ul>
<li>Как создать потоки для одновременного запуска нескольких фрагментов кода</li>
<li>Многопоточность <em>передачи сообщений</em>, где потоки передают сообщения между потоками</li>
<li>Многопоточность для <em>совместно используемого состояния</em>, когда несколько потоков имеют доступ к некоторому фрагменту данных</li>
<li>Типажи <code>Sync</code> и <code>Send</code>, которые расширяют заверения многопоточности в Rust для пользовательских видов, а также видов, предоставляемых встроенной библиотекой</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-потоков-для-одновременного-выполнения-кода"><a class="header" href="#Использование-потоков-для-одновременного-выполнения-кода">Использование потоков для одновременного выполнения кода</a></h2>
<p>В большинстве современных операционных систем программный код выполняется в виде <em>процесса</em>, причём операционная система способна управлять несколькими процессами сразу. Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно. Конструкция, благодаря которой эти независимые части выполняются, называется <em>потоком</em>. Например, веб-сервер может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.</p>
<p>Разбиение вычислений на несколько потоков может повысить производительность программы, поскольку программа выполняет несколько задач одновременно, но такое разбиение также добавляет сложности. Поскольку потоки могут работать одновременно, нет чёткой заверения, определяющей порядок выполнения частей вашего кода в разных потоках. Это может привести к таким проблемам, как:</p>
<ul>
<li>Состояния гонки, когда потоки обращаются к данным, либо ресурсам, несогласованно.</li>
<li>Взаимные блокировки, когда два потока ожидают друг друга, не позволяя тем самым продолжить работу каждому из потоков.</li>
<li>Ошибки, которые случаются только в определённых ситуациях, которые трудно воспроизвести и, соответственно, трудно надёжно исправить.</li>
</ul>
<p>Rust пытается смягчить негативные последствия использования потоков, но программирование в многопоточном среде все ещё требует тщательного обдумывания структуры кода, которая отличается от структуры кода программ, работающих в одном потоке.</p>
<p>Языки программирования реализуют потоки несколькими различными способами, и многие операционные системы предоставляют API, который язык может вызывать для создания новых потоков. Стандартная библиотека Rust использует модель реализации потоков <em>1:1</em>, при которой одному потоку операционной системы соответствует ровно один "языковой" поток. Существуют крейты, в которых реализованы другие модели многопоточности, отличающиеся от модели 1:1.</p>
<h3 id="Создание-нового-потока-с-помощью--spawn"><a class="header" href="#Создание-нового-потока-с-помощью--spawn">Создание нового потока с помощью  <code>spawn</code></a></h3>
<p>Чтобы создать новый поток, мы вызываем функцию <code>thread::spawn</code> и передаём ей замыкание (мы говорили о замыканиях в главе 13), содержащее код, который мы хотим запустить в новом потоке. Пример в приложении 16-1 печатает некоторый текст из основного потока, а также другой текст из нового потока:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-1: Создание нового потока для печати определённого текста, в то время как основной поток печатает что-то другое</span></p>
<p>Обратите внимание, что когда основной поток программы на Rust завершается, все порождённые потоки закрываются, независимо от того, завершили они работу или нет. Вывод этой программы может каждый раз немного отличаться, но он будет выглядеть примерно так:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Вызовы <code>thread::sleep</code> заставляют поток на короткое время останавливать своё выполнение, позволяя выполняться другим потокам. Очерёдность выполнения потоков вероятно будет меняться, но это не обязательно: это зависит от того, как ваша операционная система планирует потоки. В этом цикле основной поток печатает первым, несмотря на то, что указание печати из порождённого потока появляется раньше в коде. И даже несмотря на то, что мы указали порождённый поток печатать до тех пор, пока значение <code>i</code> не достигнет числа 9, оно успело дойти только до 5, когда основной поток завершился.</p>
<p>Если вы запустите этот код и увидите вывод только из основного потока или не увидите печати из других потоков, попробуйте увеличить числа в рядах, чтобы дать операционной системе больше возможностей для переключения между потоками.</p>
<h3 id="Ожидание-завершения-работы-всех-потоков-используя-join"><a class="header" href="#Ожидание-завершения-работы-всех-потоков-используя-join">Ожидание завершения работы всех потоков используя <code>join</code></a></h3>
<p>Код в приложении 16-1 преждевременно останавливает порождённый поток в большинстве случаев, из-за завершения основного потока. Более того, так как порядок выполнения потоков чётко не определён, этот код не даёт заверения, что порождённый поток вообще начнёт исполняться!</p>
<p>Мы можем исправить проблему, когда созданный поток не запускается или завершается преждевременно, сохранив возвращаемое значение <code>thread::spawn</code> в какой-либо переменной. Вид возвращаемого значения <code>thread::spawn</code> — <code>JoinHandle</code> . <code>JoinHandle</code> — это владеющее значение, которое, при вызове способа <code>join</code> , будет ждать завершения своего потока. Приложение 16-2 отображает, как использовать <code>JoinHandle</code> потока, созданного в приложении 16-1, и вызывать функцию <code>join</code> , для того, чтобы убедиться, что порождённый поток завершится раньше, чем поток <code>main</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-02/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-2. Сохранение значения <code>JoinHandle</code> потока <code>thread::spawn</code> , обеспечивающее, что поток выполнит всю необходимую работу, перед тем, как завершится</span></p>
<p>Вызов <code>join</code> у дескриптора блокирует текущий поток, пока поток, представленный дескриптором не завершится. <em>Блокировка</em> потока означает, что потоку запрещено выполнять работу или выходить из него. Поскольку мы поместили вызов <code>join</code> после цикла <code>for</code> основного потока, выполнение приложения 16-2 должно привести к выводу, подобному следующему:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Два потока продолжают чередоваться, но основной поток находится в ожидании из-за вызова <code>handle.join()</code> и не завершается до тех пор, пока не завершится запущенный поток.</p>
<p>Но давайте посмотрим, что произойдёт, если мы вместо этого переместим <code>handle.join()</code> перед циклом <code>for</code> в <code>main</code>, например так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/no-listing-01-join-too-early/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p>Основной поток будет ждать завершения порождённого потока, а затем запустит свой цикл <code>for</code> , поэтому выходные данные больше не будут чередоваться, как показано ниже:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Небольшие подробности, такие как место вызова <code>join</code>, могут повлиять на то, выполняются ли ваши потоки одновременно.</p>
<h3 id="Использование-move-замыканий-в-потоках"><a class="header" href="#Использование-move-замыканий-в-потоках">Использование <code>move</code>-замыканий в потоках</a></h3>
<p>Мы часто используем ключевое слово <code>move</code> с замыканиями, переданными в <code>thread::spawn</code>, потому что в этом случае замыкание получает из окружения права владения на используемые им значения, таким образом передавая права владения этими значениями от одного потока к другому. В разделе <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">"Захват ссылок или перемещение прав владения"</a> главы 13 мы обсудили <code>move</code> в среде замыканий. Теперь мы сосредоточимся на взаимодействии между <code>move</code> и <code>thread::spawn</code>.</p>
<p>Обратите внимание, что в приложении 16-1 замыкание, которое мы передаём в <code>thread::spawn</code> не принимает переменных: мы не используем никаких данных из основного потока в коде порождённого потока. Чтобы использовать данные из основного потока в порождённом потоке, замыкание порождённого потока должно захватывать значения, которые ему необходимы. Приложение 16-3 показывает попытку создать вектор в главном потоке и использовать его в порождённом потоке. Тем не менее, это не будет работать, как вы увидите через мгновение.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-3: Попытка использовать вектор, созданный основным потоком, в другом потоке</span></p>
<p>Замыкание использует переменную <code>v</code>, поэтому оно захватит <code>v</code> и сделает его частью окружения замыкания. Поскольку <code>thread::spawn</code> запускает это замыкание в новом потоке, мы должны иметь доступ к <code>v</code> внутри этого нового потока. Но при сборки этого примера, мы получаем следующую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch16-fearless-concurrency/listing-16-03/output.txt}}
</code></pre>
<p>Rust <em>выводит</em> как захватить <code>v</code> и так как в <code>println!</code> нужна только ссылка на <code>v</code>, то замыкание пытается заимствовать <code>v</code>. Однако есть проблема: Rust не может определить, как долго будет работать порождённый поток, поэтому он не знает, будет ли всегда действительной ссылка на <code>v</code>.</p>
<p>В приложении 16-4 приведён сценарий, который с большей вероятностью будет иметь ссылку на <code>v</code>, что будет недопустимо:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-4. Поток с замыканием, который пытается захватить ссылку на <code>v</code> из основного потока, удаляющего <code>v</code></span></p>
<p>Если бы Rust позволил нам запустить этот код, есть вероятность, что порождённый поток был бы немедленно переведён в фоновый режим, не выполнив ничего. Порождённый поток имеет ссылку на <code>v</code>, но основной поток немедленно удаляет <code>v</code> , используя функцию <code>drop</code> , которую мы обсуждали в главе 15. Затем, когда порождённый поток начинает выполняться, <code>v</code> уже не существует, поэтому ссылка на него также будет недействительной. О, нет!</p>
<p>Чтобы исправить ошибку сборщика в приложении 16-3, мы можем использовать совет из сообщения об ошибке:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Добавляя ключевое слово <code>move</code> перед замыканием, мы заставляем замыкание забирать используемые значения во владение, вместо того, чтобы позволить Rust вывести необходимость заимствования значения. Модификация Приложения 16-3, показанная в Приложении 16-5, будет собрана и запущена так, как мы ожидаем:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-5. Использование ключевого слова <code>move</code> , чтобы замыкание стало владельцем используемых им значений.</span></p>
<p>У нас может возникнуть соблазн попробовать то же самое, чтобы исправить код в приложении 16.4, где основной поток вызывал <code>drop</code> с помощью замыкания <code>move</code> . Однако это исправление не сработает, потому что то, что пытается сделать приложение 16.4, запрещено по другой причине. Если мы добавим <code>move</code> к замыканию, мы переместим <code>v</code> в окружение замыкания и больше не сможем вызывать для него <code>drop</code> в основном потоке. Вместо этого мы получим эту ошибку сборщика:</p>
<pre><code class="language-console">{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}
</code></pre>
<p>Правила владения Rust снова нас спасли! Мы получили ошибку кода из приложения 16-3, потому что Rust был консервативен и заимствовал <code>v</code> только для потока, что означало, что основной поток теоретически может сделать недействительной ссылку на порождённый поток. Сообщив Rust о передаче владения <code>v</code> в порождаемый поток, мы заверяем Rust, что основной поток больше не будет использовать <code>v</code>. Если мы изменим Приложение 16-4 таким же образом, то мы нарушаем правила владения при попытке использовать <code>v</code> в главном потоке. Ключевое слово <code>move</code> отменяет основное консервативное поведение Rust по заимствованию, что не позволяет нам нарушать правила владения.</p>
<p>Имея достаточное понимание потоков и API потоков, давайте посмотрим, что мы можем <em>делать</em> с помощью потоков.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Передача-данных-с-помощью-сообщений-между-потоками"><a class="header" href="#Передача-данных-с-помощью-сообщений-между-потоками">Передача данных с помощью сообщений между потоками</a></h2>
<p>Всё большую популярность для обеспечения безопасной многопоточности набирает способ, называемый <em>передача сообщений</em>. В этом случае потоки или акторы взаимодействуют друг с другом путём отправки сообщений с данными. Мысль этого подхода выражена в слогане из <a href="https://golang.org/doc/effective_go.html#concurrency">документации языка Go</a> таким образом: «Не стоит передавать сведения с помощью разделяемой памяти; лучше делитесь памятью, передавая сведения».</p>
<p>Для обеспечения отправки многопоточных сообщений в встроенной библиотеке языка Rust реализованы <em>потоки</em>. Поток в программировании - это общепринятый механизм, с помощью которого данные из одного потока отправляются другому потоку.</p>
<p>Вы можете представить поток в программировании как направленное движение воды, например как ручей или реку. Если вы поместите какую-нибудь вещь на воду, например резиновую уточку, она будет плыть вниз по течению до тех пор, пока это течение не кончится.</p>
<p>Поток состоит из двух половин: передатчика и приёмника. Передатчик — это место вверх по течению, где вы опускаете резиновых уточек в реку, а приёмник — это место, где резиновые уточки оказываются в конце пути. Одна часть вашего кода вызывает способы передатчика с данными, которые вы хотите отправить, а другая часть проверяет принимающую сторону на наличие поступающих сообщений. Поток считается <em>закрытым</em> , если либо передающая, либо принимающая его половина уничтожена.</p>
<p>Давайте создадим программу, в которой один поток будет генерировать значения и отправлять их в поток, а другой поток будет получать значения и распечатывать их. Мы будем отправлять между потоками простые значения, используя поток, чтобы изобразить эту функцию. После того, как вы ознакомитесь с этим способом, вы сможете использовать потоки с любыми потоками, которым необходимо взаимодействовать друг с другом. Это может быть например система чата или система, в которой несколько вычислительных потоков выполняют свою часть расчёта, а затем отправляют эту часть в отдельный поток, который уже агрегирует полученные результаты.</p>
<p>Сначала в приложении 16-6 мы создадим поток, но не будем ничего с ним делать. Обратите внимание, что этот код ещё не собирается, потому что Rust не может сказать, какой вид значений мы хотим отправить через поток.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-06/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-6: Создание потока и присваивание двух значений переменным <code>tx</code> и <code>rx</code></span></p>
<p>Мы создаём новый поток, используя функцию <code>mpsc::channel</code>; <code>mpsc</code> означает <em>несколько производителей, один потребитель</em> (multiple producer, single consumer). Коротко, способ которым стандартная библиотека Rust реализует потоки, означает, что поток может иметь несколько <em>отправляющих</em> источников генерирующих значения, но только одну <em>принимающую</em> сторону, которая потребляет эти значения. Представьте, что несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке. Сейчас мы пока начнём с одного производителя, а когда пример заработает,  добавим ещё несколько.</p>
<p>Функция <code>mpsc::channel</code> возвращает кортеж, первый элемент которого является отправляющей стороной (передатчиком), а вторым элементом является принимающая сторона (получатель). Аббревиатуры <code>tx</code> и <code>rx</code> традиционно используются во многих полях для <em>передатчика</em> и <em>приёмника</em> соответственно, поэтому мы называем соответствующие переменные именно так. Мы используем указанию <code>let</code> с шаблоном, который деструктурирует кортежи; мы обсудим использование шаблонов в указаниях <code>let</code> и деструктуризацию в главе 18. А пока знайте, что описанное использование указания <code>let</code> является удобным способом извлечения частей кортежа, возвращаемых <code>mpsc::channel</code> .</p>
<p>Давайте переместим передающую часть в порождённый поток так, чтобы он отправлял одну строку и чтобы таким образом, порождённый поток связывался с основным потоком, как показано в приложении 16-7. Это похоже на то, как если бы вы поместили резиновую утку в реку вверх по течению или отправили сообщение чата из одного потока в другой.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-07/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-7: Перемещение <code>tx</code> в созданный поток и отправка сообщения «привет»</span></p>
<p>Опять же, мы используем <code>thread::spawn</code> для создания нового потока, а затем используем <code>move</code> для перемещения <code>tx</code> в замыкание, чтобы порождённый поток владел <code>tx</code> . Порождённый поток должен владеть передатчиком, чтобы иметь возможность отправлять сообщения через поток. Передатчик имеет способ <code>send</code> , который принимает значение, которое мы хотим отправить. Способ <code>send</code> возвращает вид <code>Result&lt;T, E&gt;</code> , поэтому, если получатель уже удалён и отправить значение некуда, действие отправки вернёт ошибку. В этом примере мы вызываем <code>unwrap</code> для паники в случае ошибки. В реальном приложении мы обработали бы эту ситуацию более корректно: вернитесь к главе 9, если хотите ещё раз разобрать стратегии правильной обработки ошибок.</p>
<p>В приложении 16-8 мы получим значение от приёмника в основном потоке. Это похоже на извлечение резиновой уточки из воды в конце реки или получение сообщения в чате.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-08/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-8: В основном потоке получаем сообщение "hi" и печатаем его</span></p>
<p>Получатель имеет два важных способа: <code>recv</code> и <code>try_recv</code>. Мы используем <code>recv</code>, что является сокращением от <em>receive</em>, который блокирует выполнение основного потока и ждёт, пока данные не будут переданы по потоку. Как только значение будет получено, <code>recv</code> вернёт его в виде <code>Result&lt;T, E&gt;</code>. Когда поток закроется, <code>recv</code> вернёт ошибку, чтобы дать понять, что больше никаких сообщений не поступит.</p>
<p>В свою очередь, способ try_recv не блокирует, а сразу возвращает результат <code>Result&lt;T, E&gt;</code>: значение Ok, содержащее сообщение, если оно доступно или значение Err, если никаких сообщений не поступило. Использование try_recv полезно, если у этого потока есть и другая работа в то время, пока происходит ожидание сообщений: так, мы можем написать цикл, который вызывает try_recv время от времени, обрабатывает сообщение, если оно доступно, а в промежутке выполняет другую работу до того момента, как вновь будет произведена проверка.</p>
<p>Мы использовали <code>recv</code> в этом примере для простоты; у нас нет никакой другой работы для основного потока, кроме как ждать сообщений, поэтому блокировка основного потока уместна.</p>
<p>При запуске кода приложения 16-8, мы увидим значение, напечатанное из основного потока:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Отлично!</p>
<h3 id="потоки-и-передача-владения"><a class="header" href="#потоки-и-передача-владения">потоки и передача владения</a></h3>
<p>Правила владения играют жизненно важную роль в отправке сообщений, потому что они помогают писать безопасный многопоточный код. Предотвращение ошибок в многопоточном программировании является преимуществом для размышлений о владении во всех ваших Rust программах. Давайте проведём эксперимент, чтобы показать как потоки и владение действуют совместно для предотвращения проблем: мы попытаемся использовать значение <code>val</code> в порождённом потоке <em>после</em> того как отправим его в поток. Попробуйте собрать код в приложении 16-9, чтобы понять, почему этот код не разрешён:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-09/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-9: Попытка использовать <code>val</code> после того, как мы отправили его по потоку</span></p>
<p>Здесь мы пытаемся напечатать значение <code>val</code> после того, как отправили его в поток вызвав <code>tx.send</code>. Разрешить это было бы плохой идеей: после того, как значение было отправлено в другой поток, текущий поток мог бы изменить или удалить значение, прежде чем мы попытались бы использовать значение снова. Потенциально изменения в другом потоке могут привести к ошибкам или не ожидаемым результатам из-за противоречивых или несуществующих данных. Однако Rust выдаёт нам ошибку, если мы пытаемся собрать код в приложении 16-9:</p>
<pre><code class="language-console">{{#include ../listings/ch16-fearless-concurrency/listing-16-09/output.txt}}
</code></pre>
<p>Наша ошибка для многопоточности привела к ошибке сборки. Функция <code>send</code> вступает во владение своим свойствоом и когда значение перемещается, получатель становится владельцем этого свойства. Это останавливает нас от случайного использования значения снова после его отправки; анализатор заимствования проверяет, что все в порядке.</p>
<h3 id="Отправка-нескольких-значений-и-ожидание-получателем"><a class="header" href="#Отправка-нескольких-значений-и-ожидание-получателем">Отправка нескольких значений и ожидание получателем</a></h3>
<p>Код в приложении 16-8 собирается и выполняется, но в нем неясно показано то, что два отдельных потока общаются друг с другом через поток. В приложении 16-10 мы внесли некоторые изменения, которые докажут, что код в приложении 16-8 работает одновременно: порождённый поток теперь будет отправлять несколько сообщений и делать паузу на секунду между каждым сообщением.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-10/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-10: Отправка нескольких сообщений и пауза между ними</span></p>
<p>На этот раз порождённый поток имеет вектор строк, которые мы хотим отправить основному потоку. Мы перебираем их, отправляя каждую строку по отдельности и делаем паузу между ними, вызывая функцию <code>thread::sleep</code> со значением <code>Duration</code> равным 1 секунде.</p>
<p>В основном потоке мы больше не вызываем функцию <code>recv</code> явно: вместо этого мы используем <code>rx</code> как повторитель. Для каждого полученного значения мы печатаем его. Когда поток будет закрыт, повторение закончится.</p>
<p>При выполнении кода в приложении 16-10 вы должны увидеть следующий вывод с паузой в 1 секунду между каждой строкой:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Поскольку у нас нет кода, который приостанавливает или задерживает цикл <code>for</code> в основном потоке, мы можем сказать, что основной поток ожидает получения значений из порождённого потока.</p>
<h3 id="Создание-нескольких-отправителей-путём-клонирования-передатчика"><a class="header" href="#Создание-нескольких-отправителей-путём-клонирования-передатчика">Создание нескольких отправителей путём клонирования передатчика</a></h3>
<p>Ранее мы упоминали, что <code>mpsc</code> — это аббревиатура от <em>множество поставщиков, один потребитель</em> . Давайте используем <code>mpsc</code> в полной мере и расширим код в приложении 16.10, создав несколько потоков, которые отправляют значения одному и тому же получателю. Мы можем сделать это, клонировав передатчик, как показано в приложении 16.11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-11/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 16-11: Отправка нескольких сообщений от нескольких производителей</span></p>
<p>На этот раз, прежде чем мы создадим первый порождённый поток, мы вызовем функцию <code>clone</code> на передатчике. В результате мы получим новый передатчик, который мы сможем передать первому порождённому потоку. Исходный передатчик мы передадим второму порождённому потоку. Это даст нам два потока, каждый из которых отправляет разные сообщения одному получателю.</p>
<p>Когда вы запустите код, вывод должен выглядеть примерно так:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Вы можете увидеть значения в другом порядке, в зависимости от вашей системы. Именно такое поведение делает параллелизм как важным, так и  сложным. Если вы поэкспериментируете с <code>thread::sleep</code> , задавая различные значения переменной в разных потоках, каждый запуск будет более недетерминированным и каждый раз будут выводиться разные данные.</p>
<p>Теперь, когда мы посмотрели, как работают потоки, давайте рассмотрим другой способ многопоточности.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Многопоточное-разделяемое-состояние"><a class="header" href="#Многопоточное-разделяемое-состояние">Многопоточное разделяемое состояние</a></h2>
<p>Передача сообщений — прекрасный способ обработки параллелизма, но не единственный. Другим способом может быть доступ нескольких потоков к одним и тем же общим данным. Рассмотрим ещё раз часть слогана из документации по языку Go: «Не стоит передавать сведения с помощью разделяемой памяти».</p>
<p>Как бы выглядело общение, используя разделяемую память? Кроме того, почему энтузиасты передачи сообщений предостерегают от его использования?</p>
<p>В каком-то смысле потоки в любом языке программирования похожи на единоличное владение, потому что после передачи значения по потоку вам больше не следует использовать отправленное значение. Многопоточная, совместно используемая память подобна множественному владению: несколько потоков могут одновременно обращаться к одной и той же области памяти. Как вы видели в главе 15, где умные указатели сделали возможным множественное владение, множественное владение может добавить сложность, потому что нужно управлять этими разными владельцами. Система видов Rust и правила владения очень помогают в их правильном управлении. Для примера давайте рассмотрим мьютексы, один из наиболее распространённых многопоточных примитивов для разделяемой памяти.</p>
<h3 id="Мьютексы-предоставляют-доступ-к-данным-из-одного-потока-за-раз"><a class="header" href="#Мьютексы-предоставляют-доступ-к-данным-из-одного-потока-за-раз">Мьютексы предоставляют доступ к данным из одного потока (за раз)</a></h3>
<p><em>Mutex</em> - это сокращение от <em>взаимное исключение</em> (mutual exclusion), так как мьютекс позволяет только одному потоку получать доступ к некоторым данным в любой момент времени. Для того, чтобы получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить доступ запрашивая <em>блокировку</em> (lock) мьютекса. Блокировка - это структура данных, являющаяся частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным. Поэтому мьютекс описывается как объект <em>защищающий</em> данные, которые он хранит через систему блокировки.</p>
<p>Мьютексы имеют репутацию трудных в использовании, потому что вы должны помнить два правила:</p>
<ul>
<li>Перед тем как попытаться получить доступ к данным необходимо получить блокировку.</li>
<li>Когда вы закончили работу с данными, которые защищает мьютекс, вы должны разблокировать данные, чтобы другие потоки могли получить блокировку.</li>
</ul>
<p>Для понимания мьютекса, представьте пример из жизни как групповое обсуждение на конференции с одним микрофоном. Прежде чем участник дискуссии сможет говорить, он должен спросить или дать сигнал, что он хочет использовать микрофон. Когда он получает микрофон, то может говорить столько, сколько хочет, а затем передаёт микрофон следующему участнику, который попросит дать ему выступить. Если участник дискуссии забудет освободить микрофон, когда закончит с ним, то никто больше не сможет говорить. Если управление общим микрофоном идёт не правильно, то конференция не будет работать как было запланировано!</p>
<p>Правильное управление мьютексами может быть невероятно сложным и именно поэтому многие люди с энтузиазмом относятся к потокам. Однако, благодаря системе видов и правилам владения в Rust, вы не можете использовать блокировку и разблокировку неправильным образом.</p>
<h4 id="mutext-api"><a class="header" href="#mutext-api"><code>Mutex&lt;T&gt;</code> API</a></h4>
<p>Давайте рассмотрим пример использования мьютекса в приложении 16-12 без использования нескольких потоков:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-12/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-12: Изучение API <code>Mutex&lt;T&gt;</code> для простоты в однопоточном среде</span></p>
<p>Как и во многих других видах, мы создаём <code>Mutex&lt;T&gt;</code> с помощью сопутствующей функции <code>new</code>. Чтобы получить доступ к данным внутри мьютекса, мы используем способ <code>lock</code> для получения блокировки. Этот вызов блокирует выполнение текущего потока, так что он не сможет выполнять никакие действия, до тех пор пока не наступит наша очередь получить блокировку.</p>
<p>Вызов <code>lock</code> потерпит неудачу, если другой поток, удерживающий блокировку, запаникует. В таком случае никто не сможет получить блокировку, поэтому мы предпочли использовать <code>unwrap</code> и заставить этот поток паниковать, если мы окажемся в такой ситуации.</p>
<p>После получения блокировки мы можем воспринимать возвращённое значение, названное в данном случае <code>num</code>, как изменяемую ссылку на содержащиеся внутри данные. Система видов заверяет, что мы получим блокировку перед использованием значения в <code>m</code>. Вид <code>m</code> - <code>Mutex&lt;i32&gt;</code>, а не <code>i32</code>, поэтому мы <em>должны</em> вызвать <code>lock</code>, чтобы иметь возможность использовать значение <code>i32</code>. Мы не должны об этом забывать, тем более что в иных случаях система видов и не даст нам доступ к внутреннему значению <code>i32</code>.</p>
<p>Как вы наверное подозреваете, <code>Mutex&lt;T&gt;</code> является умным указателем. Точнее, вызов <code>lock</code> <em>возвращает</em> умный указатель, называемый <code>MutexGuard</code>, обёрнутый в <code>LockResult</code>, который мы обработали с помощью вызова <code>unwrap</code>. Умный указатель вида <code>MutexGuard</code> реализует типаж <code>Deref</code> для указания на внутренние данные; умный указатель также имеет реализацию типажа <code>Drop</code>, самостоятельно снимающего блокировку, когда <code>MutexGuard</code> выходит из области видимости, что происходит в конце внутренней области видимости. В результате у нас нет риска забыть снять блокировку и оставить мьютекс в заблокированном состоянии, препятствуя  его использованию другими потоками (снятие блокировки происходит самостоятельно ).</p>
<p>После снятия блокировки можно напечатать значение мьютекса и увидеть, что мы смогли изменить внутреннее <code>i32</code> на 6.</p>
<h4 id="Разделение-mutext-между-множеством-потоков"><a class="header" href="#Разделение-mutext-между-множеством-потоков">Разделение <code>Mutex&lt;T&gt;</code> между множеством потоков</a></h4>
<p>Теперь давайте попробуем с помощью <code>Mutex&lt;T&gt;</code> совместно использовать значение между несколькими потоками. Мы стартуем 10 потоков и каждый из них увеличивает значение счётчика на 1, поэтому счётчик изменяется от 0 до 10. Обратите внимание, что в следующих нескольких примерах будут ошибки сборщика и мы будем использовать эти ошибки, чтобы узнать больше об использовании вида <code>Mutex&lt;T&gt;</code> и как Rust помогает нам правильно его использовать. Приложение 16-13 содержит наш начальный пример:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-13/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-13. Десять потоков, увеличивающих счётчик, защищённый <code>Mutex&lt;T&gt;</code></span></p>
<p>Мы создаём переменную-счётчик <code>counter</code> для хранения <code>i32</code> значения внутри <code>Mutex&lt;T&gt;</code>, как мы это делали в приложении 16-12. Затем мы создаём 10 потоков, перебирая рядчисел. Мы используем <code>thread::spawn</code> и передаём всем этим потокам одинаковое замыкание, которое перемещает счётчик в поток, запрашивает блокировку на <code>Mutex&lt;T&gt;</code>, вызывая способ <code>lock</code>, а затем добавляет 1 к значению в мьютексе. Когда поток завершит выполнение своего замыкания, <code>num</code> выйдет из области видимости и освободит блокировку, чтобы её мог получить другой поток.</p>
<p>В основном потоке мы собираем все дескрипторы в переменную handles. Затем, как мы это делали в приложении 16-2, вызываем <code>join</code> для каждого дескриптора, чтобы убедиться в завершении всех потоков. В этот момент основной поток получит доступ к блокировке и тоже напечатает результат программы.</p>
<p>Сборщик намекнул, что этот пример не собирается. Давайте выясним почему!</p>
<pre><code class="language-console">{{#include ../listings/ch16-fearless-concurrency/listing-16-13/output.txt}}
</code></pre>
<p>Сообщение об ошибке указывает, что значение <code>counter</code> было перемещёно в замыкание на предыдущей повторения цикла. Rust говорит нам, что мы не можем передать <code>counter</code> во владение  нескольким потокам. Давайте исправим ошибку сборщика с помощью способа множественного владения, который мы обсуждали в главе 15.</p>
<h4 id="Множественное-владение-между-множеством-потоков"><a class="header" href="#Множественное-владение-между-множеством-потоков">Множественное владение между множеством потоков</a></h4>
<p>В главе 15 мы давали значение нескольким владельцам, используя умный указатель <code>Rc&lt;T&gt;</code> для создания значения подсчитанных ссылок. Давайте сделаем то же самое здесь и посмотрим, что произойдёт. Мы завернём <code>Mutex&lt;T&gt;</code> в <code>Rc&lt;T&gt;</code> в приложении 16-14 и клонируем <code>Rc&lt;T&gt;</code> перед передачей владения в поток. Теперь, когда мы увидели ошибки, мы также вернёмся к использованию цикла <code>for</code> и сохраним ключевое слово <code>move</code> у замыкания.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-14/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 16-14: Попытка использования <code>Rc&lt;T&gt;</code>, чтобы позволить нескольким потокам владеть <code>Mutex&lt;T&gt;</code></span></p>
<p>Ещё раз, мы собираем и получаем ... другие ошибки! Сборщик  учит нас.</p>
<pre><code class="language-console">{{#include ../listings/ch16-fearless-concurrency/listing-16-14/output.txt}}
</code></pre>
<p>Ничего себе, это сообщение об ошибке очень многословно! Вот важная часть, на которой следует сосредоточиться: ``Rc&lt;Mutex<i32>&gt;<code> cannot be sent between threads safely</code>. Сборщик также сообщает нам причину: <code>the trait </code>Send<code>is not implemented for</code>Rc&lt;Mutex<i32>&gt;<code> </code>. Мы поговорим о <code>Send</code> в следующем разделе: это один из типажей, который заверяет, что виды которые мы используем с потоками, предназначены для использования в многопоточном коде.</p>
<p>К сожалению, <code>Rc&lt;T&gt;</code> небезопасен для совместного использования между потоками. Когда <code>Rc&lt;T&gt;</code> управляет счётчиком ссылок, он добавляется значение к счётчику для каждого вызова <code>clone</code> и вычитается значение из счётчика, когда каждое клонированное значение удаляется при выходе из области видимости. Но он не использует примитивы многопоточности, чтобы обеспечить, что изменения в подсчёте не могут быть прерваны другим потоком. Это может привести к неправильным подсчётам - незначительным ошибкам, которые в свою очередь, могут привести к утечкам памяти или удалению значения до того, как мы отработали с ним. Нам нужен вид точно такой же как <code>Rc&lt;T&gt;</code>, но который позволяет изменять счётчик ссылок безопасно из разных потоков.</p>
<h4 id="Атомарный-счётчик-ссылок-arct"><a class="header" href="#Атомарный-счётчик-ссылок-arct">Атомарный счётчик ссылок <code>Arc&lt;T&gt;</code></a></h4>
<p>К счастью, <code>Arc&lt;T&gt;</code> <em>является</em> видом подобным виду <code>Rc&lt;T&gt;</code>, который безопасен для использования в ситуациях многопоточности. Буква <em>А</em> означает <em>атомарное</em>, что означает вид <em>ссылка подсчитываемая атомарно</em>. Atomics - это дополнительный вид примитивов для многопоточности, который мы не будем здесь подробно описывать: дополнительную сведения смотрите в документации встроенной библиотеки для <code>std::sync::atomic</code>. На данный момент вам просто нужно знать, что atomics работают как примитивные виды, но безопасны для совместного использования между потоками.</p>
<p>Вы можете спросить, почему все примитивные виды не являются атомарными и почему стандартные виды библиотек не реализованы для использования вместе с видом <code>Arc&lt;T&gt;</code> по умолчанию. Причина в том, что безопасность потоков сопровождается снижением производительности, которое вы хотите платить только тогда, когда вам это действительно нужно. Если вы просто выполняете действия со значениями в одном потоке, то ваш код может работать быстрее, если он не должен обеспечивать заверения предоставляемые atomics.</p>
<p>Давайте вернёмся к нашему примеру: виды <code>Arc&lt;T&gt;</code> и <code>Rc&lt;T&gt;</code> имеют одинаковый API, поэтому мы исправляем нашу программу, заменяя вид в строках <code>use</code>, вызове <code>new</code> и вызове <code>clone</code>. Код в приложении 16-15, наконец ссобирается и запустится:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-15/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 16-15: Использование вида <code>Arc&lt;T&gt;</code> для обёртывания <code>Mutex&lt;T&gt;</code>, теперь несколько потоков могут совместно владеть мьютексом</span></p>
<p>Код напечатает следующее:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>Мы сделали это! Мы посчитали от 0 до 10, что может показаться не очень впечатляющим, но это позволило больше узнать про <code>Mutex&lt;T&gt;</code> и безопасность потоков. Вы также можете использовать структуру этой программы для выполнения более сложных действий, чем просто увеличение счётчика. Используя эту стратегию, вы можете разделить вычисления на независимые части, разделить эти части на потоки, а затем использовать <code>Mutex&lt;T&gt;</code>, чтобы каждый поток обновлял конечный результат своей частью кода.</p>
<p>Обратите внимание, что если вы выполняете простые числовые действия, то существуют виды более простые, чем <code>Mutex&lt;T&gt;</code>, которые предоставляет модуль <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code> встроенной библиотеки</a><!-- ignore -->. Эти виды обеспечивают безопасный, параллельный, атомарный доступ к простым видам. Мы решили использовать <code>Mutex&lt;T&gt;</code> с простым видом в этом примере, чтобы подробнее рассмотреть, как работает <code>Mutex&lt;T&gt;</code>.</p>
<h3 id="Сходства-refcellt--rct-и-mutext--arct"><a class="header" href="#Сходства-refcellt--rct-и-mutext--arct">Сходства <code>RefCell&lt;T&gt;</code> / <code>Rc&lt;T&gt;</code> и <code>Mutex&lt;T&gt;</code> / <code>Arc&lt;T&gt;</code></a></h3>
<p>Вы могли заметить, что <code>counter</code> сам по себе не изменяемый (immutable), но мы можем получить изменяемую ссылку на значение внутри него; это означает, что <code>Mutex&lt;T&gt;</code> обеспечивает внутреннюю изменяемость, также как и семейство <code>Cell</code> видов. Мы использовали <code>RefCell&lt;T&gt;</code> в главе 15, чтобы получить возможность изменять содержимое внутри <code>Rc&lt;T&gt;</code>, теперь подобным образом мы используем <code>Mutex&lt;T&gt;</code> для изменения содержимого внутри <code>Arc&lt;T&gt;</code> .</p>
<p>Ещё одна подробность, на которую стоит обратить внимание: Rust не может защитить вас от всевозможных логических ошибок при использовании <code>Mutex&lt;T&gt;</code>. Вспомните в главе 15, что использование <code>Rc&lt;T&gt;</code> сопряжено с риском создания ссылочной зацикленности, где два значения <code>Rc&lt;T&gt;</code> ссылаются друг на друга, что приводит к утечкам памяти. Подобным образом, <code>Mutex&lt;T&gt;</code> сопряжён с риском создания <em>взаимных блокировок</em> (deadlocks). Это происходит, когда действия необходимо заблокировать два ресурса и каждый из двух потоков получил одну из блокировок, заставляя оба потока ждать друг друга вечно. Если вам важна тема взаимных блокировок, попробуйте создать программу Rust, которая её содержит; затем исследуйте стратегии устранения взаимных блокировок для мьютексов на любом языке и попробуйте реализовать их в Rust. Документация встроенной библиотеки для <code>Mutex&lt;T&gt;</code> и <code>MutexGuard</code> предлагает полезную сведения.</p>
<p>Мы завершим эту главу, рассказав о типажах <code>Send</code> и <code>Sync</code> и о том, как мы можем использовать их с пользовательскими видами.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Расширенная-многопоточность-с-помощью-типажей-sync-и-send"><a class="header" href="#Расширенная-многопоточность-с-помощью-типажей-sync-и-send">Расширенная многопоточность с помощью типажей <code>Sync</code> и <code>Send</code></a></h2>
<p>Важно, что сам язык Rust имеет <em>очень</em> мало возможностей для многопоточности. Почти все функции многопоточности о которых мы говорили в этой главе, были частью встроенной библиотеки, а не языка. Ваши варианты работы с многопоточностью не ограничиваются языком или встроенной библиотекой; Вы можете написать свой собственный многопоточный функционал или использовать возможности написанные другими.</p>
<p>Тем не менее, в язык встроены две концепции многопоточности: <code>std::marker</code> типажи <code>Sync</code> и <code>Send</code>.</p>
<h3 id="Разрешение-передачи-во-владение-между-потоками-с-помощью-send"><a class="header" href="#Разрешение-передачи-во-владение-между-потоками-с-помощью-send">Разрешение передачи во владение между потоками с помощью <code>Send</code></a></h3>
<p>Маркерный типаж <code>Send</code> указывает, что владение видом реализующим <code>Send</code>, может передаваться между потоками. Почти каждый вид Rust является видом <code>Send</code>, но есть некоторые исключения, вроде <code>Rc&lt;T&gt;</code>: он не может быть <code>Send</code>, потому что если вы клонировали значение <code>Rc&lt;T&gt;</code> и попытались передать владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно. По этой причине <code>Rc&lt;T&gt;</code> реализован для использования в однопоточных ситуациях, когда вы не хотите платить за снижение производительности.</p>
<p>Следовательно, система видов Rust и ограничений типажа заверяют, что вы никогда не сможете случайно небезопасно отправлять значение <code>Rc&lt;T&gt;</code> между потоками. Когда мы попытались сделать это в приложении 16-14, мы получили ошибку, <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Когда мы переключились на <code>Arc&lt;T&gt;</code>, который является видом <code>Send</code>, то код собрался.</p>
<p>Любой вид полностью состоящий из видов <code>Send</code> самостоятельно помечается как <code>Send</code>. Почти все примитивные виды являются <code>Send</code>, кроме сырых указателей, которые мы обсудим в главе 19.</p>
<h3 id="Разрешение-доступа-из-нескольких-потоков-с-sync"><a class="header" href="#Разрешение-доступа-из-нескольких-потоков-с-sync">Разрешение доступа из нескольких потоков с <code>Sync</code></a></h3>
<p>Маркерный типаж <code>Sync</code> указывает, что на вид реализующий <code>Sync</code> можно безопасно ссылаться из нескольких потоков. Другими словами, любой вид <code>T</code> является видом <code>Sync</code>, если <code>&amp;T</code> (ссылка на <code>T</code> ) является видом <code>Send</code>, что означает что ссылку можно безопасно отправить в другой поток. Подобно <code>Send</code>, примитивные виды являются видом <code>Sync</code>, а виды полностью скомбинированные из видов <code>Sync</code>, также являются <code>Sync</code> видом.</p>
<p>Умный указатель <code>Rc&lt;T&gt;</code> не является <code>Sync</code> видом по тем же причинам, по которым он не является <code>Send</code>. Вид <code>RefCell&lt;T&gt;</code> (о котором мы говорили в главе 15) и семейство связанных видов <code>Cell&lt;T&gt;</code> не являются <code>Sync</code>. Реализация проверки заимствования, которую делает вид <code>RefCell&lt;T&gt;</code> во время выполнения программы не является поточно-безопасной. Умный указатель <code>Mutex&lt;T&gt;</code> является видом <code>Sync</code> и может использоваться для совместного доступа из нескольких потоков, как вы уже видели в разделе <a data-md-type="raw_html" href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">«Совместное использование <code>Mutex&lt;T&gt;</code> между несколькими потоками»</a> <!-- ignore -->.</p>
<h3 id="Реализация-send-и-sync-вручную-небезопасна"><a class="header" href="#Реализация-send-и-sync-вручную-небезопасна">Реализация <code>Send</code> и <code>Sync</code> вручную небезопасна</a></h3>
<p>Поскольку виды созданные из типажей <code>Send</code> и <code>Sync</code> самостоятельно также являются видами <code>Send</code> и <code>Sync</code>, мы не должны реализовывать эти типажи вручную. Являясь маркерными типажами у них нет никаких способов для реализации. Они просто полезны для реализации инвариантов, связанных с многопоточностью.</p>
<p>Ручная реализация этих типажей включает в себя реализацию небезопасного кода Rust. Мы поговорим об использовании небезопасного кода Rust в главе 19; на данный момент важная сведения заключается в том, что для создания новых многопоточных видов, не состоящих из частей <code>Send</code> и <code>Sync</code> необходимо тщательно продумать заверения безопасности. В <a href="../nomicon/index.html">Rustonomicon</a> есть больше сведений об этих заверениях и о том как их соблюдать.</p>
<h2 id="Итоги-13"><a class="header" href="#Итоги-13">Итоги</a></h2>
<p>Это не последний случай, когда вы увидите многопоточность в этой книге: проект в главе 20 будет использовать концепции этой главы для более реалистичного случая, чем небольшие примеры обсуждаемые здесь.</p>
<p>Как упоминалось ранее, поскольку в языке Rust очень мало того, с помощью чего можно управлять многопоточностью, многие решения  реализованы в виде крейтов. Они развиваются быстрее, чем стандартная библиотека, поэтому обязательно поищите в Интернете текущие современные крейты.</p>
<p>Стандартная библиотека Rust предоставляет потоки для передачи сообщений и виды умных указателей, такие как <code>Mutex&lt;T&gt;</code> и <code>Arc&lt;T&gt;</code>, которые можно безопасно использовать в многопоточных средах. Система видов и анализатор заимствований заверяют, что код использующий эти решения не будет содержать гонки данных или недействительные ссылки. Получив компилирующийся код, вы можете быть уверены, что он будет успешно работать в нескольких потоках без ошибок, которые трудно обнаружить в других языках. Многопоточное программирование больше не является концепцией, которую стоит опасаться: иди вперёд и сделай свои программы многопоточными безбоязненно!</p>
<p>Далее мы поговорим об идиоматичных способах моделирования проблем и структурирования решений по мере усложнения ваших программ на Rust. Кроме того, мы обсудим как идиомы Rust связаны с теми, с которыми вы, возможно, знакомы по объектно-ориентированному программированию.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Возможности-объектно-ориентированного-программирования-в-rust"><a class="header" href="#Возможности-объектно-ориентированного-программирования-в-rust">Возможности объектно-ориентированного программирования в Rust</a></h1>
<p>Объектно-ориентированное программирование (ООП) — это способ построения программ. Объекты, как программная концепция, были введены в язык программирования Simula в 1960-х годах. Эти объекты повлияли на архитектуру программирования Алана Кея, в которой объекты передают сообщения друг другу. Чтобы описать эту архитектуру, он ввёл термин <em>объектно-ориентированное программирование</em> в 1967 году. Есть много конкурирующих определений ООП, и по некоторым из этих определений Rust является объектно-ориентированным, а по другим — нет. В этой главе мы рассмотрим некоторые характеристики, которые обычно считаются объектно-ориентированными, и то, как эти характеристики транслируются в идиомы языка Rust. Затем мы покажем, как реализовать шаблон объектно-ориентированного проектирования в Rust, и обсудим соглашения между этим вариантом и решением, использующим вместо этого некоторые сильные стороны Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Характеристики-объектно-ориентированных-языков"><a class="header" href="#Характеристики-объектно-ориентированных-языков">Характеристики объектно-ориентированных языков</a></h2>
<p>В сообществе программистов нет единого мнения о том, какими свойствами должен обладать язык, чтобы считаться объектно-ориентированным. На Rust повлияли многие парадигмы программирования, включая ООП - например, в главе 13 мы изучали особенности, пришедшие из функционального программирования. Однозначно можно утверждать, что ООП-языкам присущи следующие характерные особенности: объекты, инкапсуляция и наследование. Давайте рассмотрим, что каждая из них означает и поддерживает ли их Rust.</p>
<h3 id="Объекты-содержат-данные-и-поведение"><a class="header" href="#Объекты-содержат-данные-и-поведение">Объекты содержат данные и поведение</a></h3>
<p>Книга <em>Приёмы объектно-ориентированного проектирования. Паттерны проектирования</em> Erich Gamma, Richard Helm, Ralph Johnson, и John Vlissides (Addison-Wesley Professional, 1994), в просторечии называемая <em>Книга банды четырёх</em>, представляет собой сборник примеров объектно-ориентированного проектирования. В ней даётся следующее определение ООП:</p>
<blockquote>
<p>Объектно-ориентированные программы состоят из объектов. <em>Объект</em> представляет собой сущность, своего рода дополнение, с данными и процедурами, которые работают с этими данными. Процедуры обычно называются <em>способами</em> или <em>действиеми</em>.</p>
</blockquote>
<p>В соответствии с этим определением, Rust является объектно-ориентированным языком - в структурах и перечислениях содержатся данные, а в х <code>impl</code> определяются способы для них. Хотя структуры и перечисления, имеющие способы, не <em>называются</em> объектами, они обеспечивают  функциональность, соответствующую определению объектов в книге банды четырёх.</p>
<h3 id="Инкапсуляция-скрывающая-подробности-реализации"><a class="header" href="#Инкапсуляция-скрывающая-подробности-реализации">Инкапсуляция, скрывающая подробности реализации</a></h3>
<p>Другим особенностью, обычно связанным с объектно-ориентированным программированием, является мысль <em>инкапсуляции</em>: подробности реализации объекта недоступны для кода, использующего этот объект. Единственный способ взаимодействия с объектом — через его публичный внешняя оболочка; код, использующий этот объект, не должен иметь возможности взаимодействовать с внутренними свойствами объекта и напрямую изменять его данные или поведение. Инкапсуляция позволяет изменять и реорганизовывать внутренние свойства объекта без необходимости изменять код, который использует объект.</p>
<p>В главе 7 мы уже говорили о том, как управлять инкапсуляцией: мы можем использовать ключевое слово <code>pub</code>, чтобы определить, какие модули, виды, функции и способы в нашем коде будут публичными, а всё остальное по умолчанию будет приватными. Например, мы можем определить структуру <code>AveragedCollection</code>, в которой есть поле, содержащее вектор значений <code>i32</code>. Также, структура будет иметь поле, содержащее среднее арифметическое чисел этого вектора, таким образом, среднее не нужно будет вычислять каждый раз, когда оно кому-то понадобится. Другими словами, <code>AveragedCollection</code> будет кэшировать вычисленное среднее для нас. В приложении 17-1 приведено определение структуры <code>AveragedCollection</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 17-1: структура <code>AveragedCollection</code> содержит список целых чисел и их среднее арифметическое.</span></p>
<p>Обратите внимание, что структура помечена ключевым словом <code>pub</code>, что позволяет другому коду её использовать, однако, поля структуры остаются недоступными. Это важно, потому что мы хотим обеспечить обновление среднего значения при добавлении или удалении элемента из списка. Мы можем получить нужное поведение, определив в структуре способы <code>add</code>, <code>remove</code> и <code>average</code>, как показано в примере 17-2:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-2: Реализация публичных способов <code>add</code>,<code>remove</code>, и <code>average</code> для <code>AveragedCollection</code></span></p>
<p>Публичные способы <code>add</code>, <code>remove</code> и <code>average</code> являются единственным способом получить или изменить данные в экземпляре <code>AveragedCollection</code>. Когда элемент добавляется в <code>list</code> способом <code>add</code>, или удаляется с помощью способа <code>remove</code>, код реализации каждого из этих способов вызывает приватный способ <code>update_average</code>, который позаботится об обновлении поля <code>average</code>.</p>
<p>Мы оставляем поля <code>list</code> и <code>average</code> приватными, чтобы внешний код не мог добавлять или удалять элементы непосредственно в поле <code>list</code>; в противном случае поле <code>average</code> может оказаться не синхронизировано при подобном вмешательстве. Способ <code>average</code> возвращает значение в поле <code>average</code>, что позволяет внешнему коду читать значение <code>average</code>, но не изменять его.</p>
<p>Поскольку мы инкапсулировали подробности реализации структуры <code>AveragedCollection</code>, мы можем легко изменить такие особенности, как структура данных, в будущем. Например, мы могли бы использовать <code>HashSet&lt;i32&gt;</code> вместо <code>Vec&lt;i32&gt;</code> для поля <code>list</code>. Благодаря тому, что сигнатуры публичных способов <code>add</code>, <code>remove</code> и <code>average</code> остаются неизменными, код, использующий <code>AveragedCollection</code>, также не будет нуждаться в изменении. У нас бы не получилось этого достичь, если бы мы сделали поле <code>list</code> доступным внешнему коду: <code>HashSet&lt;i32&gt;</code> и<code>Vec&lt;i32&gt;</code> имеют разные способы для добавления и удаления элементов, поэтому внешний код, вероятно, должен измениться, если он модифицирует <code>list</code> напрямую.</p>
<p>Если инкапсуляция является обязательным особенностью для определения языка как объектно-ориентированного, то Rust соответствует этому требованию. Возможность использовать или не использовать модификатор доступа <code>pub</code> для различных частей кода позволяет скрыть подробности реализации.</p>
<h3 id="Наследование-как-система-видов-и-способ-совместного-использования-кода"><a class="header" href="#Наследование-как-система-видов-и-способ-совместного-использования-кода">Наследование как система видов и способ совместного использования кода</a></h3>
<p><em>Наследование</em> — это механизм, с помощью которого объект может унаследовать элементы из определения другого объекта, то есть получить данные и поведение родительского объекта без необходимости повторно их определять.</p>
<p>Если язык должен иметь наследование, чтобы быть объектно-ориентированным, то Rust таким не является. Здесь нет способа определить структуру, наследующую поля и реализации способов родительской структуры, без использования макроса.</p>
<p>Однако, если вы привыкли иметь наследование в своём наборе средств для программирования, вы можете использовать другие решения в Rust, в зависимости от того, по какой причине вы изначально хотите использовать наследование.</p>
<p>Вы могли бы выбрать наследование по двум основным причинам. Одна из них - возможность повторного использования кода: вы можете реализовать определённое поведение для одного вида, а наследование позволит вам повторно использовать эту реализацию для другого вида. В Rust для этого есть ограниченный способ, использующий реализацию способа типажа по умолчанию, который вы видели в приложении 10-14, когда мы добавили реализацию по умолчанию в способе <code>summarize</code> типажа <code>Summary</code>. Любой вид, реализующий свойство <code>Summary</code> будет иметь доступный способ <code>summarize</code> без дополнительного кода. Это похоже на то, как родительский класс имеет реализацию способа, и класс-наследник тоже имеет реализацию способа. Мы также можем переопределить реализацию по умолчанию для способа <code>summarize</code>, когда реализуем типаж <code>Summary</code>, что похоже на дочерний класс, переопределяющий реализацию способа, унаследованного от родительского класса.</p>
<p>Вторая причина использования наследования относится к системе видов: чтобы иметь возможность использовать дочерний вид в тех же места, что и родительский. Эта возможность также называется <em>полиморфизм</em> и означает возможность подменять объекты во время исполнения, если они имеют одинаковые характеристики.</p>
<blockquote>
<h3 id="Полиморфизм"><a class="header" href="#Полиморфизм">Полиморфизм</a></h3>
<p>Для многих людей полиморфизм является синонимом наследования. Но на самом деле это более общая концепция, относящаяся к коду, который может работать с данными нескольких видов. Обычно такими видами выступают подклассы при наследовании.</p>
<p>Вместо этого Rust использует обобщённые виды для абстрагирования от видов, и ограничения типажей (trait bounds) для указания того, какие возможности эти виды должны предоставлять. Это иногда называют <em>ограниченным свойствоическим полиморфизмом</em>.</p>
</blockquote>
<p>Наследование, как подход к разработке, в последнее время утратило популярность во многих языках программирования, поскольку часто существует риск, что мы будем наследовать код чаще, чем это необходимо. Подклассы не всегда должны обладать всеми характеристиками родительского класса, но при использовании наследования другого варианта нет. Это может сделать дизайн программы менее гибким. Кроме этого, появляется возможность вызова у подклассов способов, которые не имеют смысла или вызывают ошибки, потому что эти способы неприменимы к подклассу. Кроме того, в некоторых языках разрешается только одиночное наследование (т.е. подкласс может наследоваться только от одного класса), что ещё больше ограничивает гибкость разработки программы.</p>
<p>По этим причинам в Rust применяется иной подход, с использованием типажей-объектов вместо наследования. Давайте посмотрим как типажи-объекты реализуют полиморфизм в Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Использование-типаж-объектов-допускающих-значения-разных-видов"><a class="header" href="#Использование-типаж-объектов-допускающих-значения-разных-видов">Использование типаж-объектов, допускающих значения разных видов</a></h2>
<p>В главе 8 мы упоминали, что одним из ограничений векторов является то, что они могут хранить элементы только одного вида. Мы создали обходное решение в приложении 8-9, где мы определили перечисление <code>SpreadsheetCell</code> в котором были варианты для хранения целых чисел, чисел с плавающей точкой и текста. Это означало, что мы могли хранить разные виды данных в каждой ячейке и при этом иметь вектор, представляющий строку из ячеек. Это очень хорошее решение, когда наши взаимозаменяемые элементы вектора являются видами с фиксированным набором, известным при сборки кода.</p>
<p>Однако иногда мы хотим, чтобы пользователь нашей библиотеки мог расширить набор видов, которые допустимы в именно ситуации. Чтобы показать как этого добиться, мы создадим пример средства с графическим внешней оболочкой пользователя (GUI), который просматривает список элементов, вызывает способ <code>draw</code> для каждого из них, чтобы нарисовать его на экране - это обычная техника для средств GUI. Мы создадим библиотечный крейт с именем <code>gui</code>, содержащий структуру библиотеки GUI. Этот крейт мог бы включать некоторые готовые виды для использования, такие как <code>Button</code> или <code>TextField</code>. Кроме того, пользователи такого крейта <code>gui</code> захотят создавать свои собственные виды, которые могут быть нарисованы: например, кто-то мог бы добавить вид <code>Image</code>, а кто-то другой добавить вид <code>SelectBox</code>.</p>
<p>Мы не будем реализовывать полноценную библиотеку GUI для этого примера, но покажем, как её части будут подходить друг к другу. На момент написания библиотеки мы не можем знать и определить все виды, которые могут захотеть создать другие программисты. Но мы знаем, что <code>gui</code> должен отслеживать множество значений различных видов и ему нужно вызывать способ <code>draw</code> для каждого из этих значений различного вида. Ему не нужно точно знать, что произойдёт, когда вызывается способ <code>draw</code>, просто у значения будет доступен такой способ для вызова.</p>
<p>Чтобы сделать это на языке с наследованием, можно определить класс с именем <code>Component</code> у которого есть способ с названием <code>draw</code>. Другие классы, такие как <code>Button</code>, <code>Image</code> и <code>SelectBox</code> наследуются от <code>Component</code> и следовательно, наследуют способ <code>draw</code>. Каждый из них может переопределить реализацию способа <code>draw</code>, чтобы определить своё пользовательское поведение, но платформа может обрабатывать все виды, как если бы они были экземплярами <code>Component</code> и вызывать <code>draw</code> у них. Но поскольку в Rust нет наследования, нам нужен другой способ структурировать <code>gui</code> библиотеку, чтобы позволить пользователям расширять её новыми видами.</p>
<h3 id="Определение-типажа-для-общего-поведения"><a class="header" href="#Определение-типажа-для-общего-поведения">Определение типажа для общего поведения</a></h3>
<p>Чтобы реализовать поведение, которое мы хотим иметь в <code>gui</code>, определим типаж с именем <code>Draw</code>, который будет содержать один способ с названием <code>draw</code>. Затем мы можем определить вектор, который принимает <em>типаж-объект</em>. Типаж-объект указывает как на экземпляр вида, реализующего указанный типаж, так и на внутреннюю таблицу, используемую для поиска способов типажа указанного вида во время выполнения. Мы создаём типаж-объект в таком порядке: используем какой-нибудь вид указателя, например ссылку <code>&amp;</code> или умный указатель <code>Box&lt;T&gt;</code>, затем ключевое слово <code>dyn</code>, а затем указываем соответствующий типаж. (Мы будем говорить о причине того, что типаж-объекты должны использовать указатель в разделе <a href="ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">"Виды изменяемого размера и типаж <code>Sized</code> "</a><!-- ignore --> главы 19). Мы можем использовать типаж-объекты вместо универсального или определенного вида. Везде, где мы используем типаж-объект, система видов Rust проверит во время сборки, что любое значение, используемое в этом среде, будет реализовывать нужный типаж у типаж-объекта. Следовательно, нам не нужно знать все возможные виды во время сборки.</p>
<p>Мы упоминали, что в Rust мы воздерживаемся называть структуры и перечисления «объектами», чтобы отличать их от объектов в других языках. В структуре или перечислении данные в полях структуры и поведение в разделах <code>impl</code> разделены, тогда как в других языках данные и поведение объединены в одну концепцию, часто обозначающуюся как объект. Тем не менее, типаж-объекты <em>являются</em> более похожими на объекты на других языках, в том смысле, что они сочетают в себе данные и поведение. Но типаж-объекты отличаются от традиционных объектов тем, что не позволяют добавлять данные к типаж-объекту. Типаж-объекты обычно не настолько полезны, как объекты в других языках: их определенная цель - обеспечить абстракцию через общее поведение.</p>
<p>В приложении 17.3 показано, как определить типаж с именем <code>Draw</code> с помощью одного способа с именем <code>draw</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-03/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 17-3: Определение типажа <code>Draw</code></span></p>
<p>Этот синтаксис должен выглядеть знакомым из наших дискуссий о том, как определять типажи в главе 10. Далее следует новый синтаксис: в приложении 17.4 определена структура с именем <code>Screen</code>, которая содержит вектор с именем <code>components</code>. Этот вектор имеет вид <code>Box&lt;dyn Draw&gt;</code>, который и является типаж-объектом; это замена для любого вида внутри <code>Box</code> который реализует типаж <code>Draw</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-04/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-4: Определение структуры <code>Screen</code> с полем <code>components</code>, которое является вектором типаж-объектов, которые реализуют типаж <code>Draw</code></span></p>
<p>В структуре <code>Screen</code>, мы определим способ <code>run</code>, который будет вызывать способ <code>draw</code> каждого элемента вектора <code>components</code>, как показано в приложении 17-5:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-05/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-5: Реализация способа <code>run</code> у структуры  <code>Screen</code>, который вызывает способ <code>draw</code> каждого компонента из вектора</span></p>
<p>Это работает иначе, чем определение структуры, которая использует свойство общего вида с ограничениями типажа. Обобщённый свойство вида может быть заменён только одним определенным видом, тогда как типаж-объекты позволяют нескольким определенным видам замещать типаж-объект во время выполнения. Например, мы могли бы определить структуру <code>Screen</code> используя общий вид и ограничение типажа, как показано в приложении 17-6:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-06/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-6: Иная реализация структуры <code>Screen</code> и способа <code>run</code>, используя обобщённый вид и ограничения типажа</span></p>
<p>Это вариант ограничивает нас экземпляром <code>Screen</code>, который имеет список компонентов всех видов <code>Button</code> или всех видов <code>TextField</code>. Если у вас когда-либо будут только однородные собрания, использование обобщений и ограничений типажа является предпочтительным, поскольку определения будут мономорфизированы во время сборки для использования с определенными видами.</p>
<p>С другой стороны, с помощью способа, использующего типаж-объекты, один экземпляр <code>Screen</code> может содержать <code>Vec&lt;T&gt;</code> который содержит <code>Box&lt;Button&gt;</code>, также как и <code>Box&lt;TextField&gt;</code>. Давайте посмотрим как это работает, а затем поговорим о влиянии на производительность во время выполнения.</p>
<h3 id="Реализации-типажа"><a class="header" href="#Реализации-типажа">Реализации типажа</a></h3>
<p>Теперь мы добавим несколько видов, реализующих типаж <code>Draw</code>. Мы объявим вид <code>Button</code>. Опять же, фактическая реализация библиотеки GUI выходит за рамки этой книги, поэтому тело способа <code>draw</code> не будет иметь никакой полезной реализации. Чтобы представить, как может выглядеть такая реализация, структура <code>Button</code> может иметь поля для <code>width</code>, <code>height</code> и <code>label</code>, как показано в приложении 17-7:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-07/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-7: Структура <code>Button</code> реализует типаж <code>Draw</code></span></p>
<p>Поля <code>width</code>, <code>height</code> и <code>label</code> структуры <code>Button</code> будут отличаться от, например, полей других компонентов вроде вида <code>TextField</code>, которая могла бы иметь те же поля плюс поле <code>placeholder</code>. Каждый из видов, который мы хотим нарисовать на экране будет реализовывать типаж <code>Draw</code>, но будет использовать отличающийся код способа <code>draw</code> для определения как именно рисовать определенный вид, например <code>Button</code> в этом примере (без фактического кода GUI, который выходит за рамки этой главы). Например, вид <code>Button</code> может иметь дополнительный раздел<code>impl</code>, содержащий способы, относящиеся к тому, что происходит, когда пользователь нажимает кнопку. Эти варианты способов не будут применяться к видам вроде <code>TextField</code>.</p>
<p>Если кто-то использующий нашу библиотеку решает реализовать структуру <code>SelectBox</code>, которая имеет <code>width</code>, <code>height</code> и поля <code>options</code>, он реализует также и типаж <code>Draw</code> для вида <code>SelectBox</code>, как показано в приложении 17-8:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch17-oop/listing-17-08/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-8: Другой крейт, использующий <code>gui</code> и реализующий типаж <code>Draw</code> у структуры <code>SelectBox</code></span></p>
<p>Пользователь нашей библиотеки теперь может написать свою функцию <code>main</code> для создания экземпляра <code>Screen</code>. К экземпляру <code>Screen</code> он может добавить <code>SelectBox</code> и <code>Button</code>, поместив каждый из них в <code>Box&lt;T&gt;</code>, чтобы он стал типаж-объектом. Затем он может вызвать способ <code>run</code> у экземпляра <code>Screen</code>, который вызовет <code>draw</code> для каждого из компонентов. Приложение 17-9 показывает эту реализацию:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch17-oop/listing-17-09/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-9: Использование типаж-объектов для хранения значений разных видов, реализующих один и тот же типаж</span></p>
<p>Когда мы писали библиотеку, мы не знали, что кто-то может добавить вид <code>SelectBox</code>, но наша реализация <code>Screen</code> могла работать с новым видом и рисовать его, потому что <code>SelectBox</code> реализует типаж <code>Draw</code>, что означает, что он реализует способ <code>draw</code>.</p>
<p>Эта концепция, касающаяся только сообщений, на которые значение отвечает, в отличие от определенного вида у значения, подобна концепции <em>duck typing</em> в изменяемых типизированных языках: если что-то ходит как утка и крякает как утка, то она должна быть утка! В реализации способа <code>run</code> у <code>Screen</code> в приложении 17-5, <code>run</code> не нужно знать каким будет определенный вид каждого компонента. Он не проверяет, является ли компонент экземпляром <code>Button</code> или <code>SelectBox</code>, он просто вызывает способ <code>draw</code> компонента. Указав <code>Box&lt;dyn Draw&gt;</code> в качестве вида значений в векторе <code>components</code>, мы определили <code>Screen</code> для значений у которых мы можем вызвать способ <code>draw</code>.</p>
<p>Преимущество использования типаж-объектов и системы видов Rust для написания кода, похожего на код с использованием концепции duck typing состоит в том, что нам не нужно во время выполнения  проверять реализует ли значение в векторе определенный способ или беспокоиться о получении ошибок, если значение не реализует способ, мы все равно вызываем способ. Rust не ссобирает наш код, если значения не реализуют типаж, который нужен типаж-объектам.</p>
<p>Например, в приложении 17-10 показано, что произойдёт, если мы попытаемся создать <code>Screen</code> с <code>String</code> в качестве его компонента:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch17-oop/listing-17-10/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 17-10: Попытка использования вида, который не реализует типаж для типаж-объекта</span></p>
<p>Мы получим ошибку, потому что <code>String</code> не реализует типаж <code>Draw</code>:</p>
<pre><code class="language-console">{{#include ../listings/ch17-oop/listing-17-10/output.txt}}
</code></pre>
<p>Эта ошибка даёт понять, что либо мы передаём в компонент <code>Screen</code> что-то, что мы не собирались передавать и мы тогда должны передать другой вид, либо мы должны реализовать типаж <code>Draw</code> у вида <code>String</code>, чтобы <code>Screen</code> мог вызывать <code>draw</code> у него.</p>
<h3 id="Типаж-объекты-выполняют-изменяемую-управление-связывание"><a class="header" href="#Типаж-объекты-выполняют-изменяемую-управление-связывание">Типаж-объекты выполняют изменяемую управление (связывание)</a></h3>
<p>Вспомните, в разделе <a href="ch10-01-syntax.html#performance-of-code-using-generics">«Производительность кода, использующего обобщённые виды»</a><!-- ignore --> в главе 10 наше обсуждение процесса мономорфизации, выполняемого сборщиком, когда мы используем ограничения типажей для обобщённых видов: сборщик генерирует частные реализации функций и способов для каждого определенного вида, который мы применяем для свойства обобщённого вида. Код, который получается в результате мономорфизации, выполняет <em>статическую управление</em> , то есть когда сборщик знает, какой способ вы вызываете во время сборки. Это противоположно <em>изменяемой управления</em>, когда сборщик не может определить во время сборки, какой способ вы вызываете. В случае изменяемой управления сборщик формирует код, который во время выполнения определит, какой способ нужно вызвать.</p>
<p>Когда мы используем типаж-объекты, Rust должен использовать изменяемую управление. Сборщик не знает всех видов, которые могут быть использованы с кодом, использующим типаж-объекты, поэтому он не знает, какой способ реализован для какого вида при вызове. Вместо этого, во время выполнения, Rust использует указатели внутри типаж-объекта, чтобы узнать какой способ вызвать. Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при статической управления. Изменяемая управление также не позволяет сборщику выбрать встраивание кода способа, что в свою очередь делает невозможными некоторые оптимизации. Однако мы получили дополнительную гибкость в коде, который мы написали в приложении 17-5, и которую смогли поддержать в приложении 17-9, поэтому все "за" и "против" нужно рассматривать в комплексе.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Реализация-объектно-ориентированного-шаблона-проектирования"><a class="header" href="#Реализация-объектно-ориентированного-шаблона-проектирования">Реализация объектно-ориентированного шаблона проектирования</a></h2>
<p><em>Шаблон "Состояние"</em> — это объектно-ориентированный шаблон проектирования. Суть шаблона заключается в том, что мы определяем набор состояний, которые может иметь внутреннее значение. Состояния представлены набором <em>объектов состояния</em>, а поведение элемента изменяется в зависимости от его состояния. Мы рассмотрим пример структуры записи в блоге, в которой есть поле для хранения состояния, которое будет объектом состояния из набора «черновик», «обзор» или «опубликовано».</p>
<p>Объекты состояния имеют общую функциональность: конечно в Rust мы используем структуры и типажи, а не объекты и наследование. Каждый объект состояния отвечает за своё поведение и сам определяет, когда он должен перейти в другое состояние. Элемент, который содержит объект состояния, ничего не знает о различиях в поведении состояний или о том, когда одно состояние должно перейти в другое.</p>
<p>Преимуществом шаблона "Состояние" является то, что при изменении требований заказчика программы не требуется изменять код элемента, содержащего состояние, или код, использующий такой элемент. Нам нужно только обновить код внутри одного из объектов состояния, чтобы изменить его порядок действий, либо, возможно, добавить больше объектов состояния.</p>
<p>Для начала реализуем шаблон "Состояние" более традиционным объектно-ориентированным способом, а затем воспользуемся подходом, более естественным для Rust. Давайте шаг за шагом реализуем поток действий для записи в блоге, использующий шаблон "Состояние".</p>
<p>Окончательный функционал будет выглядеть так:</p>
<ol>
<li>Запись в блоге создаётся как пустой черновик.</li>
<li>Когда черновик готов, запрашивается его проверка.</li>
<li>После проверки происходит публикация записи.</li>
<li>Только опубликованные записи блога возвращают содержимое записи на печать, поэтому сообщения, не прошедшие проверку, не могут быть опубликованы случайно.</li>
</ol>
<p>Любые другие изменения, сделанные в записи, не должны иметь никакого эффекта. Например, если мы попытаемся подтвердить черновик записи в блоге до того, как запросим проверку, запись должна остаться неопубликованным черновиком.</p>
<p>В приложении 17-11 показан этот поток действий в виде кода: это пример использования API, который мы собираемся реализовать в библиотеке (крейте) с именем <code>blog</code>. Он пока не собирается, потому что крейт <code>blog</code> ещё не создан.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch17-oop/listing-17-11/src/main.rs:all}}</code></pre>
<p><span class="caption">Приложение 17-11: Код, отображающий желаемое поведение, которое мы хотим получить в крейте <code>blog</code></span></p>
<p>Мы хотим, чтобы пользователь мог создать новый черновик записи в блоге с помощью <code>Post::new</code>. Затем мы хотим разрешить добавление текста в запись блога. Если мы попытаемся получить содержимое записи сразу, до её проверки, мы не должны получить никакого текста на выходе, потому что запись все ещё является черновиком. Мы добавили утверждение (<code>assert_eq!</code>) в коде для опытных целей. Утверждение (assertion), что черновик записи блога должен возвращать пустую строку из способа <code>content</code> было бы отличным модульным тестом, но мы не собираемся писать тесты для этого примера.</p>
<p>Далее мы хотим разрешить сделать запрос на проверку записи и хотим, чтобы <code>content</code> возвращал пустую строку, пока проверки не завершена. Когда запись пройдёт проверку, она должна быть опубликована, то есть при вызове <code>content</code> будет возвращён текст записи.</p>
<p>Обратите внимание, что единственный вид из крейта, с которым мы взаимодействуем - это вид <code>Post</code>. Этот вид будет использовать шаблон "Состояние" и будет содержать значение, которое будет являться одним из трёх объектов состояний, представляющих различные состояния, в которых может находиться запись: "черновик", "ожидание проверки" или "опубликовано". Управление переходом из одного состояния в другое будет осуществляться внутренней логикой вида <code>Post</code>. Состояния будут переключаться в результате реакции на вызов способов экземпляра <code>Post</code> пользователями нашей библиотеки, но пользователи не должны управлять изменениями состояния напрямую. Кроме того, пользователи не должны иметь возможность ошибиться с состояниями, например, опубликовать сообщение до его проверки.</p>
<h3 id="Определение-post-и-создание-нового-экземпляра-в-состоянии-черновика"><a class="header" href="#Определение-post-и-создание-нового-экземпляра-в-состоянии-черновика">Определение <code>Post</code> и создание нового экземпляра в состоянии черновика</a></h3>
<p>Приступим к реализации библиотеки! Мы знаем, что нам нужна публичная структура <code>Post</code>, хранящая некоторое содержимое, поэтому мы начнём с определения структуры и связанной с ней публичной функцией <code>new</code> для создания экземпляра <code>Post</code>, как показано в приложении 17-12. Мы также сделаем приватный типаж <code>State</code>, который будет определять поведение, которое должны будут иметь все объекты состояний структуры <code>Post</code>.</p>
<p>Затем <code>Post</code> будет содержать типаж-объект <code>Box&lt;dyn State&gt;</code> внутри <code>Option&lt;T&gt;</code> в закрытом поле <code>state</code> для хранения объекта состояния. Чуть позже вы поймёте, зачем нужно использовать <code>Option&lt;T&gt;</code> .</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 17-12. Определение структуры <code>Post</code> и функции <code>new</code>, которая создаёт новый экземпляр <code>Post</code>, типажа <code>State</code> и структуры <code>Draft</code></span></p>
<p>Типаж <code>State</code> определяет поведение, совместно используемое различными состояниями поста. Все объекты состояний (<code>Draft</code> - "черновик", <code>PendingReview</code>  - "ожидание проверки" и <code>Published</code> - "опубликовано") будут реализовывать типаж <code>State</code>. Пока у этого типажа нет никаких способов, и мы начнём с определения состояния <code>Draft</code>, просто потому, что это первое состояние, с которого, как мы хотим, публикация будет начинать свой путь.</p>
<p>Когда мы создаём новый экземпляр <code>Post</code>, мы устанавливаем его поле <code>state</code> в значение <code>Some</code>, содержащее <code>Box</code>. Этот <code>Box</code> указывает на новый экземпляр структуры <code>Draft</code>. Это заверяет, что всякий раз, когда мы создаём новый экземпляр <code>Post</code>, он появляется как черновик. Поскольку поле <code>state</code> в структуре <code>Post</code> является приватным, нет никакого способа создать <code>Post</code> в каком-либо другом состоянии! В функции <code>Post::new</code> мы объявим поле <code>content</code> новой пустой строкой вида <code>String</code>.</p>
<h3 id="Хранение-текста-содержимого-записи"><a class="header" href="#Хранение-текста-содержимого-записи">Хранение текста содержимого записи</a></h3>
<p>В приложении 17-11 показано, что мы хотим иметь возможность вызывать способ <code>add_text</code> и передать ему <code>&amp;str</code>, которое добавляется к текстовому содержимому записи блога. Мы реализуем эту возможность как способ, а не делаем поле <code>content</code> публично доступным, используя <code>pub</code>. Это означает, что позже мы сможем написать способ, который будет управлять, как именно читаются данные из поля <code>content</code>. Способ <code>add_text</code> довольно прост, поэтому давайте добавим его реализацию в раздел<code>impl Post</code>приложения 17-13:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-13/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-13. Реализация <code>add_text</code> для добавления текста к <code>content</code> (содержимому записи)</span></p>
<p>Способ <code>add_text</code> принимает изменяемую ссылку на <code>self</code>, потому что мы меняем экземпляр <code>Post</code>, для которого вызываем <code>add_text</code>. Затем мы вызываем <code>push_str</code> для <code>String</code> у поля <code>content</code> и передаём <code>text</code> переменнаяом для добавления к сохранённому <code>content</code>. Это поведение не зависит от состояния, в котором находится запись, таким образом оно не является частью шаблона "Состояние". Способ <code>add_text</code> вообще не взаимодействует с полем <code>state</code>, но это часть поведения, которое мы хотим поддерживать.</p>
<h3 id="Убедимся-что-содержание-черновика-будет-пустым"><a class="header" href="#Убедимся-что-содержание-черновика-будет-пустым">Убедимся, что содержание черновика будет пустым</a></h3>
<p>Даже после того, как мы вызвали <code>add_text</code> и добавили некоторый контент в нашу запись, мы хотим, чтобы способ <code>content</code> возвращал пустой фрагмент строки, так как запись всё ещё находится в черновом состоянии, как это показано в строке 7 приложения 17-11. А пока давайте реализуем способ <code>content</code> наиболее простым способом, который будет удовлетворять этому требованию: будем всегда возвращать пустой фрагмент строки. Мы изменим код позже, как только реализуем возможность изменить состояние записи, чтобы она могла бы быть опубликована. Пока что записи могут находиться только в черновом состоянии, поэтому содержимое записи всегда должно быть пустым. Приложение 17-14 показывает такую реализацию-заглушку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-14/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-14. Добавление реализации-заглушки для способа <code>content</code> в <code>Post</code>, которая всегда возвращает пустой фрагмент строки.</span></p>
<p>С добавленным таким образом способом <code>content</code> всё в приложении 17-11 работает, как задумано, вплоть до строки 7.</p>
<h3 id="Запрос-на-проверку-записи-меняет-её-состояние"><a class="header" href="#Запрос-на-проверку-записи-меняет-её-состояние">Запрос на проверку записи меняет её состояние</a></h3>
<p>Далее нам нужно добавить функциональность для запроса проверки записи, который должен изменить её состояние с <code>Draft</code> на <code>PendingReview</code>. Приложение 17-15 показывает такой код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-15/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-15. Реализация способов <code>request_review</code> в структуре <code>Post</code> и типаже <code>State</code></span></p>
<p>Мы добавляем в <code>Post</code> публичный способ с именем <code>request_review</code> ("запросить проверку"), который будет принимать изменяемую ссылку на <code>self</code>. Затем мы вызываем внутренний способ <code>request_review</code> для текущего состояния <code>Post</code>, и этот второй способ <code>request_review</code> поглощает текущее состояние и возвращает новое состояние.</p>
<p>Мы добавляем способ <code>request_review</code> в типаж <code>State</code>; все виды, реализующие этот типаж, теперь должны будут реализовать способ <code>request_review</code>. Обратите внимание, что вместо <code>self</code>, <code>&amp;self</code> или <code>&amp;mut self</code> в качестве первого свойства способа у нас указан <code>self: Box&lt;Self&gt;</code>. Этот синтаксис означает, что способ действителен только при его вызове с обёрткой <code>Box</code>, содержащей наш вид. Этот синтаксис становится владельцем <code>Box&lt;Self&gt;</code>, делая старое состояние недействительным, поэтому значение состояния <code>Post</code> может быть преобразовано в новое состояние.</p>
<p>Чтобы поглотить старое состояние, способ <code>request_review</code> должен стать владельцем значения состояния. Это место, где приходит на помощь вид <code>Option</code> поля <code>state</code> записи <code>Post</code>: мы вызываем способ <code>take</code>, чтобы забрать значение <code>Some</code> из поля <code>state</code> и оставить вместо него значение <code>None</code>, потому что Rust не позволяет иметь необъявленные поля в структурах. Это позволяет перемещать значение <code>state</code> из <code>Post</code>, а не заимствовать его. Затем мы установим новое значение <code>state</code> как результат этой действия.</p>
<p>Нам нужно временно установить <code>state</code> в <code>None</code>, вместо того, чтобы установить его напрямую с помощью кода вроде <code>self.state = self.state.request_review();</code>. Нам нужно завладеть значением поля <code>state</code>. Это даст нам заверение, что <code>Post</code> не сможет использовать старое значение <code>state</code> после того, как мы преобразовали его в новое состояние.</p>
<p>Способ <code>request_review</code> в <code>Draft</code> должен вернуть новый экземпляр новой структуры <code>PendingReview</code>, обёрнутый в Box. Эта структура будет представлять состояние, в котором запись ожидает проверки. Структура <code>PendingReview</code> также реализует способ <code>request_review</code>, но не выполняет никаких преобразований. Она возвращает сама себя, потому что, когда мы запрашиваем проверку записи, уже находящейся в состоянии <code>PendingReview</code>, она всё так же должна продолжать оставаться в состоянии <code>PendingReview</code>.</p>
<p>Теперь мы начинаем видеть преимущества шаблона "Состояние": способ <code>request_review</code> для <code>Post</code> одинаков, он не зависит от значения <code>state</code>. Каждое состояние само несёт ответственность за свои действия.</p>
<p>Оставим способ <code>content</code> у <code>Post</code> таким как есть, возвращающим пустой фрагмент строки. Теперь мы можем иметь <code>Post</code> как в состоянии <code>PendingReview</code>, так и в состоянии <code>Draft</code>, но мы хотим получить такое же поведение в состоянии <code>PendingReview</code>. Приложение 17-11 теперь работает до строки 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="Добавление-approve-для-изменения-поведения-content"><a class="header" href="#Добавление-approve-для-изменения-поведения-content">Добавление <code>approve</code> для изменения поведения <code>content</code></a></h3>
<p>Способ <code>approve</code> ("одобрить") будет подобен способу <code>request_review</code>: он будет устанавливать у <code>state</code> значение, которое должна иметь запись при её одобрении, как показано в приложении 17-16:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-16/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-16. Реализация способа <code>approve</code> для вида <code>Post</code> и типажа <code>State</code></span></p>
<p>Мы добавляем способ <code>approve</code> в типаж <code>State</code>, добавляем новую структуру, которая реализует этот типаж <code>State</code> и структуру для состояния <code>Published</code>.</p>
<p>Подобно тому, как работает <code>request_review</code> для <code>PendingReview</code>, если мы вызовем способ <code>approve</code> для <code>Draft</code>, он не будет иметь никакого эффекта, потому что <code>approve</code> вернёт <code>self</code>. Когда мы вызываем для <code>PendingReview</code> способ <code>approve</code>, то он возвращает новый упакованный экземпляр структуры <code>Published</code>. Структура <code>Published</code> реализует трейт <code>State</code>, и как для способа <code>request_review</code>, так и для способа <code>approve</code> она возвращает себя, потому что в этих случаях запись должна оставаться в состоянии <code>Published</code>.</p>
<p>Теперь нам нужно обновить способ <code>content</code> для <code>Post</code>. Мы хотим, чтобы значение, возвращаемое из <code>content</code>, зависело от текущего состояния <code>Post</code>, поэтому мы собираемся перенести часть функциональности <code>Post</code> в способ <code>content</code>, заданный для <code>state</code>, как показано в приложении 17.17:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch17-oop/listing-17-17/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-17: Обновление способа <code>content</code> в структуре <code>Post</code> для делегирования части функциональности способу <code>content</code> структуры <code>State</code></span></p>
<p>Поскольку наша цель состоит в том, чтобы сохранить все эти действия внутри структур, реализующих типаж <code>State</code>, мы вызываем способ <code>content</code> у значения в поле <code>state</code> и передаём экземпляр публикации (то есть <code>self</code> ) в качестве переменной. Затем мы возвращаем значение, которое нам выдаёт вызов способа <code>content</code> поля <code>state</code>.</p>
<p>Мы вызываем способ <code>as_ref</code> у <code>Option</code>, потому что нам нужна ссылка на значение внутри <code>Option</code>, а не владение значением. Поскольку <code>state</code> является видом <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, то при вызове способа <code>as_ref</code> возвращается <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. Если бы мы не вызывали <code>as_ref</code>, мы бы получили ошибку, потому что мы не можем переместить <code>state</code> из заимствованного свойства <code>&amp;self</code> функции.</p>
<p>Затем мы вызываем способ <code>unwrap</code>. Мы знаем, что этот способ здесь никогда не приведёт к аварийному завершению программы, так все способы <code>Post</code> устроены таким образом, что после их выполнения, в поле <code>state</code> всегда содержится значение <code>Some</code>. Это один из случаев, про которых мы говорили в разделе <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">"Случаи, когда у вас больше сведений, чем у сборщика"</a><!--  --> главы 9 - случай, когда мы знаем, что значение <code>None</code> никогда не встретится, даже если сборщик не может этого понять.</p>
<p>Теперь, когда мы вызываем <code>content</code> у вида <code>&amp;Box&lt;dyn State&gt;</code>, в действие вступает принудительное приведение (deref coercion) для <code>&amp;</code> и <code>Box</code>, поэтому в конечном итоге способ <code>content</code> будет вызван для вида, который реализует типаж <code>State</code>. Это означает, что нам нужно добавить способ <code>content</code> в определение типажа <code>State</code>, и именно там мы поместим логику для определения того, какое содержимое возвращать, в зависимости от текущего состояния, как показано в приложении 17-18:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-18/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-18. Добавление способа <code>content</code> в трейт <code>State</code></span></p>
<p>Мы добавляем реализацию по умолчанию способа <code>content</code>, который возвращает пустой фрагмент строки. Это означает, что нам не придётся реализовывать <code>content</code> в структурах <code>Draft</code> и <code>PendingReview</code>.  Структура <code>Published</code> будет переопределять способ <code>content</code> и вернёт значение из <code>post.content</code>.</p>
<p>Обратите внимание, что для этого способа нам нужны изложении времени жизни, как мы обсуждали в главе 10. Мы берём ссылку на <code>post</code> в качестве переменной и возвращаем ссылку на часть этого <code>post</code>, поэтому время жизни возвращённой ссылки связано с временем жизни переменной <code>post</code>.</p>
<p>И вот, мы закончили - теперь всё из приложения 17-11 работает! Мы реализовали шаблон "Состояние", определяющий правила процесса работы с записью в блоге. Логика, связанная с этими правилами, находится в объектах состояний, а не разбросана по всей структуре <code>Post</code>.</p>
<blockquote>
<h4 id="Почему-не-перечисление"><a class="header" href="#Почему-не-перечисление">Почему не перечисление?</a></h4>
<p>Возможно, вам было важно, почему мы не использовали <code>enum</code> с различными возможными состояниями записи в качестве вариантов. Это, безусловно, одно из возможных решений. Попробуйте его реализовать и сравните конечные результаты, чтобы выбрать, какой из вариантов вам больше нравится! Одним из недостатков использования перечисления является то, что в каждом месте, где проверяется значение перечисления, потребуется выражение <code>match</code> или что-то подобное для обработки всех возможных вариантов. Возможно в этом случае нам придётся повторять больше кода, чем это было в решении с типаж-объектом.</p>
</blockquote>
<h3 id="Соглашенияы-шаблона-Состояние"><a class="header" href="#Соглашенияы-шаблона-Состояние">Соглашенияы шаблона "Состояние"</a></h3>
<p>Мы показали, что Rust способен реализовать объектно-ориентированный шаблон "Состояние" для инкапсуляции различных видов поведения, которые должна иметь запись в каждом состоянии. Способы в <code>Post</code> ничего не знают о различных видах поведения. При такой организации кода, нам достаточно взглянуть только на один его участок, чтобы узнать отличия в поведении опубликованной публикации: в реализацию типажа <code>State</code> у структуры <code>Published</code>.</p>
<p>Если бы мы захотели создать иную реализацию, не использующую паттерн состояния, мы могли бы вместо этого использовать выражения <code>match</code> в способах <code>Post</code> или даже в <code>main</code>, которые бы проверяли состояние записи и изменяли поведение в этих местах. Это приведёт к тому, что нам придётся в нескольких местах исследовать все следствия того, что пост перешёл в состояние "опубликовано"! И эта нагрузка будет только увеличиваться по мере добавления новых состояний: для каждого из этих выражений <code>match</code> потребуются дополнительные ответвления.</p>
<p>С помощью шаблона "Состояние" способы <code>Post</code> и участки, где мы используем <code>Post</code>, не требуют использования выражений <code>match</code>, а для добавления нового состояния нужно только добавить новую структуру и реализовать способы типажа у одной этой структуры.</p>
<p>Реализацию с использованием шаблона "Состояние" легко расширить для добавления новой функциональности. Чтобы увидеть, как легко поддерживать код, использующий данный шаблон, попробуйте выполнить некоторые из предложений ниже:</p>
<ul>
<li>Добавьте способ <code>reject</code>, который изменяет состояние публикации с <code>PendingReview</code> обратно на <code>Draft</code>.</li>
<li>Потребуйте два вызова способа <code>approve</code>, прежде чем переводить состояние в <code>Published</code>.</li>
<li>Разрешите пользователям добавлять текстовое содержимое только тогда, когда публикация находится в состоянии <code>Draft</code>. Подсказка: пусть объект состояния решает, можно ли менять содержимое, но не отвечает за изменение <code>Post</code>.</li>
</ul>
<p>Одним из недостатков шаблона "Состояние" является то, что поскольку состояния сами реализуют переходы между собой, некоторые из состояний получаются связанными друг с другом. Если мы добавим другое состояние между <code>PendingReview</code> и <code>Published</code>,  например <code>Scheduled</code> ("запланировано"), то придётся изменить код в <code>PendingReview</code>, чтобы оно теперь переходило в <code>Scheduled</code>. Если бы не нужно было менять <code>PendingReview</code> при добавлении нового состояния, было бы меньше работы, но это означало бы, что мы переходим на другой шаблон проектирования.</p>
<p>Другим недостатком является то, что мы сделали повторение некоторую логику. Чтобы устранить некоторое повторение, мы могли бы попытаться сделать реализации по умолчанию для способов <code>request_review</code> и <code>approve</code> типажа <code>State</code>, которые возвращают <code>self</code>; однако это нарушило бы безопасность объекта, потому что типаж не знает, каким определенно будет <code>self</code>. Мы хотим иметь возможность использовать <code>State</code> в качестве типаж-объекта, поэтому нам нужно, чтобы его способы были объектно-безопасными.</p>
<p>Другое повторение включает в себя схожие реализации способов <code>request_review</code> и <code>approve</code> у  <code>Post</code>. Оба способа делегируют реализации одного и того же способа значению поля <code>state</code> вида <code>Option</code> и устанавливают результатом новое значение поля <code>state</code>. Если бы у <code>Post</code> было много способов, которые следовали этому шаблону, мы могли бы рассмотреть определение макроса для устранения повторения (смотри раздел <a href="ch19-06-macros.html#macros">"Макросы"</a><!--  --> в главе 19).</p>
<p>Реализуя шаблон "Состояние" точно так, как он определён для объектно-ориентированных языков, мы не настолько полно используем преимущества Rust, как могли бы. Давайте посмотрим на некоторые изменения, которые мы можем внести в крейт <code>blog</code>, чтобы недопустимые состояния и переходы превратить в ошибки времени сборки.</p>
<h4 id="Кодирование-состояний-и-поведения-в-виде-видов"><a class="header" href="#Кодирование-состояний-и-поведения-в-виде-видов">Кодирование состояний и поведения в виде видов</a></h4>
<p>Мы покажем вам, как переосмыслить шаблон "Состояние", чтобы получить другой набор соглашений. Вместо того, чтобы полностью инкапсулировать состояния и переходы, так, чтобы внешний код не знал о них, мы будем кодировать состояния с помощью разных видов. Следовательно, система проверки видов Rust предотвратит попытки использовать черновые публикации, там где разрешены только опубликованные публикации, вызывая ошибки сборки.</p>
<p>Давайте рассмотрим первую часть <code>main</code> в приложении 17-11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch17-oop/listing-17-11/src/main.rs:here}}</code></pre>
<p>Мы по-прежнему поддерживаем создание новых сообщений в состоянии "черновика" с помощью способа <code>Post::new</code> и возможность добавлять текст к содержимому публикации. Но вместо способа <code>content</code> у чернового сообщения, возвращающего пустую строку, мы сделаем так, что у черновых сообщений вообще не будет способа <code>content</code>. Таким образом, если мы попытаемся получить содержимое черновика, мы получим ошибку сборщика, сообщающую, что способ не существует. В результате мы не сможем случайно отобразить черновик содержимого записи в работающей программе, потому что этот код даже не ссобирается. В приложении 17-19 показано определение структур <code>Post</code> и <code>DraftPost</code>, а также способов для каждой из них:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-19/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 17-19: Структура <code>Post</code> с способом <code>content</code> и структура <code>DraftPost</code> без способа <code>content</code></span></p>
<p>Обе структуры, <code>Post</code> и <code>DraftPost</code>, имеют приватное поле <code>content</code>, в котором хранится текст сообщения блога. Структуры больше не содержат поле <code>state</code>, потому что мы перемещаем кодирование состояния в виды структур. Структура <code>Post</code> будет представлять опубликованную публикацию, и у неё есть способ <code>content</code>, который возвращает <code>content</code>.</p>
<p>У нас все ещё есть функция <code>Post::new</code>, но вместо возврата экземпляра <code>Post</code> она возвращает экземпляр <code>DraftPost</code>. Поскольку поле <code>content</code> является приватным и нет никаких функций, которые возвращают <code>Post</code>, просто так создать экземпляр <code>Post</code> уже невозможно.</p>
<p>Структура <code>DraftPost</code> имеет способ <code>add_text</code>, поэтому мы можем добавлять текст к <code>content</code> как и раньше, но учтите, что в <code>DraftPost</code> не определён способ <code>content</code>! Так что теперь программа заверяет, что все записи начинаются как черновики, а черновики публикаций не имеют своего контента для отображения. Любая попытка обойти эти ограничения приведёт к ошибке сборщика.</p>
<h4 id="Реализация-переходов-в-виде-преобразований-в-другие-виды"><a class="header" href="#Реализация-переходов-в-виде-преобразований-в-другие-виды">Реализация переходов в виде преобразований в другие виды</a></h4>
<p>Так как же получить опубликованный пост? Мы хотим обеспечить соблюдение правила, согласно которому черновик записи должен быть рассмотрен и утверждён до того, как он будет опубликован. Запись, находящаяся в состоянии проверки, по-прежнему не должна отображать содержимое. Давайте реализуем эти ограничения, добавив ещё одну структуру, <code>PendingReviewPost</code>, определив способ <code>request_review</code> у <code>DraftPost</code>, возвращающий <code>PendingReviewPost</code>, и определив способ <code>approve</code> у <code>PendingReviewPost</code>, возвращающий <code>Post</code>, как показано в приложении 17-20:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-20/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 17-20: Вид <code>PendingReviewPost</code>, который создаётся путём вызова <code>request_review</code> экземпляра <code>DraftPost</code> и способ <code>approve</code>, который превращает <code>PendingReviewPost</code> в опубликованный <code>Post</code>.</span></p>
<p>Способы <code>request_review</code> и <code>approve</code> забирают во владение <code>self</code>, таким образом поглощая экземпляры <code>DraftPost</code> и <code>PendingReviewPost</code>, которые потом преобразуются в <code>PendingReviewPost</code> и опубликованную <code>Post</code>, соответственно. Таким образом, у нас не будет никаких долгоживущих экземпляров <code>DraftPost</code>, после того, как мы вызвали у них <code>request_review</code> и так далее. В структуре <code>PendingReviewPost</code> не определён способ <code>content</code>, поэтому попытка прочитать его содержимое приводит к ошибке сборщика, также как и в случае с <code>DraftPost</code>. Так как единственным способом получить опубликованный экземпляр <code>Post</code>, у которого действительно есть объявленный способ <code>content</code>, является вызов способа <code>approve</code> у экземпляра <code>PendingReviewPost</code>, а единственный способ получить <code>PendingReviewPost</code> - это вызвать способ <code>request_review</code> у экземпляра <code>DraftPost</code>, теперь мы закодировали процесс смены состояний записи блога с помощью системы видов.</p>
<p>Кроме этого, нужно внести небольшие изменения в <code>main</code>. Так как способы <code>request_review</code> и <code>approve</code> теперь возвращают объекты, а не преобразуют структуру от которой были вызваны, нам нужно добавить больше затеняющих присваиваний <code>let post =</code>, чтобы сохранять возвращаемые объекты. Также, теперь мы не можем использовать утверждения (assertions) для проверки того является ли содержимое черновиков и записей, находящихся на рассмотрении, пустыми строками, да они нам и не нужны - теперь стало невозможным собрать код, который бы пытался использовать содержимое записей, находящихся в этих состояниях. Обновлённый код в <code>main</code> показан в приложении 17-21:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch17-oop/listing-17-21/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 17-21: Изменения в <code>main</code>, использующие новую реализацию процесса подготовки записи блога</span></p>
<p>Изменения, которые нам нужно было внести в <code>main</code>, чтобы переназначить <code>post</code> означают, что эта реализация теперь не совсем соответствует объектно-ориентированному шаблону "Состояние": преобразования между состояниями больше не инкапсулированы внутри реализации <code>Post</code> полностью. Тем не менее, мы получили большую выгоду в том, что недопустимые состояния теперь невозможны из-за системы видов и проверки видов, которая происходит во время сборки! У нас есть заверенияия, что некоторые ошибки, такие как отображение содержимого неопубликованной публикации, будут обнаружены до того, как они дойдут до пользователей.</p>
<p>Попробуйте выполнить задачи, предложенные в начале этого раздела, в исполнения крейта <code>blog</code>, каким он стал после приложения 17-20, чтобы сформировать своё мнение о дизайне этой исполнения кода. Обратите внимание, что некоторые задачи в этом варианте могут быть уже выполнены.</p>
<p>Мы увидели, что хотя Rust и способен реализовывать объектно-ориентированные шаблоны проектирования, в нём также доступны и другие шаблоны, такие как кодирование состояния с помощью системы видов. Эти модели имеют различные соглашения. Хотя вы, возможно, очень хорошо знакомы с объектно-ориентированными шаблонами, переосмысление проблем для использования преимуществ и возможностей Rust может дать такие выгоды, как предотвращение некоторых ошибок во время сборки. Объектно-ориентированные шаблоны не всегда будут лучшим решением в Rust из-за наличия определённых возможностей, таких как владение, которого нет у объектно-ориентированных языков.</p>
<h2 id="Итоги-14"><a class="header" href="#Итоги-14">Итоги</a></h2>
<p>Независимо от того, что вы думаете о принадлежности Rust к объектно-ориентированным языкам после прочтения этой главы, теперь вы знаете, что можете использовать типаж-объекты, чтобы реализовать некоторые объектно-ориентированные свойства в Rust. Изменяемая управление может дать вашему коду некоторую гибкость в обмен на небольшое ухудшение производительности во время выполнения. Вы можете использовать эту гибкость для реализации объектно-ориентированных шаблонов, которые могут улучшить сопровождаемость вашего кода. В Rust также есть другие особенности, такие как владение, которых нет у объектно-ориентированных языков. Объектно-ориентированный шаблон не всегда будет лучшим способом использовать преимущества Rust, но является доступной опцией.</p>
<p>Далее мы рассмотрим шаблоны, которые являются ещё одной особенностью Rust, обеспечивающей высокую гибкость. Мы бегло рассказывали о них на протяжении всей книги, но ещё не видели всех их возможностей. Вперёд!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Шаблоны-и-сопоставление"><a class="header" href="#Шаблоны-и-сопоставление">Шаблоны и сопоставление</a></h1>
<p><em>Шаблоны</em> - это особый синтаксис в Rust для сопоставления со структурой видов, как сложных, так и простых. Использование шаблонов в сочетании с выражениями <code>match</code> и другими конструкциями даёт вам больший управление над потоком управления программы. Шаблон состоит из некоторой сочетания следующего:</p>
<ul>
<li>Литералы</li>
<li>Деструктурированные массивы, перечисления, структуры или кортежи</li>
<li>Переменные</li>
<li>Специальные символы</li>
<li>Заполнители</li>
</ul>
<p>Некоторые примеры шаблонов включают <code>x</code> , <code>(a, 3)</code> и <code>Some(Color::Red)</code> . В средах, в которых допустимы шаблоны, эти компоненты описывают форму данных. Затем наша программа сопоставляет значения с шаблонами, чтобы определить, имеет ли значение правильную форму данных для продолжения выполнения определённого фрагмента кода.</p>
<p>Чтобы использовать шаблон, мы сравниваем его с некоторым значением. Если шаблон соответствует значению, мы используем части значения в нашем дальнейшем коде. Вспомните выражения <code>match</code> главы 6, в которых использовались шаблоны, например, описание машины для сортировки монет. Если значение в памяти соответствует форме шаблона, мы можем использовать именованные части шаблона. Если этого не произойдёт, то не выполнится код, связанный с шаблоном.</p>
<p>Эта глава - справочник по всем моментам, связанным с шаблонами. Мы расскажем о допустимых местах использования шаблонов, разнице между опровержимыми и неопровержимыми шаблонами и про различные виды синтаксиса шаблонов, которые вы можете увидеть. К концу главы вы узнаете, как использовать шаблоны для ясного выражения многих понятий.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Все-случаи-где-могут-быть-использованы-шаблоны"><a class="header" href="#Все-случаи-где-могут-быть-использованы-шаблоны">Все случаи, где могут быть использованы шаблоны</a></h2>
<p>В процессе использования языка Rust вы часто используете шаблоны, даже не осознавая этого! В этом разделе обсуждаются все случаи, где использование шаблонов является корректным.</p>
<h3 id="Ветки-match"><a class="header" href="#Ветки-match">Ветки <code>match</code></a></h3>
<p>Как обсуждалось в главе 6, мы используем шаблоны в ветках выражений <code>match</code>. Формально выражения <code>match</code> определяется как ключевое слово <code>match</code>, значение используемое для сопоставления, одна или несколько веток, которые состоят из шаблона и выражения для выполнения, если значение соответствует шаблону этой ветки, как здесь:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Например, вот выражение <code>match</code> из приложения 6-5, которое соответствует значению <code>Option&lt;i32&gt;</code> в переменной <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Шаблонами в этом выражении <code>match</code> являются <code>None</code> и <code>Some(i)</code> слева от каждой стрелки.</p>
<p>Одно из требований к выражениям <code>match</code> состоит в том, что они должны быть <em>исчерпывающими</em> (exhaustive) в том смысле, что они должны учитывать все возможности для значения в выражении <code>match</code>. Один из способов убедиться, что вы рассмотрели каждую возможность - это иметь шаблон перехвата всех вариантов в последней ветке выражения: например, имя переменной, совпадающее с любым значением, никогда не может потерпеть неудачу и таким образом, охватывает каждый оставшийся случай.</p>
<p>Специальный шаблон <code>_</code> будет соответствовать чему угодно, но он никогда не привязывается к переменной, поэтому он часто используется в последней ветке. Шаблон <code>_</code> может быть полезен, если вы, например, хотите пренебрегать любое не указанное значение. Мы рассмотрим шаблон <code>_</code> более подробно в разделе <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">"Пренебрежение значений в шаблоне</a><!--  --> позже в этой главе.</p>
<h3 id="Условные-выражения-if-let"><a class="header" href="#Условные-выражения-if-let">Условные выражения <code>if let</code></a></h3>
<p>В главе 6 мы обсуждали, как использовать выражения <code>if let</code> как правило в качестве более короткого способа записи эквивалента <code>match</code>, которое обрабатывает только один случай. Дополнительно <code>if let</code> может иметь соответствующий <code>else</code>, содержащий код для выполнения, если шаблон выражения <code>if let</code> не совпадает.</p>
<p>В приложении 18-1 показано, что можно также смешивать и сопоставлять выражения <code>if let</code>, <code>else if</code> и <code>else if let</code>. Это даёт больше гибкости, чем <code>match</code> выражение, в котором можно выразить только одно значение для сравнения с шаблонами. Кроме того, условия в серии <code>if let</code>, <code>else if</code>, <code>else if let</code> не обязаны соотноситься друг с другом.</p>
<p>Код в приложении 18-1 показывает последовательность проверок нескольких условий, определяющих каким должен быть цвет фона. В данном примере мы создали переменные с предопределёнными значениями, которые в существующей программе могли бы быть получены из пользовательского ввода.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-1: Использование условных конструкций <code>if let</code>, <code>else if</code>, <code>else if let</code>, и <code>else</code></span></p>
<p>Если пользователь указывает любимый цвет, то этот цвет используется в качестве цвета фона. Если любимый цвет не указан, и сегодня вторник, то цвет фона - зелёный. Иначе, если пользователь указывает свой возраст в виде строки, и мы можем успешно проанализировать её и представить в виде числа, то цвет будет либо фиолетовым, либо оранжевым, в зависимости от значения числа. Если ни одно из этих условий не выполняется, то цвет фона будет синим.</p>
<p>Эта условная структура позволяет поддерживать сложные требования. С жёстко закодированными значениями, которые у нас здесь есть, этот пример напечатает <code>Using purple as the background color</code>.</p>
<p>Можно увидеть, что <code>if let</code> может также вводить затенённые переменные, как это можно сделать в <code>match</code> ветках: строка <code>if let Ok(age) = age</code> вводит новую затенённую переменную <code>age</code>, которая содержит значение внутри варианта <code>Ok</code>. Это означает, что нам нужно поместить условие <code>if age &gt; 30</code> внутри этого блок: мы не можем объединить эти два условия в <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. Затенённый <code>age</code>, который мы хотим сравнить с 30, не является действительным, пока не начнётся новая область видимости с фигурной скобки.</p>
<p>Недостатком использования <code>if let</code> выражений является то, что сборщик не проверяет полноту (exhaustiveness) всех вариантов, в то время как с помощью выражения <code>match</code> это происходит. Если мы не напишем последний раздел<code>else</code> и, благодаря этому, пропустим обработку некоторых случаев, сборщик не предупредит нас о возможной логической ошибке.</p>
<h3 id="Условные-циклы-while-let"><a class="header" href="#Условные-циклы-while-let">Условные циклы <code>while let</code></a></h3>
<p>Подобно конструкции <code>if let</code>, конструкция условного цикла <code>while let</code> позволяет повторять цикл <code>while</code> до тех пор, пока шаблон продолжает совпадать. Пример в приложении 18-2 отображает цикл <code>while let</code>, который использует вектор в качестве стека и печатает значения вектора в порядке, обратном тому, в котором они были помещены.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-2: Использование цикла <code>while let</code> для печати значений до тех пор, пока <code>stack.pop()</code> возвращает <code>Some</code></span></p>
<p>В этом примере выводится 3, 2, а затем 1. Способ <code>pop</code> извлекает последний элемент из вектора и возвращает <code>Some(value)</code>. Если вектор пуст, то <code>pop</code> возвращает <code>None</code>. Цикл <code>while</code> продолжает выполнение кода в своём разделе, пока <code>pop</code> возвращает <code>Some</code>. Когда <code>pop</code> возвращает <code>None</code>, цикл останавливается. Мы можем использовать <code>while let</code> для удаления каждого элемента из стека.</p>
<h3 id="Цикл-for"><a class="header" href="#Цикл-for">Цикл <code>for</code></a></h3>
<p>В цикле <code>for</code> значение, которое следует непосредственно за ключевым словом <code>for</code> , является шаблоном. Например, в <code>for x in y</code>  выражение <code>x</code> является шаблоном. В приложении 18-3 показано, как использовать шаблон в цикле <code>for</code> , чтобы деструктурировать или разбить кортеж как часть цикла <code>for</code> .</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-3: Использование шаблона в цикле <code>for</code> для деструктурирования кортежа</span></p>
<p>Код в приложении 18-3 выведет следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch18-patterns-and-matching/listing-18-03/output.txt}}
</code></pre>
<p>Мы адаптируем повторительс помощью способа <code>enumerate</code>, чтобы он генерировал кортеж, состоящий из значения и порядкового казателя этого значения. Первым сгенерированным значением будет кортеж <code>(0, 'a')</code>. Когда это значение сопоставляется с шаблоном <code>(index, value)</code>, <code>index</code> будет равен <code>0</code>, а <code>value</code> будет равно <code>'a'</code> и будет напечатана первая строка выходных данных.</p>
<h3 id="Указание-let"><a class="header" href="#Указание-let">Указание <code>let</code></a></h3>
<p>До этой главы мы подробно обсуждали только использование шаблонов с <code>match</code> и <code>if let</code>, но на самом деле, мы использовали шаблоны и в других местах, в том числе в указаниях <code>let</code>. Например, рассмотрим следующее простое назначение переменной с помощью <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Каждый раз, когда вы использовали подобным образом указанию <code>let</code>, вы использовали шаблоны, хотя могли и не осознавать этого! Более формально указание <code>let</code> выглядит так:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>В указаниях вида <code>let x = 5;</code> с именем переменной в слоте <code>PATTERN</code>, имя переменной является просто отдельной, простой формой шаблона. Rust сравнивает выражение с шаблоном и присваивает любые имена, которые он находит. Так что в примере <code>let x = 5;</code>, <code>x</code> - это шаблон, который означает "привязать то, что соответствует здесь, переменной <code>x</code>". Поскольку имя <code>x</code> является полностью шаблоном, этот шаблон фактически означает "привязать все к переменной <code>x</code> независимо от значения".</p>
<p>Чтобы более чётко увидеть особенность сопоставления с шаблоном <code>let</code>, рассмотрим приложение 18-4, в котором используется шаблон с <code>let</code> для деструктурирования кортежа.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-04/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-4. Использование шаблона для деструктуризации кортежа и создания трёх переменных одновременно</span></p>
<p>Здесь мы сопоставляем кортеж с шаблоном. Rust сравнивает значение <code>(1, 2, 3)</code> с шаблоном <code>(x, y, z)</code> и видит, что значение соответствует шаблону, поэтому Rust связывает <code>1</code> с <code>x</code>, <code>2</code> с <code>y</code> и <code>3</code> с <code>z</code>. Вы можете думать об этом шаблоне кортежа как о вложении в него трёх отдельных шаблонов переменных.</p>
<p>Если количество элементов в шаблоне не совпадает с количеством элементов в кортеже, то весь вид не будет совпадать и мы получим ошибку сборщика. Например, в приложении 18-5 показана попытка деструктурировать кортеж с тремя элементами в две переменные, что не будет работать.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-05/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 18-5: Неправильное построение шаблона, переменные не соответствуют количеству элементов в кортеже</span></p>
<p>Попытка собрать этот код приводит к ошибке:</p>
<pre><code class="language-console">{{#include ../listings/ch18-patterns-and-matching/listing-18-05/output.txt}}
</code></pre>
<p>Чтобы исправить ошибку, мы могли бы пренебрегать одно или несколько значений в кортеже, используя <code>_</code> или <code>..</code>, как вы увидите в разделе <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Пренебрежение значений в Шаблоне”</a> <!-- ignore -->. Если шаблон содержит слишком много переменных в шаблоне, можно решить проблему, сделав виды совпадающими, удалив некоторые переменные таким образом, чтобы число переменных равнялось числу элементов в кортеже.</p>
<h3 id="Свойства-функции-1"><a class="header" href="#Свойства-функции-1">Свойства функции</a></h3>
<p>Свойства функции также могут быть шаблонами. Код в приложении 18-6 объявляет функцию с именем <code>foo</code>, которая принимает один свойство с именем <code>x</code> вида <code>i32</code>, к настоящему времени это должно выглядеть знакомым.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-06/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-6: Сигнатура функции использует шаблоны в свойствах</span></p>
<p><code>x</code> это часть шаблона! Как и в случае с <code>let</code>, мы можем сопоставить кортеж в переменных функции с шаблоном. Приложение 18-7 разделяет значения в кортеже при его передачи в функцию.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-07/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-7: Функция с свойствами, которая разрушает кортеж</span></p>
<p>Этот код печатает <code>Current location: (3, 5)</code>. Значения <code>&amp;(3, 5)</code> соответствуют шаблону <code>&amp;(x, y)</code>, поэтому <code>x</code> - это значение <code>3</code>, а <code>y</code> - это значение <code>5</code>.</p>
<p>Добавляя к вышесказанному, мы можем использовать шаблоны в списках свойств замыкания таким же образом, как и в списках свойств функции, потому что, как обсуждалось в главе 13, замыкания похожи на функции.</p>
<p>На данный момент вы видели несколько способов использования шаблонов, но шаблоны работают не одинаково во всех местах, где их можно использовать. В некоторых местах шаблоны должны быть неопровержимыми; в других обстоятельствах они могут быть опровергнуты. Мы обсудим эти две концепции далее.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Возможность-опровержения-может-ли-шаблон-не-совпадать"><a class="header" href="#Возможность-опровержения-может-ли-шаблон-не-совпадать">Возможность опровержения: может ли шаблон не совпадать</a></h2>
<p>Шаблоны бывают двух форм: опровержимые и неопровержимые. Шаблоны, которые будут соответствовать любому возможному переданному значению, являются <em>неопровержимыми</em> (irrefutable). Примером может быть <code>x</code> в указания <code>let x = 5;</code>, потому что <code>x</code> соответствует чему-либо и, следовательно, не может не совпадать. Шаблоны, которые могут не соответствовать некоторому возможному значению, являются <em>опровержимыми</em> (refutable). Примером может быть <code>Some(x)</code> в выражении <code>if let Some(x) = a_value</code>, потому что если значение в переменной <code>a_value</code> равно <code>None</code>, а не <code>Some</code>, то шаблон <code>Some(x)</code> не будет совпадать.</p>
<p>Свойства функций, указания <code>let</code> и циклы <code>for</code> могут принимать только неопровержимые шаблоны, поскольку программа не может сделать ничего значимого, если значения не совпадают. А выражения <code>if let</code> и <code>while let</code> принимают опровержимые и неопровержимые шаблоны, но сборщик предостерегает от неопровержимых шаблонов, поскольку по определению они предназначены для обработки возможного сбоя: функциональность условного выражения заключается в его способности выполнять разный код в зависимости от успеха или неудачи.</p>
<p>В общем случае, вам не нужно беспокоиться о разнице между опровержимыми (refutable) и неопровержимыми (irrefutable) шаблонами; тем не менее, вам необходимо ознакомиться с концепцией возможности опровержения, чтобы вы могли отреагировать на неё, увидев в сообщении об ошибке. В таких случаях вам потребуется изменить либо шаблон, либо конструкцию, с которой вы используете шаблон, в зависимости от предполагаемого поведения кода.</p>
<p>Давайте посмотрим на пример того, что происходит, когда мы пытаемся использовать опровержимый шаблон, где Rust требует неопровержимый шаблон, и наоборот. В приложении 18-8 показана указание <code>let</code>, но для образца мы указали <code>Some(x)</code>, являющийся шаблоном, который можно опровергнуть. Как и следовало ожидать, этот код не будет собираться.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-08/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 18-8: Попытка использовать опровержимый шаблон вместе с <code>let</code></span></p>
<p>Если <code>some_option_value</code> было бы значением <code>None</code>, то оно не соответствовало бы шаблону <code>Some(x)</code>, что означает, что шаблон является опровержимым. Тем не менее, указание <code>let</code> может принимать только неопровержимый шаблон, потому что нет корректного кода, который может что-то сделать со значением <code>None</code>. Во время сборки Rust будет жаловаться на то, что мы пытались использовать опровержимый шаблон, для которого требуется неопровержимый шаблон:</p>
<pre><code class="language-console">{{#include ../listings/ch18-patterns-and-matching/listing-18-08/output.txt}}
</code></pre>
<p>Поскольку мы не покрыли (и не могли покрыть!) каждое допустимое значение с помощью образца <code>Some(x)</code>, то Rust выдаёт ошибку сборки.</p>
<p>Чтобы исправить проблему наличия опровержимого шаблона, там, где нужен неопровержимый шаблон, можно изменить код, использующий шаблон: вместо использования <code>let</code>, можно использовать <code>if let</code>. Затем, если шаблон не совпадает, выполнение кода внутри фигурных скобок будет пропущено, что даст возможность продолжить корректное выполнение. В приложении 18-9 показано, как исправить код из приложения 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-09/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-9. Использование <code>if let</code> и раздела с опровергнутыми шаблонами вместо <code>let</code></span></p>
<p>Код исправлен! Этот код совершенно корректный, хотя это означает, что мы не можем использовать неопровержимый образец без получения ошибки. Если мы используем шаблон <code>if let</code>, который всегда будет совпадать, то для примера <code>x</code>, показанного в приложении 18-10, сборщик выдаст предупреждение.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-10/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-10. Попытка использовать неопровержимый шаблон с <code>if let</code></span></p>
<p>Rust жалуется, что не имеет смысла использовать <code>if let</code> с неопровержимым образцом:</p>
<pre><code class="language-console">{{#include ../listings/ch18-patterns-and-matching/listing-18-10/output.txt}}
</code></pre>
<p>По этой причине совпадающие ветки выражений должны использовать опровержимые шаблоны, за исключением последнего, который должен сопоставлять любые оставшиеся значения с неопровержимым шаблоном. Rust позволяет нам использовать неопровержимый шаблон в <code>match</code> только с одной веткой, но этот синтаксис не особенно полезен и может быть заменён более простой указанием <code>let</code>.</p>
<p>Теперь, когда вы знаете, где использовать шаблоны и разницу между опровержимыми и неопровержимыми шаблонами, давайте рассмотрим весь синтаксис, который мы можем использовать для создания шаблонов.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Синтаксис-шаблонов"><a class="header" href="#Синтаксис-шаблонов">Синтаксис шаблонов</a></h2>
<p>В этом разделе мы рассмотрим все виды допустимого синтаксиса в шаблонах и расскажем, когда и для чего вам может понадобиться каждый из них.</p>
<h3 id="Сопоставление-с-литералом"><a class="header" href="#Сопоставление-с-литералом">Сопоставление с литералом</a></h3>
<p>Как мы уже видели в главе 6, можно сопоставлять шаблоны с литералами напрямую. В следующем коде есть несколько примеров:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Этот код печатает <code>one</code>, потому что значение в <code>x</code> равно 1. Данный синтаксис полезен, когда вы хотите, чтобы ваш код предпринял действие, если он получает определенное значение.</p>
<h3 id="Сопоставление-именованных-переменных"><a class="header" href="#Сопоставление-именованных-переменных">Сопоставление именованных переменных</a></h3>
<p>Именованные переменные - это неопровержимые (irrefutable) шаблоны, которые соответствуют любому значению и мы использовали их много раз в книге. Однако при использовании именованных переменных в выражениях <code>match</code> возникает сложность. Поскольку <code>match</code> начинает новую область видимости, то переменные, объявленные как часть шаблона внутри выражения <code>match</code>, будут затенять переменные с тем же именем вне конструкции <code>match</code> как и в случае со всеми переменными. В приложении 18-11 мы объявляем переменную с именем <code>x</code> со значением <code>Some(5)</code> и переменную <code>y</code> со значением <code>10</code>. Затем мы создаём выражение <code>match</code> для значения <code>x</code>. Посмотрите на шаблоны в ветках, <code>println!</code> в конце и попытайтесь выяснить, какой код будет напечатан прежде чем запускать его или читать дальше.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-11/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-11: Выражение <code>match</code> с веткой, которая добавляет затенённую переменную <code>y</code></span></p>
<p>Давайте рассмотрим, что происходит, когда выполняется выражение <code>match</code>. Шаблон в первой ветке не соответствует определённому значению <code>x</code>, поэтому выполнение продолжается.</p>
<p>Шаблон во второй ветке вводит новую переменную с именем <code>y</code>, которая будет соответствовать любому значению в <code>Some</code>. Поскольку мы находимся в новой области видимости внутри выражения <code>match</code>, это новая переменная <code>y</code>, а не <code>y</code> которую мы объявили в начале со значением 10. Эта новая привязка <code>y</code> будет соответствовать любому значению из <code>Some</code>, которое находится в <code>x</code>. Следовательно, эта новая <code>y</code> связывается с внутренним значением <code>Some</code> из переменной <code>x</code>. Этим значением является <code>5</code>, поэтому выражение для этой ветки выполняется и печатает <code>Matched, y = 5</code>.</p>
<p>Если бы <code>x</code> было значением <code>None</code> вместо <code>Some(5)</code>, то шаблоны в первых двух ветках не совпали бы, поэтому значение соответствовало бы подчёркиванию. Мы не ввели переменную <code>x</code> в шаблоне ветки со знаком подчёркивания, поэтому <code>x</code> в выражении все ещё является внешней переменной <code>x</code>, которая не была затенена. В этом гипотетическом случае совпадение <code>match</code> выведет <code>Default case, x = None</code>.</p>
<p>Когда выражение <code>match</code> завершается, заканчивается его область видимости как и область действия внутренней переменной <code>y</code>. Последний <code>println!</code> печатает <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Чтобы создать выражение <code>match</code>, которое сравнивает значения внешних <code>x</code> и <code>y</code>, вместо введения затенённой переменной нужно использовать условие в сопоставлении образца. Мы поговорим про условие в сопоставлении шаблона позже в разделе <a href="ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">“Дополнительные условия в сопоставлении образца”</a><!--  -->.</p>
<h3 id="Группа-шаблонов"><a class="header" href="#Группа-шаблонов">Группа шаблонов</a></h3>
<p>В выражениях <code>match</code> можно сравнивать сразу с несколькими шаблонами, используя синтаксис <code>|</code>, который является оператором паттерна <em>or</em>. Например, в следующем примере мы сопоставляем значение <code>x</code> с ветвями match, первая из которых содержит оператор <em>or</em>, так что если значение <code>x</code> совпадёт с любым из значений в этой ветви, то будет выполнен её код:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Будет напечатано <code>one or two</code>.</p>
<h3 id="Сопоставление-рядов-с-помощью-"><a class="header" href="#Сопоставление-рядов-с-помощью-">Сопоставление рядов с помощью <code>..=</code></a></h3>
<p>Синтаксис <code>..=</code> позволяет нам выполнять сравнение с рядом значений. В следующем коде, когда в шаблоне найдётся совпадение с любым из значений заданного ряда, будет выполнена эта ветка:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Если <code>x</code> равен 1, 2, 3, 4 или 5, то совпадение будет достигнуто в первой ветке. Этот синтаксис более удобен при указании нескольких значений для сравнения, чем использование оператора <code>|</code> для определения этой же идеи; если бы мы решили использовать <code>|</code>, нам пришлось бы написать <code>1 | 2 | 3 | 4 | 5</code>. Указание ряда намного короче, особенно если мы хотим подобрать, скажем, любое число от 1 до 1 000!</p>
<p>Сборщик проверяет, что рядне является пустым во время сборки, и поскольку единственными видами, для которых Rust может определить, пуст рядили нет, являются <code>char</code> и числовые значения, ряды допускаются только с числовыми или <code>char</code> значениями.</p>
<p>Вот пример использования рядов значений <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Rust может сообщить, что <code>'c'</code> находится в ряде первого шаблона и напечатать <code>early ASCII letter</code>.</p>
<h3 id="Деструктуризация-для-получения-значений"><a class="header" href="#Деструктуризация-для-получения-значений">Деструктуризация для получения значений</a></h3>
<p>Мы также можем использовать шаблоны для деструктуризации структур, перечислений и кортежей, чтобы использовать разные части этих значений. Давайте пройдёмся по каждому варианту.</p>
<h4 id="Деструктуризация-структуры"><a class="header" href="#Деструктуризация-структуры">Деструктуризация структуры</a></h4>
<p>В приложении 18-12 показана структура <code>Point</code> с двумя полями <code>x</code> и <code>y</code>, которые мы можем разделить, используя шаблон с указанием <code>let</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-12/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-12: Разбиение полей структуры в отдельные переменные</span></p>
<p>Этот код создаёт переменные <code>a</code> и <code>b</code> , которые сопоставляются значениям полей <code>x</code> и <code>y</code> структуры <code>p</code> . Этот пример показывает, что имена переменных в шаблоне не обязательно должны совпадать с именами полей структуры. Однако обычно имена переменных сопоставляются с именами полей, чтобы было легче запомнить, какие переменные взяты из каких полей. Из-за этого, а также из-за того, что строчка <code>let Point { x: x, y: y } = p;</code> содержит много повторения, в Rust ввели особое сокращение для шаблонов, соответствующих полям структуры: вам нужно только указать имя поля структуры, и тогда переменные, созданные из шаблона, будут иметь те же имена. Код в приложении 18-13 подобен коду в Приложении 18-12, но в шаблоне <code>let</code> создаются переменные <code>x</code> и <code>y</code>, вместо <code>a</code> и <code>b</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-13/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-13: Деструктуризация полей структуры с использованием сокращённой записи</span></p>
<p>Этот код создаёт переменные <code>x</code> и <code>y</code>, которые соответствуют полям <code>x</code> и <code>y</code> из переменной <code>p</code>. В результате переменные <code>x</code> и <code>y</code> содержат значения из структуры <code>p</code>.</p>
<p>А ещё, используя литеральные значения в шаблоне, мы можем деструктурировать, не создавая переменные для всех полей. Это даёт возможность, проверяя одни поля на соответствие определенным значениям, создавать переменные для деструктуризации других.</p>
<p>В приложении 18-14 показано выражение <code>match</code>, которое разделяет значения <code>Point</code> на три случая: точки, которые лежат непосредственно на оси <code>x</code> (что верно, когда <code>y = 0</code>), на оси <code>y</code> (<code>x = 0</code>) или ни то, ни другое.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-14/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-14: Деструктуризация и сопоставление с литералами в одном шаблоне</span></p>
<p>Первая ветвь будет соответствовать любой точке, лежащей на оси <code>x</code>, если значение поля <code>y</code> будет соответствовать литералу <code>0</code>. Шаблон по-прежнему создаёт переменную <code>x</code>, которую мы сможем использовать в коде этой ветви.</p>
<p>Подобно, вторая ветвь совпадёт с любой точкой на оси <code>y</code>, в случае, если значение поля <code>x</code> будет равно <code>0</code>, а для значения поля <code>y</code> будет создана переменная <code>y</code>. Третья ветвь не содержит никаких литералов, поэтому она соответствует любому другому <code>Point</code> и создаёт переменные как для поля <code>x</code>, так и для поля <code>y</code>.</p>
<p>В этом примере значение <code>p</code> совпадает по второй ветке, так как <code>x</code> содержит значение 0, поэтому этот код будет печатать <code>On the y axis at 7</code>.</p>
<p>Помните, что выражение <code>match</code> перестаёт проверять следующие ветви, как только оно находит первый совпадающий шаблон, поэтому, даже если <code>Point { x: 0, y: 0}</code> находится на оси <code>x</code> и оси <code>y</code>, этот код будет печатать только <code>On the x axis at 0</code> .</p>
<h4 id="Деструктуризация-перечислений"><a class="header" href="#Деструктуризация-перечислений">Деструктуризация перечислений</a></h4>
<p>Мы уже деструктурировали перечисления в книге (см., например, приложение 6-5 главы 6), но<br>не обсуждали явно, что шаблон для деструктуризации перечисления должен соответствовать способу объявления данных, хранящихся в перечислении. Например, в приложении 18-15 мы используем перечисление <code>Message</code> из приложения 6-2 и пишем <code>match</code> с шаблонами, которые будут деструктурировать каждое внутреннее значение.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-15/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-15: Деструктуризация вариантов перечисления, содержащих разные виды значений</span></p>
<p>Этот код напечатает <code>Change the color to red 0, green 160, and blue 255</code>. Попробуйте изменить значение переменной <code>msg</code>, чтобы увидеть выполнение кода в других ветках.</p>
<p>Для вариантов перечисления без каких-либо данных, вроде <code>Message::Quit</code>, мы не можем деструктурировать значение, которого нет. Мы можем сопоставить только буквальное значение <code>Message::Quit</code> в этом шаблоне, но без переменных.</p>
<p>Для вариантов перечисления похожих на структуры, таких как <code>Message::Move</code>, можно использовать шаблон, подобный шаблону, который мы указываем для сопоставления структур. После имени варианта мы помещаем фигурные скобки и затем перечисляем поля именами переменных. Таким образом мы разделяем фрагменты, которые будут использоваться в коде этой ветки. Здесь мы используем сокращённую форму, как в приложении 18-13.</p>
<p>Для вариантов перечисления, подобных кортежу, вроде <code>Message::Write</code>, который содержит кортеж с одним элементом и <code>Message::ChangeColor</code>, содержащему кортеж с тремя элементами, шаблон подобен тому, который мы указываем для сопоставления кортежей. Количество переменных в шаблоне должно соответствовать количеству элементов в варианте, который мы сопоставляем.</p>
<h4 id="Деструктуризация-вложенных-структур-и-перечислений"><a class="header" href="#Деструктуризация-вложенных-структур-и-перечислений">Деструктуризация вложенных структур и перечислений</a></h4>
<p>До сих пор все наши примеры сопоставляли структуры или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами! Например, мы можем реорганизовать код в приложении 18-15 для поддержки цветов RGB и HSV в сообщении <code>ChangeColor</code> , как показано в приложении 18-16.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-16/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-16: Сопоставление со вложенными перечислениями</span></p>
<p>Шаблон первой ветки в выражении <code>match</code> соответствует варианту перечисления <code>Message::ChangeColor</code>, который содержит вариант <code>Color::Rgb</code>; затем шаблон привязывается к трём внутренними значениями <code>i32</code>. Шаблон второй ветки также соответствует варианту перечисления <code>Message::ChangeColor</code>, но внутреннее перечисление соответствует варианту <code>Color::Hsv</code>. Мы можем указать эти сложные условия в одном выражении <code>match</code>, даже если задействованы два перечисления.</p>
<h4 id="Деструктуризация-структур-и-кортежей"><a class="header" href="#Деструктуризация-структур-и-кортежей">Деструктуризация структур и кортежей</a></h4>
<p>Можно смешивать, сопоставлять и вкладывать шаблоны деструктуризации ещё более сложными способами. В следующем примере показана сложная деструктуризация, где мы вкладываем структуры и кортежи внутрь кортежа и деструктурируем из него все примитивные значения:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Этот код позволяет нам разбивать сложные виды на составные части, чтобы мы могли использовать нужным нас значения по отдельности.</p>
<p>Деструктуризация с помощью шаблонов - это удобный способ использования фрагментов значений, таких как как значение из каждого поля в структуре, по отдельности друг от друга.</p>
<h3 id="Пренебрежение-значений-в-шаблоне"><a class="header" href="#Пренебрежение-значений-в-шаблоне">Пренебрежение значений в шаблоне</a></h3>
<p>Вы видели, что иногда полезно пренебрегать значения в шаблоне, например в последней ветке <code>match</code>, чтобы получить ветку, обрабатывающую любые значения, которая на самом деле ничего не делает, но учитывает все оставшиеся возможные значения. Есть несколько способов пренебрегать целые значения или части значений в шаблоне: используя шаблон <code>_</code> (который вы видели), используя шаблон <code>_</code> внутри другого шаблона, используя имя, начинающееся с подчёркивания, либо используя <code>..</code>, чтобы пренебрегать оставшиеся части значения. Давайте рассмотрим, как и зачем использовать каждый из этих шаблонов.</p>
<h4 id="Пренебрежение-всего-значения-с-помощью-шаблона-_"><a class="header" href="#Пренебрежение-всего-значения-с-помощью-шаблона-_">Пренебрежение всего значения с помощью шаблона <code>_</code></a></h4>
<p>Мы использовали подчёркивание (<code>_</code>) в качестве шаблона подстановочного знака (wildcard), который будет сопоставляться с любом значением, но не будет привязываться к этому значению. Это особенно удобно в последней ветке выражения <code>match</code>, но мы также можем использовать его в любом шаблоне, в том числе в свойствах функции, как показано в приложении 18-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-17/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-15: Использование <code>_</code> в сигнатуре функции</span></p>
<p>Этот код полностью пренебрегает значение <code>3</code>, переданное в качестве первого переменной, и выведет на печать <code>This code only uses the y parameter: 4</code>.</p>
<p>В большинстве случаев, когда вам больше не нужен какой-то из свойств функции, вы можете изменить её сигнатуру, убрав неиспользуемый свойство. Пренебрежение свойства функции может быть особенно полезно в случаях когда, например, вы реализуете типаж с определённой сигнатурой, но тело функции в вашей реализации не нуждается в одном из свойств. В таком случае сборщик не будет выдавать предупреждения о неиспользуемых свойствах функции, как это было бы, если бы вы указали имя свойства.</p>
<h4 id="Пренебрежение-частей-значения-с-помощью-вложенного-_"><a class="header" href="#Пренебрежение-частей-значения-с-помощью-вложенного-_">Пренебрежение частей значения с помощью вложенного <code>_</code></a></h4>
<p>Также, <code>_</code> можно использовать внутри шаблонов, чтобы пренебрегать какую-то часть значения, например, когда мы хотим проверить только определённую подробность, а остальные свойства нам не понадобятся в коде, который нужно выполнить. В приложении 18-18 показан код, ответственный за управление значениями настроек. Согласно бизнес-требованиям, пользователь не может изменить установленное значение свойства, но может удалить его и задать ему новое значение, если на данный момент оно отсутствует.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-18/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-18: Использование подчёркивания в шаблонах, соответствующих вариантам <code>Some</code>, когда нам не нужно использовать значение внутри <code>Some</code></span></p>
<p>Этот код будет печатать <code>Can't overwrite an existing customized value</code>, а затем <code>setting is Some(5)</code>. В первой ветке нам не нужно сопоставлять или использовать значения внутри варианта <code>Some</code>, но нам нужно проверить случай, когда <code>setting_value</code> и <code>new_setting_value</code> являются вариантом <code>Some</code>. В этом случае мы печатаем причину, почему мы не меняем значение <code>setting_value</code> и оно не меняется.</p>
<p>Во всех других случаях (если либо <code>setting_value</code>, либо <code>new_setting_value</code> являются вариантом <code>None</code>), выраженных шаблоном <code>_</code> во второй ветке, мы хотим, чтобы <code>new_setting_value</code> стало равно <code>setting_value</code>.</p>
<p>Мы также можем использовать подчёркивание в нескольких местах в одном шаблоне, чтобы пренебрегать определенные значения. Приложение 18-19 показывает пример пренебрежения второго и четвёртого значения в кортеже из пяти элементов.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-19/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-19: Пренебрежение нескольких частей кортежа</span></p>
<p>Этот код напечатает <code>Some numbers: 2, 8, 32</code>, а значения 4 и 16 будут пренебрежены.</p>
<h4 id="Пренебрежение-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени"><a class="header" href="#Пренебрежение-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени">Пренебрежение неиспользуемой переменной, начинающейся с символа <code>_</code> в имени</a></h4>
<p>Если вы создаёте переменную, но нигде её не используете, Rust обычно выдаёт предупреждение, потому что неиспользуемая переменная может быть ошибкой. Но иногда полезно создать переменную, которую вы пока не используете, например, когда вы создаёте протовид или только начинаете проект. В этой ситуации вы можете сказать Rust не предупреждать вас о неиспользуемой переменной, начав имя переменной с подчёркивания. В приложении 18-20 мы создаём две неиспользуемые переменные, но когда мы собираем такой код, мы должны получить предупреждение только об одной из них.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-20/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-20: Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных</span></p>
<p>Здесь мы получаем предупреждение о том, что не используем переменную <code>y</code>, но мы не получаем предупреждения о неиспользовании переменной<code>_x</code>.</p>
<p>Обратите внимание, что есть небольшая разница между использованием только <code>_</code> и использованием имени, начинающегося с подчёркивания. Синтаксис <code>_x </code> по-прежнему привязывает значение к переменной, тогда как <code>_</code> не привязывает ничего. В приложении 18-21 представлена ошибка, показывающая, в каком случае это различие имеет значение.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-21/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 18-21: Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения</span></p>
<p>Мы получим ошибку, поскольку значение <code>s</code> все равно будет перемещено в <code>_s</code>, что не позволит нам больше воспользоваться <code>s</code>. Однако использование подчёркивания само по себе никогда не приводит к привязке к значению. Приложение 18-22 ссобирается без ошибок, поскольку <code>s</code> не будет перемещён в <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-22/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-22. Использование подчёркивания не привязывает значение</span></p>
<p>Этот код работает нормально, потому что мы никогда не привязываем <code>s</code> к чему либо; оно не перемещается.</p>
<h4 id="Пренебрежение-оставшихся-частей-значения-с-помощью-"><a class="header" href="#Пренебрежение-оставшихся-частей-значения-с-помощью-">Пренебрежение оставшихся частей значения с помощью <code>..</code></a></h4>
<p>Со значениями, которые имеют много частей, можно использовать синтаксис <code>..</code>, чтобы использовать только некоторые части и пренебрегать остальные, избегая необходимости перечислять подчёркивания для каждого пренебрегаемого значения. Шаблон <code>..</code> пренебрегает любые части значения, которые мы явно не сопоставили в остальной частью шаблона. В приложении 18-23 мы имеем структуру <code>Point</code>, которая содержит координату в трёхмерном пространстве. В выражении <code>match</code> мы хотим работать только с координатой <code>x</code> и пренебрегать значения полей <code>y</code> и <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-23/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-21: Пренебрежение полей структуры <code>Point</code> кроме поля <code>x</code> с помощью <code>..</code></span></p>
<p>Мы перечисляем значение <code>x</code> и затем просто включаем шаблон <code>..</code>. Это быстрее, чем перечислять <code>y: _</code> и <code>z: _</code>, особенно когда мы работаем со структурами, которые имеют много полей, в ситуациях, когда только одно или два поля представляют для нас влечение.</p>
<p>Синтаксис <code>..</code> раскроется до необходимого количества значений. В приложении 18-24 показано, как использовать <code>..</code> с кортежем.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-24/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-24: Сопоставление только первого и последнего значений в кортеже и пренебрежение всех других значений</span></p>
<p>В этом коде первое и последнее значение соответствуют <code>first</code> и <code>last</code>. Конструкция <code>..</code> будет соответствовать и пренебрегать всё, что находится между ними.</p>
<p>Однако использование <code>..</code> должно быть однозначным. Если неясно, какие значения предназначены для сопоставления, а какие следует пренебрегать, Rust выдаст ошибку. В приложении 18-25 показан пример неоднозначного использования <code>..</code>, поэтому он не будет собираться.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-25/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 18-25: Попытка использовать <code>..</code> неоднозначным способом</span></p>
<p>При сборки примера, мы получаем эту ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}
</code></pre>
<p>Rust не может определить, сколько значений в кортеже нужно пренебрегать, прежде чем сопоставить значение с <code>second</code>, и сколько следующих значений пропренебрегать после этого. Этот код может означать, что мы хотим пренебрегать <code>2</code>, связать <code>second</code> с <code>4</code>, а затем пренебрегать <code>8</code>, <code>16</code> и <code>32</code>; или что мы хотим пренебрегать <code>2</code> и <code>4</code>, связать <code>second</code> с <code>8</code>, а затем пренебрегать <code>16</code> и <code>32</code>; и так далее. Имя переменной <code>second</code> не означает ничего особенного для Rust, поэтому мы получаем ошибку сборщика, так как использование <code>..</code> в двух местах как здесь, является неоднозначным.</p>
<h3 id="Дополнительные-условия-оператора-сопоставления-match-guards"><a class="header" href="#Дополнительные-условия-оператора-сопоставления-match-guards">Дополнительные условия оператора сопоставления (Match Guards)</a></h3>
<p><em>Условие сопоставления</em> (match guard) является дополнительным условием <code>if</code>, указанным после шаблона в ветке <code>match</code>, которое также должно быть выполнено, чтобы ветка была выбрана. Условия сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон.</p>
<p>Условие может использовать переменные, созданные в шаблоне. В приложении 18-26 показан <code>match</code>, в котором первая ветка имеет шаблон <code>Some(x)</code>, а также имеет условие сопоставления, <code>if x % 2 == 0</code> (которое будет истинным, если число чётное).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-26/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-26: Добавление условия сопоставления в шаблон</span></p>
<p>В этом примере будет напечатано <code>The number 4 is even</code>. Когда <code>num</code> сравнивается с шаблоном в первой ветке, он совпадает, потому что <code>Some(4)</code> соответствует <code>Some(x)</code>. Затем условие сопоставления проверяет, равен ли 0 остаток от деления <code>x</code> на 2 и если это так, то выбирается первая ветка.</p>
<p>Если бы <code>num</code> вместо этого было <code>Some(5)</code>, условие в сопоставлении первой ветки было бы ложным, потому что остаток от 5 делённый на 2, равен 1, что не равно 0. Rust тогда перешёл бы ко второй ветке, которое совпадает, потому что вторая ветка не имеет условия сопоставления и, следовательно, соответствует любому варианту <code>Some</code>.</p>
<p>Невозможно выразить условие <code>if x % 2 == 0</code> внутри шаблона, поэтому условие в сопоставлении даёт нам возможность выразить эту логику. Недостатком этой дополнительной выразительности является то, что сборщик не пытается проверять полноту, когда задействованы выражения с условием в сопоставлении.</p>
<p>В приложении 18-11 мы упомянули, что можно использовать условия сопоставления для решения нашей проблемы затенения шаблона. Напомним, что внутри шаблона в выражении <code>match</code> была создана новая переменная, вместо использования внешней к <code>match</code> переменной. Эта новая переменная означала, что мы не могли выполнить сравнение с помощью значения внешней переменной. В приложении 18-27 показано, как мы можем использовать условие сопоставления для решения этой проблемы.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-27/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-27. Использование условия сопоставления для проверки на равенство со значением внешней переменной</span></p>
<p>Этот код теперь напечатает <code>Default case, x = Some(5)</code>. Шаблон во второй ветке не вводит новую переменную <code>y</code>, которая будет затенять внешнюю <code>y</code>, это означает, что теперь можно использовать внешнюю переменную <code>y</code> в условии сопоставления. Вместо указания шаблона как <code>Some(y)</code>, который бы затенял бы внешнюю <code>y</code>, мы указываем <code>Some(n)</code>. Это создаёт новую переменную <code>n</code>, которая ничего не затеняет, так как переменной <code>n</code> нет вне конструкции <code>match</code>.</p>
<p>Условие сопоставления <code>if n == y</code> не является шаблоном и следовательно, не вводит новые переменные. Переменная <code>y</code> <em>и есть</em> внешняя <code>y</code>, а не новая затенённая <code>y</code>, и теперь мы можем искать элемент, который будет иметь то же значение, что и внешняя <code>y</code>, путём сравнения <code>n</code> и <code>y</code>.</p>
<p>Вы также можете использовать оператор <em>или</em> <code>|</code> в условии сопоставления, чтобы указать несколько шаблонов; условие сопоставления будет применяться ко всем шаблонам. В приложении 18-28 показан приоритет комбинирования условия сопоставления с шаблоном, который использует <code>|</code>. Важной частью этого примера является то, что условие сопоставления <code>if y</code> применяется к <code>4</code>, <code>5</code>, <em>и</em> к <code>6</code>, хотя это может выглядеть как будто <code>if y</code> относится только к <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-28/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-28: Комбинирование нескольких шаблонов с условием сопоставления</span></p>
<p>Условие сопоставления гласит, что ветка совпадает, только если значение <code>x</code> равно <code>4</code>, <code>5</code> или <code>6</code>, <em>и</em> если <code>y</code> равно <code>true</code>. Когда этот код выполняется, шаблон первой ветки совпадает, потому что <code>x</code> равно <code>4</code>, но условие сопоставления <code>if y</code> равно false, поэтому первая ветка не выбрана. Код переходит ко второй ветке, которая совпадает, и эта программа печатает <code>no</code>. Причина в том, что условие <code>if</code> применяется ко всему шаблону <code>4 | 5 | 6</code>, а не только к последнему значению <code>6</code>. Другими словами, приоритет условия сопоставления по отношению к шаблону ведёт себя так:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>а не так:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>После запуска кода, старшинство в поведении становится очевидным: если условие сопоставления применялось бы только к конечному значению в списке, указанном с помощью оператора <code>|</code>, то ветка бы совпала и программа напечатала бы <code>yes</code>.</p>
<h3 id="Связывание-"><a class="header" href="#Связывание-">Связывание <code>@</code></a></h3>
<p>Оператор <em>at</em> (<code>@</code>) позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение шаблону. В приложении 18-29 показан пример, в котором мы хотим проверить, что перечисление <code>Message::Hello</code> со значением поля <code>id</code> находится в ряде <code>3..=7</code>. Но мы также хотим привязать такое значение к переменной <code>id_variable</code>, чтобы использовать его внутри кода данной ветки. Мы могли бы назвать эту переменную <code>id</code>, так же как поле, но для этого примера мы будем использовать другое имя.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-29/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-29: Использование <code>@</code> для привязывания значения в шаблоне, с одновременной его проверкой</span></p>
<p>В этом примере будет напечатано <code>Found an id in range: 5</code>. Указывая <code>id_variable @</code> перед рядом <code>3..=7</code>, мы захватываем любое значение, попадающее в ряд, одновременно проверяя, что это значение соответствует ряду в шаблоне.</p>
<p>Во второй ветке, где у нас в шаблоне указан только ряд, код этой ветки не имеет переменной, которая содержит фактическое значение поля <code>id</code>. Значение поля <code>id</code> могло бы быть 10, 11 или 12, но код, соответствующий этому шаблону, не знает, чему оно равно. Код шаблона не может использовать значение из поля <code>id</code>, потому что мы не сохранили значение <code>id</code> в переменной.</p>
<p>В последней ветке, где мы указали переменную без ряда, у нас есть значение, доступное для использования в коде ветки, в переменной с именем <code>id</code>. Причина в том, что мы использовали упрощённый синтаксис полей структуры. Но мы не применяли никакого сравнения со значением в поле <code>id</code> в этой ветке, как мы это делали в первых двух ветках: любое значение будет соответствовать этому шаблону.</p>
<p>Использование <code>@</code> позволяет проверять значение и сохранять его в переменной в пределах одного шаблона.</p>
<h2 id="Итоги-15"><a class="header" href="#Итоги-15">Итоги</a></h2>
<p>Шаблоны Rust очень помогают различать разные виды данных. При использовании их в выражениях <code>match</code>, Rust заверяет, что ваши шаблоны охватывают все возможные значения, потому что иначе ваша программа не ссобирается. Шаблоны в указаниях <code>let</code> и свойствах функций делают такие конструкции более полезными, позволяя разбивать элементы на более мелкие части, одновременно присваивая их значения переменным. Мы можем создавать простые или сложные шаблоны в соответствии с нашими потребностями.</p>
<p>Далее, в предпоследней главе книги, мы рассмотрим некоторые продвинутые особенности различных возможностей Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Расширенные-возможности"><a class="header" href="#Расширенные-возможности">Расширенные возможности</a></h1>
<p>На данный момент вы изучили все наиболее используемые части языка программирования Rust. Прежде чем мы выполним ещё один проект в главе 20, мы рассмотрим несколько особенностей языка, с которыми вы можете сталкиваться время от времени, но не использовать каждый день. Вы можете использовать эту главу в качестве справочника, когда столкнётесь с какими-либо незнакомыми вещами. Рассмотренные здесь функции будут полезны в очень отличительных ситуациях. Хотя вы, возможно, не будете часто пользоваться ими, мы хотим убедиться, что вы знаете все возможности языка Rust.</p>
<p>В этой главе мы рассмотрим:</p>
<ul>
<li>Небезопасный Rust: как отказаться от некоторых заверений Rust и взять на себя ответственность за их ручное соблюдение</li>
<li>Продвинутые типажи: ассоциированные виды, свойства вида по умолчанию, полностью квалифицированный синтаксис, супер-типажи и шаблон создания (newtype) по отношению к типажам</li>
<li>Расширенные виды: больше о шаблоне newtype, псевдонимах вида, вид never и виды изменяемыхх размеров</li>
<li>Расширенные функции и замыкания: указатели функций и возврат замыканий</li>
<li>Макросы: способы определения кода, который определяет большую часть кода во время сборки</li>
</ul>
<p>Это набор возможностей Rust для всех! Давайте погрузимся в него!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>Во всех предыдущих главах этой книги мы обсуждали код на Rust, безопасность памяти в котором обеспечивается во время сборки. Однако внутри Rust скрывается другой язык - небезопасный Rust, который не обеспечивает безопасной работы с памятью. Этот язык называется <em>unsafe Rust</em> и работает также как и первый, но предоставляет вам дополнительные возможности.</p>
<p>Небезопасный Rust существует потому что по своей природе статический анализ довольно консервативен. Когда сборщик пытается определить, соответствует ли код заверениям, то он скорее отвергнет несколько допустимых программ, чем пропустит несколько недопустимых. Не смотря на то, что код <em>может</em> быть в порядке, если сборщик Rust не будет располагать достаточной сведениями, чтобы убедиться в этом, он отвергнет код. В таких случаях вы можете использовать небезопасный код, чтобы сказать сборщику: "Поверь мне, я знаю, что делаю". Однако имейте в виду, что вы используете небезопасный Rust на свой страх и риск: если вы неправильно используете небезопасный код, могут возникнуть проблемы, связанные с нарушением безопасности памяти, например, разыменование нулевого указателя.</p>
<p>Другая причина, по которой у Rust есть небезопасное альтер эго, заключается в том, что по существу аппаратное обеспечение компьютера небезопасно. Если Rust не позволял бы вам выполнять небезопасные действия, вы не могли бы выполнять определённые задачи. Rust должен позволить вам использовать системное, низкоуровневое программирование, такое как прямое взаимодействие с операционной системой, или даже написание вашей собственной операционной системы. Возможность написания низкоуровневого, системного кода является одной из целей языка. Давайте рассмотрим, что и как можно делать с небезопасным Rust.</p>
<h3 id="Небезопасные-сверхспособности"><a class="header" href="#Небезопасные-сверхспособности">Небезопасные сверхспособности</a></h3>
<p>Чтобы переключиться на небезопасный Rust, используйте ключевое слово <code>unsafe</code>, а затем начните новый блок, содержащий небезопасный код. В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем <em>небезопасными супер силами</em>. Эти супер силы включают в себя следующее:</p>
<ul>
<li>Разыменование сырого указателя</li>
<li>Вызов небезопасной функции или небезопасного способа</li>
<li>Доступ или изменение изменяемой статической переменной</li>
<li>Реализация небезопасного типажа</li>
<li>Доступ к полям в <code>union</code></li>
</ul>
<p>Важно понимать, что <code>unsafe</code> не отключает проверку заимствования или любые другие проверки безопасности Rust: если вы используете ссылку в небезопасном коде, она всё равно будет проверена. Единственное, что делает ключевое слово <code>unsafe</code> - даёт вам доступ к этим пяти возможностям, безопасность работы с памятью в которых не проверяет сборщик. Вы по-прежнему получаете некоторую степень безопасности внутри небезопасного раздела.</p>
<p>Кроме того, <code>unsafe</code> не означает, что код внутри этого раздела является неизбежно опасным или он точно будет иметь проблемы с безопасностью памяти: цель состоит в том, что вы, как программист, заверяете, что код внутри раздела <code>unsafe</code> будет обращаться к действительной памяти корректным образом.</p>
<p>Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных действия внутри разделов, помеченных как <code>unsafe</code>, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри <code>unsafe</code> разделов. Делайте <code>unsafe</code> разделы маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.</p>
<p>Чтобы максимально изолировать небезопасный код, советуется заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже, когда будем обсуждать небезопасные функции и способы. Части встроенной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом. Оборачивание небезопасного кода в безопасную абстракцию предотвращает возможную утечку использования <code>unsafe</code> кода во всех местах, где вы или ваши пользователи могли бы захотеть напрямую использовать функциональность, реализованную <code>unsafe</code> кодом, потому что использование безопасной абстракции само безопасно.</p>
<p>Давайте поговорим о каждой из четырёх небезопасных сверх способностей, и по ходу дела рассмотрим некоторые абстракции, которые обеспечивают безопасный внешняя оболочка для небезопасного кода.</p>
<h3 id="Разыменование-сырых-указателей"><a class="header" href="#Разыменование-сырых-указателей">Разыменование сырых указателей</a></h3>
<p>В главе 4 раздела <a href="ch04-02-references-and-borrowing.html#dangling-references">"Недействительные ссылки"</a><!--  --> мы упоминали, что сборщик заверяет, что ссылки всегда действительны. Небезопасный Rust имеет два новых вида, называемых <em>сырыми указателями</em> (raw pointers), которые похожи на ссылки. Как и в случае ссылок, сырые указатели могут быть неизменяемыми или изменяемыми и записываться как <code>*const T</code> и <code>*mut T</code> соответственно. Звёздочка не является оператором разыменования; это часть имени вида. В среде сырых указателей <em>неизменяемый</em> (immutable) означает, что указателю нельзя напрямую присвоить что-то после того как он разыменован.</p>
<p>В отличие от ссылок и умных указателей, сырые указатели:</p>
<ul>
<li>могут пренебрегать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти</li>
<li>не заверяют что ссылаются на действительную память</li>
<li>могут быть null</li>
<li>не реализуют самостоятельную очистку памяти</li>
</ul>
<p>Отказавшись от этих заверений, вы можете обменять безопасность  на большую производительность или возможность взаимодействия с другим языком или оборудованием, где заверения Rust не применяются.</p>
<p>В приложении 19-1 показано, как создать неизменяемый и изменяемый сырой указатель из ссылок.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-1: Создание необработанных указателей из ссылок</span></p>
<p>Обратите внимание, что мы не используем ключевое слово <code>unsafe</code> в этом коде. Можно создавать сырые указатели в безопасном коде; мы просто не можем разыменовывать сырые указатели за пределами небезопасного раздела, как вы увидите чуть позже.</p>
<p>Мы создали сырые указатели, используя <code>as</code> для приведения неизменяемой и изменяемой ссылки к соответствующим им видам сырых указателей. Поскольку мы создали их непосредственно из ссылок, которые обязательно являются действительными, мы знаем, что эти определенные сырые указатели являются действительными, но мы не можем делать такое же предположение о любом сыром указателе.</p>
<p>Чтобы отобразить это, создадим сырой указатель, в достоверности которого мы не можем быть так уверены. В приложении 19-2 показано, как создать необработанный указатель на произвольное место в памяти. Попытка использовать произвольную память является непредсказуемой: по этому адресу могут быть данные, а могут и не быть, сборщик может оптимизировать код так, что доступа к памяти не будет, или программа может завершиться с ошибкой сегментации. Обычно нет веских причин писать такой код, но это возможно.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-2: Создание сырого указателя на произвольный адрес памяти</span></p>
<p>Напомним, что можно создавать сырые указатели в безопасном коде, но нельзя <em>разыменовывать</em> сырые указатели и читать данные, на которые они указывают. В приложении 19-3 мы используем оператор разыменования <code>*</code> для сырого указателя, который требует <code>unsafe</code> раздела.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-3: Разыменование сырых указателей в разделе <code>unsafe</code></span></p>
<p>Создание указателей безопасно. Только при попытке доступа к объекту по адресу в указателе мы можем получить недопустимое значение.</p>
<p>Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали <code>*const i32</code> и <code>*mut i32</code>, которые ссылаются на одну и ту же область памяти, где хранится <code>num</code>. Если мы попытаемся создать неизменяемую и изменяемую ссылку на <code>num</code> вместо сырых указателей, такой код не ссобирается, т.к. будут нарушены правила заимствования, запрещающие наличие изменяемой ссылки одновременно с неизменяемыми ссылками. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый указатель на одну и ту же область памяти и изменять данные с помощью изменяемого указателя, потенциально создавая эффект гонки данных. Будьте осторожны!</p>
<p>С учётом всех этих опасностей, зачем тогда использовать сырые указатели? Одним из основных применений является взаимодействие с кодом C, как вы увидите в следующем разделе <a href="ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">"Вызов небезопасной функции или способа"</a><!--  -->. Другой случай это создание безопасных абстракций, которые не понимает анализатор заимствований. Мы введём понятие небезопасных функций и затем рассмотрим пример безопасной абстракции, которая использует небезопасный код.</p>
<h3 id="Вызов-небезопасной-функции-или-способа"><a class="header" href="#Вызов-небезопасной-функции-или-способа">Вызов небезопасной функции или способа</a></h3>
<p>Второй вид действий, которые можно выполнять в небезопасном разделе - это вызов небезопасных функций. Небезопасные функции и способы выглядят точно так же, как обычные функции и способы, но перед остальным определением у них есть дополнительное <code>unsafe</code>. Ключевое слово <code>unsafe</code> в данном среде указывает на то, что к функции предъявляются требования, которые мы должны соблюдать при вызове этой функции, поскольку Rust не может обеспечить, что мы их выполняем. Вызывая небезопасную функцию внутри раздела <code>unsafe</code>, мы говорим, что прочитали документацию к этой функции и берём на себя ответственность за соблюдение её условий.</p>
<p>Вот небезопасная функция с именем <code>dangerous</code> которая ничего не делает в своём теле:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Мы должны вызвать функцию <code>dangerous</code> в отдельном <code>unsafe</code> разделе. Если мы попробуем вызвать <code>dangerous</code> без <code>unsafe</code> раздела, мы получим ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}
</code></pre>
<p>С помощью раздела <code>unsafe</code> мы сообщаем Rust, что прочитали документацию к функции, поняли, как правильно её использовать, и убедились, что выполняем контракт функции.</p>
<p>Тела небезопасных функций являются фактически <code>unsafe</code> разделами, поэтому для выполнения других небезопасных действий внутри небезопасной функции не нужно добавлять ещё один <code>unsafe</code> блок.</p>
<h4 id="Создание-безопасных-абстракций-вокруг-небезопасного-кода"><a class="header" href="#Создание-безопасных-абстракций-вокруг-небезопасного-кода">Создание безопасных абстракций вокруг небезопасного кода</a></h4>
<p>То, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. На самом деле, обёртывание небезопасного кода в безопасную функцию - это обычная абстракция. В качестве примера рассмотрим функцию <code>split_at_mut</code> из встроенной библиотеки, которая требует некоторого небезопасного кода. Рассмотрим, как мы могли бы её реализовать. Этот безопасный способ определён для изменяемых срезов: он берет один срез и превращает его в два, разделяя срез по порядковому казателю, указанному в качестве переменной. В приложении 19-4 показано, как использовать <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-4: Использование безопасной функции <code>split_at_mut</code></span></p>
<p>Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации могла бы выглядеть примерно как в приложении 19-5, который не собирается. Для простоты мы реализуем <code>split_at_mut</code> как функцию, а не как способ, и только для значений вида <code>i32</code>, а не обобщённого вида <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 19-5: Попытка реализации <code>split_at_mut</code> с использованием только безопасного Rust</span></p>
<p>Эта функция сначала получает общую длину среза. Затем она проверяет (assert), что порядковый указатель, переданный в качестве свойства, находится в границах среза, сравнивая его с длиной. Assert означает, что если мы передадим порядковый указатель, который больше, чем длина среза, функция запаникует ещё до попытки использования этого порядкового указателя.</p>
<p>Затем мы возвращаем два изменяемых фрагмента в кортеже: один от начала исходного фрагмента до <code>mid</code> порядкового казателя (не включая сам mid), а другой - от <code>mid</code> (включая сам mid) до конца фрагмента.</p>
<p>При попытке собрать код в приложении 19-5, мы получим ошибку.</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}
</code></pre>
<p>Анализатор заимствований Rust не может понять, что мы заимствуем различные части среза, он понимает лишь, что мы хотим осуществить заимствование частей одного среза дважды. Заимствование различных частей среза в принципе нормально, потому что они не перекрываются, но Rust недостаточно умён, чтобы это понять. Когда мы знаем, что код верный, но Rust этого не понимает, значит пришло время прибегнуть к небезопасному коду.</p>
<p>Приложение 19-6 отображает, как можно использовать <code>unsafe</code> блок, сырой указатель и вызовы небезопасных функций чтобы <code>split_at_mut</code> заработала:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-6. Использование небезопасного кода в реализации функции <code>split_at_mut</code></span></p>
<p>Напомним, из раздела <a href="ch04-03-slices.html#the-slice-type">"Вид срез"</a><!-- ignore --> главы 4, что срезы состоят из указателя на некоторые данные и длины. Мы используем способ <code>len</code> для получения длины среза и способ <code>as_mut_ptr</code> для доступа к сырому указателю среза. Поскольку у нас есть изменяемый срез на значения вида <code>i32</code>, функция <code>as_mut_ptr</code> возвращает сырой указатель вида <code>*mut i32</code>, который мы сохранили в переменной <code>ptr</code>.</p>
<p>Далее проверяем, что порядковый казатель<code>mid</code> находится в границах среза. Затем мы обращаемся к небезопасному коду: функция <code>slice::from_raw_parts_mut</code> принимает сырой указатель, длину и создаёт срез. Мы используем эту функцию для создания среза, начинающегося с <code>ptr</code> и имеющего длину в <code>mid</code> элементов. Затем мы вызываем способ <code>add</code> у <code>ptr</code> с <code>mid</code> в качестве переменной, чтобы получить сырой указатель, который начинается с <code>mid</code>, и создаём срез, используя этот указатель и оставшееся количество элементов после <code>mid</code> в качестве длины.</p>
<p>Функция <code>slice::from_raw_parts_mut</code> является небезопасной, потому что она принимает необработанный указатель и должна полагаться на то, что этот указатель действителен. Способ <code>add</code> для необработанных указателей также небезопасен, поскольку он должен считать, что местоположение смещения также является действительным указателем. Поэтому мы были вынуждены разместить <code>unsafe</code> разделвокруг наших вызовов <code>slice::from_raw_parts_mut</code> и <code>add</code>, чтобы иметь возможность вызвать их. Посмотрев на код и добавив утверждение, что <code>mid</code> должен быть меньше или равен <code>len</code>, мы можем сказать, что все необработанные указатели, используемые в разделе <code>unsafe</code>, будут корректными указателями на данные внутри среза. Это приемлемое и уместное использование <code>unsafe</code>.</p>
<p>Обратите внимание, что нам не нужно помечать результирующую функцию <code>split_at_mut</code> как <code>unsafe</code>, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с помощью реализации функции, которая использует код <code>unsafe</code> раздела безопасным образом, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.</p>
<p>Напротив, использование <code>slice::from_raw_parts_mut</code> в приложении 19-7 приведёт к вероятному сбою при использовании среза. Этот код использует произвольный адрес памяти и создаёт срез из 10000 элементов.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-7: Создание среза из произвольного адреса памяти</span></p>
<p>Мы не владеем памятью в этом произвольном месте, и нет никакой заверения, что созданный этим кодом фрагмент содержит допустимые значения <code>i32</code>. Попытка использовать <code>values</code> так, как будто это допустимый срез, приводит к неопределённому поведению.</p>
<h4 id="Использование-extern-функций-для-вызова-внешнего-кода"><a class="header" href="#Использование-extern-функций-для-вызова-внешнего-кода">Использование <code>extern</code> функций для вызова внешнего кода</a></h4>
<p>Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на другом языке. Для этого в Rust есть ключевое слово <code>extern</code>, которое облегчает создание и использование <em>внешней оболочки внешних функций (Foreign Function Interface - FFI)</em>. FFI - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.</p>
<p>Приложение 19-8 отображает, как настроить встраивание с функцией <code>abs</code> из встроенной библиотеки C. Функции, объявленные внутри разделов <code>extern</code>, всегда небезопасны для вызова из кода Rust. Причина в том, что другие языки не обеспечивают соблюдение правил и заверений Rust, Rust также не может проверить заверения, поэтому ответственность за безопасность ложится на программиста.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-8: Объявление и вызов <code>extern</code> функции, написанной на другом языке программирования</span></p>
<p>Внутри раздела <code>extern "C"</code> мы перечисляем имена и сигнатуры внешних функций из другого языка, которые мы хотим вызвать. Часть <code>"C"</code> определяет какой <em>application binary interface</em> (ABI - двоичный внешняя оболочка приложений) использует внешняя функция. Внешнюю оболочку ABI определяет как вызвать функцию на уровне ассемблера. Использование ABI <code>"C"</code> является наиболее часто используемым и следует правилам ABI внешней оболочки языка Си.</p>
<blockquote>
<h4 id="Вызов-функций-rust-из-других-языков"><a class="header" href="#Вызов-функций-rust-из-других-языков">Вызов функций Rust из других языков</a></h4>
<p>Также можно использовать <code>extern</code> для создания внешней оболочки, позволяющего другим языкам вызывать функции Rust. Вместо того чтобы создавать целый раздел<code>extern</code>, мы добавляем ключевое слово <code>extern</code> и указываем ABI для использования непосредственно перед ключевым словом <code>fn</code> для необходимой функции. Нам также нужно добавить изложение <code>#[no_mangle]</code>, чтобы сказать сборщику Rust не искажать имя этой функции. <em>Искажение</em> - это когда сборщик меняет имя, которое мы дали функции, на другое имя, которое содержит больше сведений для других частей процесса сборки, но менее читабельно для человека. Сборщик каждого языка программирования искажает имена по-разному, поэтому, чтобы функция Rust могла быть использована другими языками, мы должны отключить искажение имён в сборщике Rust.</p>
<p>В следующем примере мы делаем функцию <code>call_from_c</code> доступной из кода на C, после того как она будет собрана в разделяемую библиотеку и прилинкована с C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p>Такое использование <code>extern</code> не требует <code>unsafe</code>.</p>
</blockquote>
<h3 id="Получение-доступа-и-внесение-изменений-в-изменяемую-статическую-переменную"><a class="header" href="#Получение-доступа-и-внесение-изменений-в-изменяемую-статическую-переменную">Получение доступа и внесение изменений в изменяемую статическую переменную</a></h3>
<p>В этой книге мы ещё не говорили о <em>вездесущих переменных</em>, которые Rust поддерживает, но с которыми могут возникнуть проблемы из-за действующих в Rust правил владения. Если два потока обращаются к одной и той же изменяемой вездесущей переменной, это может привести к гонке данных.</p>
<p>Вездесущие переменные в Rust называют <em>статическими</em> (static). Приложение 19-9 отображает пример объявления и использования в качестве значения статической переменной, имеющей вид строкового среза:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-9: Определение и использование неизменяемой статической переменной</span></p>
<p>Статические переменные похожи на константы, которые мы обсуждали в разделе <a href="ch03-01-variables-and-mutability.html#constants">“Различия между переменными и константами”</a><!-- ignore --> главы 3. Имена статических переменных по общему соглашению пишутся в нотации <code>SCREAMING_SNAKE_CASE</code>, и мы <em>должны</em> указывать вид переменной, которым в данном случае является <code>&amp;'static str</code>. Статические переменные могут хранить только ссылки со временем жизни <code>'static</code>, это означает что сборщик Rust может вывести время жизни и нам не нужно прописывать его явно. Доступ к неизменяемой статической переменной является безопасным.</p>
<p>Тонкое различие между константами и неизменяемыми статическими переменными заключается в том, что значения в статической переменной имеют фиксированный адрес в памяти. При использовании значения всегда будут доступны одни и те же данные. Константы, с другой стороны, могут повторять свои данные при каждом использовании. Ещё одно отличие заключается в том, что статические переменные могут быть изменяемыми. Обращение к изменяемым статическим переменным и их изменение является <em>небезопасным</em>. В приложении 19-10 показано, как объявить, получить доступ и модифицировать изменяемую статическую переменную с именем <code>COUNTER</code>.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-10: Чтение из изменяемой статической переменной или запись в неё небезопасны</span></p>
<p>Как и с обычными переменными, мы определяем изменяемость с помощью ключевого слова <code>mut</code>. Любой код, который читает из или пишет в переменную <code>COUNTER</code> должен находиться в <code>unsafe</code> разделе. Этот код собирается и печатает <code>COUNTER: 3</code>, как и следовало ожидать, потому что выполняется в одном потоке. Наличие нескольких потоков с доступом к <code>COUNTER</code> приведёт к ситуации гонки данных.</p>
<p>Наличие изменяемых данных, которые доступны вездесуще, делает трудным реализацию заверения отсутствия гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там, где это возможно, предпочтительно использовать техники многопоточности и умные указатели, ориентированные на многопоточное исполнение, которые мы обсуждали в главе 16. Таким образом, сборщик сможет проверить, что обращение к данным, доступным из разных потоков, выполняется безопасно.</p>
<h3 id="Реализация-небезопасных-типажей"><a class="header" href="#Реализация-небезопасных-типажей">Реализация небезопасных типажей</a></h3>
<p>Мы можем использовать <code>unsafe</code> для реализации небезопасного трейта. Трейт является небезопасным, если хотя бы один из его способов имеет некоторый инвариант, который сборщик не может проверить. Мы объявляем трейты <code>unsafe</code>, добавляя ключевое слово <code>unsafe</code> перед <code>trait</code> и помечая реализацию трейта как <code>unsafe</code>, как показано в приложении 19-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-11: Определение и реализация небезопасного трейта</span></p>
<p>Используя <code>unsafe impl</code>, мы даём обещание поддерживать инварианты, которые сборщик не может проверить.</p>
<p>Для примера вспомним маркерные типажи <code>Sync</code> и <code>Send</code>, которые мы обсуждали в разделе <a data-md-type="raw_html" href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">"Расширяемый параллелизм с помощью типажей <code>Sync</code> и <code>Send</code>"</a><!-- ignore --> главы 16: сборщик реализует эти типажи самостоятельно , если наши виды полностью состоят из видов <code>Send</code> и <code>Sync</code>. Если мы создадим вид, который содержит вид, не являющийся <code>Send</code> или <code>Sync</code>, такой, как сырой указатель, и мы хотим пометить этот вид как <code>Send</code> или <code>Sync</code>, мы должны использовать <code>unsafe</code> блок. Rust не может проверить, что наш вид поддерживает заверения того, что он может быть безопасно передан между потоками или доступен из нескольких потоков; поэтому нам нужно добавить эти проверки вручную и указать это с помощью <code>unsafe</code>.</p>
<h3 id="Доступ-к-полям-объединений-union"><a class="header" href="#Доступ-к-полям-объединений-union">Доступ к полям объединений (union)</a></h3>
<p>Последнее действие, которое работает только с <code>unsafe</code> - это доступ к полям <em>union</em>. <code>union</code> похож на <code>struct</code>, но в каждом определенном экземпляре одновременно может использоваться только одно объявленное поле. Объединения в основном используются для взаимодействия с объединениями в коде на языке Си. Доступ к полям объединений небезопасен, поскольку Rust не может обязательно определить вид данных, которые в данный момент хранятся в экземпляре объединения. Подробнее об объединениях вы можете узнать в <a href="../reference/items/unions.html">the Rust Reference</a>.</p>
<h3 id="Когда-использовать-небезопасный-код"><a class="header" href="#Когда-использовать-небезопасный-код">Когда использовать небезопасный код</a></h3>
<p>Использование <code>unsafe</code> для выполнения одного из пяти действий (супер способностей), которые только что обсуждались, не является ошибочным или не одобренным. Но получить корректный <code>unsafe</code> код сложнее, потому что сборщик не может помочь в обеспечении безопасности памяти. Если у вас есть причина использовать <code>unsafe</code> код, вы можете делать это, а наличие явной <code>unsafe</code> изложении облегчает отслеживание источника проблем, если они возникают.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутые-типажи"><a class="header" href="#Продвинутые-типажи">Продвинутые типажи</a></h2>
<p>Мы познакомились с трейтами в разделе <a href="ch10-02-traits.html#traits-defining-shared-behavior">"Трейты: Определение общего поведения"</a><!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Rust, мы можем перейти к более подробному рассмотрению.</p>
<h3 id="Указание-видов-заполнителей-в-определениях-трейтов-с-ассоциированными-видами"><a class="header" href="#Указание-видов-заполнителей-в-определениях-трейтов-с-ассоциированными-видами">Указание видов-заполнителей в определениях трейтов с ассоциированными видами</a></h3>
<p><em>Ассоциированные виды</em> связывают вид-заполнитель с типажом таким образом, что определения способов типажа могут использовать эти виды-заполнители в своих сигнатурах. Для именно реализации типажа вместо типа-заполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить типажи, использующие некоторые виды, без необходимости точно знать, что это за виды, пока типажи не будут реализованы.</p>
<p>Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Ассоциированные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.</p>
<p>Одним из примеров трейта с ассоциированным видом является типаж <code>Iterator</code> из встроенной библиотеки. Ассоциированный вид называется <code>Item</code> и символизирует вид значений, по которым повторяется вид, реализующий типаж <code>Iterator</code>. Определение трейта <code>Iterator</code> показано в приложении 19-12.</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-12: Определение трейта <code>Iterator</code>, который имеет ассоциированный вид <code>Item</code></span></p>
<p>Вид <code>Item</code> является заполнителем и определение способа <code>next</code> показывает, что он будет возвращать значения вида <code>Option&lt;Self::Item&gt;</code>. Разработчики типажа <code>Iterator</code> определят определенный вид для <code>Item</code>, а способ <code>next</code> вернёт <code>Option</code> содержащий значение этого определенного вида.</p>
<p>Ассоциированные виды могут показаться концепцией похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя концепциями, мы рассмотрим реализацию типажа <code>Iterator</code> для вида с именем <code>Counter</code>, который указывает, что вид <code>Item</code> равен <code>u32</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}</code></pre>
<p>Этот синтаксис весьма напоминает обобщённые виды. Так почему же типаж <code>Iterator</code> не определён обобщённым видом, как показано в приложении 19-13?</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-13: Гипотетическое определение типажа <code>Iterator</code> используя обобщённые виды</span></p>
<p>Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны аннотировать виды в каждой реализации; потому что мы также можем реализовать <code>Iterator&lt;String&gt; for Counter</code> или любого другого вида, мы могли бы иметь несколько реализации <code>Iterator</code> для <code>Counter</code>. Другими словами, когда типаж имеет обобщённый свойство, он может быть реализован для вида несколько раз, каждый раз меняя определенные виды свойств обобщённого вида. Когда мы используем способ <code>next</code> у <code>Counter</code>, нам пришлось бы предоставить изложении вида, указывая какую реализацию <code>Iterator</code> мы хотим использовать.</p>
<p>С ассоциированными видами не нужно аннотировать виды, потому что мы не можем реализовать типаж у вида несколько раз. В приложении 19-12 с определением, использующим ассоциированные виды можно выбрать только один вид <code>Item</code>, потому что может быть только одно объявление <code>impl Iterator for Counter</code>. Нам не нужно указывать, что нужен повторительзначений вида <code>u32</code> везде, где мы вызываем <code>next</code> у <code>Counter</code>.</p>
<p>Ассоциированные виды также становятся частью контракта типажа: разработчики типажа должны предоставить вид, который заменит ассоциированный заполнитель вида. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошей практикой является документирование связанного вида в документации по API.</p>
<h3 id="Свойства-обобщённого-вида-по-умолчанию-и-перегрузка-операторов"><a class="header" href="#Свойства-обобщённого-вида-по-умолчанию-и-перегрузка-операторов">Свойства обобщённого вида по умолчанию и перегрузка операторов</a></h3>
<p>Когда мы используем свойства обобщённого вида, мы можем указать определенный вид по умолчанию для обобщённого вида. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида с помощью синтаксиса  <code>&lt;PlaceholderType=ConcreteType&gt;</code>.</p>
<p>Отличным примером, когда этот способ полезен, является <em>перегрузка оператора</em> (operator overloading), когда вы настраиваете поведение оператора (например, <code>+</code> ) для определённых ситуаций.</p>
<p>Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Но можно перегрузить перечисленные действия и соответствующие им типажи из <code>std::ops</code> путём реализации типажей, связанных с этими операторами. Например, в приложении 19-14 мы перегружаем оператор <code>+</code>, чтобы складывать два экземпляра <code>Point</code>. Мы делаем это реализуя типаж <code>Add</code> для структуры <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-14: Реализация типажа <code>Add</code> для перегрузки оператора <code>+</code> для экземпляров <code>Point</code></span></p>
<p>Способ <code>add</code> складывает значения <code>x</code> двух экземпляров <code>Point</code> и значения <code>y</code> у <code>Point</code> для создания нового экземпляра <code>Point</code>. Типаж <code>Add</code> имеет ассоциированный вид с именем <code>Output</code>, который определяет вид, возвращаемый из способа <code>add</code>.</p>
<p>Обобщённый вид по умолчанию в этом коде находится в типаже <code>Add</code> . Вот его определение:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код должен выглядеть знакомым: типаж с одним способом и ассоциированным видом. Новый синтаксис это <code>RHS=Self</code>. Такой синтаксис называется <em>свойства вида по умолчанию</em> (default type parameters). Свойство обобщённого вида <code>RHS</code> (сокращённо “right hand side”) определяет вид свойства <code>rhs</code> в способе <code>add</code>. Если мы не укажем определенный вид для <code>RHS</code> при реализации типажа <code>Add</code>, то видом для <code>RHS</code> по умолчанию будет <code>Self</code>, который будет видом для которого реализуется типаж <code>Add</code>.</p>
<p>Когда мы реализовали <code>Add</code> для структуры <code>Point</code>, мы использовали стандартное значение для <code>RHS</code>, потому что хотели сложить два экземпляра <code>Point</code>. Давайте посмотрим на пример реализации типажа <code>Add</code>, где мы хотим пользовательский вид <code>RHS</code> вместо использования вида по умолчанию.</p>
<p>У нас есть две разные структуры <code>Millimeters</code> и <code>Meters</code>, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида в другую структуру известно как шаблон <em>newtype</em>, который мы более подробно опишем в разделе <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">"Шаблон Newtype для реализация внешних типажей у внешних видов"</a><!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь реализацию типажа <code>Add</code>, которая делает правильное преобразование единиц. Можно реализовать <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве <code>Rhs</code>, как показано в приложении 19-15.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-15: Реализация типажа <code>Add</code> для структуры  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span></p>
<p>Чтобы сложить <code>Millimeters</code> и <code>Meters</code>, мы указываем <code>impl Add&lt;Meters&gt;</code>, чтобы указать значение свойства вида <code>RHS</code> (Meters) вместо использования значения по умолчанию <code>Self</code> (Millimeters).</p>
<p>Свойства вида по умолчанию используются в двух основных случаях:</p>
<ul>
<li>Чтобы расширить вид без внесения изменений ломающих существующий код</li>
<li>Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей</li>
</ul>
<p>Типаж <code>Add</code> из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида, но типаж <code>Add</code> позволяет сделать больше. Использование свойства вида по умолчанию в объявлении типажа <code>Add</code> означает, что не нужно указывать дополнительный свойство большую часть времени. Другими словами, большая часть кода реализации не нужна, что делает использование типажа проще.</p>
<p>Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида к существующему типажу, можно дать ему значение по умолчанию, чтобы разрешить расширение функциональности типажа без нарушения кода существующей реализации.</p>
<h3 id="Полностью-квалифицированный-синтаксис-для-устранения-неоднозначности-вызов-способов-с-одинаковым-именем"><a class="header" href="#Полностью-квалифицированный-синтаксис-для-устранения-неоднозначности-вызов-способов-с-одинаковым-именем">Полностью квалифицированный синтаксис для устранения неоднозначности: вызов способов с одинаковым именем</a></h3>
<p>В Rust ничего не мешает типажу иметь способ с одинаковым именем, таким же как способ другого типажа и Rust не мешает реализовывать оба таких типажа у одного вида. Также возможно реализовать способ с таким же именем непосредственно у вида, такой как и способы у типажей.</p>
<p>При вызове способов с одинаковыми именами в Rust нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим код в приложении 19-16, где мы определили два типажа: <code>Pilot</code> и <code>Wizard</code>, у обоих есть способ <code>fly</code>. Затем мы реализуем оба типажа у вида <code>Human</code> в котором уже реализован способ с именем <code>fly</code>. Каждый способ <code>fly</code> делает что-то своё.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-16: Два типажа определены с способом <code>fly</code> и реализованы у вида <code>Human</code>, а также способ <code>fly</code> реализован непосредственно у <code>Human</code></span></p>
<p>Когда мы вызываем <code>fly</code> у экземпляра <code>Human</code>, то сборщик по умолчанию вызывает способ, который непосредственно реализован для вида, как показано в приложении 19-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-17: Вызов <code>fly</code> у экземпляра <code>Human</code></span></p>
<p>Запуск этого кода напечатает <code>*waving arms furiously*</code> , показывая, что Rust называется способ <code>fly</code> реализованный непосредственно у <code>Human</code>.</p>
<p>Чтобы вызвать способы <code>fly</code> у типажа <code>Pilot</code> или типажа <code>Wizard</code> нужно использовать более явный синтаксис, указывая какой способ <code>fly</code> мы имеем в виду. Приложение 19-18 отображает такой синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span></p>
<p>Указание имени типажа перед именем способа проясняет сборщику Rust, какую именно реализацию <code>fly</code> мы хотим вызвать. Мы могли бы также написать <code>Human::fly(&amp;person)</code>, что эквивалентно используемому нами <code>person.fly()</code> в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.</p>
<p>Выполнение этого кода выводит следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
</code></pre>
<p>Поскольку способ <code>fly</code> принимает свойство <code>self</code>, если у нас было два <em>вида</em> оба реализующих один <em>типаж</em>, то Rust может понять, какую реализацию типажа использовать в зависимости от вида <code>self</code>.</p>
<p>Однако, ассоциированные функции, не являющиеся способами, не имеют свойства <code>self</code>. Когда существует несколько видов или типажей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Rust не всегда знает, какой вид вы имеете в виду, если только вы не используете <em>полный синтаксис</em>. Например, в приложении 19-19 мы создаём типаж для приюта животных, который хочет назвать всех маленьких собак <em>Spot</em>. Мы создаём типаж <code>Animal</code> со связанной с ним функцией <code>baby_name</code>, не являющейся способом. Типаж <code>Animal</code> реализован для структуры <code>Dog</code>, для которой мы также напрямую предоставляем связанную функцию <code>baby_name</code>, не являющуюся способом.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-19: Типаж с ассоциированной функцией и вид с ассоциированной функцией с тем же именем, которая тоже реализует типаж</span></p>
<p>Мы реализовали код для приюта для животных, который хочет назвать всех щенков именем Spot, в ассоциированной функции <code>baby_name</code>, которая определена для <code>Dog</code>. Вид <code>Dog</code> также реализует типаж <code>Animal</code>, который описывает характеристики, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в реализации <code>Animal</code> у <code>Dog</code> в функции <code>baby_name</code> ассоциированной с типажом <code>Animal</code>.</p>
<p>В <code>main</code> мы вызываем функцию <code>Dog::baby_name</code>, которая вызывает ассоциированную функцию определённую напрямую у <code>Dog</code>. Этот код печатает следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
</code></pre>
<p>Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию <code>baby_name</code>, которая является частью типажа <code>Animal</code> реализованного у <code>Dog</code>, так чтобы код печатал <code>A baby dog is called a puppy</code>. Техника указания имени типажа использованная в приложении 19-18 здесь не помогает; если мы изменим <code>main</code> код как в приложении 19-20, мы получим ошибку сборки.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 19-20. Попытка вызвать функцию <code>baby_name</code> из типажа <code>Animal</code>, но Rust не знает какую реализацию использовать</span></p>
<p>Поскольку <code>Animal::baby_name</code> не имеет свойства <code>self</code>, и могут быть другие виды, реализующие типаж <code>Animal</code>, Rust не может понять, какую реализацию <code>Animal::baby_name</code> мы хотим использовать. Мы получим эту ошибку сборщика:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
</code></pre>
<p>Чтобы устранить неоднозначность и сказать Rust, что мы хотим использовать реализацию <code>Animal</code> для <code>Dog</code>, нужно использовать полный синтаксис. Приложение 19-21 отображает, как использовать полный синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-21: Использование полного синтаксиса для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у типажа <code>Animal</code> реализованную в <code>Dog</code></span></p>
<p>Мы указываем изложение вида в угловых скобках, которая указывает на то что мы хотим вызвать способ <code>baby_name</code> из типажа <code>Animal</code> реализованный в <code>Dog</code>, также указывая что мы хотим рассматривать вид <code>Dog</code> в качестве <code>Animal</code> для вызова этой функции. Этот код теперь напечатает то, что мы хотим:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
</code></pre>
<p>В общем, полный синтаксис определяется следующим образом:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Для ассоциированных функций, которые не являются способами, будет отсутствовать <code>receiver</code> (объект приёмника): будет только список переменных. Вы можете использовать полный синтаксис везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого синтаксиса, которую Rust может понять из другой сведений в программе. Вам нужно использовать более подробный синтаксис только в тех случаях, когда существует несколько реализаций, использующих одно и то же название, и Rust нужно помочь определить, какую реализацию вы хотите вызвать.</p>
<h3 id="Использование-супер-типажей-для-требования-функциональности-одного-типажа-в-рамках-другого-типажа"><a class="header" href="#Использование-супер-типажей-для-требования-функциональности-одного-типажа-в-рамках-другого-типажа">Использование супер типажей для требования функциональности одного типажа в рамках другого типажа</a></h3>
<p>Иногда вы можете написать определение типажа, которое зависит от другого типажа: для вида, реализующего первый типаж, вы хотите потребовать, чтобы этот вид также реализовал второй типаж. Вы должны сделать это, чтобы ваше определение типажа могло использовать связанные элементы второго типажа. Типаж, на который опирается ваше определение типажа, называется <em>supertrait</em> вашего типажа.</p>
<p>Например, мы хотим создать типаж <code>OutlinePrint</code> с способом <code>outline_print</code>, который будет печатать значение обрамлённое звёздочками. Мы хотим чтобы структура <code>Point</code>, реализующая типаж встроенной библиотеки <code>Display</code>, вывела на печать <code>(x, y)</code> при вызове <code>outline_print</code> у экземпляра <code>Point</code>, который имеет значение <code>1</code> для <code>x</code> и значение <code>3</code> для <code>y</code>. Она должна напечатать следующее:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>В реализации <code>outline_print</code> мы хотим использовать функциональность типажа <code>Display</code>. Поэтому нам нужно указать, что типаж <code>OutlinePrint</code> будет работать только для видов, которые также реализуют <code>Display</code> и предоставляют функциональность, которая нужна в <code>OutlinePrint</code>. Мы можем сделать это в объявлении типажа, указав <code>OutlinePrint: Display</code>. Этот способ похож на добавление ограничения в типаж. В приложении 19-22 показана реализация типажа <code>OutlinePrint</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-22: Реализация типажа <code>OutlinePrint</code> которая требует функциональности типажа <code>Display</code></span></p>
<p>Поскольку мы указали, что типаж <code>OutlinePrint</code> требует типажа <code>Display</code>, мы можем использовать функцию <code>to_string</code>, которая самостоятельно реализована для любого вида реализующего <code>Display</code>. Если бы мы попытались использовать <code>to_string</code> не добавляя двоеточие и не указывая типаж <code>Display</code> после имени типажа, мы получили бы сообщение о том, что способ с именем <code>to_string</code> не был найден у вида <code>&amp;Self</code> в текущей области видимости.</p>
<p>Давайте посмотрим что происходит, если мы пытаемся реализовать типаж <code>OutlinePrint</code> для вида, который не реализует <code>Display</code>, например структура <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}</code></pre>
<p>Мы получаем сообщение о том, что требуется реализация <code>Display</code>, но её нет:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
</code></pre>
<p>Чтобы исправить, мы реализуем <code>Display</code> у структуры <code>Point</code> и выполняем требуемое ограничение <code>OutlinePrint</code>, вот так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Тогда реализация типажа <code>OutlinePrint</code> для структуры <code>Point</code> будет собрана успешно и мы можем вызвать <code>outline_print</code> у экземпляра <code>Point</code> для отображения значения обрамлённое звёздочками.</p>
<h3 id="Шаблон-newtype-для-реализация-внешних-типажей-у-внешних-видов"><a class="header" href="#Шаблон-newtype-для-реализация-внешних-типажей-у-внешних-видов">Шаблон Newtype для реализация внешних типажей у внешних видов</a></h3>
<p>В разделе <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">"Реализация типажа у типа"</a><!-- ignore --> главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается реализовать типаж у вида, если либо типаж, либо вид являются местными для нашего крейта. Можно обойти это ограничение, используя <em>шаблон нового вида</em> (newtype pattern), который включает в себя создание нового вида в кортежной структуре. (Мы рассмотрели кортежные структуры  в разделе <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">"Использование структур кортежей без именованных полей для создания различных видов"</a><!--  --> главы 5.) Структура кортежа будет иметь одно поле и будет тонкой оболочкой для вида которому мы хотим реализовать типаж. Тогда вид оболочки является местным для нашего крейта и мы можем реализовать типаж для местной обёртки. <em>Newtype</em> это термин, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого шаблона и вид оболочки исключается во время сборки.</p>
<p>В качестве примера, мы хотим реализовать типаж <code>Display</code> для вида <code>Vec&lt;T&gt;</code>, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что типаж <code>Display</code> и вид <code>Vec&lt;T&gt;</code> объявлены вне нашего крейта. Мы можем сделать структуру <code>Wrapper</code>, которая содержит экземпляр <code>Vec&lt;T&gt;</code>; тогда мы можем реализовать <code>Display</code> у структуры <code>Wrapper</code> и использовать значение <code>Vec&lt;T&gt;</code> как показано в приложении 19-23.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-23. Создание вида <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для реализации <code>Display</code></span></p>
<p>Реализация <code>Display</code> использует <code>self.0</code> для доступа к внутреннему <code>Vec&lt;T&gt;</code>, потому что <code>Wrapper</code> это структура кортежа, а <code>Vec&lt;T&gt;</code> это элемент с порядковым казателем 0 в кортеже. Затем мы можем использовать функциональные возможности вида <code>Display</code> у <code>Wrapper</code>.</p>
<p>Недостатком использования этой техники является то, что <code>Wrapper</code> является новым видом, поэтому он не имеет способов для значения, которое он держит в себе. Мы должны были бы реализовать все способы для <code>Vec&lt;T&gt;</code> непосредственно во <code>Wrapper</code>, так чтобы эти способы делегировались внутреннему <code>self.0</code>, что позволило бы нам обращаться с <code>Wrapper</code> точно так же, как с <code>Vec&lt;T&gt;</code>. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида, реализуя типаж <code>Deref</code> (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью <code>Deref</code> типажа"</a><!-- ignore --> главы 15) у <code>Wrapper</code> для возвращения внутреннего вида, то это было бы решением. Если мы не хотим, чтобы вид <code>Wrapper</code> имел все способы внутреннего вида, например, для ограничения поведения вида <code>Wrapper</code>, то пришлось бы вручную реализовать только те способы, которые нам нужны.</p>
<p>Этот шаблон newtype также полезен, даже когда типажи не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутые-виды"><a class="header" href="#Продвинутые-виды">Продвинутые виды</a></h2>
<p>Система видов Rust имеет некоторые особенности, о которых мы уже упоминали, но ещё не обсуждали. Мы начнём с общего обзора newtypes, а затем разберёмся, чем они могут пригодиться в качестве видов. Далее мы перейдём к псевдонимам видов - возможности, похожей на newtypes, но с несколько иной семантикой. Мы также обсудим вид <code>!</code> и виды с изменяемым размером.</p>
<h3 id="Использование-паттерна-newtype-для-обеспечения-безопасности-видов-и-создания-абстракций"><a class="header" href="#Использование-паттерна-newtype-для-обеспечения-безопасности-видов-и-создания-абстракций">Использование паттерна Newtype для обеспечения безопасности видов и создания абстракций</a></h3>
<blockquote>
<p>Примечание: В этом разделе предполагается, что вы прочитали предыдущий раздел <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">"Использование паттерна Newtype для реализации внешних трейтов для внешних видов."</a><!-- ignore --></p>
</blockquote>
<p>Паттерн newtype полезен и для других задач, помимо тех, которые мы обсуждали до сих пор, в частности, для статического обеспечения того, чтобы значения никогда не путались, а также для указания единиц измерения значения. Пример использования newtypes для указания единиц измерения вы видели в приложении 19-15: вспомните, как структуры <code>Millimeters</code> и <code>Meters</code> обернули значения <code>u32</code> в newtype. Если бы мы написали функцию с свойствоом вида <code>Millimeters</code>, мы не смогли бы собрать программу, которая случайно попыталась бы вызвать эту функцию со значением вида <code>Meters</code> или обычным <code>u32</code>.</p>
<p>Мы также можем использовать паттерн newtype для абстрагирования от некоторых подробностей реализации вида: новый вид может предоставлять публичный API, который отличается от API скрытого внутри вида.</p>
<p>Newtypes также позволяют скрыть внутреннюю реализацию. Например, мы можем создать вид <code>People</code>, который обернёт <code>HashMap&lt;i32, String&gt;</code>, хранящий ID человека, связанный с его именем. Код, использующий <code>People</code>, будет взаимодействовать только с публичным API, который мы предоставляем, например, способ добавления имени в собрание <code>People</code>; этому коду не нужно будет знать, что внутри мы присваиваем <code>i32</code> ID именам. Паттерн newtype - это лёгкий способ достижения инкапсуляции для скрытия подробностей реализации, который мы обсуждали в разделе <a href="ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">"Инкапсуляция, скрывающая подробности реализации"</a><!-- ignore --> главы 17.</p>
<h3 id="Создание-синонимов-вида-с-помощью-псевдонимов-вида"><a class="header" href="#Создание-синонимов-вида-с-помощью-псевдонимов-вида">Создание синонимов вида с помощью псевдонимов вида</a></h3>
<p>Rust предоставляет возможность объявить <em>псевдоним вида</em> чтобы дать существующему виду другое имя. Для этого мы используем ключевое слово <code>type</code>. Например, мы можем создать псевдоним вида <code>Kilometers</code> для <code>i32</code> следующим образом:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Теперь псевдоним <code>Kilometers</code> является <em>синонимом</em> для <code>i32</code>; в отличие от видов <code>Millimeters</code> и <code>Meters</code>, которые мы создали в приложении 19-15, <code>Kilometers</code> не является отдельным, новым видом. Значения, имеющие вид <code>Kilometers</code>, будут обрабатываться так же, как и значения вида <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}
<span class="boring">}</span></code></pre></pre>
<p>Поскольку <code>Kilometers</code> и <code>i32</code> являются одним и тем же видом, мы можем добавлять значения обоих видов и передавать значения <code>Kilometers</code> функциям, принимающим свойства <code>i32</code>. Однако, используя этот способ, мы не получаем тех преимуществ проверки видов, которые мы получаем от паттерна newtype, рассмотренного ранее. Другими словами, если мы где-то перепутаем значения <code>Kilometers</code> и <code>i32</code>, сборщик не выдаст нам ошибку.</p>
<p>Синонимы в основном используются для сокращения повторений. Например, у нас может быть такой многословный тип:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Написание таких длинных видов в сигнатурах функций и в виде аннотаций видов по всему коду может быть утомительным и чреватым ошибками. Представьте себе проект, наполненный таким кодом, как в приложении 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-24/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-24: Использование длинного вида во многих местах</span></p>
<p>Псевдоним вида делает этот код более удобным для работы, сокращая количество повторений. В приложении 19-25 мы ввели псевдоним <code>Thunk</code> для вида verbose и можем заменить все использования этого вида более коротким псевдонимом <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-25/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-25: Представление псевдонима <code>Thunk</code> для уменьшения количества повторений</span></p>
<p>Такой код гораздо легче читать и писать! Выбор осмысленного имени для псевдонима вида также может помочь прояснить ваши намерения (<em>thunk</em> - название для кода, который будет вычисляться позднее, поэтому это подходящее имя для сохраняемого замыкания).</p>
<p>Псевдонимы видов также часто используются с видом <code>Result&lt;T, E&gt;</code> для сокращения повторений. Рассмотрим модуль <code>std::io</code> в встроенной библиотеке. Действия ввода-вывода часто возвращают <code>Result&lt;T, E&gt;</code> для обработки ситуаций, когда эти действия не удаются. В данной библиотеке есть структура <code>std::io::Error</code>, которая отражает все возможные ошибки ввода/вывода. Многие функции в <code>std::io</code> будут возвращать <code>Result&lt;T, E&gt;</code>, где <code>E</code> - это <code>std::io::Error</code>, например, эти функции в трейте <code>Write</code>:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-05-write-trait/src/lib.rs}}</code></pre>
<p><code>Result&lt;..., Error&gt;</code> часто повторяется. Поэтому <code>std::io</code> содержит такое объявление псевдонима вида:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}</code></pre>
<p>Поскольку это объявление находится в модуле <code>std::io</code>, мы можем использовать полный псевдоним <code>std::io::Result&lt;T&gt;</code>; это и есть <code>Result&lt;T, E&gt;</code>, где в качестве <code>E</code> выступает <code>std::io::Error</code>. Сигнатуры функций трейта <code>Write</code> в итоге выглядят следующим образом:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}</code></pre>
<p>Псевдоним вида помогает двумя способами: он облегчает написание кода <em>и</em> даёт нам согласованный внешняя оболочка для всего из <code>std::io</code>. Поскольку это псевдоним, то это просто ещё один вид <code>Result&lt;T, E&gt;</code>, что означает, что с ним мы можем использовать любые способы, которые работают с <code>Result&lt;T, E&gt;</code>, а также особый синтаксис вроде <code>?</code> оператора.</p>
<h3 id="Вид-never-который-никогда-не-возвращается"><a class="header" href="#Вид-never-который-никогда-не-возвращается">Вид Never, который никогда не возвращается</a></h3>
<p>В Rust есть особый вид <code>!</code>, который на жаргоне теории видов известен как <em>empty type</em> (пустой вид), потому что он не содержит никаких значений. Мы предпочитаем называть его <em>never type</em> (никакой вид), потому что он используется в качестве возвращаемого вида, когда функция ничего не возвращает. Вот пример:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-07-never-type/src/lib.rs:here}}</code></pre>
<p>Этот код читается как "функция <code>bar</code> ничего не возвращает". Функции, которые ничего не возвращают, называются <em>рассеивающими функциями</em> (diverging functions). Мы не можем производить значения вида <code>!</code>, поэтому <code>bar</code> никогда ничего не вернёт.</p>
<p>Но для чего нужен вид, для которого вы никогда не сможете создать значения? Напомним код из приложения 2-5, фрагмента "игры в загадки"; мы воспроизвели его часть здесь в приложении 19-26.</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}</code></pre>
<p><span class="caption">Приложение 19-26: Сопоставление <code>match</code> с веткой, которая заканчивается <code>continue</code></span></p>
<p>В то время мы опустили некоторые подробности в этом коде. В главе 6 раздела <a href="ch06-02-match.html#the-match-control-flow-operator">"Оператор управления потоком <code>match</code>"</a><!--  --> мы обсуждали, что все ветви <code>match</code> должны возвращать одинаковый вид. Например, следующий код не работает:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}</code></pre>
<p>Вид <code>guess</code> в этом коде должен быть целым <em>и</em> строкой, а Rust требует, чтобы <code>guess</code> имел только один вид. Так что же возвращает <code>continue</code>? Как нам позволили вернуть <code>u32</code> из одной ветви и при этом иметь другую ветвь, которая оканчивается <code>continue</code> в приложении 19-26?</p>
<p>Как вы уже возможно догадались, <code>continue</code> имеет  значение <code>!</code>. То есть, когда Rust вычисляет вид <code>guess</code>, он смотрит на обе сопоставляемые ветки, первая со значением <code>u32</code> и последняя со значением <code>!</code>. Так как <code>!</code> никогда не может иметь значение, то Rust решает что видом <code>guess</code> является вид <code>u32</code>.</p>
<p>Формальный подход к описанию такого поведения заключается в том, что выражения вида <code>!</code> могут быть преобразованы в любой другой вид. Нам позволяется завершить этот <code>match</code> с помощью <code>continue</code>, потому что <code>continue</code> не возвращает никакого значения; вместо этого он передаёт управление обратно в начало цикла, поэтому в случае <code>Err</code> мы никогда не присваиваем значение <code>guess</code>.</p>
<p>Вид never полезен также для макроса <code>panic!</code>. Вспомните функцию <code>unwrap</code>, которую мы вызываем для значений <code>Option&lt;T&gt;</code>, чтобы создать значение или вызвать панику с этим определением:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}</code></pre>
<p>В этом коде происходит то же самое, что и в <code>match</code> в приложении 19-26: Rust видит, что <code>val</code> имеет вид <code>T</code>, а <code>panic!</code> имеет вид <code>!</code>, поэтому результатом общего выражения <code>match</code> является <code>T</code>. Этот код работает, потому что <code>panic!</code> не производит никакого значения; он завершает программу. В случае <code>None</code> мы не будем возвращать значение из <code>unwrap</code>, поэтому этот код работает.</p>
<p>Последнее выражение, которое имеет вид <code>!</code> это <code>loop</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}</code></pre>
<p>В данном случае цикл никогда не завершится, поэтому <code>!</code> является значением выражения. Но это не будет так, если мы добавим <code>break</code>, так как цикл завершит свою работу, когда дойдёт до <code>break</code>.</p>
<h3 id="Виды-с-изменяемым-размером-и-трейт-sized"><a class="header" href="#Виды-с-изменяемым-размером-и-трейт-sized">Виды с изменяемым размером и трейт <code>Sized</code></a></h3>
<p>Rust необходимо знать некоторые подробности о видах, например, сколько места нужно выделить для значения определённого вида. Из-за этого один из особенностей системы видов поначалу вызывает некоторое недоумение: концепция <em>видов с изменяемым размером</em>. Иногда называемые <em>DST</em> или <em>безразмерные виды</em>, эти виды позволяют нам писать код, используя значения, размер которых мы можем узнать только во время выполнения.</p>
<p>Давайте углубимся в подробности изменяемого вида <code>str</code>, который мы использовали на протяжении всей книги. Все верно, не вида <code>&amp;str</code>, а вида <code>str</code> самого по себе, который является DST. Мы не можем знать, какой длины строка до момента времени выполнения, то есть мы не можем создать переменную вида <code>str</code> и не можем принять переменная вида <code>str</code>. Рассмотрим следующий код, который не работает:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}</code></pre>
<p>Rust должен знать, сколько памяти выделить для любого значения определенного вида и все значения вида должны использовать одинаковый объем памяти. Если Rust позволил бы нам написать такой код, то эти два значения <code>str</code> должны были бы занимать одинаковое количество памяти. Но они имеют разную длину: <code>s1</code> нужно 12 байтов памяти, а для <code>s2</code> нужно 15. Вот почему невозможно создать переменную имеющую вид изменяемого размера.</p>
<p>Так что же нам делать? В этом случае вы уже знаете ответ: мы преобразуем виды <code>s1</code> и <code>s2</code> в <code>&amp;str</code>, а не в <code>str</code>. Вспомните из раздела <a href="ch04-03-slices.html#string-slices">"Строковые срезы"</a> главы 4, что структура данных среза просто хранит начальную позицию и длину среза. Так, в отличие от <code>&amp;T</code>, который содержит только одно значение - адрес памяти, где находится <code>T</code>, в <code>&amp;str</code> хранятся <em>два</em> значения - адрес <code>str</code> и его длина. Таким образом, мы можем узнать размер значения <code>&amp;str</code> во время сборки: он вдвое больше длины <code>usize</code>. То есть, мы всегда знаем размер <code>&amp;str</code>, независимо от длины строки, на которую оно ссылается. В целом, именно так в Rust используются виды изменяемого размера: они содержат дополнительный бит метаданных, который хранит размер изменяемой сведений. Золотое правило изменяемых размерных видов заключается в том, что мы всегда должны помещать значения таких видов за каким-либо указателем.</p>
<p>Мы можем комбинировать <code>str</code> со всеми видами указателей: например, <code>Box&lt;str&gt;</code> или <code>Rc&lt;str&gt;</code>. На самом деле, вы уже видели это раньше, но с другим изменяемым размерным видом: трейтами. Каждый трейт - это изменяемый размерный вид, на который мы можем ссылаться, используя имя трейта. В главе 17 в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование трейт-объектов, допускающих значения разных видов"</a> мы упоминали, что для использования трейтов в качестве трейт-объектов мы должны поместить их за указателем, например <code>&amp;dyn Trait</code> или <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> тоже подойдёт).</p>
<p>Для работы с DST Rust использует трейт <code>Sized</code> чтобы решить, будет ли размер вида известен на стадии сборки. Этот трейт самостоятельно реализуется для всего, чей размер известен к моменту сборки. Кроме того, Rust неявно добавляет ограничение на <code>Sized</code> к каждой универсальной функции. То есть, определение универсальной функции, такое как:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}</code></pre>
<p>на самом деле рассматривается как если бы мы написали её в виде:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}</code></pre>
<p>По умолчанию обобщённые функции будут работать только с видами чей размер известен во время сборки. Тем не менее, можно использовать следующий особый синтаксис, чтобы ослабить это ограничение:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}</code></pre>
<p>Ограничение трейта <code>?Sized</code> означает «<code>T</code> может или не может быть <code>Sized</code>», эта нотация отменяет стандартное правило, согласно которому универсальные виды должны иметь известный размер во время сборки. Использовать синтаксис <code>?Trait</code> в таком качестве можно только для <code>Sized</code>, и ни для каких других трейтов.</p>
<p>Также обратите внимание, что мы поменяли вид свойства <code>t</code> с <code>T</code> на <code>&amp;T</code>. Поскольку вид мог бы не быть <code>Sized</code>, мы должны использовать его за каким-либо указателем. В данном случае мы выбрали ссылку.</p>
<p>Далее мы поговорим о функциях и замыканиях!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Продвинутые-функции-и-замыкания"><a class="header" href="#Продвинутые-функции-и-замыкания">Продвинутые функции и замыкания</a></h2>
<p>В этом разделе рассматриваются некоторые продвинутые возможности, относящиеся к функциям и замыканиям, такие как указатели функций и возвращаемые замыкания.</p>
<h3 id="Указатели-функций"><a class="header" href="#Указатели-функций">Указатели функций</a></h3>
<p>Мы уже обсуждали, как передавать замыкания в функции; но также можно передавать обычные функции в функции! Эта техника полезна, когда вы хотите передать ранее созданную функцию, а не определять новое замыкание. Функции соответствуют виду <code>fn</code> (со строчной буквой f), не путать с трейтом замыкания <code>Fn</code>. Вид <code>fn</code> называется <em>указателем функции</em>. Передача функций с помощью указателей функций позволяет использовать функции в качестве переменных других функций.</p>
<p>Для указания того, что свойство является указателем на функцию, используется синтаксис, такой же, как и для замыканий, что отображается в приложении 19-27, где мы определили функцию <code>add_one</code>, которая добавляет единицу к переданному ей свойству. Функция <code>do_twice</code> принимает два свойства: указатель на любую функцию, принимающую свойство <code>i32</code> и возвращающую <code>i32</code>, и число вида <code>i32</code>. Функция <code>do_twice</code> дважды вызывает функцию <code>f</code>, передавая ей значение <code>arg</code>, а затем складывает полученные результаты. Функция <code>main</code> вызывает функцию <code>do_twice</code> с переменнойми <code>add_one</code> и <code>5</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-27/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-27: Использование вида <code>fn</code> для получения указателя на функцию в качестве переменной</span></p>
<p>Этот код выводит <code>Ответ: 12</code>. Мы указали, что свойство <code>f</code> в <code>do_twice</code> является <code>fn</code>, которая принимает на вход единственный свойство вида <code>i32</code> и возвращает <code>i32</code>. Затем мы можем вызвать <code>f</code> в теле <code>do_twice</code>. В <code>main</code> мы можем передать имя функции <code>add_one</code> в качестве первого переменной в <code>do_twice</code>.</p>
<p>В отличие от замыканий, <code>fn</code> является видом, а не трейтом, поэтому мы указываем <code>fn</code> непосредственно в качестве вида свойства, а не объявляем свойство универсального вида с одним из трейтов <code>Fn</code> в качестве связанного.</p>
<p>Указатели функций реализуют все три трейта замыканий (<code>Fn</code>, <code>FnMut</code> и <code>FnOnce</code>), то есть вы всегда можете передать указатель функции в качестве переменной функции, которая ожидает замыкание. Лучше всего для описания функции использовать универсальный вид и один из трейтов замыканий, чтобы ваши функции могли принимать как функции, так и замыкания.</p>
<p>Однако, одним из примеров, когда вы бы хотели принимать только <code>fn</code>, но не замыкания, является взаимодействие с внешним кодом, который не имеет замыканий: функции языка C могут принимать функции в качестве переменных, однако замыканий в языке C нет.</p>
<p>В качестве примера того, где можно использовать либо замыкание, определяемое непосредственно в месте передачи, либо именованную функцию, рассмотрим использование способа <code>map</code>, предоставляемого трейтом <code>Iterator</code> в встроенной библиотеке. Чтобы использовать функцию <code>map</code> для преобразования вектора чисел в вектор строк, мы можем использовать замыкание, например, так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-15-map-closure/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Или мы можем использовать функцию в качестве переменной <code>map</code> вместо замыкания, например, так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-16-map-function/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Обратите внимание, что мы должны использовать полный синтаксис, о котором мы говорили ранее в разделе <a href="ch19-03-advanced-traits.html#advanced-traits">"Продвинутые трейты"</a><!--  -->, потому что доступно несколько функций с именем <code>to_string</code>. Здесь мы используем функцию <code>to_string</code> определённую в типаже <code>ToString</code>, который реализован в встроенной библиотеке для любого вида реализующего типаж <code>Display</code>.</p>
<p>Вспомните из раздела <a href="ch06-01-defining-an-enum.html#enum-values">"Значения перечислений"</a> главы 6, что имя каждого определённого нами варианта перечисления также становится функцией-объявителем. Мы можем использовать эти объявители в качестве указателей на функции, реализующих трейты замыканий, что означает, что мы можем использовать объявители в качестве переменных для способов, принимающих замыкания, например, так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-17-map-initializer/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы создаём экземпляры <code>Status::Value</code>, используя каждое значение <code>u32</code> в ряде (0..20), с которым вызывается <code>map</code> с помощью функции объявителя <code>Status::Value</code>. Некоторые люди предпочитают этот стиль, а некоторые предпочитают использовать замыкания. Оба варианта собирается в один и тот же код, поэтому используйте любой стиль, который вам понятнее.</p>
<h3 id="Возврат-замыканий"><a class="header" href="#Возврат-замыканий">Возврат замыканий</a></h3>
<p>Замыкания представлены трейтами, что означает, что вы не можете возвращать замыкания из функций. В большинстве случаев, когда вам захочется вернуть трейт, вы можете использовать определенный вид, реализующий этот трейт, в качестве возвращаемого значения функции. Однако вы не можете сделать подобного с замыканиями, поскольку у них не может быть определенного вида, который можно было бы вернуть; например, вы не можете использовать указатель на функцию <code>fn</code> в качестве возвращаемого вида.</p>
<p>Следующий код пытается напрямую вернуть замыкание, но он не собирается:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-18-returns-closure/src/lib.rs}}</code></pre>
<p>Ошибка сборщика выглядит следующим образом:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/no-listing-18-returns-closure/output.txt}}
</code></pre>
<p>Ошибка снова ссылается на типаж <code>Sized</code> ! Rust не знает, сколько памяти нужно будет выделить для замыкания. Мы видели решение этой проблемы ранее. Мы можем использовать типаж-объект:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-19-returns-closure-trait-object/src/lib.rs}}</code></pre>
<p>Этот код просто отлично собирается. Для получения дополнительной сведений об типаж-объектах обратитесь к разделу <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование типаж-объектов которые допускают значения разных видов"</a><!--  --> главы 17.</p>
<p>Далее давайте посмотрим на макросы!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Макросы"><a class="header" href="#Макросы">Макросы</a></h2>
<p>Мы использовали макросы, такие как <code>println!</code> на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Термин <em>макрос</em> относится к семейству возможностей в Rust. Это <em>декларативные</em> (declarative) макросы с помощью <code>macro_rules!</code> и три вида <em>процедурных</em> (procedural) макросов:</p>
<ul>
<li>Пользовательские (выводимые) <code>#[derive]</code> макросы, которые указывают код, добавленный с помощью атрибута <code>derive</code>, используемые для структур и перечислений</li>
<li>Макросы подобные атрибутам (attribute-like), которые определяют настраиваемые атрибуты, используемые для любого элемента языка</li>
<li>Похожие на функции (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream</li>
</ul>
<p>Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.</p>
<h3 id="Разница-между-макросами-и-функциями"><a class="header" href="#Разница-между-макросами-и-функциями">Разница между макросами и функциями</a></h3>
<p>По сути, макросы являются способом написания кода, который записывает другой код, что известно как <em>мета программирование</em>. В Приложении C мы обсуждаем атрибут <code>derive</code>, который генерирует за вас реализацию различных типажей. Мы также использовали макросы <code>println!</code> и <code>vec!</code> на протяжении книги. Все эти макросы <em>раскрываются</em> для генерации большего количества кода, чем исходный код написанный вами вручную.</p>
<p>Мета программирование полезно для уменьшения объёма кода, который вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.</p>
<p>Сигнатура функции должна объявлять некоторое количество и вид этих свойств имеющихся у функции. Макросы, с другой стороны, могут принимать переменное число свойств: мы можем вызвать <code>println!("hello")</code> с одним переменнаяом или <code>println!("hello {}", name)</code> с двумя переменнойми. Также макросы раскрываются до того как сборщик преобразует смысл кода, поэтому макрос может, например, реализовать типаж заданного вида. Функция этого не может, потому что она вызывается во время выполнения и типаж должен быть реализован во время сборки.</p>
<p>Обратной стороной реализации макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте Rust код, который записывает другой Rust код. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.</p>
<p>Другое важное различие между макросами и функциями заключается в том, что вы должны объявить макросы или добавить их в область видимости <em>прежде</em> чем можете вызывать их в файле, в отличии от функций, которые вы можете объявить где угодно и вызывать из любого места.</p>
<h3 id="Декларативные-макросы-с-macro_rules-для-общего-мета-программирования"><a class="header" href="#Декларативные-макросы-с-macro_rules-для-общего-мета-программирования">Декларативные макросы с <code>macro_rules!</code> для общего мета программирования</a></h3>
<p>Наиболее широко используемой формой макросов в Rust являются <em>декларативные макросы</em>. Они также иногда упоминаются как "макросы на примере", "<code>macro_rules!</code> макрос" или просто "макросы". По своей сути декларативные макросы позволяют писать нечто похожее на выражение <code>match</code> в  Rust. Как обсуждалось в главе 6, <code>match</code> выражения являются управляющими структурами, которые принимают некоторое выражение, результат значения выражения сопоставляют с шаблонами, а затем запускают код для сопоставляемой ветки. Макросы также сравнивают значение с шаблонами, которые связаны с определенным кодом: в этой ситуации значение является литералом исходного кода Rust, переданным в макрос. Шаблоны сравниваются со структурами этого исходного кода и при совпадении код, связанный с каждым шаблоном, заменяет код переданный макросу. Все это происходит во время сборки.</p>
<p>Для определения макроса используется конструкция <code>macro_rules!</code>. Давайте рассмотрим, как использовать <code>macro_rules!</code> глядя на то, как объявлен макрос <code>vec!</code>. В главе 8 рассказано, как можно использовать макрос <code>vec!</code> для создания нового вектора с определёнными значениями. Например, следующий макрос создаёт новый вектор, содержащий три целых числа:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>Мы также могли использовать макрос <code>vec!</code> для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не смогли бы использовать функцию, чтобы сделать то же самое, потому что мы не знали бы заранее количество или вид значений.</p>
<p>В приложении 19-28 приведено несколько упрощённое определение макроса <code>vec!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-28/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-28: Упрощённая исполнение определения макроса <code>vec!</code></span></p>
<blockquote>
<p>Примечание: фактическое определение макроса <code>vec!</code> в встроенной библиотеке содержит код для предварительного выделения правильного объёма памяти. Этот код является оптимизацией, которую мы здесь не используем, чтобы сделать пример проще.</p>
</blockquote>
<p>Изложение <code>#[macro_export]</code> указывает, что данный макрос должен быть доступен всякий раз, когда крейт с объявленным макросом, добавлен в область видимости. Без этой изложении макрос нельзя добавить в область видимости.</p>
<p>Затем мы начинаем объявление макроса с помощью  <code>macro_rules!</code> и имени макроса, который объявляется <em>без</em> восклицательного знака. Название, в данном случае <code>vec</code>, после которого следуют фигурные скобки, указывающие тело определения макроса.</p>
<p>Структура в теле макроса <code>vec!</code> похожа на структуру <code>match</code> выражения. Здесь у нас есть одна ветвь с шаблоном <code>( $( $x:expr ),* )</code>, затем следует ветвь <code>=&gt;</code> и раздел кода, связанный с этим шаблоном. Если шаблон сопоставлен успешно, то соответствующий раздел кода будет сгенерирован. Учитывая, что данный код является единственным шаблоном в этом макросе, существует только один действительный способ сопоставления, любой другой шаблон приведёт к ошибке. Более сложные макросы будут иметь более одной ветви.</p>
<p>Допустимый синтаксис шаблона в определениях макросов отличается от синтаксиса шаблона рассмотренного в главе 18, потому что шаблоны макроса сопоставляются со структурами кода Rust, а не со значениями. Давайте пройдёмся по тому, какие части шаблона в приложении 19-28 что означают; полный синтаксис шаблонов макроса можно найти в <a href="../reference/macros-by-example.html">Справочнике по Rust</a>.</p>
<p>Во-первых, мы используем набор скобок, чтобы охватить весь шаблон. Мы используем знак доллара ( <code>$</code>) для объявления переменной в системе макросов, которая будет содержать код на Rust, соответствующий шаблону. Знак доллара показывает, что это макропеременная, а не обычная переменная Rust. Далее следует набор скобок, в котором фиксируются значения, соответствующие шаблону в скобках, для использования в коде замены. Внутри <code>$()</code> находится <code>$x:expr</code>, которое соответствует любому выражению Rust и даёт выражению имя <code>$x</code>.</p>
<p>Запятая, следующая за <code>$()</code> указывает на то, что буквенный символ-разделитель запятая может дополнительно появиться после кода, который соответствует коду в <code>$()</code>. Звёздочка <code>*</code> указывает, что шаблон соответствует ноль или больше раз тому, что предшествует <code>*</code>.</p>
<p>Когда вызывается этот макрос с помощью <code>vec![1, 2, 3];</code> шаблон <code>$x</code> соответствует три раза всем трём выражениям <code>1</code>, <code>2</code> и <code>3</code>.</p>
<p>Теперь давайте посмотрим на шаблон в теле кода, связанного с этой ветвью: <code>temp_vec.push()</code> внутри <code>$()*</code> генерируется для каждой части, которая соответствует символу <code>$()</code> в шаблоне ноль или более раз в зависимости от того, сколько раз шаблон сопоставлен. Символ <code>$x</code> заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с <code>vec![1, 2, 3];</code>, сгенерированный код, заменяющий этот вызов макроса будет следующим:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Мы определили макрос, который может принимать любое количество переменных любого вида и может генерировать код для создания вектора, содержащего указанные элементы.</p>
<p>Чтобы узнать больше о том, как писать макросы, обратитесь к онлайн-документации или другим ресурсам, таким как <a href="https://veykril.github.io/tlborm/">«Маленькая книга макросов Rust»</a> , начатая Дэниелом Кипом и продолженная Лукасом Виртом.</p>
<h3 id="Процедурные-макросы-для-генерации-кода-из-атрибутов"><a class="header" href="#Процедурные-макросы-для-генерации-кода-из-атрибутов">Процедурные макросы для генерации кода из атрибутов</a></h3>
<p>Вторая форма макросов - это <em>процедурные макросы</em> (procedural macros), которые действуют как функции (и являются видом процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают над этим кодом и создают некоторый код в качестве вывода, а не выполняют сопоставления с шаблонами и замену кода другим кодом, как это делают декларативные макросы. Процедурные макросы могут быть трёх видов: "пользовательского вывода" (custom-derive), "похожие на атрибут" (attribute-like) и "похожие на функцию" (function-like), все они работают схожим образом.</p>
<p>При создании процедурных макросов объявления должны находиться в собственном крейте целенаправленного вида. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. В приложении 19-29 показано, как задать процедурный макрос, где <code>some_attribute</code> является заполнителем для использования целенаправленного макроса.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Приложение 19-29: Пример определения процедурного макроса</span></p>
<p>Функция, которая определяет процедурный макрос, принимает <code>TokenStream</code> в качестве входных данных и создаёт <code>TokenStream</code> в качестве вывода. Вид <code>TokenStream</code> объявлен крейтом <code>proc_macro</code>, включённым в Rust и представляет собой последовательность токенов. Это ядро макроса: исходный код над которым работает макрос, является входным <code>TokenStream</code>, а код создаваемый макросом является выходным <code>TokenStream</code>. К функции имеет также прикреплённый атрибут, определяющий какой вид процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же крейте.</p>
<p>Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие формы отличающимися.</p>
<h3 id="Как-написать-пользовательский-derive-макрос"><a class="header" href="#Как-написать-пользовательский-derive-макрос">Как написать пользовательский <code>derive</code> макрос</a></h3>
<p>Давайте создадим крейт с именем <code>hello_macro</code>, который определяет типаж с именем <code>HelloMacro</code> и имеет одну с ним ассоциированную функцию с именем <code>hello_macro</code>. Вместо того, чтобы пользователи нашего крейта самостоятельно реализовывали типаж <code>HelloMacro</code> для каждого из своих видов, мы предоставим им процедурный макрос, чтобы они могли аннотировать свой вид с помощью атрибута <code>#[derive(HelloMacro)]</code> и получили реализацию по умолчанию для функции <code>hello_macro</code>. Реализация по умолчанию выведет <code>Hello, Macro! My name is TypeName!</code>, где <code>TypeName</code> - это имя вида, для которого был определён этот типаж. Другими словами, мы напишем крейт, использование которого позволит другому программисту писать код показанный в приложении 19-30.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-30/src/main.rs}}</code></pre>
<p><span class="caption">Приложение 19-30: Код, который сможет писать пользователь нашего крейта при использовании нашего процедурного макроса</span></p>
<p>Этот код напечатает <code>Hello, Macro! My name is Pancakes!</code>, когда мы закончим. Первый шаг - создать новый, библиотечный крейт так:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Далее, мы определим типаж <code>HelloMacro</code> и ассоциированную с ним функцию:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/hello_macro/src/lib.rs}}</code></pre>
<p>У нас есть типаж и его функция. На этом этапе пользователь крейта может реализовать типаж для достижения желаемой функциональности, так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/pancakes/src/main.rs}}</code></pre>
<p>Тем не менее, ему придётся написать разделреализации для каждого вида, который он хотел использовать вместе с <code>hello_macro</code>; а мы хотим избавить их от необходимости делать эту работу.</p>
<p>Кроме того, мы пока не можем предоставить функцию <code>hello_macro</code> с реализацией по умолчанию, которая будет печатать имя вида, для которого реализован типаж: Rust не имеет возможностей рефлексии (reflection), поэтому он не может выполнить поиск имени вида во время выполнения кода. Нам нужен макрос для генерации кода во время сборки.</p>
<p>Следующим шагом является определение процедурного макроса. На момент написания этой статьи процедурные макросы должны быть в собственном крейте. Со временем это ограничение может быть отменено. Соглашение о структурировании крейтов и макросов является следующим: для крейта с именем <code>foo</code>, его пользовательский, крейт с выводимым процедурным макросом называется <code>foo_derive</code>. Давайте начнём с создания нового крейта с именем <code>hello_macro_derive</code> внутри проекта <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Наши два крейта тесно связаны, поэтому мы создаём процедурный макрос-крейт в каталоге крейта <code>hello_macro</code>. Если мы изменим определение типажа в <code>hello_macro</code>, то нам придётся также изменить реализацию процедурного макроса в <code>hello_macro_derive</code>. Два крейта нужно будет опубликовать отдельно и программисты, использующие эти крейты, должны будут добавить их как зависимости, а затем добавить их в область видимости. Мы могли вместо этого сделать так, что крейт <code>hello_macro</code> использует <code>hello_macro_derive</code> как зависимость и реэкспортирует код процедурного макроса. Однако то, как мы структурировали проект, делает возможным программистам использовать <code>hello_macro</code> даже если они не хотят <code>derive</code> функциональность.</p>
<p>Нам нужно объявить крейт <code>hello_macro_derive</code> как процедурный макрос-крейт. Также понадобятся функционал из крейтов <code>syn</code> и <code>quote</code>, как вы увидите через мгновение, поэтому нам нужно добавить их как зависимости. Добавьте следующее в файл <em>Cargo.toml</em> для <code>hello_macro_derive</code>:</p>
<p><span class="filename">Файл: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}
</code></pre>
<p>Чтобы начать определение процедурного макроса, поместите код приложения 19-31 в ваш файл <em>src/lib.rs</em> крейта <code>hello_macro_derive</code>. Обратите внимание, что этот код не ссобирается пока мы не добавим определение для функции <code>impl_hello_macro</code>.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-31: Код, который потребуется в большинстве процедурных макро крейтов для обработки Rust кода</span></p>
<p>Обратите внимание, что мы разделили код на функцию <code>hello_macro_derive</code>, которая отвечает за синтаксический анализ <code>TokenStream</code> и функцию <code>impl_hello_macro</code>, которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса удобнее. Код во внешней функции ( <code>hello_macro_derive</code> в данном случае) будет одинаковым для почти любого процедурного макрос крейта, который вы видите или создаёте. Код, который вы указываете в теле внутренней функции (в данном случае <code>impl_hello_macro</code> ) будет отличаться в зависимости от цели вашего процедурного макроса.</p>
<p>Мы представили три новых крейта: <code>proc_macro</code> <a href="https://crates.io/crates/syn"><code>syn</code></a> и <a href="https://crates.io/crates/quote"><code>quote</code></a>. Макрос <code>proc_macro</code> поставляется с Rust, поэтому нам не нужно было добавлять его в зависимости внутри <em>Cargo.toml</em>. Макрос <code>proc_macro</code> - это API сборщика, который позволяет нам читать и манипулировать Rust кодом из нашего кода.</p>
<p>Крейт <code>syn</code> разбирает Rust код из строки в структуру данных над которой мы может выполнять действия. Крейт <code>quote</code> превращает структуры данных <code>syn</code> обратно в код Rust. Эти крейты упрощают разбор любого вида Rust кода, который мы хотели бы обрабатывать: написание полного синтаксического анализатора для кода Rust не является простой задачей.</p>
<p>Функция <code>hello_macro_derive</code> будет вызываться, когда пользователь нашей библиотеки указывает своему виду <code>#[derive(HelloMacro)]</code>. Это возможно, потому что мы аннотировали функцию <code>hello_macro_derive</code> с помощью <code>proc_macro_derive</code> и указали имя <code>HelloMacro</code>, которое соответствует имени нашего типажа; это соглашение, которому следует большинство процедурных макросов.</p>
<p>Функция <code>hello_macro_derive</code> сначала преобразует <code>input</code> из <code>TokenStream</code> в структуру данных, которую мы можем затем преобразовать и над которой выполнять действия. Здесь крейт <code>syn</code> вступает в игру. Функция <code>parse</code> в <code>syn</code> принимает <code>TokenStream</code> и возвращает структуру <code>DeriveInput</code>, представляющую разобранный код Rust. Приложение 19-32 показывает соответствующие части структуры <code>DeriveInput</code>, которые мы получаем при разборе строки <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Приложение 19-32: Экземпляр <code>DeriveInput</code> получаемый, когда разбирается код имеющий атрибут макроса из приложения 19-30</span></p>
<p>Поля этой структуры показывают, что код Rust, который мы разобрали, является разделструктуры с <code>ident</code> (определителем, означающим имя) <code>Pancakes</code>. В этой структуре есть больше полей для описания всех видов кода Rust; проверьте <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">документацию <code>syn</code> о структуре <code>DeriveInput</code></a> для получения дополнительной сведений.</p>
<p>Вскоре мы определим функцию <code>impl_hello_macro</code>, в которой построим новый, дополнительный код Rust. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является <code>TokenStream</code>. Возвращаемый <code>TokenStream</code> добавляется в код, написанный пользователями макроса, поэтому, когда они соберут свой крейт, они получат дополнительную функциональность, которую мы предоставляем в изменённом <code>TokenStream</code>.</p>
<p>Возможно, вы заметили, что мы вызываем <code>unwrap</code> чтобы выполнить панику в функции <code>hello_macro_derive</code>, если вызов функции <code>syn::parse</code> потерпит неудачу. Наш процедурный макрос должен паниковать при ошибках, потому что функции <code>proc_macro_derive</code> должны возвращать <code>TokenStream</code>, а не вид <code>Result</code> для соответствия API процедурного макроса. Мы упростили этот пример с помощью <code>unwrap</code>, но в рабочем коде вы должны предоставить более определенные сообщения об ошибках, если что-то пошло не правильно, используя <code>panic!</code> или <code>expect</code>.</p>
<p>Теперь, когда у нас есть код для преобразования аннотированного Rust кода из <code>TokenStream</code> в экземпляр <code>DeriveInput</code>, давайте сгенерируем код реализующий типаж <code>HelloMacro</code> у аннотированного вида, как показано в приложении 19-33.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-33/hello_macro/hello_macro_derive/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 19-33: Реализация типажа <code>HelloMacro</code> с использованием проанализированного кода Rust.</span></p>
<p>Мы получаем экземпляр структуры <code>Ident</code> содержащий имя (определитель) аннотированного вида с использованием <code>ast.ident</code>. Структура в приложении 19-32 показывает, что когда мы запускаем функцию <code>impl_hello_macro</code> для кода из приложения 19-30, то получаемый <code>ident</code> будет иметь поле <code>ident</code> со значением <code>"Pancakes"</code>. Таким образом, переменная <code>name</code> в приложении 19-33 будет содержать экземпляр структуры <code>Ident</code>, что при печати выдаст строку <code>"Pancakes"</code>, что является именем структуры в приложении 19-30.</p>
<p>Макрос <code>quote!</code> позволяет определить код Rust, который мы хотим вернуть. Сборщик ожидает что-то отличное от прямого результата выполнения макроса <code>quote!</code>, поэтому нужно преобразовать его в <code>TokenStream</code>. Мы делаем это путём вызова способа <code>into</code>, который использует промежуточное представление и возвращает значение требуемого вида <code>TokenStream</code>.</p>
<p>Макрос <code>quote!</code> также предоставляет очень классную механику шаблонов: мы можем ввести <code>#name</code> и <code>quote!</code> заменит его значением из переменной <code>name</code>. Вы можете даже сделать некоторое повторение, подобное тому, как работают обычные макросы. Проверьте <a href="https://docs.rs/quote">документацию крейта <code>quote</code></a> для подробного введения.</p>
<p>Мы хотим, чтобы наш процедурный макрос генерировал реализацию нашего типажа <code>HelloMacro</code> для вида, который аннотировал пользователь, который мы можем получить, используя <code>#name</code>. Реализация типажа имеет одну функцию <code>hello_macro</code>, тело которой содержит функциональность, которую мы хотим предоставить: напечатать <code>Hello, Macro! My name is</code> с именем аннотированного вида.</p>
<p>Макрос <code>stringify!</code> используемый здесь, встроен в Rust. Он принимает Rust выражение, такое как <code>1 + 2</code> и во время сборки сборщик превращает выражение в строковый литерал, такой как <code>"1 + 2"</code>. Он отличается от макросов <code>format!</code> или <code>println!</code>, которые вычисляют выражение, а затем превращают результат в виде вида <code>String</code>. Существует возможность того, что введённый <code>#name</code> может оказаться выражением для печати буквально как есть, поэтому здесь мы используем <code>stringify!</code>. Использование <code>stringify!</code> также экономит выделение памяти путём преобразования <code>#name</code> в строковый литерал во время сборки.</p>
<p>На этом этапе приказ <code>cargo build</code> должна завершиться успешно для обоих <code>hello_macro</code> и <code>hello_macro_derive</code>. Давайте подключим эти крейты к коду в приложении 19-30, чтобы увидеть процедурный макрос в действии! Создайте новый двоичный проект в каталоге ваших <em>проектов</em> с использованием приказы <code>cargo new pancakes</code>. Нам нужно добавить <code>hello_macro</code> и <code>hello_macro_derive</code> в качестве зависимостей для крейта <code>pancakes</code> в файл <em>Cargo.toml</em>. Если вы публикуете свои исполнения <code>hello_macro</code> и <code>hello_macro_derive</code> на сайт <a href="https://crates.io/">crates.io</a>, они будут обычными зависимостями; если нет, вы можете указать их как <code>path</code> зависимости следующим образом:</p>
<pre><code class="language-toml">{{#include ../listings/ch19-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}
</code></pre>
<p>Поместите код в приложении 19-30 в <em>src/main.rs</em> и выполните <code>cargo run</code>: он должен вывести <code>Hello, Macro! My name is Pancakes!</code>. Реализация типажа <code>HelloMacro</code> из процедурного макроса была включена без необходимости его реализации крейтом <code>pancakes</code>; <code>#[derive(HelloMacro)]</code> добавил реализацию типажа.</p>
<p>Далее давайте рассмотрим, как другие виды процедурных макросов отличаются от пользовательских выводимых макросов.</p>
<h3 id="Макросы-похожие-на-атрибут"><a class="header" href="#Макросы-похожие-на-атрибут">Макросы, похожие на атрибут</a></h3>
<p>Подобные атрибутам макросы похожи на пользовательские выводимые макросы, но вместо генерации кода для <code>derive</code> атрибута, они позволяют создавать новые атрибуты. Они являются также более гибкими: <code>derive</code> работает только для структур и перечислений; атрибут-подобные могут применяться и к другим элементам, таким как функции. Вот пример использования  атрибутного макроса: допустим, у вас есть атрибут именованный <code>route</code> который аннотирует функции при использовании фреймворка для веб-приложений:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>Данный атрибут <code>#[route]</code> будет определён платформой как процедурный макрос. Сигнатура функции определения макроса будет выглядеть так:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Здесь есть два свойства вида <code>TokenStream</code>. Первый для содержимого атрибута: часть <code>GET, "/"</code> . Второй это тело элемента, к которому прикреплён атрибут: в данном случае <code>fn index() {}</code> и остальная часть тела функции.</p>
<p>Кроме того, атрибутные макросы работают так же как и пользовательские выводимые макросы: вы создаёте крейт с видом <code>proc-macro</code> и реализуете функцию, которая генерирует код, который хотите!</p>
<h3 id="Макросы-похожие-на-функции"><a class="header" href="#Макросы-похожие-на-функции">Макросы, похожие на функции</a></h3>
<p>Макросы, похожие на функции, выглядят подобно вызову функций. Подобно макросам <code>macro_rules!</code> они являются более гибкими, чем функции; например, они могут принимать неизвестное количество переменных. Тем не менее, макросы <code>macro_rules!</code> можно объявлять только с использованием синтаксиса подобного сопоставлению, который мы обсуждали ранее в разделе <a data-md-type="raw_html" href="ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">"Декларативные макросы <code>macro_rules!</code> для общего мета программирования"</a>. Макросы, похожие на функции, принимают свойство <code>TokenStream</code> и их определение манипулирует этим <code>TokenStream</code>, используя код Rust, как это делают два других вида процедурных макроса. Примером подобного функционально подобного макроса является макрос <code>sql!</code>, который можно вызвать так:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Этот макрос будет разбирать SQL указанию внутри него и проверять, что она синтаксически правильная, что является гораздо более сложной обработкой, чем то что может сделать макрос <code>macro_rules!</code>. Макрос <code>sql!</code> мог бы быть определён так:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Это определение похоже на сигнатуру пользовательского выводимого макроса: мы получаем токены, которые находятся внутри скобок и возвращаем код, который мы хотели сгенерировать.</p>
<h2 id="Итоги-16"><a class="header" href="#Итоги-16">Итоги</a></h2>
<p>Фух! Теперь у вас в распоряжении есть некоторые возможности Rust, которые вы не будете часто использовать, но вы будете знать, что они доступны в особых обстоятельствах. Мы представили несколько сложных тем, чтобы при появлении сообщения с предложением исправить ошибку или в коде других людей, вы могли бы распознать эти концепции и синтаксис. Используйте эту главу как справочник, который поможет вам найти решение.</p>
<p>Далее мы применим на практике все, что обсуждали на протяжении всей книги, и выполним ещё один проект!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Финальный-проект-создание-многопоточного-веб-сервера"><a class="header" href="#Финальный-проект-создание-многопоточного-веб-сервера">Финальный проект: создание многопоточного веб-сервера</a></h1>
<p>Это был долгий путь, но мы дошли до финала книги. В этой главе мы сделаем ещё один проект, чтобы закрепить несколько тем из последних глав и резюмировать то, что прошли в самом начале.</p>
<p>В качестве нашего финального проекта мы напишем веб-сервер, который выводит надпись “hello” в веб-браузере, как на рисунке 20-1.</p>
<p><img src="https://github.com/ruRust/book/blob/master/rustbook-en/src/img/trpl20-01.png?raw=true" alt="hello from rust" /></p>
<p><span class="caption">Рисунок 20-1: Наш последний совместный проект</span></p>
<p>Для создания веб-сервера нам понадобится:</p>
<ol>
<li>Узнать немного о протоколах TCP и HTTP.</li>
<li>Сделать прослушивание TCP соединения у сокета.</li>
<li>Создать функциональность для парсинга небольшого количества HTTP-запросов.</li>
<li>Научить сервер отдавать корректный HTTP-ответ.</li>
<li>Улучшить пропускную способность нашего сервера с помощью пула потоков.</li>
</ol>
<p>Прежде чем мы начнём, заметим: способ, который мы будем использовать - не лучшим способ создания веб-сервера на Rust. Члены сообщества уже опубликовали на <a href="https://crates.io/">crates.io</a> несколько готовых к использованию крейтов, которые предоставляют более полные реализации веб-сервера и пула потоков, чем те, которые мы создадим. Однако наша цель в этой главе — научиться новому, а не идти по лёгкому пути. Поскольку Rust — это язык системного программирования, мы можем выбирать тот уровень абстракции, который нам подходит, и можем переходить на более низкий уровень, что может быть невозможно или непрактично в других языках. Поэтому мы напишем основной HTTP-сервер и пул потоков вручную, чтобы вы могли изучить общие идеи и способы, лежащие в основе крейтов, которые, возможно, вы будете использовать в будущем.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Создание-однопоточного-веб-сервера"><a class="header" href="#Создание-однопоточного-веб-сервера">Создание однопоточного веб-сервера</a></h2>
<p>Начнём с однопоточного веб-сервера. Перед тем, как начать, давайте сделаем краткий обзор протоколов, задействованных при создании веб-серверов. Детальное описание этих протоколов выходит за рамки этой книги, но краткий обзор даст вам необходимую сведения.</p>
<p>Двумя основными протоколами, используемыми в веб-серверах, являются <em>протокол передачи гипертекста</em> <em>(HTTP - Hypertext Transfer Protocol)</em> и <em>Протокол управления передачей</em> <em>(TCP - Transmission Control Protocol)</em>. Оба протокола являются протоколами вида <em>запрос-ответ</em> (request-response), то есть <em>клиент</em> объявляет запросы, а <em>сервер</em> слушает эти запросы и предоставляет ответ клиенту. Содержимое этих запросов и ответов определяется протоколами.</p>
<p>TCP - это протокол нижнего уровня, который описывает подробности того, как сведения передаётся от одного сервера к другому, но не определяет, что это за сведения. HTTP строится поверх TCP, определяя содержимое запросов и ответов. Технически возможно использовать HTTP с другими протоколами, но в подавляющем большинстве случаев HTTP отправляет свои данные поверх TCP. Мы будем работать с необработанными байтами в TCP и запросами и ответами в HTTP.</p>
<h3 id="Прослушивание-tcp-соединения"><a class="header" href="#Прослушивание-tcp-соединения">Прослушивание TCP соединения</a></h3>
<p>Нашему веб-серверу необходимо прослушивать TCP-соединение, так что это первая часть, над которой мы будем работать. Стандартная библиотека предлагает для этого модуль <code>std::net</code>. Сделаем новый проект обычным способом:</p>
<pre><code class="language-console">$ cargo new hello
      Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Дл начала добавьте код из приложения 20-1 в файл <em>src/main.rs</em>. Этот код будет прослушивать входящие TCP потоки по адресу <code>127.0.0.1:7878</code>. Когда сервер примет входящий поток, он напечатает <code>Connection established!</code> ("Соединение установлено!").</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-01/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-1: Прослушивание входящих потоков и печать сообщения при получении потока</span></p>
<p>Используя <code>TcpListener</code> мы можем слушать TCP соединения к адресу <code>127.0.0.1:7878</code>. В адресе, в его части перед двоеточием, сначала идёт IP-адрес, относящийся к вашему компьютеру (он одинаковый на каждом компьютере и не представляет определенный компьютер автора), а часть <code>7878</code> является портом. Мы выбрали этот порт по двум причинам: HTTP обычно не используется на этом порту, поэтому маловероятно, что наш сервер будет конфликтовать с каким-нибудь другим сервером, который может выполняться на вашей машине, и ещё 7878 - это слово <em>rust</em>, набранное на телефоне.</p>
<p>Функция <code>bind</code> в этом сценарии работает так же, как функция <code>new</code>, поскольку она возвращает новый экземпляр <code>TcpListener</code> . Причина, по которой функция называется <code>bind</code> заключается в том, что в сетевой терминологии подключение к порту для прослушивания называется «привязка к порту» (“binding to a port”).</p>
<p>Функция <code>bind</code> возвращает <code>Result&lt;T, E&gt;</code>, а это значит, что привязка может не состояться. Так, например, подключение к порту 80 предполагает наличие привилегий администратора (прочие пользователи могут прослушивать порты только от 1023-го и выше), поэтому если мы попытаемся подключиться к порту 80, не будучи администратором, привязка не сработает. Привязка также не выполнится, например, если мы запустим два экземпляра нашей программы, прослушивающие один и тот же порт. Поскольку мы пишем простейший сервер в учебных целях, мы не будем беспокоиться об обработке подобных ошибок; вместо этого мы используем <code>unwrap</code> для прекращения работы программы в случае возникновения ошибок.</p>
<p>Способ <code>incoming</code> в <code>TcpListener</code> возвращает повторитель, который даёт нам последовательность потоков (определеннее, потоков вида <code>TcpStream</code> ). Один <em>поток</em> представляет собой открытое соединение между клиентом и сервером. <em>Соединением</em> называется полный процесс запроса и ответа, в котором клиент подключается к серверу, сервер генерирует ответ, и сервер закрывает соединение. Таким образом, мы будем читать из потока <code>TcpStream</code> то, что отправил клиент, а затем записывать наш ответ в поток, для отправки его обратно клиенту. В целом, цикл <code>for</code> будет обрабатывать каждое соединение по очереди и создавать серию потоков, которые мы будем обрабатывать.</p>
<p>На текущий момент наша обработка потока состоит из вызова <code>unwrap</code> для завершения программы, если в потоке возникли ошибки, если же таковых не обнаружится, программа выведет сообщение. В следующем приложении мы добавим больше функциональности для успешного сценария. Причиной того, что мы можем получать ошибки от способа <code>incoming</code>, когда клиент подключается к серверу, является то, что на самом деле мы не перебираем подключения. На самом деле мы перебираем <em>попытки подключения</em>. Подключение может не состояться по ряду причин, многие из которых зависят от операционной системы. Например, многие операционные системы имеют ограничение на количество одновременно открытых соединений, которые они могут поддерживать; при превышении этого лимита новые попытки установить соединение будут приводить к ошибке, пока какие-либо из уже открытых соединений не будут закрыты.</p>
<p>Попробуем запустить этот код! Вызовите <code>cargo run</code> в окне вызова, а затем загрузите <em>127.0.0.1:7878</em> в веб-браузере. В браузере должно отображаться сообщение об ошибке, например «Connection reset», поскольку сервер в настоящее время не отправляет обратно никаких данных. Но когда вы посмотрите на свой окно вызова, вы должны увидеть несколько сообщений, которые были напечатаны, когда браузер подключался к серверу!</p>
<pre><code class="language-text">     Running `target/debug/hello`
 Connection established!
 Connection established!
 Connection established!
</code></pre>
<p>Иногда вы видите несколько сообщений, напечатанных для одного запроса браузера; Причина может заключаться в том, что браузер выполняет запрос страницы, а также других ресурсов, таких как значок <em>favicon.ico,</em> который отображается на вкладке браузера.</p>
<p>Также может быть, что браузер пытается подключиться к серверу несколько раз, потому что сервер не отвечает. Когда <code>stream</code> выходит из области видимости и отбрасывается в конце цикла, соединение закрывается как часть реализации <code>drop</code>. Браузеры иногда обрабатывают закрытые соединения, повторяя попытки, потому что проблема может быть временной. Важным фактором является то, что мы успешно получили дескриптор TCP-соединения!</p>
<p>Не забудьте остановить программу, нажав <span class="keystroke">ctrl-c</span>, когда вы закончите выполнение определённой исполнения кода. Затем перезапустите программу, вызвав приказ <code>cargo run</code>, после того, как вы внесли какой-либо набор изменений, чтобы убедиться, что выполняется самая свежая исполнение кода.</p>
<h3 id="Чтение-запросов"><a class="header" href="#Чтение-запросов">Чтение запросов</a></h3>
<p>Реализуем функционал чтения запроса из браузера! Чтобы разделить части, связанные с получением соединения и последующим действием с ним, мы запустим новую функцию для обработки соединения. В этой новой функции <code>handle_connection</code> мы будем читать данные из потока TCP и распечатывать их, чтобы мы могли видеть данные, отправленные из браузера. Измените код, чтобы он выглядел как в приложении 20-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-02/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-2: Чтение из <code>TcpStream</code> и печать данных</span></p>
<p>Мы добавляем <code>std::io::prelude</code> и <code>std::io::BufReader</code> в область видимости, чтобы получить доступ к типажам и видам, которые позволяют нам читать и писать в поток. В цикле <code>for</code> функции <code>main</code> вместо вывода сообщения о том, что мы установили соединение, мы теперь вызываем новую функцию <code>handle_connection</code> и передаём ей <code>stream</code>.</p>
<p>В функции <code>handle_connection</code> мы создаём новый экземпляр <code>BufReader</code>, который оборачивает изменяемую ссылку на <code>stream</code>. <code>BufReader</code> добавляет буферизацию, управляя вызовами способов типажа <code>std::io::Read</code> за нас.</p>
<p>Мы создаём переменную <code>http_request</code> для сбора строк запроса, который браузер отправляет на наш сервер. Мы указываем, что хотим собрать эти строки в вектор, добавляя изложение вида <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> реализует трейт <code>std::io::BufRead</code>, который реализует способ <code>lines</code>. Способ <code>lines</code> возвращает повторитель<code>Result&lt;String, std::io::Error&gt;</code>, разделяющий поток данных на части всякий раз, когда ему попадается байт новой строки. Чтобы получить все строки <code>String</code>, мы с помощью map вызываем <code>unwrap</code> у каждого <code>Result</code>. Значение <code>Result</code> может быть ошибкой, если данные не соответствуют стандарту UTF-8 или если возникли проблемы с чтением из потока. Опять же, программа в промышленном исполнении должна обрабатывать эти ошибки более изящно, но мы для простоты решили прекращать работу программы в случае ошибки.</p>
<p>Браузер сигнализирует об окончании HTTP-запроса, отправляя два символа перевода строки подряд, поэтому, чтобы получить один запрос из потока, мы забираем строки, пока не получим строку, которая является пустой строкой. После того, как мы собрали строки в вектор, мы распечатываем их, используя красивое отладочное форматирование, чтобы мы могли взглянуть на указания, которые веб-браузер отправляет на наш сервер.</p>
<p>Попробуем этот код! Запустите программу и снова сделайте запрос в веб-браузере. Обратите внимание, что мы по-прежнему будем получать в браузере страницу с ошибкой, но вывод нашей программы в окне вызова теперь будет выглядеть примерно так:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>В зависимости от вашего браузера результат может немного отличаться. Теперь, когда мы печатаем данные запроса, мы можем понять, почему мы получаем несколько подключений из одного запроса браузера, посмотрев на путь после <code>GET</code> в первой строке запроса. Если все повторяющиеся соединения запрашивают <em>/</em> , мы знаем, что браузер пытается получить <em>/</em> повторно, потому что он не получает ответа от нашей программы.</p>
<p>Давайте разберём эти данные запроса, чтобы понять, что браузер запрашивает у нашей программы.</p>
<h3 id="Пристальный-взгляд-на-http-запрос"><a class="header" href="#Пристальный-взгляд-на-http-запрос">Пристальный взгляд на HTTP запрос</a></h3>
<p>HTTP - это текстовый протокол и запрос имеет следующий формат:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка - это <em>строка запроса</em> , содержащая сведения о том, что запрашивает клиент. Первая часть строки запроса указывает используемый <em>способ</em> , например <code>GET</code> или <code>POST</code> , который описывает, как клиент выполняет этот запрос. Наш клиент использовал запрос <code>GET</code>, что означает, что он просит нас предоставить сведения.</p>
<p>Следующая часть строки запроса - это <em>/</em>, которая указывает <em>унифицированный определитель</em> <em>ресурса (URI),</em> который запрашивает клиент: URI почти, но не совсем то же самое, что и <em>унифицированный указатель ресурса</em> <em>(URL)</em>. Разница между URI и URL-адресами не важна для наших целей в этой главе, но спецификация HTTP использует термин URI, поэтому мы можем просто мысленно заменить URL-адрес здесь.</p>
<p>Последняя часть - это исполнение HTTP, которую использует клиент, а затем строка запроса заканчивается <em>последовательностью CRLF</em> . (CRLF обозначает <em>возврат каретки</em> и <em>перевод строки</em> , что является термином из дней пишущих машинок!) Последовательность CRLF также может быть записана как <code>\r\n</code> , где <code>\r</code> - возврат каретки, а <code>\n</code> - перевод строки. Последовательность CRLF отделяет строку запроса от остальных данных запроса. Обратите внимание, что при печати CRLF мы видим начало новой строки, а не <code>\r\n</code> .</p>
<p>Глядя на данные строки запроса, которые мы получили от запуска нашей программы, мы видим, что <code>GET</code> - это способ, <em>/</em> - это URI запроса, а <code>HTTP/1.1</code> - это исполнение.</p>
<p>После строки запроса оставшиеся строки, начиная с <code>Host:</code> далее, являются заголовками. <code>GET</code> запросы не имеют тела.</p>
<p>Попробуйте сделать запрос из другого браузера или запросить другой адрес, например <em>127.0.0.1:7878/test</em> , чтобы увидеть, как изменяются данные запроса.</p>
<p>Теперь, когда мы знаем, что запрашивает браузер, давайте отправим обратно в ответ некоторые данные!</p>
<h3 id="Написание-ответа"><a class="header" href="#Написание-ответа">Написание ответа</a></h3>
<p>Теперь реализуем отправку данных в ответ на запрос клиента. Ответы имеют следующий формат:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка - это <em>строка состояния</em>, которая содержит исполнение HTTP, используемую в ответе, числовой код состояния, который суммирует результат запроса, и фразу причины, которая предоставляет текстовое описание кода состояния. После последовательности CRLF идут любые заголовки, другая последовательность CRLF и тело ответа.</p>
<p>Вот пример ответа, который использует HTTP исполнения 1.1, имеет код состояния 200, фразу причины OK, без заголовков и без тела:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Код состояния 200 - это стандартный успешный ответ. Текст представляет собой крошечный успешный HTTP-ответ. Давайте запишем это в поток как наш ответ на успешный запрос! Из функции <code>handle_connection</code> удалите <code>println!</code> который печатал данные запроса и заменял их кодом из Приложения 20-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-03/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-3: Запись крошечного успешного HTTP-ответа в поток</span></p>
<p>Первый перевод строки определяет переменную <code>response</code>, которая содержит данные сообщения об успешном выполнении. Затем мы вызываем <code>as_bytes</code> в нашем <code>response</code>, чтобы преобразовать строковые данные в байты. Способ <code>write_all</code> в <code>stream</code> принимает вид <code>&amp;[u8]</code> и отправляет эти байты непосредственно получателю. Поскольку действие <code>write_all</code> может завершиться с ошибкой, мы, как и ранее, используем <code>unwrap</code> на любом потенциально ошибочном результате. И опять, в реальном приложении здесь вам нужно было бы добавить обработку ошибок.</p>
<p>После этих изменений давайте запустим наш код и сделаем запрос. Мы больше не печатаем никаких данных в окно вызова, поэтому мы не увидим никакого вывода, кроме сообщений от Cargo. Когда вы загрузите <em>127.0.0.1:7878</em> в веб-браузере, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали код получения HTTP-запроса и отправки ответа на него!</p>
<h3 id="Возвращение-реального-html"><a class="header" href="#Возвращение-реального-html">Возвращение реального HTML</a></h3>
<p>Давайте реализуем функционал чего-нибудь большего, чем просто пустой страницы. Создайте новый файл <em>hello.html</em> в корне каталога вашего проекта, а не в каталоге <em>src</em> . Вы можете ввести любой HTML-код, который вам заблагорассудится; В приложении 20-4 показан один из вариантов.</p>
<p><span class="filename">Файл: hello.html</span></p>
<pre><code class="language-html">{{#include ../listings/ch20-web-server/listing-20-05/hello.html}}
</code></pre>
<p><span class="caption">Приложение 20-4: Пример HTML-файла для ответа на запрос</span></p>
<p>Это простейший HTML5-документ с заголовком и каким-то текстом. Чтобы сервер возвращал его в ответ на полученный запрос, мы изменим <code>handle_connection</code>, как показано в приложении 20-5, чтобы считать HTML-файл, добавить его в ответ в качестве тела и отправить.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-05/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-5. Отправка содержимого <em>hello.html</em> в качестве тела ответа</span></p>
<p>Мы добавили элемент <code>fs</code> в указанию <code>use</code>, чтобы включить в область видимости модуль файловой системы встроенной библиотеки. Код для чтения содержимого файла в строку должен выглядеть знакомым для вас; мы использовали его в главе 12, когда читали содержимое файла для нашего проекта ввода-вывода в приложении 12-4.</p>
<p>Далее мы используем <code>format!</code> чтобы добавить содержимое файла в качестве тела ответа об успешном завершении. Чтобы обеспечить действительный HTTP-ответ, мы добавляем заголовок <code>Content-Length</code> который имеет размер тела нашего ответа, в данном случае размер <code>hello.html</code> .</p>
<p>Запустите этот код приказом <code>cargo run</code> и загрузите <em>127.0.0.1:7878</em> в браузере; вы должны увидеть выведенный HTML в браузере!</p>
<p>В настоящее время мы пренебрегаем данные запроса в переменной <code>http_request</code> и в любом случае просто отправляем обратно содержимое HTML-файла. Это означает, что если вы попытаетесь запросить адрес <em>127.0.0.1:7878/something-else</em> в своём браузере, вы все равно получите тот же самый HTML-ответ. Пока что наш сервер очень ограничен, и не умеет делать то, что делает большинство веб-серверов. Мы хотим настроить наши ответы в зависимости от запроса и отправлять обратно HTML-файл только для правильно сформированного запроса к пути <em>/</em> .</p>
<h3 id="Проверка-запроса-и-выборочное-возвращение-ответа"><a class="header" href="#Проверка-запроса-и-выборочное-возвращение-ответа">Проверка запроса и выборочное возвращение ответа</a></h3>
<p>Сейчас наш веб-сервер возвращает HTML из файла независимо от того, что определенно запросил клиент. Давайте добавим проверку того, что браузер запрашивает <em>/</em>, прежде чем вернуть HTML-файл, и будем возвращать ошибку, если браузер запрашивает что-то постороннее. Для этого нам нужно модифицировать <code>handle_connection</code>, как показано в приложении 20-6. Новый код проверяет соответствует ли требуемый запросом ресурс с определителем <em>/</em>, и содержит разделы <code>if</code> и <code>else</code>, чтобы иначе обрабатывать другие запросы.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-06/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-6: Обрабатываем запросы для корневого ресурса <em>/</em> не так, как запросы для других ресурсов</span></p>
<p>Мы будем рассматривать только первую строку HTTP-запроса, поэтому вместо того, чтобы читать весь запрос в вектор, мы вызываем <code>next</code> , чтобы получить первый элемент из повторителя. Первый вызов <code>unwrap</code> заботится об обработке <code>Option</code> и останавливает программу, если в повторителе нет элементов. Второй <code>unwrap</code> обрабатывает <code>Result</code> и имеет тот же эффект, что и <code>unwrap</code>, который был в <code>map</code>, добавленном в приложении 20-2.</p>
<p>Затем мы проверяем переменную <code>request_line</code>, чтобы увидеть, равна ли она строке запроса, соответствующей запросу GET для пути <em>/</em> . Если это так, раздел<code>if</code> возвращает содержимое нашего HTML-файла.</p>
<p>Если <code>request_line</code> <em>не</em> равна запросу GET для пути <em>/</em>, это означает, что мы получили какой-то другой запрос. Мы скоро добавим код в раздел<code>else</code>, чтобы ответить на все остальные запросы.</p>
<p>Запустите этот код сейчас и запросите <em>127.0.0.1:7878</em> ; вы должны получить HTML в <em>hello.html</em> . Если вы сделаете любой другой запрос, например <em>127.0.0.1:7878/something-else</em> , вы получите ошибку соединения, подобную той, которую вы видели при запуске кода из Приложения 20-1 и Приложения 20-2.</p>
<p>Теперь давайте добавим код из приложения 20-7 в раздел<code>else</code> чтобы вернуть ответ с кодом состояния 404, который сигнализирует о том, что контент для запроса не найден. Мы также вернём HTML-код для страницы, отображаемой в браузере, с указанием ответа конечному пользователю.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-07/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение  20-7: Отвечаем кодом состояния 404 и страницей ошибки, если было запрошено что-то, отличающееся от ресурса <em>/</em></span></p>
<p>Здесь ответ имеет строку состояния с кодом 404 и фразу причины <code>NOT FOUND</code>. Тело ответа будет HTML из файла <em>404.html</em>. Вам нужно создать файл <em>404.html</em> рядом с <em>hello.html</em> для этой страницы ошибки; снова не стесняйтесь использовать любой HTML код или пример HTML кода в приложении 20-8.</p>
<p><span class="filename">Файл: 404.html</span></p>
<pre><code class="language-html">{{#include ../listings/ch20-web-server/listing-20-07/404.html}}
</code></pre>
<p><span class="caption">Приложение 20-8. Пример содержимого страницы для отправки с любым ответом 404</span></p>
<p>С этими изменениями снова запустите сервер. Запрос на <em>127.0.0.1:7878</em> должен возвращать содержимое <em>hello.html</em>, и любой другой запрос, как <em>127.0.0.1:7878/foo</em>, должен возвращать сообщение об ошибке HTML от <em>404.html</em>.</p>
<h3 id="Рефакторинг"><a class="header" href="#Рефакторинг">Рефакторинг</a></h3>
<p>На текущий момент разделы <code>if</code> и <code>else</code> во многом повторяются: они оба читают файлы и записывают содержимое файлов в поток. Разница лишь в строке состояния и имени файла. Давайте сделаем код более лаконичным, вынеся эти отличия в отдельные разделы <code>if</code> и <code>else</code>, в которых переменным будут присвоены значения строки состояния и имени файла; далее эти переменные мы сможем использовать в коде для чтения файла и создания ответа. В приложении 20-9 показан код после изменения объёмных разделов <code>if</code> и <code>else</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-09/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-9: Рефакторинг разделов <code>if</code> и <code>else</code>, чтобы они содержали только код, который отличается для каждого из случаев</span></p>
<p>Теперь разделы <code>if</code> и <code>else</code> возвращают только соответствующие значения для строки состояния и имени файла в кортеже. Затем мы используем деструктурирование, чтобы присвоить эти два значения <code>status_line</code> и <code>filename</code> используя шаблон в указания <code>let</code>, как обсуждалось в главе 18.</p>
<p>Ранее повторяющийся код теперь находится вне разделов <code>if</code> и <code>else</code> и использует переменные <code>status_line</code> и <code>filename</code>. Это позволяет легче увидеть разницу между этими двумя случаями и означает, что у нас есть только одно место для обновления кода, если захотим изменить работу чтения файлов и записи ответов. Поведение кода в приложении 20-9 будет таким же, как и в 20-8.</p>
<p>Потрясающие! Теперь у нас есть простой веб-сервер примерно на 40 строках кода Rust, который отвечает на один запрос страницей с контентом и отвечает на все остальные запросы ответом 404.</p>
<p>В настоящее время наш сервер работает в одном потоке, что означает, что он может обслуживать только один запрос за раз. Давайте разберёмся, почему это может быть проблемой, сымитировав несколько медленных запросов. Затем мы исправим ситуацию так, чтобы наш сервер мог обрабатывать несколько запросов одновременно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Превращение-однопоточного-сервера-в-многопоточный-сервер"><a class="header" href="#Превращение-однопоточного-сервера-в-многопоточный-сервер">Превращение однопоточного сервера в многопоточный сервер</a></h2>
<p>В текущей реализации сервер обрабатывает каждый запрос по очереди, то есть, он не начнёт обрабатывать второе соединение, пока не завершит обработку первого. При росте числа запросов к серверу, такое последовательное выполнение было бы все менее и менее оптимальным. Если сервер получает какой-то запрос, обработка которого занимает достаточно много времени, последующим запросам придётся ждать завершения обработки длительного запроса, даже если эти новые запросы сами по себе могут быть обработаны быстро. Нам нужно это исправить, но сначала рассмотрим проблему в действии.</p>
<h3 id="Подражание-медленного-запроса-в-текущей-реализации-сервера"><a class="header" href="#Подражание-медленного-запроса-в-текущей-реализации-сервера">Подражание медленного запроса в текущей реализации сервера</a></h3>
<p>Мы посмотрим, как запрос с медленной обработкой может повлиять на другие запросы, сделанные к серверу в текущей реализации. В приложении 20-10 реализована обработка запроса к ресурсу <em>/sleep</em> с эмуляцией медленного ответа, при которой сервер будет ждать 5 секунд перед тем, как ответить.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-10/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-10: Подражание медленного запроса с помощью 5-секундной задержки</span></p>
<p>Мы переключились с <code>if</code> на <code>match</code>, так как теперь у нас есть три случая. Нам придётся явно сопоставить срез от <code>request_line</code> для проверки совпадения шаблона со строковыми литералами; <code>match</code> не делает самостоятельно е ссылки и разыменования, как это делает способ равенства.</p>
<p>Первая ветка совпадает с разделом <code>if</code> из приложения 20-9. Вторая ветка соответствует запросу <em>/sleep</em> . Когда этот запрос получен, сервер заснёт на 5 секунд, прежде чем отдать успешную HTML-страницу. Третья ветка совпадает с разделом <code>else</code> из приложения 20-9.</p>
<p>Можно увидеть, насколько примитивен наш сервер: в существующих библиотеках распознавание разных запросов осуществлялось бы гораздо менее многословно!</p>
<p>Запустите сервер приказом <code>cargo run</code>. Затем откройте два окна браузера: одно с адресом <em>http://127.0.0.1:7878/</em>, другое с <em>http://127.0.0.1:7878/sleep</em>. Если вы несколько раз обратитесь к URI <em>/</em>, то как и раньше увидите, что сервер быстро ответит. Но если вы введёте URI <em>/sleep</em>, а затем загрузите URI <em>/</em>, то увидите что <em>/</em> ждёт, пока <code>/sleep</code> не отработает полные 5 секунд перед загрузкой страницы.</p>
<p>Есть несколько способов, которые можно использовать, чтобы избавиться от подтормаживания запросов после одного медленного запроса; способ, который мы реализуем, называется пулом потоков.</p>
<h3 id="Улучшение-пропускной-способности-с-помощью-пула-потоков"><a class="header" href="#Улучшение-пропускной-способности-с-помощью-пула-потоков">Улучшение пропускной способности с помощью пула потоков</a></h3>
<p><em>Пул потоков</em> является группой заранее порождённых потоков, ожидающих в пуле и готовых выполнить задачу. Когда программа получает новую задачу, она назначает эту задачу одному из потоков в пуле, и тогда задача будет обработана этим потоком. Остальные потоки в пуле доступны для обработки любых других задач, поступающих в то время, пока первый поток занят. Когда первый поток завершает обработку своей задачи, он возвращается в пул свободных потоков, готовых приступить к новой задаче. Пул потоков позволяет обрабатывать соединения параллельно, увеличивая пропускную способность вашего сервера.</p>
<p>Мы ограничим число потоков в пуле небольшим числом, чтобы защитить нас от атак вида «отказ в обслуживании» (DoS - Denial of Service); если бы наша программа создавала новый поток в момент поступления каждого запроса, то кто-то сделавший 10 миллионов запросов к серверу, мог бы создать хаос, использовать все ресурсы нашего сервера и остановить обработку запросов.</p>
<p>Вместо порождения неограниченного количества потоков, у нас будет фиксированное количество потоков, ожидающих в пуле. Поступающие запросы будут отправляться в пул для обработки. Пул будет иметь очередь входящих запросов. Каждый из потоков в пуле будет извлекать запрос из этой очереди, обрабатывать запрос и затем запрашивать в очереди следующий запрос. При таком дизайне мы можем обрабатывать <code>N</code> запросов одновременно, где <code>N</code> - количество потоков. Если каждый поток отвечает на длительный запрос, последующие запросы могут по-прежнему задержаться в очереди, но теперь мы увеличили количество "длинных" запросов, которые мы можем обработать, перед тем, как эта ситуация снова возникнет.</p>
<p>Этот подход - лишь один из многих способов улучшить пропускную способность веб-сервера. Другими вариантами, на которые возможно стоило бы обратить внимание, являются: <em>модель fork/join</em>, <em>модель однопоточного не согласованного ввода-вывода</em> или <em>модель многопоточного не согласованного ввода-вывода</em>. Если вам важна эта тема, вы можете почитать больше сведений о других решениях и попробовать реализовать их самостоятельно. С таким низкоуровневым языком как Rust, любой из этих вариантов осуществим.</p>
<p>Прежде чем приступить к реализации пула потоков, давайте поговорим о том, как должно выглядеть использование пула. Когда вы пытаетесь проектировать код, сначала необходимо написать клиентский внешнюю оболочку. Напишите API кода, чтобы он был структурирован так, как вы хотите его вызывать, затем реализуйте функциональность данной структуры, вместо подхода реализовывать функционал, а затем разрабатывать общедоступный API.</p>
<p>Подобно тому, как мы использовали разработку через тестирование (test-driven) в проекте главы 12, мы будем использовать здесь разработку, управляемую сборщиком (compiler-driven). Мы напишем код, вызывающий нужные нам функции, а затем посмотрим на ошибки сборщика, чтобы определить, что мы должны изменить дальше, чтобы заставить код работать. Однако перед этим, в качестве отправной точки, мы рассмотрим технику, которую мы не будем применять в дальнейшем.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="Порождение-потока-для-каждого-запроса"><a class="header" href="#Порождение-потока-для-каждого-запроса">Порождение потока для каждого запроса</a></h4>
<p>Сначала давайте рассмотрим, как мог бы выглядеть код, если бы он создавал бы новый поток для каждого соединения. Как упоминалось ранее, мы не планируем использовать этот способ в окончательной реализации, из-за возможных проблем при потенциально неограниченном числе порождённых потоков. Это лишь отправная точка, с которой начнёт работу наш многопоточный сервер. Затем мы улучшим код, добавив пул потоков, и тогда разницу между этими двумя решениями будет легче заметить. В приложении 20-11 показаны изменения, которые нужно внести в код <code>main</code>, чтобы порождать новый поток для обработки каждого входящего соединения внутри цикла <code>for</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch20-web-server/listing-20-11/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 20-11: Порождение нового потока для каждого соединения</span></p>
<p>Как вы изучили в главе 16, функция <code>thread::spawn</code> создаст новый поток и затем запустит код замыкания в этом новом потоке. Если вы запустите этот код и загрузите <em>/sleep</em> в своём браузере, а затем загрузите <em>/</em> в двух других вкладках браузера, вы действительно увидите, что запросам к <em>/</em> не приходится ждать завершения <em>/sleep</em>. Но, как мы уже упоминали, это в какой-то момент приведёт к сильному снижению производительности системы, так как вы будете создавать новые потоки без каких-либо ограничений.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="Создание-конечного-числа-потоков"><a class="header" href="#Создание-конечного-числа-потоков">Создание конечного числа потоков</a></h4>
<p>Мы хотим, чтобы наш пул потоков работал подобным, знакомым образом, чтобы переключение с потоков на пул потоков не требовало больших изменений в коде использующем наш API. В приложении 20-12 показан гипотетический внешняя оболочка для структуры <code>ThreadPool</code>, который мы хотим использовать вместо <code>thread::spawn</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/listing-20-12/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-12: Наш наилучший внешняя оболочка <code>ThreadPool</code></span></p>
<p>Мы используем <code>ThreadPool::new</code>, чтобы создать новый пул потоков с конфигурируемым числом потоков, в данном случае четырьмя. Затем в цикле <code>for</code> функция <code>pool.execute</code> имеет внешнюю оболочку, похожий на <code>thread::spawn</code>, в том смысле, что он так же принимает замыкание, код которого пул должен выполнить для каждого соединения. Нам нужно реализовать <code>pool.execute</code>, чтобы он принимал замыкание и передавал его потоку из пула для выполнения. Этот код пока не ссобирается, но мы постараемся, чтобы сборщик помог нам это исправить.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="Создание-threadpool-с-помощью-разработки-управляемой-сборщиком"><a class="header" href="#Создание-threadpool-с-помощью-разработки-управляемой-сборщиком">Создание <code>ThreadPool</code> с помощью разработки, управляемой сборщиком</a></h4>
<p>Внесите изменения приложения 20-12 в файл <em>src/main.rs</em>, а затем давайте воспользуемся ошибками сборщика из приказы <code>cargo check</code> для управления нашей разработкой. Вот первая ошибка, которую мы получаем:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/listing-20-12/output.txt}}
</code></pre>
<p>Замечательно! Ошибка говорит о том, что нам нужен вид или модуль <code>ThreadPool</code>, поэтому мы сейчас его создадим. Наша реализация <code>ThreadPool</code> не будет зависеть от того, что делает наш веб-сервер. Итак, давайте переделаем крейт <code>hello</code> из двоичного в библиотечный, чтобы хранить там нашу реализацию <code>ThreadPool</code>. После того, как мы переключимся в библиотечный крейт, мы также сможем использовать отдельную библиотеку пула потоков для любой подходящей работы, а не только для обслуживания веб-запросов.</p>
<p>Создайте файл <em>src/lib.rs</em>, который содержит следующий код, который является простейшим определением структуры <code>ThreadPool</code>, которое мы можем иметь на данный момент:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/src/lib.rs}}</code></pre>
<p>Затем изменените файл <em>main.rs</em>, чтобы внести <code>ThreadPool</code>  из библиотечного крейта в текущую область видимости, добавив следующий код в начало <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/src/main.rs:here}}</code></pre>
<p>Этот код по-прежнему не будет работать, но давайте проверим его ещё раз, чтобы получить следующую ошибку, которую нам нужно устранить:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/output.txt}}
</code></pre>
<p>Эта ошибка указывает, что далее нам нужно создать ассоциированную функцию с именем <code>new</code> для <code>ThreadPool</code>. Мы также знаем, что <code>new</code> должна иметь один свойство, который может принимать <code>4</code> в качестве переменной и должен возвращать экземпляр <code>ThreadPool</code>. Давайте реализуем простейшую функцию <code>new</code>, которая будет иметь эти характеристики:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/src/lib.rs}}</code></pre>
<p>Мы выбираем <code>usize</code> в качестве вида свойства <code>size</code>, потому что мы знаем, что отрицательное число потоков не имеет никакого смысла. Мы также знаем, что мы будем использовать число 4 в качестве количества элементов в собрания потоков, для чего предназначен вид <code>usize</code>, как обсуждалось в разделе <a href="ch03-02-data-types.html#integer-types">"Целочисленные виды"</a><!--  --> главы 3.</p>
<p>Давайте проверим код ещё раз:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/output.txt}}
</code></pre>
<p>Теперь мы ошибка возникает из-за того, что у нас нет способа <code>execute</code> в структуре <code>ThreadPool</code>. Вспомните раздел <a href="ch20-02-multithreaded.html#creating-a-finite-number-of-threads">"Создание конечного числа потоков"</a><!-- ignore -->, в котором мы решили, что наш пул потоков должен иметь внешнюю оболочку, похожий на <code>thread::spawn</code>. Кроме того, мы реализуем функцию <code>execute</code>, чтобы она принимала замыкание и передавала его свободному потоку из пула для запуска.</p>
<p>Мы определим способ <code>execute</code> у <code>ThreadPool</code>, принимающий замыкание в качестве свойства. Вспомните из раздела <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">"Перемещение захваченных значений из замыканий и трейты <code>Fn</code>"</a> <!-- ignore --> главы 13 сведения о том, что мы можем принимать замыкания в качестве свойств тремя различными типажами: <code>Fn</code> , <code>FnMut</code> и <code>FnOnce</code>. Нам нужно решить, какой вид замыкания использовать здесь. Мы знаем, что в конечном счёте мы сделаем что-то похожее на реализацию встроенной библиотеки <code>thread::spawn</code>, поэтому мы можем посмотреть, какие ограничения накладывает на свой свойство сигнатура функции <code>thread::spawn</code>. Документация показывает следующее:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Свойство вида <code>F</code> - это как раз то, что нас важно; свойство вида <code>T</code> относится к возвращаемому значению и нам он не важен. Можно увидеть, что <code>spawn</code> использует <code>FnOnce</code> в качестве ограничения типажа у <code>F</code>. Возможно это как раз то, чего мы хотим, так как в конечном итоге мы передадим полученный в <code>execute</code> переменная в функцию <code>spawn</code>. Дополнительную уверенность в том, что <code>FnOnce</code> - это именно тот типаж, который мы хотим использовать, нам даёт факт, что поток для выполнения запроса будет выполнять замыкание этого запроса только один раз, что соответствует части  <code>Once</code> ("единожды") в названии типажа <code>FnOnce</code>.</p>
<p>Свойство вида <code>F</code> также имеет ограничение типажа <code>Send</code> и ограничение времени жизни <code>'static</code>, которые полезны в нашей ситуации: нам нужен <code>Send</code> для передачи замыкания из одного потока в другой и <code>'static</code>, потому что мы не знаем, сколько времени поток будет выполняться. Давайте создадим способ <code>execute</code> для <code>ThreadPool</code>, который будет принимать обобщённый свойство вида <code>F</code> со следующими ограничениями:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/no-listing-03-define-execute/src/lib.rs:here}}</code></pre>
<p>Мы по-прежнему используем <code>()</code> после <code>FnOnce</code> потому что типаж <code>FnOnce</code> представляет замыкание, которое не принимает свойств и возвращает единичный вид <code>()</code>. Также как и при определении функций, вид возвращаемого значения в сигнатуре может быть опущен, но даже если у нас нет свойств, нам все равно нужны скобки.</p>
<p>Опять же, это самая простая реализация способа <code>execute</code>: она ничего не делает, мы просто пытаемся сделать код собираемым. Давайте проверим снова:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/no-listing-03-define-execute/output.txt}}
</code></pre>
<p>Сейчас мы получаем только предупреждения, что означает, что код собирается! Но обратите внимание, если вы попробуете <code>cargo run</code> и сделаете запрос в браузере, вы увидите ошибки в браузере, которые мы видели в начале главы. Наша библиотека на самом деле ещё не вызывает замыкание, переданное в <code>execute</code>!</p>
<blockquote>
<p>Примечание: вы возможно слышали высказывание о языках со строгими сборщиками, таких как Haskell и Rust, которое звучит так: «Если код собирается, то он работает». Но это высказывание не всегда верно. Наш проект собирается, но абсолютно ничего не делает! Если бы мы создавали существующий, законченный проект, это был бы хороший момент начать писать модульные тесты, чтобы проверять, что код собирается <em>и</em> имеет желаемое поведение.</p>
</blockquote>
<h4 id="Проверка-количества-потоков-в-new"><a class="header" href="#Проверка-количества-потоков-в-new">Проверка количества потоков в <code>new</code></a></h4>
<p>Мы ничего не делаем с свойствами <code>new</code> и <code>execute</code>. Давайте реализуем тела этих функций с нужным нам поведением. Для начала давайте подумаем о <code>new</code>. Ранее мы выбрали беззнаковый вид для свойства <code>size</code>, потому что пул с отрицательным числом потоков не имеет смысла. Пул с нулём потоков также не имеет смысла, однако ноль - это вполне допустимое значение <code>usize</code>. Мы добавим код для проверки того, что <code>size</code> больше нуля, прежде чем вернуть экземпляр <code>ThreadPool</code>, и заставим программу паниковать, если она получит ноль, используя макрос <code>assert!</code>, как показано в приложении 20-13.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-13/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-13: Реализация <code>ThreadPool::new</code> с аварийным завершениям работы, если <code>size</code> равен нулю</span></p>
<p>Мы добавили немного документации для нашей структуры <code>ThreadPool</code> с помощью комментариев. Обратите внимание, что мы следовали хорошим практикам документирования, добавив раздел, в котором указывается ситуация, при которой функция может аварийно завершаться, как это обсуждалось в главе 14. Попробуйте запустить <code>cargo doc --open</code> и кликнуть на структуру <code>ThreadPool</code>, чтобы увидеть как выглядит сгенерированная документация для <code>new</code>!</p>
<p>Вместо добавления макроса <code>assert!</code>, как мы здесь сделали, мы могли бы преобразовать функцию <code>new</code> в функцию <code>build</code> таким образом, чтобы она возвращала <code>Result</code> , подобно тому, как мы делали в функции <code>Config::new</code> проекта ввода/вывода в приложении 12-9. Но в данном случае мы решили, что попытка создания пула потоков без указания хотя бы одного потока должна быть непоправимой ошибкой. Если вы чувствуете такое стремление, попробуйте написать функцию <code>build</code>  с сигнатурой ниже, для сравнения с функцией <code>new</code>:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="Создание-места-для-хранения-потоков"><a class="header" href="#Создание-места-для-хранения-потоков">Создание места для хранения потоков</a></h4>
<p>Теперь, имея возможность удостовериться, что количество потоков для хранения в пуле соответствует требованиям, мы можем создавать эти потоки и сохранять их в структуре <code>ThreadPool</code> перед тем как возвратить её. Но как мы "сохраним" поток? Давайте ещё раз посмотрим на сигнатуру <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Функция <code>spawn</code> возвращает вид <code>JoinHandle&lt;T&gt;</code>, где <code>T</code> является видом, который возвращает замыкание. Давайте попробуем использовать <code>JoinHandle</code> и посмотрим, что произойдёт. В нашем случае замыкания, которые мы передаём пулу потоков, будут обрабатывать соединение и не будут возвращать ничего, поэтому <code>T</code> будет единичным (unit) видом <code>()</code>.</p>
<p>Код в приложении 20-14 ссобирается, но пока не создаст ни одного потока. Мы изменили определение <code>ThreadPool</code> так, чтобы он содержал вектор экземпляров <code>thread::JoinHandle&lt;()&gt;</code>, инициализировали вектор ёмкостью <code>size</code>, установили цикл <code>for</code>, который будет выполнять некоторый код для создания потоков, и вернули экземпляр <code>ThreadPool</code>, содержащий их.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">{{#rustdoc_include ../listings/ch20-web-server/listing-20-14/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-14: Создание вектора в <code>ThreadPool</code> для хранения потоков</span></p>
<p>Мы включили <code>std::thread</code> в область видимости библиотечного крейта, потому что мы используем <code>thread::JoinHandle</code> в качестве вида элементов вектора в <code>ThreadPool</code>.</p>
<p>После получения корректного значения size, наш <code>ThreadPool</code> создаёт новый вектор, который может содержать <code>size</code> элементов. Функция <code>with_capacity</code> выполняет ту же задачу, что и <code>Vec::new</code>, но с важным отличием: она заранее выделяет необходимый объём памяти в векторе. Поскольку мы знаем, что нам нужно хранить <code>size</code> элементов в векторе, предварительное выделение памяти для этих элементов будет немного более эффективным, чем использование <code>Vec::new</code>, при котором размер вектора будет увеличиваться по мере вставки элементов.</p>
<p>Если вы снова запустите приказ <code>cargo check</code>, она должна завершиться успешно.</p>
<h4 id="Структура-worker-ответственная-за-отправку-кода-из-threadpool-в-поток"><a class="header" href="#Структура-worker-ответственная-за-отправку-кода-из-threadpool-в-поток">Структура <code>Worker</code>, ответственная за отправку кода из <code>ThreadPool</code> в поток</a></h4>
<p>Мы целенаправленно оставили комментарий в цикле <code>for</code> в Приложении 20-14 по поводу создания потоков. Сейчас мы разберёмся, как на самом деле создаются потоки. Стандартная библиотека предоставляет <code>thread::spawn</code> для создания потоков, причём <code>thread::spawn</code> ожидает получить некоторый код, который поток должен выполнить, как только он будет создан. Однако в нашем случае мы хотим создавать потоки и заставлять их <em>ожидать</em> код, который мы будем передавать им позже. Реализация потоков в встроенной библиотеке не предоставляет никакого способа сделать это, мы должны реализовать это вручную.</p>
<p>Мы будем реализовывать это поведение, добавив новую структуру данных между <code>ThreadPool</code> и потоками, которая будет управлять этим новым поведением. Мы назовём эту структуру <code>Worker</code> ("работник"), это общепринятое имя в реализации пулов. Работник берёт код, который нужно выполнить, и запускает этот код внутри рабочего потока. Представьте людей, работающих на кухне ресторана: работники ожидают, пока не поступят заказы от клиентов, а затем они несут ответственность за принятие этих заказов и их выполнение.</p>
<p>Вместо того чтобы хранить вектор экземпляров <code>JoinHandle&lt;()&gt;</code> в пуле потоков, мы будем хранить экземпляры структуры <code>Worker</code>. Каждый <code>Worker</code> будет хранить один экземпляр <code>JoinHandle&lt;()&gt;</code>. Затем мы реализуем способ у <code>Worker</code>, который будет принимать замыкание и отправлять его в существующий поток для выполнения. Для того чтобы мы могли различать работники в пуле при логировании или отладке, мы также присвоим каждому работнику <code>id</code>.</p>
<p>Вот как выглядит новая последовательность действий, которые будут происходить при создании <code>ThreadPool</code>. Мы реализуем код, который будет отправлять замыкание в поток, после того, как у нас будет <code>Worker</code> , заданный следующим образом:</p>
<ol>
<li>Определим структуру <code>Worker</code>, которая содержит <code>id</code> и <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Изменим <code>ThreadPool</code>, чтобы он содержал вектор экземпляров <code>Worker</code>.</li>
<li>Определим функцию <code>Worker::new</code>, которая принимает номер <code>id</code> и возвращает экземпляр <code>Worker</code>, который содержит <code>id</code> и поток, порождённый с пустым замыканием.</li>
<li>В <code>ThreadPool::new</code> используем счётчик цикла <code>for</code> для генерации <code>id</code>, создаём новый <code>Worker</code> с этим <code>id</code> и сохраняем экземпляр "работника" в вектор.</li>
</ol>
<p>Если вы готовы принять вызов, попробуйте реализовать эти изменения самостоятельно, не глядя на код в приложении 20-15.</p>
<p>Готовы? Вот приложение 20-15 с одним из способов сделать указанные ранее изменения.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-15/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-15: Изменение <code>ThreadPool</code> для хранения экземпляров <code>Worker</code> вместо непосредственного хранения потоков</span></p>
<p>Мы изменили название поля в <code>ThreadPool</code> с <code>threads</code> на <code>workers</code>, поскольку теперь оно содержит экземпляры <code>Worker</code> вместо экземпляров <code>JoinHandle&lt;()&gt;</code>. Мы используем счётчик в цикле <code>for</code> для передачи цифрового определителя в качестве переменной <code>Worker::new</code>, и сохраняем каждый новый <code>Worker</code> в векторе с именем <code>workers</code>.</p>
<p>Внешний код (вроде нашего сервера в <em>src/bin/main.rs</em>) не обязательно должен знать подробности реализации, касающиеся использования структуры <code>Worker</code> внутри <code>ThreadPool</code>, поэтому мы делаем структуру <code>Worker</code> и её функцию <code>new</code> приватными. Функция <code>Worker::new</code> использует заданный нами <code>id</code> и сохраняет экземпляр <code>JoinHandle&lt;()&gt;</code>, который создаётся при порождении нового потока с пустым замыканием.</p>
<blockquote>
<p>Примечание: Если операционная система не может создать поток из-за нехватки системных ресурсов, <code>thread::spawn</code> аварийно завершится. Это приведёт к аварийному завершению нашего сервера целиком, даже если некоторые потоки были созданы успешно. Для простоты будем считать, что нас устраивает такое поведение, но в существующей реализации пула потоков вы, вероятно, захотите использовать <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> и его способ <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore -->, который вместо этого возвращает <code>Result</code> .</p>
</blockquote>
<p>Этот код ссобирается и будет хранить количество экземпляров <code>Worker</code>, которое мы указали в качестве переменной функции <code>ThreadPool::new</code>. Но мы всё <em>ещё</em> не обрабатываем замыкание, которое мы получаем в способе <code>execute</code>. Давайте посмотрим, как это сделать далее.</p>
<h4 id="Отправка-запросов-в-потоки-через-потоки"><a class="header" href="#Отправка-запросов-в-потоки-через-потоки">Отправка запросов в потоки через потоки</a></h4>
<p>Следующая проблема, с которой мы будем бороться, заключается в том, что замыкания, переданные в <code>thread::spawn</code> абсолютно ничего не делают. Сейчас мы получаем замыкание, которое хотим выполнить, в способе <code>execute</code>. Но мы должны передать какое-то замыкание в способ <code>thread::spawn</code>, при создании каждого <code>Worker</code>  во время создания <code>ThreadPool</code>.</p>
<p>Мы хотим, чтобы вновь созданные структуры <code>Worker</code> извлекали код для запуска из очереди, хранящейся в <code>ThreadPool</code> и отправляли этот код в свой поток для выполнения.</p>
<p>потоки (channels), простой способ коммуникации между двумя потоками, с которыми мы познакомились в главе 16, кажется наилучше подойдут для этого сценария. Мы будем использовать поток в качестве очереди заданий, а приказ <code>execute</code> отправит задание из <code>ThreadPool</code> экземплярам <code>Worker</code>, которые будут отправлять задание в свой поток. План таков:</p>
<ol>
<li><code>ThreadPool</code> создаст поток и будет хранить отправитель.</li>
<li>Каждый <code>Worker</code> будет хранить приёмник.</li>
<li>Мы создадим новую структуру <code>Job</code>, которая будет хранить замыкания, которые мы хотим отправить в поток.</li>
<li>Способ <code>execute</code> отправит задание, которое он хочет выполнить, в отправляющую сторону потока.</li>
<li>В своём потоке <code>Worker</code> будет циклически опрашивать принимающую сторону потока и выполнять замыкание любого задания, которое он получит.</li>
</ol>
<p>Давайте начнём с создания потока в <code>ThreadPool::new</code> и удержания отправляющей стороны в экземпляре <code>ThreadPool</code>, как показано в приложении 20-16. В структуре <code>Job</code> сейчас ничего не содержится, но это будет вид элемента, который мы отправляем в поток.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-16/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-16: Модификация <code>ThreadPool</code> для хранения отправляющей части потока, который отправляет экземпляры <code>Job</code></span></p>
<p>В <code>ThreadPool::new</code> мы создаём наш новый поток и сохраняем в пуле его отправляющую сторону. Код успешно ссобирается.</p>
<p>Давайте попробуем передавать принимающую сторону потока каждому "работнику" (структуре Worker), когда пул потоков создаёт поток. Мы знаем, что хотим использовать получающую часть потока в потоке, порождаемым "работником", поэтому мы будем ссылаться на свойство <code>receiver</code> в замыкании. Код 20-17 пока не собирается.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/listing-20-17/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-17: Передача принимающей части потока "работникам"</span></p>
<p>Мы внесли несколько небольших и простых изменений: мы передаём принимающую часть потока в <code>Worker::new</code>, а затем используем его внутри замыкания.</p>
<p>При попытке проверить код, мы получаем ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/listing-20-17/output.txt}}
</code></pre>
<p>Код пытается передать <code>receiver</code> нескольким экземплярам <code>Worker</code>. Это не сработает, поскольку, как вы можете помнить из главы 16: реализация потока, которую предоставляет Rust - несколько <em>производителей</em>, один <em>потребитель</em>. Это означает, что мы не можем просто клонировать принимающую сторону потока, чтобы исправить этот код. Кроме этого, мы не хотим отправлять одно и то же сообщение нескольким потребителям, поэтому нам нужен единый список сообщений для множества обработчиков, чтобы каждое сообщение обрабатывалось лишь один раз.</p>
<p>Кроме того, удаление задачи из очереди потока включает изменение <code>receiver</code>, поэтому потокам необходим безопасный способ делиться и изменять <code>receiver</code>, в противном случае мы можем получить условия гонки (как описано в главе 16).</p>
<p>Вспомните умные указатели, которые обсуждались в главе 16: чтобы делиться владением между несколькими потоками и разрешать потокам изменять значение, нам нужно использовать вид <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Вид <code>Arc</code> позволит нескольким "работникам" владеть получателем (receiver), а <code>Mutex</code> заверяет что только один "работник" сможет получить задание (job) от получателя за раз. Приложение 20-18 показывает изменения, которые мы должны сделать.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-18/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-18. Совместное использование приёмника в "работниках" с применением <code>Arc</code> и <code>Mutex</code></span></p>
<p>В <code>ThreadPool::new</code> мы помещаем принимающую сторону потока внутрь <code>Arc</code> и <code>Mutex</code>. Для каждого нового "работника" мы клонируем <code>Arc</code>, чтобы увеличить счётчик ссылок так, что "работники" могут разделять владение принимающей стороной потока.</p>
<p>С этими изменениями код собирается! Мы подбираемся к цели!</p>
<h4 id="Реализация-способа-execute"><a class="header" href="#Реализация-способа-execute">Реализация способа <code>execute</code></a></h4>
<p>Давайте реализуем наконец способ <code>execute</code> у структуры <code>ThreadPool</code>. Мы также изменим вид <code>Job</code> со структуры на псевдоним вида для типаж-объекта, который будет содержать вид замыкания, принимаемый способом <code>execute</code>. Как описано в разделе <a href="ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">"Создание синонимов вида с помощью псевдонимов типа"</a><!-- ignore --> главы 19, псевдонимы видов позволяют делать длинные виды короче, облегчая их использование. Посмотрите на приложение 20-19.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-19/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-19: Создание псевдонима вида <code>Job</code> для указателя <code>Box</code>, содержащего каждое замыкание и затем отправляющее задание (job) в поток</span></p>
<p>После создания нового экземпляра <code>Job</code> с замыканием, полученным в <code>execute</code>, мы посылаем его через отправляющий конец потока. На тот случай, если отправка не удастся, вызываем <code>unwrap</code> у <code>send</code>. Это может произойти, например, если мы остановим выполнение всех наших потоков, что означает, что принимающая сторона прекратила получать новые сообщения. На данный момент мы не можем остановить выполнение наших потоков: наши потоки будут функционировать до тех пор, пока существует пул. Причина, по которой мы используем <code>unwrap</code>, заключается в том, что, хотя мы знаем, что сбой не произойдёт, сборщик этого не знает.</p>
<p>Но мы ещё не закончили! В "работнике" (worker) наше замыкание, переданное в <code>thread::spawn</code> все ещё <em>ссылается</em> только на принимающую сторону потока. Вместо этого нам нужно, чтобы замыкание работало в бесконечном цикле, запрашивая задание у принимающей части потока и выполняя задание, когда оно принято. Давайте внесём изменения, показанные в приложении 20-20 внутри <code>Worker::new</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-20/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-20: Получение и выполнение заданий в потоке "работника"</span></p>
<p>Здесь мы сначала вызываем <code>lock</code> у <code>receiver</code>, чтобы получить мьютекс, а затем вызываем <code>unwrap</code>, чтобы аварийно завершить работу при любых ошибках. Захват блокировки может завершиться неудачей, если мьютекс находится в <em>отравленном</em> состоянии (poisoned state), что может произойти, если какой-то другой поток завершился аварийно, удерживая блокировку, вместо снятия блокировки. В этой ситуации вызвать <code>unwrap</code> для аварийного завершения потока вполне оправдано. Не стесняйтесь заменить <code>unwrap</code> на <code>expect</code> с сообщением об ошибке, которое имеет для вас значение.</p>
<p>Если мы получили блокировку мьютекса, мы вызываем <code>recv</code>, чтобы получить <code>Job</code> из потока. Последний вызов <code>unwrap</code> позволяет миновать любые ошибки, которые могут возникнуть, если поток, управляющий отправитель, прекратил функционировать, подобно тому, как способ <code>send</code> возвращает <code>Err</code>, если получатель не принимает сообщение.</p>
<p>Вызов <code>recv</code> - блокирующий, поэтому пока задач нет, текущий поток будет ждать, пока задача не появится. <code>Mutex&lt;T&gt;</code> заверяет, что только один поток <code>Worker</code> за раз попытается запросить задачу.</p>
<p>Наш пул потоков теперь находится в рабочем состоянии! Выполните <code>cargo run</code> и сделайте несколько запросов:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Успех! Теперь у нас есть пул потоков, который обрабатывает соединения не согласованно. Никогда не создаётся более четырёх потоков, поэтому наша система не будет перегружена, если сервер получит много запросов. Если мы отправим запрос ресурса <em>/sleep</em>, сервер сможет обслуживать другие запросы, обрабатывая их в другом потоке.</p>
<blockquote>
<p>Примечание: если вы запросите <em>/sleep</em> в нескольких окнах браузера одновременно, они могут загружаться по одному, с интервалами в 5 секунд. Некоторые веб-браузеры выполняют несколько экземпляров одного и того же запроса последовательно из-за кэширования. Такое ограничение не связано с работой нашего веб-сервера.</p>
</blockquote>
<p>После изучения цикла <code>while let</code> в главе 18 вы можете удивиться, почему мы не написали код рабочего потока (worker thread), как показано в приложении 20-22.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">{{#rustdoc_include ../listings/ch20-web-server/listing-20-21/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-22: Иная реализация <code>Worker::new</code> с использованием <code>while let</code></span></p>
<p>Этот код собирается и запускается, но не даёт желаемого поведения: медленный запрос всё равно приведёт к тому, что другие запросы будут ждать обработки. Причина здесь несколько тоньше: структура <code>Mutex</code> не имеет публичного способа <code>unlock</code>, так как владение блокировкой основано на времени жизни <code>MutexGuard&lt;T&gt;</code> внутри <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>, которое возвращает способ <code>lock</code>. Во время сборки анализатор заимствований может проследить за выполнением правила, согласно которому к ресурсу, охраняемому <code>Mutex</code>, нельзя получить доступ пока мы удерживаем блокировку. Однако в этой реализация мы также можем получить ситуацию, когда блокировка будет удерживаться дольше, чем предполагалось, если мы не будем внимательно учитывать время жизни <code>MutexGuard&lt;T&gt;</code>.</p>
<p>Код в приложении 20-20, использующий <code>let job = receiver.lock().unwrap().recv().unwrap();</code> работает, потому что при использовании <code>let</code> любые промежуточные значения, используемые в выражении справа от знака равенства, немедленно уничтожаются после завершения указания <code>let</code>. Однако <code>while let</code> (и <code>if let</code> и <code>match</code>) не удаляет временные значения до конца связанного раздела. Таким образом, в приложении 20-21 блокировка не снимается в течение всего времени вызова <code>job()</code>, что означает, что другие работники не могут получать задания.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Мягкое-завершение-работы-и-очистка"><a class="header" href="#Мягкое-завершение-работы-и-очистка">Мягкое завершение работы и очистка</a></h2>
<p>Приложение 20-20 не согласованно отвечает на запросы с помощью использования пула потоков, как мы и хотели. Мы получаем некоторые предупреждения про <code>workers</code>, <code>id</code> и поля <code>thread</code>, которые мы не используем напрямую, что напоминает нам о том, что мы не освобождаем все ресурсы. Когда мы используем менее элегантный способ остановки основного потока клавишной сочетанием <span class="keystroke">ctrl-c</span>, все остальные потоки также немедленно останавливаются, даже если они находятся в середине обработки запроса.</p>
<p>Далее, реализуем типаж  <code>Drop</code> для вызова <code>join</code> у каждого потока в пуле, чтобы они могли завершить запросы, над которыми они работают, перед закрытием. Затем мы реализуем способ сообщить потокам, что они должны перестать принимать новые запросы и завершить работу. Чтобы увидеть этот код в действии, мы изменим наш сервер так, чтобы он принимал только два запроса, после чего корректно завершал работу пула потоков.</p>
<h3 id="Реализация-типажа-drop-для-threadpool"><a class="header" href="#Реализация-типажа-drop-для-threadpool">Реализация типажа <code>Drop</code> для <code>ThreadPool</code></a></h3>
<p>Давайте начнём с реализации <code>Drop</code> у нашего пула потоков. Когда пул удаляется, все наши потоки должны объединиться (join), чтобы убедиться, что они завершают свою работу. В приложении 20-22 показана первая попытка реализации <code>Drop</code>, код пока не будет работать.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/listing-20-22/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-22: Присоединение (Joining) каждого потока, когда пул потоков выходит из области видимости</span></p>
<p>Сначала мы пройдёмся по каждому <code>worker</code> из пула потоков. Для этого мы используем <code>&amp;mut</code> с <code>self</code>, потому что нам нужно иметь возможность изменять <code>worker</code>. Для каждого обработчика мы выводим сообщение о том, что он завершает работу, а затем вызываем <code>join</code> у потока этого обработчика. Для случаев, когда вызов <code>join</code> не удался, мы используем <code>unwrap</code>, чтобы заставить Rust запаниковать и перейти в режим грубого завершения работы.</p>
<p>Ошибка получаемая при сборки этого кода:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/listing-20-22/output.txt}}
</code></pre>
<p>Ошибка говорит нам, что мы не можем вызвать <code>join</code>, потому что у нас есть только изменяемое заимствование каждого <code>worker</code>, а <code>join</code> забирает во владение свой переменная. Чтобы решить эту проблему, нам нужно извлечь поток из экземпляра <code>Worker</code>, который владеет <code>thread</code>, чтобы <code>join</code> мог его использовать. Мы сделали это в приложении 17-15: теперь, когда <code>Worker</code> хранит в себе <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, мы можем воспользоваться способом <code>take</code> у <code>Option</code>, чтобы извлечь значение из варианта <code>Some</code>, тем самым оставляя на его месте <code>None</code>. Другими словами, в рабочем состоянии <code>Worker</code> будет использовать вариант <code>Some</code> содержащий <code>thread</code>, а когда мы захотим завершить <code>Worker</code>, мы заменим <code>Some</code> на <code>None</code>, чтобы у <code>Worker</code> не было потока для работы.</p>
<p>Итак, мы хотим обновить объявление <code>Worker</code> следующим образом:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/no-listing-04-update-worker-definition/src/lib.rs:here}}</code></pre>
<p>Теперь давайте опираться на сборщик, чтобы найти другие места, которые нужно изменить. Проверяя код, мы получаем две ошибки:</p>
<pre><code class="language-console">{{#include ../listings/ch20-web-server/no-listing-04-update-worker-definition/output.txt}}
</code></pre>
<p>Давайте обратимся ко второй ошибке, которая указывает на код в конце <code>Worker::new</code>; нам нужно обернуть значение <code>thread</code> в вариант <code>Some</code> при создании нового <code>Worker</code>. Внесите следующие изменения, чтобы исправить эту ошибку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch20-web-server/no-listing-05-fix-worker-new/src/lib.rs:here}}</code></pre>
<p>Первая ошибка находится в нашей реализации <code>Drop</code>. Ранее мы упоминали, что намеревались вызвать <code>take</code> для свойства <code>Option</code>, чтобы забрать <code>thread</code> из процесса <code>worker</code>. Следующие изменения делают это:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">{{#rustdoc_include ../listings/ch20-web-server/no-listing-06-fix-threadpool-drop/src/lib.rs:here}}</code></pre>
<p>Как уже говорилось в главе 17, способ <code>take</code> у вида <code>Option</code> забирает значение из варианта <code>Some</code> и оставляет вариант <code>None</code> в этом месте. Мы используем <code>if let</code>, чтобы деструктурировать <code>Some</code> и получить поток; затем вызываем <code>join</code> у потока. Если поток "работника" уже <code>None</code>, мы знаем, что этот "работник" уже очистил свой поток, поэтому в этом случае ничего не происходит.</p>
<h3 id="Сигнализация-потокам-прекратить-прослушивание-получения-задач"><a class="header" href="#Сигнализация-потокам-прекратить-прослушивание-получения-задач">Сигнализация потокам прекратить прослушивание получения задач</a></h3>
<p>Теперь, после всех внесённых нами изменений, код собирается без каких-либо предупреждений. Но плохая новость в том, что этот код всё ещё не работает так, как мы этого хотим. Причина заключается в логике замыканий, запускаемых потоками экземпляров Worker: в данный момент мы вызываем join, но это не приводит к завершению потоков, так как они находятся в бесконечном цикле, ожидая новую задачу. Если мы попытаемся удалить ThreadPool в текущей реализации drop, основной поток навсегда заблокируется в ожидании завершения первого потока из пула.</p>
<p>Чтобы решить эту проблему, нам нужно будет изменить реализацию <code>drop</code> в <code>ThreadPool</code>, а затем внести изменения в цикл <code>Worker</code> .</p>
<p>Во-первых, изменим реализацию <code>drop</code> <code>ThreadPool</code> таким образом, чтобы явно удалять <code>sender</code> перед тем, как начнём ожидать завершения потоков. В приложении 20-23 показаны изменения в <code>ThreadPool</code> для явного удаления <code>sender</code> . Мы используем ту же технику <code>Option</code> и <code>take</code>, что и с потоком, чтобы переместить <code>sender</code> из <code>ThreadPool</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior">{{#rustdoc_include ../listings/ch20-web-server/listing-20-23/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-23. Явное удаление <code>sender</code> перед ожиданием завершения рабочих потоков</span></p>
<p>Удаление <code>sender</code> закрывает поток, что указывает на то, что сообщения больше не будут отправляться. Когда это произойдёт, все вызовы <code>recv</code>, выполняемые рабочими процессами в бесконечном цикле, вернут ошибку. В приложении 20-24 мы меняем цикл <code>Worker</code> для корректного выхода из него в этом случае, что означает, что потоки завершатся, когда реализация <code>drop</code> <code>ThreadPool</code> вызовет для них <code>join</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/listing-20-24/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 20-24: Явный выход из цикла, когда <code>recv</code> возвращает ошибку</span></p>
<p>Чтобы увидеть этот код в действии, давайте изменим <code>main</code>, чтобы принимать только два запроса, прежде чем корректно завершить работу сервера как показано в приложении 20-25.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch20-web-server/listing-20-25/src/main.rs:here}}</code></pre>
<p><span class="caption">Код 20-25. Выключение сервера после обслуживания двух запросов с помощью выхода из цикла</span></p>
<p>Вы бы не хотели, чтобы существующий веб-сервер отключался после обслуживания только двух запросов. Этот код всего лишь отображает, что корректное завершение работы и освобождение ресурсов находятся в рабочем состоянии.</p>
<p>Способ <code>take</code> определён в типаже <code>Iterator</code> и ограничивает повторение максимум первыми двумя элементами. <code>ThreadPool</code> выйдет из области видимости в конце <code>main</code> и будет запущена его реализация <code>drop</code>.</p>
<p>Запустите сервер с <code>cargo run</code> и сделайте три запроса. Третий запрос должен выдать ошибку и в окне вызова вы должны увидеть вывод, подобный следующему:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Вы возможно увидите другой порядок рабочих потоков и напечатанных сообщений. Мы можем увидеть, как этот код работает по сообщениям: "работники" номер 0 и 3 получили первые два запроса. Сервер прекратил принимать соединения после второго подключения, а реализация <code>Drop</code> для <code>ThreadPool</code> начинает выполняется ещё тогда, когда как работник 3 даже не приступил к выполнению своей работы. Удаление <code>sender</code> отключает все рабочие потоки от потока и просит их завершить работу. Каждый рабочий поток при отключении печатает сообщение, а затем пул потоков вызывает <code>join</code>, чтобы дождаться, пока каждый из рабочих потоков завершится.</p>
<p>Обратите внимание на один важная особенность этого определенного запуска: ThreadPool удалил <code>sender</code>, и прежде чем какой-либо из работников получил ошибку, мы попытались присоединить (join) рабочий поток с номером 0. Рабочий поток 0 ещё не получил ошибку от <code>recv</code>, поэтому основной поток заблокировался, ожидания завершения потока работника 0. Тем временем, работник 3 получил задание, а затем каждый из рабочих потоков получил ошибку. Когда рабочий поток 0 завершился, основной поток ждал окончания завершения выполнения остальных рабочих потоков. В этот момент все они вышли из своих циклов и остановились.</p>
<p>Примите поздравления! Теперь мы завершили проект; у нас есть основной веб-сервер, использующий пул потоков для не согласованных ответов. Мы можем выполнить корректное завершение работы сервера, очистив все потоки в пуле.</p>
<p>Вот полный код для справки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-final-code/src/main.rs}}</code></pre>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-final-code/src/lib.rs}}</code></pre>
<p>Мы могли бы сделать ещё больше! Если вы хотите продолжить совершенствование этого проекта, вот несколько идей:</p>
<ul>
<li>Добавьте больше документации в <code>ThreadPool</code> и его публичные способы.</li>
<li>Добавьте тесты для функционала, реализуемого библиотекой.</li>
<li>Замените вызовы <code>unwrap</code> на более устойчивую обработку ошибок.</li>
<li>Используйте <code>ThreadPool</code> для выполнения некоторых других задач, помимо обслуживания веб-запросов.</li>
<li>На <a href="https://crates.io/">crates.io</a> найдите крейт для работы с пулами потоков и на его основе реализуйте подобный веб-сервер. Затем сравните его API и надёжность с реализованным нами пулом потоков.</li>
</ul>
<h2 id="Итоги-17"><a class="header" href="#Итоги-17">Итоги</a></h2>
<p>Отличная работа! Вы сделали это к концу книги! Мы хотим поблагодарить вас за то, что присоединились к нам в этом путешествии по языку Rust. Теперь вы готовы реализовать свои собственные проекты на Rust и помочь с проектами другим людям. Имейте в виду, что сообщество Rust разработчиков довольно гостеприимно, они с удовольствием постараются помочь вам с любыми трудностями, с которыми вы можете столкнуться в своём путешествии по Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Дополнительная-сведения"><a class="header" href="#Дополнительная-сведения">Дополнительная сведения</a></h1>
<p>Следующие разделы содержат справочные материалы, которые могут оказаться полезными в вашем путешествии по Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приложение-a-Ключевые-слова"><a class="header" href="#Приложение-a-Ключевые-слова">Приложение A: Ключевые слова</a></h2>
<p>Следующий список содержит ключевые слова, зарезервированные для текущего или будущего использования в языке Rust. Как таковые их нельзя использовать в качестве определителей (за исключением сырых определителей, которые мы обсудим в разделе <a href="appendix-01-keywords.html#raw-identifiers">«Сырые определители</a><!-- ignore -->»). Идентификаторы — это имена функций, переменных, свойств, полей структур, модулей, крейтов, констант, макросов, статических значений, атрибутов, видов, свойств или времён жизни.</p>
<h3 id="Используемые-в-настоящее-время-ключевые-слова"><a class="header" href="#Используемые-в-настоящее-время-ключевые-слова">Используемые в настоящее время ключевые слова</a></h3>
<p>Ниже приведён список используемых в настоящее время ключевых слов с их описанием.</p>
<ul>
<li><code>as</code> — выполнить примитивное преобразование, уточнить определенную характеристику, которую содержит объект, или переименовать элемент в выражении <code>use</code></li>
<li><code>async</code> — возврат <code>Future</code> вместо блокировки текущего потока</li>
<li><code>await</code> — остановка выполнения до готовности результата <code>Future</code></li>
<li><code>break</code> — немедленный выход из цикла</li>
<li><code>const</code> — определение константного элемента или неизменяемого сырого указателя</li>
<li><code>continue</code> — досрочный переход к следующей повторения цикла</li>
<li><code>crate</code> — ссылка на корень пакета в пути к модулю</li>
<li><code>dyn</code> — изменяемая отсылка к типажу объекта</li>
<li><code>else</code> — иные  ветви для конструкций управления потока <code>if</code> и <code>if let</code></li>
<li><code>enum</code> — определение перечислений</li>
<li><code>extern</code> — связывание внешней функции или переменной</li>
<li><code>false</code> — логический ложный литерал</li>
<li><code>fn</code> — определение функции или вида указателя на функцию</li>
<li><code>for</code> — циклически перебирать элементы из повторителя, реализовывать признак или указывать время жизни с более высоким рейтингом.</li>
<li><code>if</code> — ветвление на основе результата условного выражения</li>
<li><code>impl</code> — реализация встроенной функциональности или функциональности типажа</li>
<li><code>in</code> — часть синтаксиса цикла <code>for</code></li>
<li><code>let</code> — объявление (связывание) переменной</li>
<li><code>loop</code> — безусловный цикл</li>
<li><code>match</code> — сопоставление значения с шаблонами</li>
<li><code>mod</code> — определение модуля</li>
<li><code>move</code> — перекладывание владения на замыкание всеми захваченными элементами</li>
<li><code>mut</code> — обозначение изменчивости в ссылках, сырах указателей и привязках к шаблону</li>
<li><code>pub</code> — модификатор публичной доступность полей структур, разделов <code>impl</code> и модулей</li>
<li><code>ref</code> — привязка по ссылке</li>
<li><code>return</code> — возвращает результат из функции</li>
<li><code>Self</code> — псевдоним для определяемого или реализуемого вида</li>
<li><code>self</code> — объект текущего способа или модуля</li>
<li><code>static</code> — вездесущая переменная или время жизни, продолжающееся на протяжении всего выполнения программы</li>
<li><code>struct</code> — определение структуры</li>
<li><code>super</code> — родительский модуль текущего модуля</li>
<li><code>trait</code> — определение типажа</li>
<li><code>true</code> — логический истинный литерал</li>
<li><code>type</code> — определение псевдонима вида или связанного вида</li>
<li><code>union</code> - определить <a href="../reference/items/unions.html">объединение</a><!-- ignore -->; является ключевым словом только при использовании в объявлении объединения</li>
<li><code>unsafe</code> — обозначение небезопасного кода, функций, типажей и их реализаций</li>
<li><code>use</code> — ввод имён в область видимости</li>
<li><code>where</code> — ограничение вида</li>
<li><code>while</code> — условный цикл, основанный на результате выражения</li>
</ul>
<h3 id="Ключевые-слова-зарезервированные-для-будущего-использования"><a class="header" href="#Ключевые-слова-зарезервированные-для-будущего-использования">Ключевые слова, зарезервированные для будущего использования</a></h3>
<p>Следующие ключевые слова ещё не имеют никакой функциональности, но зарезервированы Rust для возможного использования в будущем.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="Сырые-определители"><a class="header" href="#Сырые-определители">Сырые определители</a></h3>
<p><em>Сырые определители</em> — это синтаксис, позволяющий использовать ключевые слова там, где обычно они не могут быть. Для создания и использования сырого определителя к ключевому слову добавляется префикс <code>r#</code>.</p>
<p>Например, ключевое слово <code>match</code>. Если вы попытаетесь собрать следующую функцию, использующую в качестве имени <code>match</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>вы получите ошибку:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Ошибка говорит о том, что вы не можете использовать ключевое слово <code>match</code> в качестве определителя функции. Чтобы получить возможность использования слова <code>match</code> в качестве имени функции, нужно использовать синтаксис «сырых определителей», например так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>Этот код ссобирается без ошибок. Обратите внимание, что префикс <code>r#</code> в определении имени функции указан так же, как он указан в месте её вызова в <code>main</code>.</p>
<p>Сырые определители позволяют вам использовать любое слово, которое вы выберете, в качестве определителя, даже если это слово окажется зарезервированным ключевым словом. Это даёт нам больше свободы в выборе имён определителей, а также позволяет нам встраиваться с программами, написанными на языке, где эти слова не являются ключевыми. Кроме того, необработанные определители позволяют вам использовать библиотеки, написанные в исполнения Rust, отличной от используемой в вашем крейте. Например, <code>try</code> не является ключевым словом в выпуске 2015 года, но является в выпуске 2018 года. Если вы зависите от библиотеки, написанной с использованием исполнения 2015 года и имеющей функцию <code>try</code>, вам потребуется использовать синтаксис сырого определителя, в данном случае <code>r#try</code>, для вызова этой функции из кода исполнения 2018 года. См. <a href="appendix-05-editions.html">Приложение E</a><!-- ignore --> для получения дополнительной сведений о изданиех Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-Б-Операторы-и-обозначения"><a class="header" href="#Дополнение-Б-Операторы-и-обозначения">Дополнение Б: Операторы и обозначения</a></h2>
<p>Это дополнение содержит глоссарий синтаксиса Rust, включая операторы и другие обозначения, которые появляются сами по себе или в среде путей, обобщений, типажей, макросов, атрибутов, комментариев, кортежей и скобок.</p>
<h3 id="Операторы"><a class="header" href="#Операторы">Операторы</a></h3>
<p>Таблица Б-1 содержит операторы языка Rust, пример появления оператора, короткое объяснение, возможность перегрузки оператора. Если оператор можно перегрузить, то показан типаж, с помощью которого его можно перегрузить.</p>
<p><span class="caption">Таблица Б-1: Операторы</span></p>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Пример</th><th>Объяснение</th><th>Перегружаемость</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Вызов макроса</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Побитовое или логическое отрицание</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Сравнение "не равно"</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Остаток от деления</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Остаток от деления и присваивание</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Заимствование</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Указывает что данный вид заимствуется</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Побитовое И</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Побитовое И и присваивание</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Логическое И</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Арифметическое умножение</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Арифметическое умножение и присваивание</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Разыменование ссылки</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Указывает, что данный вид является сырым указателем</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Соединение ограничений вида</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Арифметическое сложение</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Арифметическое сложение и присваивание</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Разделитель переменных и элементов</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Арифметическое отрицание</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Арифметическое вычитание</td><td><code>Sub</code></td></tr>
<tr><td><code>-</code></td><td><code>var -= expr</code></td><td>Арифметическое вычитание и присваивание</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>&amp;vert;...&amp;vert; -&gt; type</code></td><td>...</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Доступ к элементу</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Указывает на рядчисел, исключая правый</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Указывает на рядчисел, включая правый</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Синтаксис обновления структуры</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Привязка «И все остальное»</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Устарело, используйте новый синтаксис <code>..=</code>) Используется при определении инклюзивного ряда</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Арифметическое деление</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Арифметическое деление и присваивание</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Ограничения видов</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Объявление поля структуры</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Метка цикла</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Признак конца указания и элемента</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Часть синтаксиса массива фиксированного размера</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Битовый сдвиг влево</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Битовый сдвиг влево и присваивание</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Сравнение "меньше чем"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Сравнение "меньше или равно"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Присваивание/эквивалентность</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Сравнение "равно"</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Часть синтаксиса конструкции match</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Сравнение "больше чем"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Сравнение "больше или равно"</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Битовый сдвиг вправо</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Битовый сдвиг вправо и присваивание</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Побитовое исключающее ИЛИ</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Побитовое исключающее ИЛИ и присваивание</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>&amp;vert;</code></td><td><code>pat &amp;vert; pat</code></td><td>Иные шаблоны</td><td></td></tr>
<tr><td><code>&amp;vert;</code></td><td><code>expr &amp;vert; expr</code></td><td>Побитовое ИЛИ</td><td><code>BitOr</code></td></tr>
<tr><td><code>&amp;vert;=</code></td><td><code>var &amp;vert;= expr</code></td><td>Побитовое ИЛИ и присваивание</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>&amp;vert;&amp;vert;</code></td><td><code>expr &amp;vert;&amp;vert; expr</code></td><td>Короткое логическое ИЛИ</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Возврат ошибки</td><td></td></tr>
</tbody></table>
</div>
<h3 id="Обозначения-не-операторы"><a class="header" href="#Обозначения-не-операторы">Обозначения не-операторы</a></h3>
<p>Следующий список содержит все символы, которые не работают как операторы; то есть они не ведут себя как вызов функции или способа.</p>
<p>Таблица Б-2 показывает символы, которые появляются сами по себе и допустимы в различных местах.</p>
<p><span class="caption">Таблица Б-2: Автономный синтаксис</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Именованное время жизни или метка цикла</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Числовой литерал определённого вида</td></tr>
<tr><td><code>"..."</code></td><td>Строковый литерал</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code>, etc.</td><td>Необработанный строковый литерал, в котором не обрабатываются escape-символы</td></tr>
<tr><td><code>b"..."</code></td><td>Строковый литерал байтов; создаёт массив байтов вместо строки</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>, etc.</td><td>Необработанный строковый байтовый литерал, сочетание необработанного и байтового литерала</td></tr>
<tr><td><code>'...'</code></td><td>Символьный литерал</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII байтовый литерал</td></tr>
<tr><td><code>&amp;vert;...&amp;vert; expr</code></td><td>Замыкание</td></tr>
<tr><td><code>!</code></td><td>Всегда пустой вид для расходящихся функций</td></tr>
<tr><td><code>_</code></td><td>«Пренебрегаемое» связывание шаблонов; также используется для читабельности целочисленных литералов</td></tr>
</tbody></table>
</div>
<p>Таблица Б-3 показывает обозначения которые появляются в среде путей упорядочевания модулей</p>
<p><span class="caption">Таблица Б-3. Синтаксис, связанный с путями</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Путь к пространству имён</td></tr>
<tr><td><code>::path</code></td><td>Путь относительно корня крейта (т. е. явный абсолютный путь)</td></tr>
<tr><td><code>self::path</code></td><td>Путь относительно текущего модуля (т. е. явный относительный путь).</td></tr>
<tr><td><code>super::path</code></td><td>Путь относительно родительского модуля текущего модуля</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Ассоциированные константы, функции и виды</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Ассоциированный элемент для вида, который не может быть назван прямо (например <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Устранение неоднозначности вызова способа путём именования типажа, который определяет его</td></tr>
<tr><td><code>type::method(...)</code></td><td>Устранение неоднозначности путём вызова способа через имя вида, для которого он определён</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Устранение неоднозначности вызова способа путём именования типажа и вида</td></tr>
</tbody></table>
</div>
<p>Таблица Б-4 показывает обозначения которые появляются в среде использования обобщённых видов свойств</p>
<p><span class="caption">Таблица Б-4: Обобщения</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Определяет свойства для обобщённых свойств в виде (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Определяет свойства для обобщённых свойств, функций, или способов в выражении. Часто называют turbofish (например <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Определение обобщённой функции</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Определение обобщённой структуры</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Объявление обобщённого перечисления</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Определение обобщённой реализации</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Высокоуровневое связывание времени жизни</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Обобщённый вид где один или более ассоциированных видов имеют определённое присваивание (например <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Таблица Б-5 показывает обозначения которые появляются в среде использования обобщённых видов свойств с ограничениями видов</p>
<p><span class="caption">Таблица Б-5: Ограничения видов</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Обобщённый свойство <code>T</code> ограничивается до видов которые реализуют типаж <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Обобщённый вид <code>T</code> должен существовать не меньше чем <code>'a</code> (то есть вид не может иметь ссылки с временем жизни меньше чем <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Обобщённый вид <code>T</code> не имеет заимствованных ссылок кроме имеющих время жизни <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>Обобщённое время жизни <code>'b</code> должно быть не меньше чем <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Позволяет обобщённым видам свойства иметь изменяемый размер</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Соединение ограничений видов</td></tr>
</tbody></table>
</div>
<p>Таблица Б-6 показывает обозначения, которые появляются в среде вызова или определения макросов и указания атрибутов элемента.</p>
<p><span class="caption">Таблица Б-6: Макросы и атрибуты</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Внешний атрибут</td></tr>
<tr><td><code>#![meta]</code></td><td>Внутренний атрибут</td></tr>
<tr><td><code>$ident</code></td><td>Подстановка в макросе</td></tr>
<tr><td><code>$ident:kind</code></td><td>Захват макроса</td></tr>
<tr><td><code>$(…)…</code></td><td>Повторение макроса</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Вызов макроса</td></tr>
</tbody></table>
</div>
<p>Таблица Б-7 показывает обозначения, которые создают комментарии.</p>
<p><span class="caption">Таблица Б-7: Комментарии</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Однострочный комментарий</td></tr>
<tr><td><code>//!</code></td><td>Внутренний однострочный комментарий документации</td></tr>
<tr><td><code>///</code></td><td>Внешний однострочный комментарий документации</td></tr>
<tr><td><code>/*...*/</code></td><td>Многострочный комментарий</td></tr>
<tr><td><code>/*!...*/</code></td><td>Внутренний многострочный комментарий документации</td></tr>
<tr><td><code>/**...*/</code></td><td>Внешний многострочный комментарий документации</td></tr>
</tbody></table>
</div>
<p>Таблица Б-8 показывает обозначения, которые появляются в среде использования кортежей.</p>
<p><span class="caption">Таблица Б-8: Кортежи</span></p>
<div class="table-wrapper"><table><thead><tr><th>Обозначение</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Пустой кортеж, он же пустой вид. И литерал и вид.</td></tr>
<tr><td><code>(expr)</code></td><td>Выражение в скобках</td></tr>
<tr><td><code>(expr,)</code></td><td>Кортеж с одним элементом выражения</td></tr>
<tr><td><code>(type,)</code></td><td>Кортеж с одним элементом вида</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Выражение кортежа</td></tr>
<tr><td><code>(type, ...)</code></td><td>Вид кортежа</td></tr>
<tr><td><code>(type, ...)</code></td><td>Выражение вызова функции; также используется для объявления структур-кортежей и вариантов-кортежей перечисления</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Взятие элемента по порядковому указателю в кортеже</td></tr>
</tbody></table>
</div>
<p>Таблица Б-9 показывает среды, в которых используются фигурные скобки.</p>
<p><span class="caption">Таблица Б-9: Фигурные скобки</span></p>
<div class="table-wrapper"><table><thead><tr><th>Среда</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Выражение раздела</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> литерал</td></tr>
</tbody></table>
</div>
<p>Таблица Б-10 показывает среды, в которых используются квадратные скобки.</p>
<p><span class="caption">Таблица Б-10: Квадратные скобки</span></p>
<div class="table-wrapper"><table><thead><tr><th>Среда</th><th>Объяснение</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Литерал массива</td></tr>
<tr><td><code>[expr; len]</code></td><td>Литерал массива, содержащий <code>len</code> копий <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Массив, содержащий <code>len</code> экземпляров вида <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Взятие по порядковому указателю в собрания. Возможна перегрузка (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Взятие среза собрания по порядковому казателю, используется <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, или <code>RangeFull</code> как "порядковый указатель"</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-В-Выводимые-типажи"><a class="header" href="#Дополнение-В-Выводимые-типажи">Дополнение В: Выводимые типажи</a></h2>
<p>Во многих частях книги мы обсуждали атрибут <code>derive</code>, которые Вы могли применить к объявлению структуры или перечисления. Атрибут <code>derive</code> генерирует код по умолчанию для реализации типажа, который вы указали в  <code>derive</code>.</p>
<p>В этом дополнении, мы расскажем про все типажи, которые вы можете использовать в атрибуте <code>derive</code>. Каждая секция содержит:</p>
<ul>
<li>Действия и методы, добавляемые типажом</li>
<li>Как представлена реализация типажа через <code>derive</code></li>
<li>Что реализация типажа рассказывает про вид</li>
<li>Условия, в которых разрешено или запрещено реализовывать типаж</li>
<li>Примеры ситуаций, которые требуют наличие типажа</li>
</ul>
<p>Если Вам понадобилось поведение отличное от поведения при реализации через <code>derive</code>, обратитесь к <a href="../std/index.html">документации по встроенной библиотеке</a><!-- ignore --> чтобы узнать как вручную реализовать типаж.</p>
<p>Перечисленные здесь типажи являются единственными, определёнными встроенной библиотекой, которые могут быть реализованы в ваших видах с помощью <code>derive</code>. Другие типажи, определённые в встроенной библиотеке, не имеют ощутимого поведения по умолчанию, поэтому вам решать, как реализовать их для достижения ваших целей.</p>
<p>Пример типажа, который нельзя реализовать через derive - <code>Display</code>, который обрабатывает форматирование для конечных пользователей. Вы всегда должны сами рассмотреть лучший способ для отображения вида конечному пользователю. Какие части вида должны быть разрешены для просмотра конечному пользователю? Какие части они найдут подходящими? Какой формат вывода для них будет самым подходящим? Сборщик Rust не знает ответы на эти вопросы, поэтому он не может подобрать подходящее стандартное поведение.</p>
<p>Список видов, реализуемых через derive, в этом дополнении не является исчерпывающим: библиотеки могут реализовывать <code>derive</code> для их собственных типажей, составляя свои списки типажей, которые Вы можете использовать с помощью <code>derive</code>. Реализация <code>derive</code> включает в себя использование процедурных макросов, которые были рассмотрены в разделе <a href="ch19-06-macros.html#macros">"Макросы"</a><!--  --> главы 19.</p>
<h3 id="debug-для-отладочного-вывода"><a class="header" href="#debug-для-отладочного-вывода"><code>Debug</code> для отладочного вывода</a></h3>
<p>Типаж <code>Debug</code> включает отладочное форматирование в форматируемых строках, которые вы можете указать с помощью <code>:?</code> внутри <code>{}</code> фигурных скобок.</p>
<p>Типаж <code>Debug</code> позволяет Вам напечатать объекты вида с целью отладки, поэтому Вы и другие программисты, использующие Ваш вид, смогут проверить объект в определённой точке выполнения программы.</p>
<p>Типаж <code>Debug</code> обязателен в некоторых случаях. Например, при использовании макроса <code>assert_eq!</code>. Этот макрос печатает значения входных переменных, если они не совпадают. Это позволяет программистам увидеть, почему эти объекты не равны.</p>
<h3 id="partialeq-и-eq-для-сравнения-равенства"><a class="header" href="#partialeq-и-eq-для-сравнения-равенства"><code>PartialEq</code> и <code>Eq</code> для сравнения равенства</a></h3>
<p>Типаж <code>PartialEq</code> позволяет Вам сравнить объекты одного вида на эквивалентность, и включает для них использование операторов <code>==</code> и <code>!=</code>.</p>
<p>Использование <code>PartialEq</code> реализует способ <code>eq</code>. Когда <code>PartialEq</code> используют для структуры, два объекта равны если равны <em>все</em> поля объектов, и объекты не равны, если хотя бы одно поле отлично. Когда используется для перечислений, каждый вариант равен себе, и не равен другим вариантам.</p>
<p>Типаж <code>PartialEq</code> обязателен в некоторых случаях. Например для макроса <code>assert_eq!</code>, где необходимо сравнивать два объекта одного вида на эквивалентность.</p>
<p>Типаж <code>Eq</code> не имеет методов. Он сигнализирует что каждое значение аннотированного вида равно самому себе. Типаж <code>Eq</code> может быть применён только для видов реализующих типаж <code>PartialEq</code>, хотя не все виды, которые реализуют <code>PartialEq</code> могут реализовывать <code>Eq</code>. Примером являются числа с плавающей запятой: реализация чисел с плавающей запятой говорит, что два экземпляра со значениями не-число (<code>NaN</code>) не равны друг другу.</p>
<p>Типаж <code>Eq</code>необходим в некоторых случаях. Например, для ключей в <code>HashMap&lt;K, V&gt;</code>. Поэтому <code>HashMap&lt;K, V&gt;</code> может сказать, что два ключа являются одним и тем же.</p>
<h3 id="partialord-и-ord-для-сравнения-порядка"><a class="header" href="#partialord-и-ord-для-сравнения-порядка"><code>PartialOrd</code> и <code>Ord</code> для сравнения порядка</a></h3>
<p>Типаж <code>PartialOrd</code> позволяет Вам сравнить объекты одного вида с помощью сортировки. Вид, реализующий <code>PartialOrd</code> может использоваться с операторами <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, и <code>&gt;=</code>. Вы можете реализовать типаж <code>PartialOrd</code> только для видов, реализующих <code>PartialEq</code>.</p>
<p>Использование <code>PartialOrd</code> реализует способ <code>partial_cmp</code>, который возвращает <code>Option&lt;Ordering&gt;</code> который является <code>None</code> когда значения не выстраивают порядок. Примером значения, которое не может быть упорядочено, не являются числом (<code>NaN</code>) значение с плавающей запятой. Вызов <code>partial_cmp</code> с любым числом с плавающей запятой и значением <code>NaN</code> вернёт <code>None</code>.</p>
<p>Когда используется для структур, <code>PartialOrd</code> сравнивает два объекта путём сравнения значений каждого поля в порядке, в котором поля объявлены в структуре. Когда используется для перечислений, то варианты перечисления объявленные ранее будут меньше чем варианты объявленные позже.</p>
<p>Например, типаж <code>PartialOrd</code> может потребоваться для метода <code>gen_range</code> из <code>rand</code> крейта который генерирует случайные значения в заданном ряде (который определён выражением ряда).</p>
<p>Типаж <code>Ord</code> позволяет знать, для двух значений аннотированного вида всегда будет существовать валидный порядок. Типаж <code>Ord</code> реализовывает способ <code>cmp</code>, который возвращает <code>Ordering</code> а не <code>Option&lt;Ordering&gt;</code> потому что валидный порядок всегда будет существовать. Вы можете применить типаж  <code>Ord</code> только для видов, реализовывающих типаж <code>PartialOrd</code> и <code>Eq</code> (<code>Eq</code> также требует <code>PartialEq</code>). При использовании на структурах или перечислениях, <code>cmp</code> имеет такое же поведение, как и <code>partial_cmp</code> в<code>PartialOrd</code>.</p>
<p>Типаж <code>Ord</code> необходим в некоторых случаях. Например, сохранение значений в <code>BTreeSet&lt;T&gt;</code>, виде данных, который хранит сведения на основе порядка отсортированных данных.</p>
<h3 id="clone-и-copy-для-повторения-значений"><a class="header" href="#clone-и-copy-для-повторения-значений"><code>Clone</code> и <code>Copy</code> для повторения значений</a></h3>
<p>Типаж <code>Clone</code> позволяет вам явно создать глубокую копию значения, а также процесс повторения может вызывать особый код и копировать данные с кучи. Более подробно про <code>Clone</code> смотрите в секции <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">"Способы взаимодействия переменных и данных: клонирование"</a> в разделе 4.</p>
<p>Использование <code>Clone</code> реализует способ <code>clone</code>, который в случае реализации на всем виде, вызывает <code>clone</code>для каждой части данных вида. Это подразумевает, что все поля или значения в виде также должны реализовывать <code>Clone</code> для использования <code>Clone</code>.</p>
<p>Типаж <code>Clone</code> необходим в некоторых случаях. Например, для вызова метода <code>to_vec</code> для среза. Срез не владеет данными, содержащимися в нем, но вектор значений, возвращённый из <code>to_vec</code> должен владеть этими объектами, поэтому <code>to_vec</code> вызывает <code>clone</code> для всех данных. Таким образом, вид хранящийся в срезе, должен реализовывать <code>Clone</code>.</p>
<p>Типаж <code>Copy</code> позволяет повторять значения копируя только данные, которые хранятся на стеке, произвольный код не требуется. Смотрите секцию <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">"Стековые данные: Копирование"</a><!-- ignore --> в разделе 4 для большей сведений о <code>Copy</code>.</p>
<p>Типаж <code>Copy</code> не содержит методов для предотвращения перегрузки этих методов программистами, иначе бы это нарушило соглашение, что никакой произвольный код не запускается. Таким образом все программисты могут предполагать, что копирование значений будет происходить быстро.</p>
<p>Вы можете вывести <code>Copy</code> для любого вида все части которого реализуют <code>Copy</code>. Вид который реализует <code>Copy</code> должен также реализовывать <code>Clone</code>, потому что вид реализующий <code>Copy</code> имеет тривиальную реализацию <code>Clone</code> который выполняет ту же задачу, что и <code>Copy</code>.</p>
<p>Типаж <code>Copy</code> нужен очень редко; виды, реализовывающие <code>Copy</code> имеют небольшую оптимизацию, то есть для него не нужно вызывать способ <code>clone</code>, который делает код более кратким.</p>
<p>Все, что вы делаете с <code>Copy</code> можно также делать и с <code>Clone</code>, но код может быть медленнее и требовать вызов метода <code>clone</code> в некоторых местах.</p>
<h3 id="hash-для-превращения-значения-в-значение-фиксированного-размера"><a class="header" href="#hash-для-превращения-значения-в-значение-фиксированного-размера"><code>Hash</code> для превращения значения в значение фиксированного размера</a></h3>
<p>Типаж <code>Hash</code> позволяет превратить значение произвольного размера в значение фиксированного размера с использованием хеш-функции. Использование <code>Hash</code> реализует способ <code>hash</code>. При реализации через derive, способ <code>hash</code> комбинирует результаты вызова <code>hash</code> на каждой части данных вида, то есть все поля или значения должны реализовывать <code>Hash</code> для использования <code>Hash</code> с помощью derive.</p>
<p>Типаж <code>Hash</code> необходим в некоторых случаях. Например, для хранения ключей в <code>HashMap&lt;K, V&gt;</code>, для их более эффективного хранения.</p>
<h3 id="default-для-значений-по-умолчанию"><a class="header" href="#default-для-значений-по-умолчанию"><code>Default</code> для значений по умолчанию</a></h3>
<p>Типаж <code>Default</code> позволяет создавать значение по умолчанию для вида. Использование <code>Default</code> реализует функцию <code>default</code>. Стандартная реализация метода <code>default</code> вызовет функцию <code>default</code> на каждой части данных вида, то есть для использования <code>Default</code> через derive, все поля и значения вида данных должны также реализовывать <code>Default</code>.</p>
<p>Функция <code>Default::default</code>часто используется в сочетания с синтаксисом обновления структуры, который мы обсуждали в секции <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">"Создание экземпляра структуры из экземпляра другой структуры с помощью синтаксиса обновления структуры"</a><!-- ignore --> главы 5. Вы можете настроить несколько полей для структуры, а для остальных полей установить значения с помощью <code>..Default::default()</code>.</p>
<p>Типаж <code>Default</code> необходим в некоторых случаях. Например, для метода <code>unwrap_or_default</code> у вида <code>Option&lt;T&gt;</code>. Если значение <code>Option&lt;T&gt;</code> будет <code>None</code>, способ <code>unwrap_or_default</code> вернёт результат вызова функции <code>Default::default</code> для вида <code>T</code>, хранящегося в <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-Г---Средства-разработки"><a class="header" href="#Дополнение-Г---Средства-разработки">Дополнение Г - Средства разработки</a></h2>
<p>В этом дополнении мы расскажем про часто используемые средства разработки, предоставляемые Rust. Мы рассмотрим самостоятельное форматирование, быстрый путь исправления предупреждений, линтер, и встраивание с IDE.</p>
<h3 id="Самостоятельное-форматирование-с-rustfmt"><a class="header" href="#Самостоятельное-форматирование-с-rustfmt">Самостоятельное форматирование с <code>rustfmt</code></a></h3>
<p>Средство <code>rustfmt</code> переформатирует ваш код в соответствии со стилем кода сообщества. Многие совместные проекты используют <code>rustfmt</code>, чтобы предотвратить споры о том, какой стиль использовать при написании Rust: все форматируют свой код с помощью этого средства.</p>
<p>Для установки <code>rustfmt</code>, введите следующее:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Этот приказ установит <code>rustfmt</code> и <code>cargo-fmt</code>, также как Rust даёт Вам одновременно <code>rustc</code> и <code>cargo</code>. Для форматирования проекта, использующего Cargo, введите следующее:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Этот приказ отформатирует весь код на языке Rust в текущем крейте. Будет изменён только стиль кода, семантика останется прежней. Для большей сведений о <code>rustfmt</code>, смотрите <a href="https://github.com/rust-lang/rustfmt">документацию</a>.</p>
<h3 id="Исправление-кода-с-rustfix"><a class="header" href="#Исправление-кода-с-rustfix">Исправление кода с <code>rustfix</code></a></h3>
<p>Средство rustfix включён в установку Rust и может самостоятельно исправлять предупреждения сборщика с очевидным способом исправления проблемы, скорее всего, подходящим вам. Вероятно, вы уже видели предупреждения сборщика. Например, рассмотрим этот код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Мы вызываем функцию <code>do_something</code> 100 раз, но никогда не используем переменную <code>i</code> в теле цикла <code>for</code>. Rust предупреждает нас об этом:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Предупреждение предлагает нам использовать <code>_i</code> как имя переменной: нижнее подчёркивание в начале определителя предполагает, что мы его не используем. Мы можем самостоятельно применить это предположение с помощью <code>rustfix</code>, запустив приказ <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Когда посмотрим в <em>src/main.rs</em> снова, мы увидим что <code>cargo fix</code> изменил наш код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Переменная цикла <code>for</code> теперь носит имя <code>_i</code>, и предупреждение больше не появляется.</p>
<p>Также Вы можете использовать приказ <code>cargo fix</code> для перемещения вашего кода между различными изданиеми Rust. Издания будут рассмотрены в дополнении Д.</p>
<h3 id="Больше-проверок-с-clippy"><a class="header" href="#Больше-проверок-с-clippy">Больше проверок с Clippy</a></h3>
<p>Средство Clippy является собранием проверок (lints) для анализа Вашего кода, поэтому Вы можете найти простые ошибки и улучшить ваш Rust код.</p>
<p>Для установки Clippy, введите следующее:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Для запуска проверок Clippy’s для проекта Cargo, введите следующее:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Например, скажем что Вы хотите написать программу, в которой будет использоваться приближенная математическая константа, такая как число Пи, как в следующей программе:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>Запуск <code>cargo clippy</code> для этого проекта вызовет следующую ошибку:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Эта ошибка сообщает вам, что в Rust уже определена более точная константа <code>PI</code>, и что ваша программа будет более корректной, если вы вместо неё будете использовать эту константу. Затем вы должны изменить свой код, чтобы использовать константу <code>PI</code>. Следующий код не приводит к ошибкам или предупреждениям от Clippy:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>Для большей сведений о Clippy смотрите <a href="https://github.com/rust-lang/rustfmt">документацию</a>.</p>
<h3 id="Встраивание-с-ide-с-помощью-rust-analyzer"><a class="header" href="#Встраивание-с-ide-с-помощью-rust-analyzer">Встраивание с IDE с помощью <code>rust-analyzer</code></a></h3>
<p>Чтобы облегчить встраивание с IDE, сообщество Rust советует использовать <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->. Этот средство представляет собой набор ориентированных на сборщик утилит, которые используют <a href="http://langserver.org/">Language Server Protocol</a><!-- ignore -->, который является спецификацией для взаимодействия IDE и языков программирования друг с другом. Разные клиенты могут использовать <code>rust-analyzer</code>, например <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">подключаемый модуль анализатора Rust для Visual Studio Code</a>.</p>
<p>Посетите <a>домашнюю страницу</a> проекта <code>rust-analyzer</code> для получения указаний по установке, затем установите поддержку языкового сервера в именно среде IDE. Ваша IDE получит такие возможности, как автозаполнение, переход к определению и встроенные ошибки.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приложение-e---Издания-языка"><a class="header" href="#Приложение-e---Издания-языка">Приложение E - Издания языка</a></h2>
<p>В главе 1, можно увидеть, что приказ <code>cargo new</code> добавляет некоторые мета-данные о издания языка в файл <em>Cargo.toml</em>. Данное приложение рассказывает, что они означают.</p>
<p>Язык Rust и его сборщик имеют шестинедельный цикл выпуска, означающий, что пользователи постоянно получают новые функции. В других языках обычно выпускают большие обновления, но редко. Объединение Rust выпускает меньшие обновления, но более часто. Через некоторое время все эти небольшие изменения накапливаются. Между релизами обычно сложно оглянуться назад и сказать "Ого, язык сильно изменился между исполнениями Rust 1.10 и Rust 1.31!"</p>
<p>Каждые два или три года, объединение Rust выпускает новую издание языка <em>(Rust edition)</em>. Каждая издание объединяет все новые особенности, которые попали в язык с новыми пакетами, с полной, обновлённой документацией и набором средств. Новые издания поставляются как часть шестинедельного процесса релизов.</p>
<p>Для разных людей издания служат разным целям:</p>
<ul>
<li>Для активных пользователей новая издание приносит все инкрементальные изменения в удобный и понятный пакет.</li>
<li>Для тех, кто языком не пользуется, новая реакция является сигналом, что некоторые важные улучшения, на которые возможно надо взглянуть ещё раз, попали в язык.</li>
<li>Для тех кто разрабатывает на Rust, новая издание даёт некоторую точку отсчёта для проекта в целом.</li>
</ul>
<p>На момент написания доступны две издания Rust: Rust 2015 и Rust 2018. Данная книга написана с использованием идиом издания Rust 2018.</p>
<p>Ключ <code>edition</code> в настроечном файле  <em>Cargo.toml</em> отображает, какую издание сборщик должен использовать для вашего кода. Если ключа нет, то для обратной совместимости сборщик Rust использует издание <code>2015</code>.</p>
<p>Любой проект может выбрать издание отличную от издания по умолчанию, которая равна 2015. Издания могут содержать несовместимые изменения, включая новые ключевые слова, которые могут конфликтовать с определителями в коде. Однако, пока вы не переключитесь на новую издание, ваш код будет продолжать собираться даже после обновления используемой исполнения сборщика.</p>
<p>Все исполнения сборщика Rust поддерживают любую издание, которая предшествовала выпуску текущей, и они могут линковать пакеты любой поддерживаемой издания. Изменения изданий действуют только на способ начального разбора сборщиком исходного кода. Поэтому, если вы используете 2015 издание, а одна из ваших зависимостей использует 2018, ваш проект будет собран и сможет пользоваться этой зависимостью. Обратная ситуация, когда ваш проект использует Rust 2018, а зависимость использует Rust 2015, работает таким же образом.</p>
<p>Внесём ясность: большая часть возможностей будет доступна во всех изданиях. Разработчики, использующие любую издание Rust, будут продолжать получать улучшения по мере выпуска новых релизов. Однако в некоторых случаях, в основном, когда добавляются новые ключевые слова, некоторые новые возможности могут быть доступны только в последних изданиях. Нужно переключить издание, чтобы воспользоваться новыми возможностями.</p>
<p>Для получения больше подробностей, есть полная книга <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> про издания, в которой перечисляются различия между изданиями и объясняется, как самостоятельно обновить свой код на новую издание с помощью приказы <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приложение-Е-Переводы-книги"><a class="header" href="#Приложение-Е-Переводы-книги">Приложение Е: Переводы книги</a></h2>
<p>Для ресурсов на языках, отличных от английского. Большинство из них все ещё в разработке; см. <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">ярлык «Переводы»</a>, чтобы помочь или сообщить нам о новом переводе!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Дополнение-Ё---Как-создаётся-rust-и-nightly-rust"><a class="header" href="#Дополнение-Ё---Как-создаётся-rust-и-nightly-rust">Дополнение Ё - Как создаётся Rust и “Nightly Rust”</a></h2>
<p>Это дополнение рассказывает как создаётся Rust, и как это влияет на Вас как на разработчика.</p>
<h3 id="Безотказность-без-стагнации"><a class="header" href="#Безотказность-без-стагнации">Безотказность без стагнации</a></h3>
<p>Как язык, Rust <em>много</em> заботиться о безотказности Вашего кода. Мы хотим чтобы Rust был прочным фундаментом, вашей опорой, и если бы все постоянно менялось, это было бы невозможно. В то же время, если мы не можем экспериментировать с различными возможностями, мы не можем обнаружить важные проблемы до релиза, когда мы не можем их изменить.</p>
<p>Нашим решением проблемы является “безотказность без стагнации”, и наш руководящий принцип: Вы никогда не должны бояться перехода на новую безотказную исполнение Rust. Каждое обновление должно быть безболезненным, но также должно добавлять новые функции, меньше дефектов и более быструю скорость сборки.</p>
<h3 id="Ту-ту-потоки-выпуска-и-поездка-на-поезде"><a class="header" href="#Ту-ту-потоки-выпуска-и-поездка-на-поезде">Ту-ту! потоки выпуска и поездка на поезде</a></h3>
<p>Разработка языка Rust работает по принципу <em>расписания поездов</em>. То есть, вся разработка совершается в ветке <code>master</code> Rust репозитория. Выпуски следуют модели последовательного выпуска продукта (software release train), которая была использована Cisco IOS и другими программными продуктами. Есть три <em>потока выпуска</em> Rust:</p>
<ul>
<li>Ночной (Nightly)</li>
<li>Бета (Beta)</li>
<li>Безотказный (Stable)</li>
</ul>
<p>Большинство Rust разработчиков используют безотказную исполнение, но те кто хотят попробовать экспериментальные новые функции, должны использовать Nightly или Beta.</p>
<p>Приведём пример, как работает процесс разработки и выпуска новых исполнений. Давайте предположим, что объединение Rust работает над исполнением Rust 1.5. Его релиз состоялся в декабре 2015 года, но это даст реалистичность номера исполнения. Была добавлена новая функциональность в Rust: новые коммиты в ветку <code>master</code>. Каждую ночь выпускается новая ночная исполнение Rust. Каждый день является днём выпуска ночной исполнения и эти выпуски создаются нашей структурой самостоятельно . По мере того как идёт время, наши выпуски выглядят так:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Каждые шесть недель наступает время подготовки новой Beta исполнения! Ветка <code>beta</code> Rust репозитория ответвляется от ветки <code>master</code>, используемой исполнением Nightly. Теперь мы имеем два выпуска:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Многие пользователи Rust не используют активно бета-исполнение, но тестируют бета-исполнение в их системе CI для помощи Rust обнаружить проблемы обратной совместимости. В это время каждую ночь выпускается новая исполнение Nightly:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Предположим, что была найдена регрессия. Хорошо, что мы можем протестировать бета-исполнение перед тем как регрессия попала в безотказную исполнение! Исправление отправляется в ветку <code>master</code>, поэтому исполнение nightly исправлена и затем исправление также направляется в ветку <code>beta</code>, и происходит новый выпуск бета-исполнения:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Через шесть недель после выпуска бета-исполнения, наступает время для выпуска безотказной исполнения! Ветка <code>stable</code> создаётся из ветки <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Ура! Rust 1.5 выпущена! Но мы также забыли про одну вещь: так как прошло шесть недель, мы должны выпустить бета-исполнение <em>следующей</em>  исполнения Rust 1.6. Поэтому после ответвления ветки <code>stable</code> из ветки <code>beta</code>, следующая исполнение <code>beta</code> ответвляется снова от <code>nightly</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Это называется “модель поезда” (train model), потому что каждые шесть недель выпуск “покидает станцию”, но ему все ещё нужно пройти поток beta, чтобы попасть в безотказную исполнение.</p>
<p>Rust выпускается каждые шесть недель, как часы. Если вы знаете дату одного выпуска Rust, вы знаете дату выпуска следующего: это шесть недель позднее. Хорошим особенностью выпуска исполнений каждые шесть недель является то, что следующий поезд прибывает скоро. Если какая-то функция не попадает в релиз, не надо волноваться: ещё один выпуск произойдёт очень скоро! Это помогает снизить давление в случае если функция возможно не отполирована к дате выпуска.</p>
<p>Благодаря этому процессу, вы всегда можете посмотреть следующую исполнение Rust и убедиться, что на неё легко будет перейти: если бета-выпуск будет работать не так как ожидалось, вы можете сообщить об этом разработчикам и он будет исправлен перед выпуском безотказной исполнения! Поломки в бета-исполнения случаются относительно редко, но <code>rustc</code> все ещё является частью программного обеспечения, поэтому дефекты все ещё существуют.</p>
<h3 id="Ненадежные-функции"><a class="header" href="#Ненадежные-функции">Ненадежные функции</a></h3>
<p>У этой модели выпуска есть ещё один плюс: ненадежные функции. Rust использует технику называемую “флаги функционала” (feature flags) для определения функций, которые были включены в выпуске. Если новая функция находится в активной разработке, она попадает в ветку <code>master</code>, и поэтому попадает в ночную исполнение, но с <em>флагом функции</em> (feature flag). Если как пользователь, вы хотите попробовать работу такой функции, находящейся в разработке, вы должны использовать ночную исполнение Rust и указать в вашем исходном коде определённый флаг.</p>
<p>Если вы используете бета или безотказную исполнение Rust, Вы не можете использовать флаги функций. Этот ключевой момент позволяет использовать на практике новые возможности перед их отладкой. Это может использоваться желающими идти в ногу со временем, а другие могут использовать безотказную исполнение и быть уверенными что их код не сломается. Безотказность без стагнации.</p>
<p>Эта книга содержит сведения только о безотказных возможностях, так как разрабатываемые возможности продолжают меняться в процессе и несомненно они будут отличаться в зависимости от того, когда эта книга написана и когда эти возможности будут включены в безотказные сборки. Вы можете найти сведения о возможностях ночной исполнения в интернете.</p>
<h3 id="rustup-и-роль-ночной-исполнения-rust"><a class="header" href="#rustup-и-роль-ночной-исполнения-rust">Rustup и роль ночной исполнения Rust</a></h3>
<p>Rustup делает лёгким изменение между различными потоками Rust, на вездесущем или местном для проекта уровне. По умолчанию устанавливается безотказная исполнение Rust. Для установки ночной исполнения выполните приказ:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Вы можете также увидеть все установленные <em>средства разработчика (toolchains)</em> (исполнения Rust и ассоциированные компоненты) с помощью <code>rustup</code>. Это пример вывода у одного из авторов Rust с компьютером на Windows:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Как видите, включенный набор средств (toolchain) используется по умолчанию. Большинство пользователей Rust используют безотказные исполнения большую часть времени. Возможно, вы захотите использовать безотказную большую часть времени, но использовать каждую ночную исполнение в определенном проекте, потому что заботитесь о передовых возможностях. Для этого вы можете использовать приказ <code>rustup override</code> в каталоге этого проекта, чтобы установить ночной набор средств, должна использоваться приказ <code>rustup</code>, когда вы находитесь в этом каталоге:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Теперь каждый раз, когда вы вызываете <code>rustc</code> или <code>cargo</code> внутри <em>~/projects/needs-nightly</em>, <code>rustup</code> будет следить за тем, чтобы вы используете ночную исполнение Rust, а не безотказную по умолчанию. Это очень удобно, когда у вас есть множество Rust проектов!</p>
<h3 id="Процесс-rfc-и-приказы"><a class="header" href="#Процесс-rfc-и-приказы">Процесс RFC и приказы</a></h3>
<p>Итак, как вы узнаете об этих новых возможностях? Модель разработки Rust следует <em>процессу запроса комментариев (RFC - Request For Comments)</em>. Если хотите улучшить Rust, вы можете написать предложение, которое называется RFC.</p>
<p>Любой может написать RFC для улучшения Rust, предложения рассматриваются и обсуждаются приказом Rust, которая состоит из множества тематических подгрупп. На <a href="https://www.rust-lang.org/governance">веб-сайте Rust</a> есть полный список приказов, который включает приказы для каждой области проекта: дизайн языка, реализация сборщика, инфраструктура, документация и многое другое. Соответствующая приказ читает предложение и комментарии, пишет некоторые собственные комментарии и в конечном итоге, приходит к согласию принять или отклонить эту возможность.</p>
<p>Если новая возможность принята и кто-то может реализовать её, то задача открывается в репозитории Rust. Человек реализующий её, вполне может не быть тем, кто предложил эту возможность! Когда реализация готова, она попадает в <code>master</code> ветвь с флагом функции, как мы обсуждали в разделе <a href="appendix-07-nightly-rust.html#unstable-features">"Небезотказных функциях"</a><!--  -->.</p>
<p>Через некоторое время, разработчики Rust использующие ночные выпуски, смогут опробовать новую возможность, члены приказы обсудят её, как она работает в ночной исполнения и решат, должна ли она попасть в безотказную исполнение Rust или нет. Если принимается решение двигать её вперёд, ограничение функции с помощью флага убирается и функция теперь считается безотказной! Она едет в новую  безотказную исполнение Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
