<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Программирование игры в загадки - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие подходы программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание образцов структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> правила написания способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и тайностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х проверок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать проверки</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением проверок</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация проверок</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Переработка кода для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через проверка</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный одновременность</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для одновременного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Одновременность с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый одновременность с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности предметно-направленного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики предметно-направленных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-предметов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона предметно-направленного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> правила написания шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Конечный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Программируем-игру-в-загадки"><a class="header" href="#Программируем-игру-в-загадки">Программируем игру в загадки</a></h1>
<p>Давайте окунёмся в Rust, вместе поработав над опытным проектом! В этой главе вы познакомитесь с несколькими общими подходами Rust, показав, как использовать их в существующей программе. Вы узнаете о <code>let</code> , <code>match</code>, способах, ассопряженных функциях, внешних дополнениях и многом другом! В следующих главах мы рассмотрим эти идеи более подробно. В этой главе вы просто ппримените в основах.</p>
<p>Мы реализуем классическую для начинающих программистов задачу — игру в загадки. Вот как это работает: программа генерирует случайное целое число в ряде от 1 до 100. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра напечатает поздравительное сообщение и завершится.</p>
<h2 id="Настройка-нового-проекта"><a class="header" href="#Настройка-нового-проекта">Настройка нового проекта</a></h2>
<p>Для настройки нового проекта перейдите в каталог <em>projects</em>, который вы создали в главе 1, и создайте новый проект с использованием Cargo, как показано ниже:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Первая приказ, <code>cargo new</code>, принимает в качестве первого переменной имя проекта (<code>guessing_game</code>). Вторая приказ изменяет каталог на новый каталог проекта.</p>
<p>Загляните в созданный файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Как вы уже видели в главе 1, <code>cargo new</code> создаёт программу «Hello, world!». Посмотрите файл <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Теперь давайте соберем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью приказы <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Приказ <code>run</code> пригодится, когда необходимо ускоренно выполнить повторение проекта. Именно так мы собираемся делать в этом проекте, быстро проверяя каждую повторение, прежде чем перейти к следующей.</p>
<p>Снова откройте файл <em>src/main.rs</em>. Весь код вы будете писать в нем.</p>
<h2 id="Обработка-догадки"><a class="header" href="#Обработка-догадки">Обработка догадки</a></h2>
<p>Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой виде. Начнём с того, что позволим игроку ввести догадку. Вставьте код из приложения 2-1 в <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}</code></pre>
<p><span class="caption">Приложение 2-1: код, который получает догадку от пользователя и выводит её на экран</span></p>
<p>Этот код содержит много сведений, поэтому давайте рассмотрим его построчно. Чтобы получить пользовательский ввод и затем вывести итог, нам нужно включить в область видимости библиотеку ввода/вывода <code>io</code>. Библиотека <code>io</code> является частью встроенной библиотеки, известной как <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>По умолчанию в Rust есть набор элементов, определённых в встроенной библиотеке, которые он добавляет в область видимости каждой программы. Этот набор называется <em>прелюдией</em>, и вы можете изучить его содержание <a href="../std/prelude/index.html">в документации встроенной библиотеки</a>.</p>
<p>Если вид, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора <code>use</code>. Использование библиотеки <code>std::io</code> предоставляет ряд полезных функциональных возможностей, включая способность принимать пользовательский ввод.</p>
<p>Как уже отмечалось в главе 1, функция <code>main</code> является точкой входа в программу:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Ключевое слово <code>fn</code> объявляет новую функцию, круглые скобки <code>()</code> показывают, что у функции нет входных свойств, фигурная скобка <code>{</code> - обозначение начала тела функции.</p>
<p>Также в главе 1 упоминалось, что <code>println!</code> — это макрос, который выводит строку на экран:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Этот код показывает сведения о ходе игры и запрашивает пользовательский ввод.</p>
<h3 id="Хранение-значений-с-помощью-переменных"><a class="header" href="#Хранение-значений-с-помощью-переменных">Хранение значений с помощью переменных</a></h3>
<p>Далее мы создаём <em>переменную</em> для хранения пользовательского ввода, как показано ниже:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Вот теперь программа становится важнее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем оператор <code>let</code>. Вот ещё один пример:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Эта строка создаёт новую переменную с именем <code>apples</code> и привязывает её к значению 5. В Rust переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту подход в разделе <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">"Переменные и изменчивость".</a><!-- ignore --> в главе 3. Чтобы сделать переменную изменяемой, мы добавляем <code>mut</code> перед её именем:</p>
<pre><code class="language-rust ignore">let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая</code></pre>
<blockquote>
<p>Примечание: сочетание знаков <code>//</code> начинает комментарий, который продолжается до конца строки. Rust пренебрегает всё, что находится в комментариях. Мы обсудим комментарии более подробно в <a href="ch03-04-comments.html">Главе 3</a><!-- ignore -->.</p>
</blockquote>
<p>Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что <code>let mut guess</code> предоставит изменяемую переменную с именем <code>guess</code>. Знак равенства (<code>=</code>) сообщает Rust, что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с <code>guess</code>, которое является итогом вызова функции <code>String::new</code>, возвращающей новый образец <code>String</code>. <a data-md-type="raw_html" href="../std/string/struct.String.html"><code>String</code></a> — это вид строки, предоставляемый встроенной библиотекой, который является расширяемым фрагментом текста в кодировке UTF-8.</p>
<p>правила написания <code>::</code> в строке <code>::new</code> указывает, что <code>new</code> является ассопряженной функцией вида <code>String</code>. <em>Ассопряженная функция</em> — это функция, реализованная для вида, в данном случае <code>String</code>. Функция <code>new</code> создаёт новую пустую строку. Функцию <code>new</code> можно встретить во многих видах, это привычное название для функции, которая создаёт новое значение какого-либо вида.</p>
<p>В конечном итоге строка <code>let mut guess = String::new();</code> создала изменяемую переменную, которая связывается с новым пустым образцом <code>String</code>. Фух!</p>
<h3 id="Получение-пользовательского-ввода"><a class="header" href="#Получение-пользовательского-ввода">Получение пользовательского ввода</a></h3>
<p>Напомним: мы подключили функциональность ввода/вывода из встроенной библиотеки с помощью <code>use std::io;</code> в первой строке программы. Теперь мы вызовем функцию <code>stdin</code> из модуля <code>io</code>, которая позволит нам обрабатывать пользовательский ввод:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Если бы мы не импортировали библиотеку <code>io</code> с помощью <code>use std::io</code> в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как <code>std::io::stdin</code>. Функция <code>stdin</code> возвращает образец <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>, который является видом, представляющим дескриптор принятого ввода для вашего окна вызова.</p>
<p>Далее строка <code>.read_line(&amp;mut guess)</code> вызывает способ <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> на дескрипторе принятого ввода для получения ввода от пользователя. Мы также передаём <code>&amp;mut guess</code> в качестве переменной <code>read_line</code>, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача <code>read_line</code> — принять все, что пользователь вводит в стандартный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве переменной. Строковый переменная должен быть изменяемым, чтобы способ мог изменить содержимое строки.</p>
<p>Символ <code>&amp;</code> указывает, что этот переменная является <em>ссылкой</em>, которая предоставляет возможность нескольким частям вашего кода получить доступ к одному фрагменту данных без необходимости копировать эти данные в память несколько раз. Ссылки — это сложная функциональная возможность, а одним из главных преимуществ Rust является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>. (В главе 4 ссылки будут описаны более подробно).</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Обработка-возможного-сбоя-с-помощью-вида-result"><a class="header" href="#Обработка-возможного-сбоя-с-помощью-вида-result">Обработка возможного сбоя с помощью вида <code>Result</code></a></h3>
<p>Мы всё ещё работаем над этой строкой кода. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной логической строки. Следующая часть — способ:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Мы могли бы написать этот код так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове способа с помощью правил написания <code>.method_name()</code> часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.</p>
<p>Как упоминалось ранее, <code>read_line</code> помещает всё, что вводит пользователь, в строку, которую мы ему передаём, но также возвращает значение <code>Result</code>. <a data-md-type="raw_html" href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> — это <a href="ch06-00-enums.html"><em>перечисление</em></a><!-- ignore -->, часто называемое <em>enum</em>, то есть вид, который может находиться в одном из нескольких возможных состояний. Мы называем каждое такое состояние <em>вариантом</em>.</p>
<p>В <a href="ch06-00-enums.html">Главе 6</a> рассмотрим перечисления более подробно. Задачей видов <code>Result</code> является кодирование сведений для обработки ошибок.</p>
<p>Вариантами <code>Result</code> являются <code>Ok</code> и <code>Err</code>. Вариант <code>Ok</code> указывает, что действие завершилась успешно, а внутри <code>Ok</code> находится успешно сгенерированное значение. Вариант <code>Err</code> означает, что действие не удалась, а <code>Err</code> содержит сведения о причинах неудачи.</p>
<p>Значения вида <code>Result</code>, как и значения любого вида, имеют определённые для них способы. У образца <code>Result</code> есть <a href="../std/result/enum.Result.html#method.expect">способ <code>expect</code></a><!-- ignore -->, который можно вызвать. Если этот образец <code>Result</code> является значением <code>Err</code>, <code>expect</code> вызовет сбой программы и отобразит сообщение, которое вы передали в качестве переменной. Если способ <code>read_line</code> возвращает <code>Err</code>, то это, скорее всего, итог ошибки основной операционной системы. Если образец <code>Result</code> является значением <code>Ok</code>, <code>expect</code> возьмёт возвращаемое значение, которое удерживает <code>Ok</code>, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.</p>
<p>Если не вызвать <code>expect</code>, программа ссобирается, но будет получено предупреждение:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust предупреждает о неиспользованном значении <code>Result</code>, возвращаемого из <code>read_line</code>, показывая, что программа не учла возможность возникновения ошибки.</p>
<p>Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении сбоев, поэтому используем <code>expect</code>. О способах восстановления после ошибок вы узнаете в <a href="ch09-02-recoverable-errors-with-result.html">главе 9</a>.</p>
<h3 id="Вывод-значений-с-помощью-заполнителей-println"><a class="header" href="#Вывод-значений-с-помощью-заполнителей-println">Вывод значений с помощью заполнителей <code>println!</code></a></h3>
<p>Кроме закрывающей фигурной скобки, в коде на данный время есть ещё только одно место для обсуждения:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {}", guess);
<span class="boring">}</span></code></pre>
<p>Этот код выводит строку, которая теперь содержит ввод пользователя. Набор фигурных скобок <code>{}</code> является заполнителем: думайте о <code>{}</code> как о маленьких клешнях краба, которые удерживают значение на месте. При печати значения переменной имя переменной может заключаться в фигурные скобки. При печати итога вычисления выражения поместите пустые фигурные скобки в строку вида, затем после строки вида укажите список выражений, разделённых запятыми, которые будут напечатаны в каждом заполнителе пустой фигурной скобки в том же порядке. Печать переменной и итога выражения одним вызовом <code>println!</code> будет выглядеть так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Этот код выведет <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="Проверка-первой-части"><a class="header" href="#Проверка-первой-части">Проверка первой части</a></h3>
<p>Давайте проверим первую часть игры. Запустите её используя <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.</p>
<h2 id="Генерация-тайного-числа"><a class="header" href="#Генерация-тайного-числа">Генерация тайного числа</a></h2>
<p>Далее нам нужно сгенерировать тайное число, которое пользователь попытается угадать. Тайное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в ряде от 1 до 100, чтобы игра не была слишком сложной. Rust пока не включает функциональность случайных чисел в свою стандартную библиотеку. Однако приказ Rust предоставляет [крейт <code>rand</code>] с подобной функциональностью.</p>
<h3 id="Использование-крейта-для-получения-дополнительного-функционала"><a class="header" href="#Использование-крейта-для-получения-дополнительного-функционала">Использование крейта для получения дополнительного функционала</a></h3>
<p>Помните, что пакет (crate) - это собрание файлов исходного кода Rust. Проект, создаваемый нами, представляет собой <br> <em>двоичный пакет (binary crate)</em>, который является исполняемым файлом. Пакет <code>rand</code> - это <em>библиотечный пакет (library crate)</em>, содержащий код, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.</p>
<p>Согласование работы внешних пакетов является тем местом, где Cargo на самом деле блистает. Чтобы начать писать код, использующий <code>rand</code>, необходимо изменить файл <em>Cargo.toml</em>, включив в него в качестве зависимости пакет <code>rand</code>. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком секции <code>[dependencies]</code>, созданным для вас Cargo. Обязательно укажите <code>rand</code> в точности так же, как здесь, с таким же номером исполнения, иначе примеры кода из этого урока могут не заработать.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Имя файла: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>В файле <em>Cargo.toml</em> всё, что следует за заголовком, является частью этой секции, которая продолжается до тех пор, пока не начнётся следующая. В <code>[dependencies]</code> вы сообщаете Cargo, от каких внешних крейтов зависит ваш проект и какие исполнения этих крейтов вам нужны. В этом случае мы указываем крейт <code>rand</code> со спецификатором семантической исполнения <code>0.8.5</code>. Cargo понимает <a href="http://semver.org">семантическое версионирование</a> (иногда называемое <em>SemVer</em>), которое является стандартом для описания исполнений. Число <code>0.8.5</code> на самом деле является сокращением от <code>^0.8.5</code>, что означает любую исполнение не ниже <code>0.8.5</code>, но ниже <code>0.9.0</code>.</p>
<p>Cargo рассчитывает, что эти исполнения имеют общедоступное API, совместимое с исполнением <code>0.8.5</code>, и вы получите последние исполнения исправлений, которые по-прежнему будут собираться с кодом из этой главы. Не обеспечивается, что исполнение <code>0.9.0</code> или выше будет иметь тот же API, что и в следующих примерах.</p>
<p>Теперь, не меняя ничего в коде, давайте соберём проект, как показано в приложении 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Приложение 2-2: итог выполнения <code>cargo build</code> после добавления крейта rand в качестве зависимости</span></p>
<p>Вы можете увидеть другие номера исполнений (но все они будут совместимы с кодом благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.</p>
<p>Когда мы включаем внешнюю зависимость, Cargo берет последние исполнения всего, что нужно этой зависимости, из <em>реестра (registry)</em>, который является копией данных с <a href="https://crates.io/">Crates.io</a>. Crates.io — это место, где участники экосистемы Rust размещают свои проекты с открытым исходным кодом для использования другими.</p>
<p>После обновления реестра Cargo проверяет раздел <code>[dependencies]</code> и загружает все указанные в списке пакеты, которые ещё не были загружены. В нашем случае, хотя мы указали только <code>rand</code> в качестве зависимости, Cargo также захватил другие пакеты, от которых зависит работа <code>rand</code>. После загрузки пакетов Rust собирает их, а затем собирает проект с имеющимися зависимостями.</p>
<p>Если сразу же запустить <code>cargo build</code> снова, не внося никаких изменений, то кроме строки <code>Finished</code> вы не получите никакого вывода. Cargo знает, что он уже загрузил и собрал зависимости, и вы не вносили никаких изменений в файл <em>Cargo.toml</em>. Cargo также знает, что вы ничего не изменили в своём коде, поэтому он не пересоберет и его. Если делать нечего, он просто завершает работу.</p>
<p>Если вы откроете файл <em>src/main.rs</em>, внесёте тривиальное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле <em>src/main.rs</em>. Ваши зависимости не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и собрано для них.</p>
<h4 id="Обеспечение-воспроизводимых-сборок-с-помощью-файла-cargolock"><a class="header" href="#Обеспечение-воспроизводимых-сборок-с-помощью-файла-cargolock">Обеспечение воспроизводимых сборок с помощью файла <em>Cargo.lock</em></a></h4>
<p>В Cargo есть рычаг, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает ваш код. Пока вы не укажете обратное, Cargo будет использовать только те исполнения зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит исполнение 0.8.6 пакета <code>rand</code> , и она содержит важное исправление ошибки, но также регрессию, которая может сломать ваш код. Чтобы справиться с этим, Rust создаёт файл <em>Cargo.lock</em> при первом запуске <code>cargo build</code>, поэтому теперь он есть в каталоге <em>guessing_game</em>.</p>
<p>Когда вы создаёте проект в первый раз, Cargo определяет все исполнения зависимостей, которые соответствуют критериям, а затем записывает их в файл <em>Cargo.lock</em>. Когда вы будете собирать свой проект в будущем, Cargo увидит, что файл <em>Cargo.lock</em> существует, и будет использовать указанные там исполнения, а не выполнять всю работу по выяснению исполнений заново. Это позволяет самостоятельно создавать воспроизводимую сборку. Другими словами, ваш проект останется на <code>0.8.5</code> до тех пор, пока вы явно не обновите его благодаря файлу <em>Cargo.lock</em>. Поскольку файл <em>Cargo.lock</em> важен для воспроизводимых сборок, он часто хранится в системе управления исполнениями вместе с остальным кодом проекта.</p>
<h4 id="Обновление-пакета-для-получения-новой-исполнения"><a class="header" href="#Обновление-пакета-для-получения-новой-исполнения">Обновление пакета для получения новой исполнения</a></h4>
<p>Если вы <em>захотите</em> обновить пакет, Cargo предоставляет приказ <code>update</code>, которая пренебрегает файл <em>Cargo.lock</em> и определяет последние исполнения, соответствующие вашим спецификациям из файла <em>Cargo.toml</em>. После этого Cargo запишет эти исполнения в файл <em>Cargo.lock</em>. Иначе по умолчанию Cargo будет искать только исполнения больше 0.8.5, но при этом меньше 0.9.0. Если пакет <code>rand</code> имеет две новые исполнения — 0.8.6 и 0.9.0 — то при запуске <code>cargo update</code> вы увидите следующее:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo пренебрегает релиз 0.9.0. В этот время также появится изменение в файле <em>Cargo.lock</em>, указывающее на то, что исполнение <code>rand</code>, которая теперь используется, равна 0.8.6. Чтобы использовать <code>rand</code> исполнения 0.9.0 или любой другой исполнения из серии 0.9.<em>x</em>, необходимо обновить файл <em>Cargo.toml</em> следующим образом:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>В следующий раз, при запуске <code>cargo build</code>, Cargo обновит реестр доступных пакетов и пересмотрит ваши требования к <code>rand</code> в соответствии с новой исполнением, которую вы указали.</p>
<p>Можно много рассказать про <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> и <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">его экосистему</a><!-- ignore --> которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Rust разработчики имеют возможность писать меньшие проекты, которые составлены из многих пакетов.</p>
<h3 id="Генерация-случайного-числа"><a class="header" href="#Генерация-случайного-числа">Генерация случайного числа</a></h3>
<p>Давайте начнём использовать <code>rand</code>, чтобы сгенерировать число для угадывания. Следующим шагом будет обновление <em>src/main.rs</em>, как показано в приложении 2-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<p><span class="caption">Приложение 2-3: Добавление кода который генерирует случайное число</span></p>
<p>Сначала мы добавляем строку <code>use rand::Rng</code>. Типаж <code>Rng</code> определяет способы, реализующие генераторы случайных чисел, и этот типаж должен быть в области видимости, чтобы эти способы можно было использовать. В главе 10 мы рассмотрим типажи подробно.</p>
<p>Затем мы добавляем две строки посередине. В первой строке мы вызываем функцию <code>rand::thread_rng</code>, дающую нам генератор случайных чисел, который мы собираемся использовать: тот самый, который является местным для текущего потока выполнения и запускается операционной системой. Затем мы вызываем его способ <code>gen_range</code>. Этот способ определяется <code>Rng</code>, который мы включили в область видимости с помощью оператора <code>use rand::Rng</code>. Способ <code>gen_range</code> принимает в качестве переменной выражение ряда и генерирует случайное число в этом ряде. Вид используемого выражения ряда принимает разновидность <code>start..=end</code> и включает нижнюю и верхнюю границы, поэтому, чтобы запросить число от 1 до 100, нам нужно указать <code>1..=100</code>.</p>
<blockquote>
<p>Примечание: непросто сразу разобраться, какие типажи использовать, какие способы и функции вызывать из пакета, поэтому каждый пакет имеет документацию с указаниями по его использованию. Ещё одной замечательной особенностью Cargo является выполнение приказы <code>cargo doc --open</code>, которая местно собирает документацию, предоставляемую всеми вашими зависимостями, и открывает её в браузере. К примеру, если важна другая функциональность из пакета <code>rand</code>, запустите <code>cargo doc --open</code> и нажмите <code>rand</code> в боковой панели слева.</p>
</blockquote>
<p>Во второй новой строке мы увидим загаданное число. Во время разработки программы полезно иметь возможность её пропроверять, но в конечной исполнения мы это удалим. Конечно, ведь это совсем не похоже на игру, если программа печатает ответ сразу после запуска!</p>
<p>Попробуйте запустить программу несколько раз:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Вы должны получить разные случайные числа, и все они должны быть числами в ряде от 1 до 100. Отличная работа!</p>
<h2 id="Сравнение-догадки-с-тайным-числом"><a class="header" href="#Сравнение-догадки-с-тайным-числом">Сравнение догадки с тайным числом</a></h2>
<p>Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем сравнить их. Этот шаг показан в приложении 2-4. Учтите, что этот код ещё не ссобирается, подробнее мы объясним дальше.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<p><span class="caption">Приложение 2-4: Обработка возможных возвращаемых значений при сравнении двух чисел</span></p>
<p>Сначала добавим ещё один оператор <code>use</code>, который вводит вид с именем <code>std::cmp::Ordering</code> в область видимости из встроенной библиотеки. Вид <code>Ordering</code> является ещё одним перечислением и имеет варианты <code>Less</code>, <code>Greater</code> и <code>Equal</code>. Это три возможных исхода при сравнении двух величин.</p>
<p>После чего ниже добавляем пять новых строк, использующих вид <code>Ordering</code>. Способ <code>cmp</code> сравнивает два значения и может вызываться для всего, что можно сравнить. Он принимает ссылку на все, что требуется сравнить: здесь сравнивается <code>guess</code> с <code>secret_number</code>. В итоге возвращается вариант перечисления <code>Ordering</code>, которое мы ввели в область видимости с помощью оператора <code>use</code>. Для принятия решения о том, что делать дальше, мы используем выражение <a href="ch06-02-match.html"><code>match</code></a>, определяющее, какой вариант <code>Ordering</code> был возвращён из вызова <code>cmp</code> со значениями <code>guess</code> и <code>secret_number</code>.</p>
<p>Выражение <code>match</code> состоит из <em>веток (arms)</em>. Ветка состоит из <em>шаблона</em> для сопоставления и кода, который будет запущен, если значение, переданное в <code>match</code>, соответствует шаблону этой ветки. Rust принимает значение, заданное <code>match</code>, и по очереди просматривает шаблон каждой ветки. Шаблоны и конструкция <code>match</code> — это мощные возможности Rust, позволяющие выразить множество случаев, с которыми может столкнуться ваш код, и обеспечить их обработку. Эти возможности будут подробно раскрыты в главе 6 и главе 18 соответственно.</p>
<p>Давайте рассмотрим пример с выражением <code>match</code>, которое мы здесь используем. Скажем, пользователь угадал 50, а случайно сгенерированное тайное число на этот раз — 38.</p>
<p>Когда код сравнивает 50 с 38, способ <code>cmp</code> вернёт <code>Ordering::Greater</code>, поскольку 50 больше, чем 38. Выражение <code>match</code> получит значение <code>Ordering::Greater</code> и начнёт проверять шаблон в каждой ветке. Он просмотрит шаблон первой ветки, <code>Ordering::Less</code>, и увидит, что значение <code>Ordering::Greater</code> не соответствует <code>Ordering::Less</code>, поэтому пропренебрегает код этой ветки и перейдёт к следующей. Шаблон следующей ветки — <code>Ordering::Greater</code>, который <em>соответствует</em> <code>Ordering::Greater</code>! Код этой ветки будет выполнен и напечатает <code>Too big!</code> на экран. Выражение <code>match</code> заканчивается после первого успешного совпадения, поэтому в этом сценарии оно не будет рассматривать последнюю ветку.</p>
<p>Однако код в приложении 2-4 всё ещё не ссобирается. Давайте попробуем:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs:840:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>Суть ошибки заключается в наличии <em>несовпадающих видов</em>. У Rust строгая постоянная система видов. Однако в нем также есть рычаг вывода видов. Когда мы написали <code>let mut guess = String::new()</code>, Rust смог сделать вывод, что <code>guess</code> должна быть <code>String</code> и не заставил указывать вид. С другой стороны, <code>secret_number</code> — это числовой вид. Несколько видов чисел в Rust могут иметь значение от 1 до 100: <code>i32</code>, 32-битное число; <code>u32</code>, беззнаковое 32-битное число; <code>i64</code>, 64-битное число, и так далее. Если не указано иное, Rust по умолчанию использует <code>i32</code>, который будет видом <code>secret_number</code>, если вы не добавите сведения о виде где-то ещё, чтобы заставить Rust вывести другой числовой вид. Причина ошибки заключается в том, что Rust не может сравнить строку и числовой вид.</p>
<p>В конечном итоге необходимо преобразовать <code>String</code>, считываемую программой в качестве входных данных, в существующий числовой вид, чтобы иметь возможность числового сравнения с загаданным числом. Для этого добавьте в тело функции <code>main</code> следующую строку:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p>Вот эта строка:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>Мы создаём переменную с именем <code>guess</code>. Но подождите, разве в программе уже нет переменной с этим именем <code>guess</code>? Так и есть, но Rust позволяет нам затенять предыдущее значение <code>guess</code> новым. <em>Затенение</em> позволяет нам повторно использовать имя переменной <code>guess</code>, чтобы избежать создания двух единственных переменных, таких как <code>guess_str</code> и <code>guess</code>, например. Мы рассмотрим это более подробно в главе 3, а пока знайте, что эта функция часто используется, когда необходимо преобразовать значение из одного вида в другой.</p>
<p>Мы связываем эту новую переменную с выражением <code>guess.trim().parse()</code>. Переменная <code>guess</code> в этом выражении относится к исходной переменной <code>guess</code>, которая содержала входные данные в виде строки. Способ <code>trim</code> на образце <code>String</code> удалит любые пробельные символы в начале и конце строки для того, чтобы мы могли сопоставить строку с <code>u32</code>, который содержит только числовые данные. Пользователь должен нажать <span class="keystroke">enter</span>, чтобы выполнить <code>read_line</code> и ввести свою догадку, при этом в строку добавится символ новой строки. Например, если пользователь набирает <span class="keystroke">5</span> и нажимает <span class="keystroke">enter</span>, <code>guess</code> будет выглядеть так: <code>5\n</code>. Символ <code>\n</code> означает "новая строка". (В Windows нажатие <span class="keystroke">enter</span> сопровождается возвратом каретки и новой строкой, <code>\r\n</code>). Способ <code>trim</code> убирает <code>\n</code> или <code>\r\n</code>, оставляя только <code>5</code>.</p>
<p>Способ <a href="../std/primitive.str.html#method.parse"><code>parse</code> строк</a><!-- ignore --> преобразует строку в другой вид. Здесь мы используем его для преобразования строки в число. Нам нужно сообщить Rust точный числовой вид, который мы хотим получить, используя <code>let guess: u32</code>. Двоеточие ( <code>:</code> ) после <code>guess</code> говорит Rust, что мы аннотируем вид переменной. В Rust есть несколько встроенных числовых видов; <code>u32</code>, показанный здесь, представляет собой 32-битное целое число без знака. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других видах чисел в главе 3.</p>
<p>Кроме того, изложение <code>u32</code> в этом примере программы и сравнение с <code>secret_number</code> означает, что Rust сделает вывод, что <code>secret_number</code> должен быть <code>u32</code>. Итак, теперь сравнение будет между двумя значениями одного типа!</p>
<p>Способ <code>parse</code> будет работать только с символами, которые логически могут быть преобразованы в числа, и поэтому легко может вызвать ошибки. Если, например, строка содержит <code>A👍%</code>, преобразовать её в число невозможно. Так как способ <code>parse</code> может потерпеть неудачу, он возвращает вид <code>Result</code> — так же как и способ <code>read_line</code> (обсуждалось ранее в разделе <a data-md-type="raw_html" href="#handling-potential-failure-with-result">«Обработка возможной ошибки с помощью вида <code>Result</code>»</a>). Мы будем точно так же обрабатывать данный <code>Result</code>, вновь используя способ <code>expect</code>. Если <code>parse</code> вернёт вариант <code>Result</code> <code>Err</code>, так как не смог создать число из строки, вызов <code>expect</code> аварийно завершит игру и отобразит переданное ему сообщение. Если <code>parse</code> сможет успешно преобразовать строку в число, он вернёт вариант <code>Result</code> <code>Ok</code>, а <code>expect</code> вернёт число, полученное из значения <code>Ok</code>.</p>
<p>Давайте запустим программу теперь:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Хорошо! Несмотря на то, что были добавлены пробелы в строке ввода, программа всё равно поняла, что пользователь имел в виду число 76. Запустите программу несколько раз, чтобы проверить разное поведение при различных видах ввода: задайте число правильно, задайте слишком большое число и задайте слишком маленькое число.</p>
<p>Сейчас у нас работает большая часть игры, но пользователь может сделать только одну догадку. Давайте изменим это, добавив цикл!</p>
<h2 id="Возможность-нескольких-догадок-с-помощью-циклов"><a class="header" href="#Возможность-нескольких-догадок-с-помощью-циклов">Возможность нескольких догадок с помощью циклов</a></h2>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Мы добавляем цикл, чтобы дать пользователям больше шансов угадать число:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p>Как видите, мы перемеисполнения всё, начиная с подсказки ввода догадки, в цикл. Не забудьте добавить ещё по четыре пробела на отступы строк внутри цикла и запустите программу снова. Теперь программа будет бесконечно запрашивать ещё одну догадку, что в действительности создаёт новую неполадку. Похоже, пользователь не сможет выйти из игры!</p>
<p>Пользователь может прервать выполнение программы с помощью сочетания клавиш <span class="keystroke">ctrl+c</span>. Но есть и другой способ спастись от этого ненасытного монстра, о котором говорилось при обсуждении <code>parse</code> в <a href="#comparing-the-guess-to-the-secret-number">«Сравнение догадки с тайным числом»</a>: если пользователь введёт нечисловой ответ, программа завершится аварийно. Мы можем воспользоваться этим, чтобы позволить пользователю выйти из игры, как показано здесь:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ввод <code>quit</code> приведёт к выходу из игры, но, как вы заметите, так же будет и при любом другом нечисловом вводе. Однако это, мягко говоря, не разумно. Мы хотим, чтобы игра самостоятельно остановилась, когда будет угадано правильное число.</p>
<h3 id="Выход-после-правильной-догадки"><a class="header" href="#Выход-после-правильной-догадки">Выход после правильной догадки</a></h3>
<p>Давайте запрограммируем игру на выход при выигрыше пользователя, добавив оператор <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p>Добавление строки <code>break</code> после <code>You win!</code> заставляет программу выйти из цикла, когда пользователь правильно угадает тайное число. Выход из цикла также означает выход из программы, так как цикл является последней частью <code>main</code>.</p>
<h3 id="Обработка-недопустимого-ввода"><a class="header" href="#Обработка-недопустимого-ввода">Обработка недопустимого ввода</a></h3>
<p>Чтобы улучшить поведение игры, вместо аварийного завершения программы, когда пользователь вводит не число, давайте заставим игру пренебрегать этотобстоятельство, позволяя пользователю продолжить угадывание. Для этого необходимо изменить строку, в которой <code>guess</code> преобразуется из <code>String</code> в <code>u32</code>, как показано в приложении 2-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 2-5. Пренебрежение нечисловой догадки и запрос другой догадки вместо завершения программы</span></p>
<p>Мы заменяем вызов <code>expect</code> на выражение <code>match</code>, чтобы перейти от аварийного завершения при ошибке к обработке ошибки. Помните, что <code>parse</code> возвращает вид <code>Result</code>, а <code>Result</code> — это перечисление, которое имеет варианты <code>Ok</code> и <code>Err</code>. Здесь мы используем выражение <code>match</code>, как и в случае с итогом <code>Ordering</code> способа <code>cmp</code>.</p>
<p>Если <code>parse</code> успешно преобразует строку в число, он вернёт значение <code>Ok</code>, содержащее полученное число. Это значение <code>Ok</code> будет соответствовать шаблону первой ветки, а выражение <code>match</code> просто вернёт значение <code>num</code>, которое <code>parse</code> произвёл и поместил внутрь значения <code>Ok</code>. Это число окажется в нужной нам переменной <code>guess</code>, которую мы создали.</p>
<p>Если способ <code>parse</code> <em>не способен</em> превратить строку в число, он вернёт значение <code>Err</code>, которое содержит более подробную сведения об ошибке. Значение <code>Err</code> не совпадает с шаблоном <code>Ok(num)</code> в первой ветке <code>match</code>, но совпадает с шаблоном <code>Err(_)</code> второй ветки. Подчёркивание <code>_</code> является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений <code>Err</code>, независимо от того, какая сведения находится внутри. Поэтому программа выполнит код второй ветки, <code>continue</code>, который сообщает программе перейти к следующей повторения <code>loop</code> и запросить ещё одну догадку. В этом случае программа эффективно пренебрегает все ошибки, с которыми <code>parse</code> может столкнуться!</p>
<p>Всё в программе теперь должно работать как положено. Давайте попробуем:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Потрясающе! С помощью одной маленькой последней правки мы закончим игру в угадывание. Напомним, что программа все ещё печатает тайное число. Это хорошо подходило для проверки, но это портит игру. Давайте удалим <code>println!</code>, который выводит тайное число. В Приложении 2-6 показан окончательный вариант кода.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Приложение 2-6: полный код игры</span></p>
<p>На данный время вы успешно создали игру в загадки. Поздравляем!</p>
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Этот проект — опытный способ познакомить вас со многими новыми подходами Rust: <code>let</code>, <code>match</code>, функции, использование внешних крейтов и многое другое. В следующих нескольких главах вы изучите эти подходы более подробно. Глава 3 охватывает понятия, которые есть в большинстве языков программирования, такие как переменные, виды данных и функции, и показывает, как использовать их в Rust. В главе 4 рассматривается владение — особенность, которая отличает Rust от других языков. В главе 5 обсуждаются структуры и правила написания способов, а в главе 6 объясняется, как работают перечисления.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
