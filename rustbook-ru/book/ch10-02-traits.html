<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Трейты (характеристики): определение разделяемого поведения - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Типажи-определение-общего-поведения"><a class="header" href="#Типажи-определение-общего-поведения">Типажи: определение общего поведения</a></h2>
<p><em>Типаж</em> сообщает сборщику Rust о функциональности, которой обладает определённый вид и которой он может поделиться с другими видами. Можно использовать типажи, чтобы определять общее поведение абстрактным способом. Мы можем использовать <em>ограничение типажа</em> (trait bounds) чтобы указать, что общим видом может быть любой вид, который имеет определённое поведение.</p>
<blockquote>
<p>Примечание: Типажи похожи на функциональность часто называемую <em>внешней оболочкими</em> в других языках программирования, хотя и с некоторыми отличиями.</p>
</blockquote>
<h3 id="Определение-типажа"><a class="header" href="#Определение-типажа">Определение типажа</a></h3>
<p>Поведение вида определяется теми способами, которые мы можем вызвать у данного вида. Различные виды разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов. Определение типажей - это способ сгруппировать сигнатуры способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.</p>
<p>Например, пусть есть несколько структур, которые имеют различный вид и различный размер текста: структура <code>NewsArticle</code>, которая содержит новость, напечатанную в каком-то месте мира; структура <code>Tweet</code>, которая содержит 280 символьную строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.</p>
<p>Мы хотим создать крейт библиотеки медиа-агрегатора <code>aggregator</code>, которая может отображать сводку данных сохранённых в экземплярах структур <code>NewsArticle</code> или <code>Tweet</code>. Чтобы этого достичь, нам необходимо иметь возможность для каждой структуры получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ <code>summarize</code>. Приложение 10-12 показывает определение типажа <code>Summary</code>, который выражает это поведение.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 10-12: Определение типажа <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span></p>
<p>Здесь мы объявляем типаж с использованием ключевого слова <code>trait</code>, а затем его название, которым в нашем случае является <code>Summary</code>. Также мы объявляем крейт как <code>pub</code> что позволяет крейтам, зависящим от нашего крейта, тоже использовать наш крейт, что мы увидим в последующих примерах. Внутри фигурных скобок объявляются сигнатуры способов, которые описывают поведения видов, реализующих данный типаж, в данном случае поведение определяется только одной сигнатурой способа <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>После сигнатуры способа, вместо предоставления реализации в фигурных в скобках, мы используем точку с запятой. Каждый вид, реализующий данный типаж, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид содержащий типаж <code>Summary</code>, будет также иметь и способ <code>summarize</code> объявленный с точно такой же сигнатурой.</p>
<p>Типаж может иметь несколько способов в описании его тела: сигнатуры способов перечисляются по одной на каждой строке и должны закачиваться символом <code>;</code>.</p>
<h3 id="Реализация-типажа-у-вида"><a class="header" href="#Реализация-типажа-у-вида">Реализация типажа у вида</a></h3>
<p>Теперь, после того как мы определили желаемое поведение используя типаж <code>Summary</code>, можно реализовать его у видов в нашем медиа-агрегаторе. Приложение 10-13 показывает реализацию типажа <code>Summary</code> у структуры <code>NewsArticle</code>, которая использует для создания сводки в способе <code>summarize</code> заголовок, автора и место публикации статьи. Для структуры <code>Tweet</code> мы определяем реализацию <code>summarize</code> используя имя пользователя и следующий за ним полный текст твита, полагая что содержание твита уже ограничено 280 символами.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 10-13: Реализация типажа <code>Summary</code> для структур <code>NewsArticle</code> и <code>Tweet</code></span></p>
<p>Реализация типажа у вида подобна реализации обычных способов. Разница в том что после <code>impl</code> мы ставим имя типажа, который мы хотим реализовать, затем используем ключевое слово <code>for</code>, а затем указываем имя вида, для которого мы хотим сделать реализацию типажа. Внутри раздела <code>impl</code> мы помещаем сигнатуру способа объявленную в типаже. Вместо добавления точки с запятой в конце, после каждой сигнатуры используются фигурные скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов типажа для определенного вида.</p>
<p>Теперь когда библиотека реализовала типаж <code>Summary</code> для <code>NewsArticle</code> и <code>Tweet</code>, программисты использующие крейт могут вызывать способы типажа у экземпляров видов <code>NewsArticle</code> и <code>Tweet</code> точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести типаж в область видимости точно так же как и виды. Здесь пример того как двоичный крейт может использовать наш <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}</code></pre>
<p>Данный код напечатает: <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Другие крейты, которые зависят от <code>aggregator</code>, тоже могу включить типаж <code>Summary</code> в область видимости для реализации <code>Summary</code> в их собственных видах. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем реализовать типаж для вида только в том случае, если хотя бы один из типажей вида является местным для нашего крейта. Например, мы можем реализовать стандартный библиотечный типаж <code>Display</code> на собственном виде <code>Tweet</code> как часть функциональности нашего крейта <code>aggregator</code> потому что вид <code>Tweet</code> является местным для крейта <code>aggregator</code>. Также мы можем реализовать <code>Summary</code> для <code>Vec&lt;T&gt;</code> в нашем крейте <code>aggregator</code>, потому что типаж <code>Summary</code> является местным для нашего крейта <code>aggregator</code>.</p>
<p>Но мы не можем реализовать внешние типажи для внешних видов. Например, мы не можем реализовать типаж <code>Display</code> для <code>Vec&lt;T&gt;</code> внутри нашего крейта <code>aggregator</code>, потому что <code>Display</code> и <code>Vec&lt;T&gt;</code> оба определены в встроенной библиотеке а не местно в нашем крейте <code>aggregator</code>. Это ограничение является частью свойства называемого <em>согласованность</em> (coherence), а ещё точнее <em>сиротское правило</em> (orphan rule), которое называется так потому что не представлен родительский вид. Это правило заверяет, что код других людей не может сломать ваш код и наоборот. Без этого правила два крейта могли бы реализовать один типаж для одинакового вида и Rust не сможет понять, какой реализацией нужно пользоваться.</p>
<h3 id="Реализация-поведения-по-умолчанию"><a class="header" href="#Реализация-поведения-по-умолчанию">Реализация поведения по умолчанию</a></h3>
<p>Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в типаже вместо того, чтобы требовать реализации всех способов в каждом виде, реализующим данный типаж. Затем, когда мы реализуем типаж для определённого вида, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов.</p>
<p>В примере 10-14 показано, как указать строку по умолчанию для способа <code>summarize</code> из типажа <code>Summary</code> вместо определения только сигнатуры способа, как мы сделали в примере 10-12.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 10-14: Определение типажа <code>Summary</code> с реализацией способа <code>summarize</code> по умолчанию</span></p>
<p>Для использования реализации по умолчанию при создании сводки у экземпляров <code>NewsArticle</code> вместо определения пользовательской реализации, мы указываем пустой раздел<code>impl</code> с <code>impl Summary for NewsArticle {}</code>.</p>
<p>Хотя мы больше не определяем способ <code>summarize</code> непосредственно в <code>NewsArticle</code>, мы предоставили реализацию по умолчанию и указали, что <code>NewsArticle</code> реализует типаж <code>Summary</code>. В результате мы всё ещё можем вызвать способ <code>summarize</code> у экземпляра <code>NewsArticle</code>, например так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}</code></pre>
<p>Этот код печатает <code>New article available! (Read more...)</code> .</p>
<p>Создание реализации по умолчанию не требует от нас изменений чего-либо в реализации <code>Summary</code> для <code>Tweet</code> в приложении 10-13. Причина заключается в том, что синтаксис для переопределения реализации по умолчанию является таким же, как синтаксис для реализации способа типажа, который не имеет реализации по умолчанию.</p>
<p>Реализации по умолчанию могут вызывать другие способы в том же типаже, даже если эти другие способы не имеют реализации по умолчанию. Таким образом, типаж может предоставить много полезной функциональности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить типаж <code>Summary</code> имеющий способ <code>summarize_author</code>, реализация которого требуется, а затем определить способ <code>summarize</code> который имеет реализацию по умолчанию, которая внутри вызывает способ <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}</code></pre>
<p>Чтобы использовать такую исполнение типажа <code>Summary</code>, нужно только определить способ <code>summarize_author</code>, при реализации типажа для вида:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}</code></pre>
<p>После того, как мы определим <code>summarize_author</code>, можно вызвать <code>summarize</code> для экземпляров структуры <code>Tweet</code> и реализация по умолчанию способа <code>summarize</code> будет вызывать определение <code>summarize_author</code> которое мы уже предоставили. Так как мы реализовали способ <code>summarize_author</code> типажа <code>Summary</code>, то типаж даёт нам поведение способа <code>summarize</code> без необходимости писать код.</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}</code></pre>
<p>Этот код печатает <code>1 new tweet: (Read more from @horse_ebooks...)</code> .</p>
<p>Обратите внимание, что невозможно вызвать реализацию по умолчанию из переопределённой реализации того же способа.</p>
<h3 id="Типажи-как-свойства"><a class="header" href="#Типажи-как-свойства">Типажи как свойства</a></h3>
<p>Теперь, когда вы знаете, как определять и реализовывать типажи, можно изучить, как использовать типажи, чтобы определить функции, которые принимают много различных видов. Мы будем использовать типаж <code>Summary</code>,  реализованный для видов <code>NewsArticle</code> и <code>Tweet</code> в приложении 10-13, чтобы определить функцию <code>notify</code>, которая вызывает способ <code>summarize</code> для его свойства <code>item</code>, который имеет некоторый вид, реализующий типаж <code>Summary</code>. Для этого мы используем синтаксис <code>impl Trait</code> примерно так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}</code></pre>
<p>Вместо определенного вида у свойства <code>item</code> указывается ключевое слово <code>impl</code> и имя типажа. Этот свойство принимает любой вид, который реализует указанный типаж. В теле <code>notify</code> мы можем вызывать любые способы у экземпляра <code>item</code> , которые приходят с типажом <code>Summary</code>, такие как способ <code>summarize</code>. Мы можем вызвать <code>notify</code> и передать в него любой экземпляр <code>NewsArticle</code> или <code>Tweet</code>. Код, который вызывает данную функцию с любым другим видом, таким как <code>String</code> или <code>i32</code>, не будет собираться, потому что эти виды не реализуют типаж <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="Синтаксис-ограничения-типажа"><a class="header" href="#Синтаксис-ограничения-типажа">Синтаксис ограничения типажа</a></h4>
<p>Синтаксис <code>impl Trait</code> работает для простых случаев, но на самом деле является синтаксическим сахаром для более длинной формы, которая называется <em>ограничением типажа</em> (trait bound); это выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>Эта более длинная форма эквивалентна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида с ограничением типажа после двоеточия внутри угловых скобок.</p>
<p>Синтаксис <code>impl Trait</code> удобен и делает код более сжатым в простых случаях, в то время как более полный синтаксис с ограничением типажа в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые реализуют типаж  <code>Summary</code>. Использование синтаксиса  <code>impl Trait</code> выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Использовать <code>impl Trait</code> удобнее если мы хотим разрешить функции иметь разные виды для <code>item1</code> и <code>item2</code> (но оба вида должны реализовывать <code>Summary</code>). Если же мы хотим заставить оба свойства иметь один и тот же вид, то мы должны использовать ограничение типажа так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Обобщённый вид <code>T</code> указан для видов свойств <code>item1</code> и <code>item2</code> и ограничивает функцию так, что определенные значения видов переданные переменнойми для <code>item1</code> и <code>item2</code> должны быть одинаковыми.</p>
<h4 id="Задание-нескольких-границ-типажей-с-помощью-синтаксиса-"><a class="header" href="#Задание-нескольких-границ-типажей-с-помощью-синтаксиса-">Задание нескольких границ типажей с помощью синтаксиса <code>+</code></a></h4>
<p>Также можно указать более одного ограничения типажа. Допустим, мы хотели бы чтобы <code>notify</code> использовал как форматирование вывода так и  <code>summarize</code> для свойства <code>item</code>: <br>тогда мы указываем что в <code>notify</code> свойство <code>item</code> должен реализовывать оба типажа <code>Display</code> и <code>Summary</code>. Мы можем сделать это используя синтаксис <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>Синтаксис <code>+</code> также допустим с ограничениями типажа для обобщённых видов:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>При наличии двух ограничений типажа, тело способа <code>notify</code> может вызывать <code>summarize</code> и использовать <code>{}</code> для форматирования <code>item</code> при его печати.</p>
<h4 id="Более-ясные-границы-типажа-с-помощью-where"><a class="header" href="#Более-ясные-границы-типажа-с-помощью-where">Более ясные границы типажа с помощью <code>where</code></a></h4>
<p>Использование слишком большого количества ограничений типажа имеет свои недостатки. Каждый обобщённый вид имеет свои границы типажа, поэтому функции с несколькими свойствами обобщённого вида могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение сигнатуры. По этой причине в Rust есть иной синтаксис для определения ограничений типажа внутри предложения <code>where</code> после сигнатуры функции. Поэтому вместо того, чтобы писать так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>можно использовать <code>where</code> таким образом:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}</code></pre>
<p>Сигнатура этой функции менее загромождена: название функции, список свойств, и возвращаемый вид находятся рядом, а сигнатура не содержит в себе множество ограничений типажа.</p>
<h3 id="Возврат-значений-вида-реализующего-определённый-типаж"><a class="header" href="#Возврат-значений-вида-реализующего-определённый-типаж">Возврат значений вида реализующего определённый типаж</a></h3>
<p>Также можно использовать синтаксис <code>impl Trait</code> в возвращаемой позиции, чтобы вернуть значение некоторого вида реализующего типаж, как показано здесь:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}</code></pre>
<p>Используя <code>impl Summary</code> для возвращаемого вида, мы указываем, что функция <code>returns_summarizable</code> возвращает некоторый вид, который реализует типаж <code>Summary</code> без обозначения определенного вида. В этом случае <code>returns_summarizable</code> возвращает <code>Tweet</code>, но код, вызывающий эту функцию, этого не знает.</p>
<p>Возможность возвращать вид, который определяется только реализуемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды, которые знает только сборщик или виды, которые очень долго указывать. Синтаксис <code>impl Trait</code> позволяет кратко указать, что функция возвращает некоторый вид, который реализует типаж <code>Iterator</code> без необходимости писать очень длинный вид.</p>
<p>Однако, <code>impl Trait</code> возможно использовать, если возвращаете только один вид. Например, данный код, который возвращает значения или вида <code>NewsArticle</code> или вида <code>Tweet</code>, но в качестве возвращаемого вида объявляет <code>impl Summary</code> , не будет работать:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}</code></pre>
<p>Возврат либо <code>NewsArticle</code> либо <code>Tweet</code> не допускается из-за ограничений того, как реализован синтаксис <code>impl Trait</code> в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">"Использование объектов типажей, которые разрешены для значений или разных видов"</a><!--  --> Главы 17.</p>
<h3 id="Использование-ограничений-типажа-для-условной-реализации-способов"><a class="header" href="#Использование-ограничений-типажа-для-условной-реализации-способов">Использование ограничений типажа для условной реализации способов</a></h3>
<p>Используя ограничение типажа с разделом <code>impl</code>, который использует свойства обобщённого вида, можно реализовать способы условно, для тех видов, которые реализуют указанный типаж. Например, вид <code>Pair&lt;T&gt;</code>  в приложении 10-15 всегда реализует функцию  <code>new</code> для возврата нового экземпляра <code>Pair&lt;T&gt;</code> (вспомните раздел <a href="ch05-03-method-syntax.html#defining-methods">“Определение способов”</a><!-- ignore --> Главы 5 где <code>Self</code> является псевдонимом вида для вида раздела <code>impl</code>, который в данном случае является <code>Pair&lt;T&gt;</code>). Но в следующем разделе <code>impl</code> вид <code>Pair&lt;T&gt;</code> реализует способ  <code>cmp_display</code> только если его внутренний вид <code>T</code> реализует типаж <code>PartialOrd</code> (позволяющий сравнивать) <em>и</em> типаж <code>Display</code> (позволяющий выводить на печать).</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 10-15: Условная реализация способов у обобщённых видов в зависимости от ограничений типажа</span></p>
<p>Мы также можем условно реализовать типаж для любого вида, который реализует другой типаж. Реализации типажа для любого вида, который удовлетворяет ограничениям типажа, называются <em>общими реализациями</em> и широко используются в встроенной библиотеке Rust. Например, стандартная библиотека реализует типаж <code>ToString</code> для любого вида, который реализует типаж <code>Display</code>. Раздел<code>impl</code> в встроенной библиотеке выглядит примерно так:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать способ <code>to_string</code> определённый типажом <code>ToString</code> для любого вида, который реализует типаж <code>Display</code>. Например, мы можем превратить целые числа в их соответствующие <code>String</code> значения, потому что целые числа реализуют типаж <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Общие реализации приведены в документации к типажу в разделе "Implementors".</p>
<p>Типажи и ограничения типажей позволяют писать код, который использует свойства обобщённого вида для уменьшения повторения кода, а также указывая сборщику, что мы хотим обобщённый вид, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения типажа, чтобы проверить, что все определенные виды, используемые с нашим кодом, обеспечивают правильное поведение.  В изменяемых типизированных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида, который не реализует вид определяемый способом. Но Rust перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить проблемы, прежде чем наш код начнёт работать. Кроме того, мы не должны писать код, который проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
