<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Продвинутые типажи - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html" class="active"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Продвинутые-типажи"><a class="header" href="#Продвинутые-типажи">Продвинутые типажи</a></h2>
<p>Мы познакомились с трейтами в разделе <a href="ch10-02-traits.html#traits-defining-shared-behavior">"Трейты: Определение общего поведения"</a><!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Rust, мы можем перейти к более подробному рассмотрению.</p>
<h3 id="Указание-видов-заполнителей-в-определениях-трейтов-с-ассоциированными-видами"><a class="header" href="#Указание-видов-заполнителей-в-определениях-трейтов-с-ассоциированными-видами">Указание видов-заполнителей в определениях трейтов с ассоциированными видами</a></h3>
<p><em>Ассоциированные виды</em> связывают вид-заполнитель с типажом таким образом, что определения способов типажа могут использовать эти виды-заполнители в своих сигнатурах. Для именно реализации типажа вместо типа-заполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить типажи, использующие некоторые виды, без необходимости точно знать, что это за виды, пока типажи не будут реализованы.</p>
<p>Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Ассоциированные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.</p>
<p>Одним из примеров трейта с ассоциированным видом является типаж <code>Iterator</code> из встроенной библиотеки. Ассоциированный вид называется <code>Item</code> и символизирует вид значений, по которым повторяется вид, реализующий типаж <code>Iterator</code>. Определение трейта <code>Iterator</code> показано в приложении 19-12.</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-12: Определение трейта <code>Iterator</code>, который имеет ассоциированный вид <code>Item</code></span></p>
<p>Вид <code>Item</code> является заполнителем и определение способа <code>next</code> показывает, что он будет возвращать значения вида <code>Option&lt;Self::Item&gt;</code>. Разработчики типажа <code>Iterator</code> определят определенный вид для <code>Item</code>, а способ <code>next</code> вернёт <code>Option</code> содержащий значение этого определенного вида.</p>
<p>Ассоциированные виды могут показаться концепцией похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя концепциями, мы рассмотрим реализацию типажа <code>Iterator</code> для вида с именем <code>Counter</code>, который указывает, что вид <code>Item</code> равен <code>u32</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}</code></pre>
<p>Этот синтаксис весьма напоминает обобщённые виды. Так почему же типаж <code>Iterator</code> не определён обобщённым видом, как показано в приложении 19-13?</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-13: Гипотетическое определение типажа <code>Iterator</code> используя обобщённые виды</span></p>
<p>Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны аннотировать виды в каждой реализации; потому что мы также можем реализовать <code>Iterator&lt;String&gt; for Counter</code> или любого другого вида, мы могли бы иметь несколько реализации <code>Iterator</code> для <code>Counter</code>. Другими словами, когда типаж имеет обобщённый свойство, он может быть реализован для вида несколько раз, каждый раз меняя определенные виды свойств обобщённого вида. Когда мы используем способ <code>next</code> у <code>Counter</code>, нам пришлось бы предоставить изложении вида, указывая какую реализацию <code>Iterator</code> мы хотим использовать.</p>
<p>С ассоциированными видами не нужно аннотировать виды, потому что мы не можем реализовать типаж у вида несколько раз. В приложении 19-12 с определением, использующим ассоциированные виды можно выбрать только один вид <code>Item</code>, потому что может быть только одно объявление <code>impl Iterator for Counter</code>. Нам не нужно указывать, что нужен повторительзначений вида <code>u32</code> везде, где мы вызываем <code>next</code> у <code>Counter</code>.</p>
<p>Ассоциированные виды также становятся частью контракта типажа: разработчики типажа должны предоставить вид, который заменит ассоциированный заполнитель вида. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошей практикой является документирование связанного вида в документации по API.</p>
<h3 id="Свойства-обобщённого-вида-по-умолчанию-и-перегрузка-операторов"><a class="header" href="#Свойства-обобщённого-вида-по-умолчанию-и-перегрузка-операторов">Свойства обобщённого вида по умолчанию и перегрузка операторов</a></h3>
<p>Когда мы используем свойства обобщённого вида, мы можем указать определенный вид по умолчанию для обобщённого вида. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида с помощью синтаксиса  <code>&lt;PlaceholderType=ConcreteType&gt;</code>.</p>
<p>Отличным примером, когда этот способ полезен, является <em>перегрузка оператора</em> (operator overloading), когда вы настраиваете поведение оператора (например, <code>+</code> ) для определённых ситуаций.</p>
<p>Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Но можно перегрузить перечисленные действия и соответствующие им типажи из <code>std::ops</code> путём реализации типажей, связанных с этими операторами. Например, в приложении 19-14 мы перегружаем оператор <code>+</code>, чтобы складывать два экземпляра <code>Point</code>. Мы делаем это реализуя типаж <code>Add</code> для структуры <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-14: Реализация типажа <code>Add</code> для перегрузки оператора <code>+</code> для экземпляров <code>Point</code></span></p>
<p>Способ <code>add</code> складывает значения <code>x</code> двух экземпляров <code>Point</code> и значения <code>y</code> у <code>Point</code> для создания нового экземпляра <code>Point</code>. Типаж <code>Add</code> имеет ассоциированный вид с именем <code>Output</code>, который определяет вид, возвращаемый из способа <code>add</code>.</p>
<p>Обобщённый вид по умолчанию в этом коде находится в типаже <code>Add</code> . Вот его определение:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Этот код должен выглядеть знакомым: типаж с одним способом и ассоциированным видом. Новый синтаксис это <code>RHS=Self</code>. Такой синтаксис называется <em>свойства вида по умолчанию</em> (default type parameters). Свойство обобщённого вида <code>RHS</code> (сокращённо “right hand side”) определяет вид свойства <code>rhs</code> в способе <code>add</code>. Если мы не укажем определенный вид для <code>RHS</code> при реализации типажа <code>Add</code>, то видом для <code>RHS</code> по умолчанию будет <code>Self</code>, который будет видом для которого реализуется типаж <code>Add</code>.</p>
<p>Когда мы реализовали <code>Add</code> для структуры <code>Point</code>, мы использовали стандартное значение для <code>RHS</code>, потому что хотели сложить два экземпляра <code>Point</code>. Давайте посмотрим на пример реализации типажа <code>Add</code>, где мы хотим пользовательский вид <code>RHS</code> вместо использования вида по умолчанию.</p>
<p>У нас есть две разные структуры <code>Millimeters</code> и <code>Meters</code>, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида в другую структуру известно как шаблон <em>newtype</em>, который мы более подробно опишем в разделе <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">"Шаблон Newtype для реализация внешних типажей у внешних видов"</a><!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь реализацию типажа <code>Add</code>, которая делает правильное преобразование единиц. Можно реализовать <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве <code>Rhs</code>, как показано в приложении 19-15.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 19-15: Реализация типажа <code>Add</code> для структуры  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span></p>
<p>Чтобы сложить <code>Millimeters</code> и <code>Meters</code>, мы указываем <code>impl Add&lt;Meters&gt;</code>, чтобы указать значение свойства вида <code>RHS</code> (Meters) вместо использования значения по умолчанию <code>Self</code> (Millimeters).</p>
<p>Свойства вида по умолчанию используются в двух основных случаях:</p>
<ul>
<li>Чтобы расширить вид без внесения изменений ломающих существующий код</li>
<li>Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей</li>
</ul>
<p>Типаж <code>Add</code> из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида, но типаж <code>Add</code> позволяет сделать больше. Использование свойства вида по умолчанию в объявлении типажа <code>Add</code> означает, что не нужно указывать дополнительный свойство большую часть времени. Другими словами, большая часть кода реализации не нужна, что делает использование типажа проще.</p>
<p>Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида к существующему типажу, можно дать ему значение по умолчанию, чтобы разрешить расширение функциональности типажа без нарушения кода существующей реализации.</p>
<h3 id="Полностью-квалифицированный-синтаксис-для-устранения-неоднозначности-вызов-способов-с-одинаковым-именем"><a class="header" href="#Полностью-квалифицированный-синтаксис-для-устранения-неоднозначности-вызов-способов-с-одинаковым-именем">Полностью квалифицированный синтаксис для устранения неоднозначности: вызов способов с одинаковым именем</a></h3>
<p>В Rust ничего не мешает типажу иметь способ с одинаковым именем, таким же как способ другого типажа и Rust не мешает реализовывать оба таких типажа у одного вида. Также возможно реализовать способ с таким же именем непосредственно у вида, такой как и способы у типажей.</p>
<p>При вызове способов с одинаковыми именами в Rust нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим код в приложении 19-16, где мы определили два типажа: <code>Pilot</code> и <code>Wizard</code>, у обоих есть способ <code>fly</code>. Затем мы реализуем оба типажа у вида <code>Human</code> в котором уже реализован способ с именем <code>fly</code>. Каждый способ <code>fly</code> делает что-то своё.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-16: Два типажа определены с способом <code>fly</code> и реализованы у вида <code>Human</code>, а также способ <code>fly</code> реализован непосредственно у <code>Human</code></span></p>
<p>Когда мы вызываем <code>fly</code> у экземпляра <code>Human</code>, то сборщик по умолчанию вызывает способ, который непосредственно реализован для вида, как показано в приложении 19-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-17: Вызов <code>fly</code> у экземпляра <code>Human</code></span></p>
<p>Запуск этого кода напечатает <code>*waving arms furiously*</code> , показывая, что Rust называется способ <code>fly</code> реализованный непосредственно у <code>Human</code>.</p>
<p>Чтобы вызвать способы <code>fly</code> у типажа <code>Pilot</code> или типажа <code>Wizard</code> нужно использовать более явный синтаксис, указывая какой способ <code>fly</code> мы имеем в виду. Приложение 19-18 отображает такой синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span></p>
<p>Указание имени типажа перед именем способа проясняет сборщику Rust, какую именно реализацию <code>fly</code> мы хотим вызвать. Мы могли бы также написать <code>Human::fly(&amp;person)</code>, что эквивалентно используемому нами <code>person.fly()</code> в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.</p>
<p>Выполнение этого кода выводит следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
</code></pre>
<p>Поскольку способ <code>fly</code> принимает свойство <code>self</code>, если у нас было два <em>вида</em> оба реализующих один <em>типаж</em>, то Rust может понять, какую реализацию типажа использовать в зависимости от вида <code>self</code>.</p>
<p>Однако, ассоциированные функции, не являющиеся способами, не имеют свойства <code>self</code>. Когда существует несколько видов или типажей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Rust не всегда знает, какой вид вы имеете в виду, если только вы не используете <em>полный синтаксис</em>. Например, в приложении 19-19 мы создаём типаж для приюта животных, который хочет назвать всех маленьких собак <em>Spot</em>. Мы создаём типаж <code>Animal</code> со связанной с ним функцией <code>baby_name</code>, не являющейся способом. Типаж <code>Animal</code> реализован для структуры <code>Dog</code>, для которой мы также напрямую предоставляем связанную функцию <code>baby_name</code>, не являющуюся способом.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-19: Типаж с ассоциированной функцией и вид с ассоциированной функцией с тем же именем, которая тоже реализует типаж</span></p>
<p>Мы реализовали код для приюта для животных, который хочет назвать всех щенков именем Spot, в ассоциированной функции <code>baby_name</code>, которая определена для <code>Dog</code>. Вид <code>Dog</code> также реализует типаж <code>Animal</code>, который описывает характеристики, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в реализации <code>Animal</code> у <code>Dog</code> в функции <code>baby_name</code> ассоциированной с типажом <code>Animal</code>.</p>
<p>В <code>main</code> мы вызываем функцию <code>Dog::baby_name</code>, которая вызывает ассоциированную функцию определённую напрямую у <code>Dog</code>. Этот код печатает следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
</code></pre>
<p>Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию <code>baby_name</code>, которая является частью типажа <code>Animal</code> реализованного у <code>Dog</code>, так чтобы код печатал <code>A baby dog is called a puppy</code>. Техника указания имени типажа использованная в приложении 19-18 здесь не помогает; если мы изменим <code>main</code> код как в приложении 19-20, мы получим ошибку сборки.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}</code></pre>
<p><span class="caption">Приложение 19-20. Попытка вызвать функцию <code>baby_name</code> из типажа <code>Animal</code>, но Rust не знает какую реализацию использовать</span></p>
<p>Поскольку <code>Animal::baby_name</code> не имеет свойства <code>self</code>, и могут быть другие виды, реализующие типаж <code>Animal</code>, Rust не может понять, какую реализацию <code>Animal::baby_name</code> мы хотим использовать. Мы получим эту ошибку сборщика:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
</code></pre>
<p>Чтобы устранить неоднозначность и сказать Rust, что мы хотим использовать реализацию <code>Animal</code> для <code>Dog</code>, нужно использовать полный синтаксис. Приложение 19-21 отображает, как использовать полный синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-21: Использование полного синтаксиса для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у типажа <code>Animal</code> реализованную в <code>Dog</code></span></p>
<p>Мы указываем изложение вида в угловых скобках, которая указывает на то что мы хотим вызвать способ <code>baby_name</code> из типажа <code>Animal</code> реализованный в <code>Dog</code>, также указывая что мы хотим рассматривать вид <code>Dog</code> в качестве <code>Animal</code> для вызова этой функции. Этот код теперь напечатает то, что мы хотим:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
</code></pre>
<p>В общем, полный синтаксис определяется следующим образом:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Для ассоциированных функций, которые не являются способами, будет отсутствовать <code>receiver</code> (объект приёмника): будет только список переменных. Вы можете использовать полный синтаксис везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого синтаксиса, которую Rust может понять из другой сведений в программе. Вам нужно использовать более подробный синтаксис только в тех случаях, когда существует несколько реализаций, использующих одно и то же название, и Rust нужно помочь определить, какую реализацию вы хотите вызвать.</p>
<h3 id="Использование-супер-типажей-для-требования-функциональности-одного-типажа-в-рамках-другого-типажа"><a class="header" href="#Использование-супер-типажей-для-требования-функциональности-одного-типажа-в-рамках-другого-типажа">Использование супер типажей для требования функциональности одного типажа в рамках другого типажа</a></h3>
<p>Иногда вы можете написать определение типажа, которое зависит от другого типажа: для вида, реализующего первый типаж, вы хотите потребовать, чтобы этот вид также реализовал второй типаж. Вы должны сделать это, чтобы ваше определение типажа могло использовать связанные элементы второго типажа. Типаж, на который опирается ваше определение типажа, называется <em>supertrait</em> вашего типажа.</p>
<p>Например, мы хотим создать типаж <code>OutlinePrint</code> с способом <code>outline_print</code>, который будет печатать значение обрамлённое звёздочками. Мы хотим чтобы структура <code>Point</code>, реализующая типаж встроенной библиотеки <code>Display</code>, вывела на печать <code>(x, y)</code> при вызове <code>outline_print</code> у экземпляра <code>Point</code>, который имеет значение <code>1</code> для <code>x</code> и значение <code>3</code> для <code>y</code>. Она должна напечатать следующее:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>В реализации <code>outline_print</code> мы хотим использовать функциональность типажа <code>Display</code>. Поэтому нам нужно указать, что типаж <code>OutlinePrint</code> будет работать только для видов, которые также реализуют <code>Display</code> и предоставляют функциональность, которая нужна в <code>OutlinePrint</code>. Мы можем сделать это в объявлении типажа, указав <code>OutlinePrint: Display</code>. Этот способ похож на добавление ограничения в типаж. В приложении 19-22 показана реализация типажа <code>OutlinePrint</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-22: Реализация типажа <code>OutlinePrint</code> которая требует функциональности типажа <code>Display</code></span></p>
<p>Поскольку мы указали, что типаж <code>OutlinePrint</code> требует типажа <code>Display</code>, мы можем использовать функцию <code>to_string</code>, которая самостоятельно реализована для любого вида реализующего <code>Display</code>. Если бы мы попытались использовать <code>to_string</code> не добавляя двоеточие и не указывая типаж <code>Display</code> после имени типажа, мы получили бы сообщение о том, что способ с именем <code>to_string</code> не был найден у вида <code>&amp;Self</code> в текущей области видимости.</p>
<p>Давайте посмотрим что происходит, если мы пытаемся реализовать типаж <code>OutlinePrint</code> для вида, который не реализует <code>Display</code>, например структура <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}</code></pre>
<p>Мы получаем сообщение о том, что требуется реализация <code>Display</code>, но её нет:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
</code></pre>
<p>Чтобы исправить, мы реализуем <code>Display</code> у структуры <code>Point</code> и выполняем требуемое ограничение <code>OutlinePrint</code>, вот так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
<span class="boring">}</span></code></pre></pre>
<p>Тогда реализация типажа <code>OutlinePrint</code> для структуры <code>Point</code> будет собрана успешно и мы можем вызвать <code>outline_print</code> у экземпляра <code>Point</code> для отображения значения обрамлённое звёздочками.</p>
<h3 id="Шаблон-newtype-для-реализация-внешних-типажей-у-внешних-видов"><a class="header" href="#Шаблон-newtype-для-реализация-внешних-типажей-у-внешних-видов">Шаблон Newtype для реализация внешних типажей у внешних видов</a></h3>
<p>В разделе <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">"Реализация типажа у типа"</a><!-- ignore --> главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается реализовать типаж у вида, если либо типаж, либо вид являются местными для нашего крейта. Можно обойти это ограничение, используя <em>шаблон нового вида</em> (newtype pattern), который включает в себя создание нового вида в кортежной структуре. (Мы рассмотрели кортежные структуры  в разделе <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">"Использование структур кортежей без именованных полей для создания различных видов"</a><!--  --> главы 5.) Структура кортежа будет иметь одно поле и будет тонкой оболочкой для вида которому мы хотим реализовать типаж. Тогда вид оболочки является местным для нашего крейта и мы можем реализовать типаж для местной обёртки. <em>Newtype</em> это термин, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого шаблона и вид оболочки исключается во время сборки.</p>
<p>В качестве примера, мы хотим реализовать типаж <code>Display</code> для вида <code>Vec&lt;T&gt;</code>, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что типаж <code>Display</code> и вид <code>Vec&lt;T&gt;</code> объявлены вне нашего крейта. Мы можем сделать структуру <code>Wrapper</code>, которая содержит экземпляр <code>Vec&lt;T&gt;</code>; тогда мы можем реализовать <code>Display</code> у структуры <code>Wrapper</code> и использовать значение <code>Vec&lt;T&gt;</code> как показано в приложении 19-23.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 19-23. Создание вида <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для реализации <code>Display</code></span></p>
<p>Реализация <code>Display</code> использует <code>self.0</code> для доступа к внутреннему <code>Vec&lt;T&gt;</code>, потому что <code>Wrapper</code> это структура кортежа, а <code>Vec&lt;T&gt;</code> это элемент с порядковым казателем 0 в кортеже. Затем мы можем использовать функциональные возможности вида <code>Display</code> у <code>Wrapper</code>.</p>
<p>Недостатком использования этой техники является то, что <code>Wrapper</code> является новым видом, поэтому он не имеет способов для значения, которое он держит в себе. Мы должны были бы реализовать все способы для <code>Vec&lt;T&gt;</code> непосредственно во <code>Wrapper</code>, так чтобы эти способы делегировались внутреннему <code>self.0</code>, что позволило бы нам обращаться с <code>Wrapper</code> точно так же, как с <code>Vec&lt;T&gt;</code>. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида, реализуя типаж <code>Deref</code> (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью <code>Deref</code> типажа"</a><!-- ignore --> главы 15) у <code>Wrapper</code> для возвращения внутреннего вида, то это было бы решением. Если мы не хотим, чтобы вид <code>Wrapper</code> имел все способы внутреннего вида, например, для ограничения поведения вида <code>Wrapper</code>, то пришлось бы вручную реализовать только те способы, которые нам нужны.</p>
<p>Этот шаблон newtype также полезен, даже когда типажи не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-04-advanced-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-04-advanced-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
