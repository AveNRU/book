<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>правила написания образца - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие подходы программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Примечания</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие устройства</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование устройств для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание образцов устройств</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей устройства</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> правила написания способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Устройство потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Краткий поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими делами с помощью дополнений, ящиков и звеньев</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Дополнения и ящики</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение звеньев для управления областью действия и тайностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве звеньев</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, особенности (свойства) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Особенности (свойства): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х проверок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать проверки</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением проверок</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Создание проверок</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Дело с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Переработка кода для обеспечения выделения на звенья и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка возможности библиотеки с помощью разработки через проверка</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Полезные  возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего дела с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Обнародование ящика на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью особенности Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью особенности Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный одновременность</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для одновременного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Одновременность с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый одновременность с помощью особенностей Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности предметно-направленного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Свойства предметно-направленных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование особенность-предметов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Выполнение образца предметно-направленного разработки</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Образцы и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться образцы</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли образец не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html" class="active"><strong aria-hidden="true">18.3.</strong> правила написания образца</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые особенности</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Конечный дело: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые особенности</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Ржавчина и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="правила-написания-образцов"><a class="header" href="#правила-написания-образцов">правила написания образцов</a></h2>
<p>В этом разделе мы рассмотрим все виды допустимого правил написания в образцах и расскажем, когда и для чего вам может понадобиться каждый из них.</p>
<h3 id="Сопоставление-с-записью"><a class="header" href="#Сопоставление-с-записью">Сопоставление с записью</a></h3>
<p>Как мы уже видели в главе 6, можно сопоставлять образцы с записями напрямую. В следующем коде есть несколько примеров:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Этот код печатает <code>one</code>, потому что значение в <code>x</code> равно 1. Данный правила написания полезен, когда вы хотите, чтобы ваш код предпринял действие, если он получает определенное значение.</p>
<h3 id="Сопоставление-именованных-переменных"><a class="header" href="#Сопоставление-именованных-переменных">Сопоставление именованных переменных</a></h3>
<p>Именованные переменные - это неопровержимые (irrefutable) образцы, которые соответствуют любому значению и мы использовали их много раз в книге. Однако при использовании именованных переменных в выражениях <code>match</code> возникает сложность. Поскольку <code>match</code> начинает новую область видимости, то переменные, объявленные как часть образца внутри выражения <code>match</code>, будут затенять переменные с тем же именем вне устройства <code>match</code> как и в случае со всеми переменными. В приложении 18-11 мы объявляем переменную с именем <code>x</code> со значением <code>Some(5)</code> и переменную <code>y</code> со значением <code>10</code>. Затем мы создаём выражение <code>match</code> для значения <code>x</code>. Посмотрите на образцы в ветках, <code>println!</code> в конце и попытайтесь выяснить, какой код будет напечатан прежде чем запускать его или читать дальше.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-11: Выражение <code>match</code> с веткой, которая добавляет затенённую переменную <code>y</code></span></p>
<p>Давайте рассмотрим, что происходит, когда выполняется выражение <code>match</code>. Образец в первой ветке не соответствует определённому значению <code>x</code>, поэтому выполнение продолжается.</p>
<p>Образец во второй ветке вводит новую переменную с именем <code>y</code>, которая будет соответствовать любому значению в <code>Some</code>. Поскольку мы находимся в новой области видимости внутри выражения <code>match</code>, это новая переменная <code>y</code>, а не <code>y</code> которую мы объявили в начале со значением 10. Эта новая привязка <code>y</code> будет соответствовать любому значению из <code>Some</code>, которое находится в <code>x</code>. Следовательно, эта новая <code>y</code> связывается с внутренним значением <code>Some</code> из переменной <code>x</code>. Этим значением является <code>5</code>, поэтому выражение для этой ветки выполняется и печатает <code>Matched, y = 5</code>.</p>
<p>Если бы <code>x</code> было значением <code>None</code> вместо <code>Some(5)</code>, то образцы в первых двух ветках не совпали бы, поэтому значение соответствовало бы подчёркиванию. Мы не ввели переменную <code>x</code> в образце ветки со знаком подчёркивания, поэтому <code>x</code> в выражении все ещё является внешней переменной <code>x</code>, которая не была затенена. В этом гипотетическом случае совпадение <code>match</code> выведет <code>Default case, x = None</code>.</p>
<p>Когда выражение <code>match</code> завершается, заканчивается его область видимости как и область действия внутренней переменной <code>y</code>. Последний <code>println!</code> печатает <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Чтобы создать выражение <code>match</code>, которое сравнивает значения внешних <code>x</code> и <code>y</code>, вместо введения затенённой переменной нужно использовать условие в сопоставлении образца. Мы поговорим про условие в сопоставлении образца позже в разделе <a href="#extra-conditionals-with-match-guards">“Дополнительные условия в сопоставлении образца”</a><!--  -->.</p>
<h3 id="объединение-образцов"><a class="header" href="#объединение-образцов">объединение образцов</a></h3>
<p>В выражениях <code>match</code> можно сравнивать сразу с несколькими образцами, используя правила написания <code>|</code>, который является оператором образца <em>or</em>. Например, в следующем примере мы сопоставляем значение <code>x</code> с ветвями match, первая из которых содержит оператор <em>or</em>, так что если значение <code>x</code> совпадёт с любым из значений в этой ветви, то будет выполнен её код:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Будет напечатано <code>one or two</code>.</p>
<h3 id="Сопоставление-рядов-с-помощью-"><a class="header" href="#Сопоставление-рядов-с-помощью-">Сопоставление рядов с помощью <code>..=</code></a></h3>
<p>правила написания <code>..=</code> позволяет нам выполнять сравнение с рядом значений. В следующем коде, когда в образце найдётся совпадение с любым из значений заданного ряда, будет выполнена эта ветка:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Если <code>x</code> равен 1, 2, 3, 4 или 5, то совпадение будет достигнуто в первой ветке. Этот правила написания более удобен при указании нескольких значений для сравнения, чем использование оператора <code>|</code> для определения этой же мысли; если бы мы решили использовать <code>|</code>, нам пришлось бы написать <code>1 | 2 | 3 | 4 | 5</code>. Указание ряда намного короче, особенно если мы хотим подобрать, скажем, любое число от 1 до 1 000!</p>
<p>Сборщик проверяет, что рядне является пустым во время сборки, и поскольку единственными видами, для которых Ржавчина может определить, пуст рядили нет, являются <code>char</code> и числовые значения, ряды допускаются только с числовыми или <code>char</code> значениями.</p>
<p>Вот пример использования рядов значений <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust может сообщить, что <code>'c'</code> находится в ряде первого образца и напечатать <code>early ASCII letter</code>.</p>
<h3 id="Разъединение-для-получения-значений"><a class="header" href="#Разъединение-для-получения-значений">Разъединение для получения значений</a></h3>
<p>Мы также можем использовать образцы для разъединения устройств, перечислений и упорядоченных рядов, чтобы использовать разные части этих значений. Давайте пройдёмся по каждому исходу.</p>
<h4 id="Разъединение-устройства"><a class="header" href="#Разъединение-устройства">Разъединение устройства</a></h4>
<p>В приложении 18-12 показана устройства <code>Point</code> с двумя полями <code>x</code> и <code>y</code>, которые мы можем разделить, используя образец с указанием <code>let</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Приложение 18-12: Разбиение полей устройства в отдельные переменные</span></p>
<p>Этот код создаёт переменные <code>a</code> и <code>b</code> , которые сопоставляются значениям полей <code>x</code> и <code>y</code> устройства <code>p</code> . Этот пример показывает, что имена переменных в образце не обязательно должны совпадать с именами полей устройства. Однако обычно имена переменных сопоставляются с именами полей, чтобы было легче запомнить, какие переменные взяты из каких полей. Из-за этого, а также из-за того, что строчка <code>let Point { x: x, y: y } = p;</code> содержит много повторения, в Ржавчина ввели особое сокращение для образцов, соответствующих полям устройства: вам нужно только указать имя поля устройства, и тогда переменные, созданные из образца, будут иметь те же имена. Код в приложении 18-13 подобен коду в Приложении 18-12, но в образце <code>let</code> создаются переменные <code>x</code> и <code>y</code>, вместо <code>a</code> и <code>b</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Приложение 18-13: Разъединение полей устройства с использованием сокращённой записи</span></p>
<p>Этот код создаёт переменные <code>x</code> и <code>y</code>, которые соответствуют полям <code>x</code> и <code>y</code> из переменной <code>p</code>. В итоге переменные <code>x</code> и <code>y</code> содержат значения из устройства <code>p</code>.</p>
<p>А ещё, используя записанные значения в образце, мы можем разъединять, не создавая переменные для всех полей. Это даёт возможность, проверяя одни поля на соответствие определенным значениям, создавать переменные для разъединения других.</p>
<p>В приложении 18-14 показано выражение <code>match</code>, которое разделяет значения <code>Point</code> на три случая: точки, которые лежат непосредственно на оси <code>x</code> (что верно, когда <code>y = 0</code>), на оси <code>y</code> (<code>x = 0</code>) или ни то, ни другое.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-14: Разъединение и сопоставление с записями в одном образце</span></p>
<p>Первая ветвь будет соответствовать любой точке, лежащей на оси <code>x</code>, если значение поля <code>y</code> будет соответствовать записи <code>0</code>. Образец по-прежнему создаёт переменную <code>x</code>, которую мы сможем использовать в коде этой ветви.</p>
<p>Подобно, вторая ветвь совпадёт с любой точкой на оси <code>y</code>, в случае, если значение поля <code>x</code> будет равно <code>0</code>, а для значения поля <code>y</code> будет создана переменная <code>y</code>. Третья ветвь не содержит никаких записей, поэтому она соответствует любому другому <code>Point</code> и создаёт переменные как для поля <code>x</code>, так и для поля <code>y</code>.</p>
<p>В этом примере значение <code>p</code> совпадает по второй ветке, так как <code>x</code> содержит значение 0, поэтому этот код будет печатать <code>On the y axis at 7</code>.</p>
<p>Помните, что выражение <code>match</code> перестаёт проверять следующие ветви, как только оно находит первый совпадающий образец, поэтому, даже если <code>Point { x: 0, y: 0}</code> находится на оси <code>x</code> и оси <code>y</code>, этот код будет печатать только <code>On the x axis at 0</code> .</p>
<h4 id="Разъединение-перечислений"><a class="header" href="#Разъединение-перечислений">Разъединение перечислений</a></h4>
<p>Мы уже разъединили перечисления в книге (см., например, приложение 6-5 главы 6), но<br>не обсуждали явно, что образец для разъединения перечисления должен соответствовать способу объявления данных, хранящихся в перечислении. Например, в приложении 18-15 мы используем перечисление <code>Message</code> из приложения 6-2 и пишем <code>match</code> с образцами, которые будут разъединять каждое внутреннее значение.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}")
        }
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-15: Разъединение исходов перечисления, содержащих разные виды значений</span></p>
<p>Этот код напечатает <code>Change the color to red 0, green 160, and blue 255</code>. Попробуйте изменить значение переменной <code>msg</code>, чтобы увидеть выполнение кода в других ветках.</p>
<p>Для исходов перечисления без каких-либо данных, вроде <code>Message::Quit</code>, мы не можем разъединять значение, которого нет. Мы можем сопоставить только буквальное значение <code>Message::Quit</code> в этом образце, но без переменных.</p>
<p>Для исходов перечисления похожих на устройства, таких как <code>Message::Move</code>, можно использовать образец, подобный образцу, который мы указываем для сопоставления устройств. После имени исхода мы помещаем фигурные скобки и затем перечисляем поля именами переменных. Таким образом мы разделяем отрывки, которые будут использоваться в коде этой ветки. Здесь мы используем сокращённую разновидность, как в приложении 18-13.</p>
<p>Для исходов перечисления, подобных упорядоченному ряду, вроде <code>Message::Write</code>, который содержит упорядоченный ряд с одним элементом и <code>Message::ChangeColor</code>, содержащему упорядоченный ряд с тремя элементами, образец подобен тому, который мы указываем для сопоставления упорядоченных рядов. Количество переменных в образце должно соответствовать количеству элементов в исходе, который мы сопоставляем.</p>
<h4 id="Разъединение-вложенных-устройств-и-перечислений"><a class="header" href="#Разъединение-вложенных-устройств-и-перечислений">Разъединение вложенных устройств и перечислений</a></h4>
<p>До сих пор все наши примеры сопоставляли устройства или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами! Например, мы можем ресогласовать код в приложении 18-15 для поддержки цветов RGB и HSV в сообщении <code>ChangeColor</code> , как показано в приложении 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}")
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-16: Сопоставление со вложенными перечислениями</span></p>
<p>Образец первой ветки в выражении <code>match</code> соответствует исходу перечисления <code>Message::ChangeColor</code>, который содержит исход <code>Color::Rgb</code>; затем образец привязывается к трём внутренними значениями <code>i32</code>. Образец второй ветки также соответствует исходу перечисления <code>Message::ChangeColor</code>, но внутреннее перечисление соответствует исходу <code>Color::Hsv</code>. Мы можем указать эти сложные условия в одном выражении <code>match</code>, даже если задействованы два перечисления.</p>
<h4 id="Разъединение-устройств-и-упорядоченных-рядов"><a class="header" href="#Разъединение-устройств-и-упорядоченных-рядов">Разъединение устройств и упорядоченных рядов</a></h4>
<p>Можно смешивать, сопоставлять и вкладывать образцы разъединения ещё более сложными способами. В следующем примере показана сложная разъединение, где мы вкладываем устройства и упорядоченные ряды внутрь упорядоченного ряда и разъединим из него все простые значения:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>Этот код позволяет нам разбивать сложные виды на составные части, чтобы мы могли использовать нужным нас значения по отдельности.</p>
<p>Разъединение с помощью образцов - это удобный способ использования отрывков значений, таких как как значение из каждого поля в устройстве, по отдельности друг от друга.</p>
<h3 id="Пренебрежение-значений-в-образце"><a class="header" href="#Пренебрежение-значений-в-образце">Пренебрежение значений в образце</a></h3>
<p>Вы видели, что иногда полезно пренебрегать значения в образце, например в последней ветке <code>match</code>, чтобы получить ветку, обрабатывающую любые значения, которая на самом деле ничего не делает, но учитывает все оставшиеся возможные значения. Есть несколько способов пренебрегать целые значения или части значений в образце: используя образец <code>_</code> (который вы видели), используя образец <code>_</code> внутри другого образца, используя имя, начинающееся с подчёркивания, либо используя <code>..</code>, чтобы пренебрегать оставшиеся части значения. Давайте рассмотрим, как и зачем использовать каждый из этих образцов.</p>
<h4 id="Пренебрежение-всего-значения-с-помощью-образца-_"><a class="header" href="#Пренебрежение-всего-значения-с-помощью-образца-_">Пренебрежение всего значения с помощью образца <code>_</code></a></h4>
<p>Мы использовали подчёркивание (<code>_</code>) в качестве образца подстановочного знака (wildcard), который будет сопоставляться с любом значением, но не будет привязываться к этому значению. Это особенно удобно в последней ветке выражения <code>match</code>, но мы также можем использовать его в любом образце, в том числе в свойствах функции, как показано в приложении 18-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Приложение 18-15: Использование <code>_</code> в ярлыке функции</span></p>
<p>Этот код полностью пренебрегает значение <code>3</code>, переданное в качестве первого переменной, и выведет на печать <code>This code only uses the y parameter: 4</code>.</p>
<p>В большинстве случаев, когда вам больше не нужен какой-то из свойств функции, вы можете изменить её ярлык, убрав неиспользуемый свойство. Пренебрежение свойства функции может быть особенно полезно в случаях когда, например, вы выполняете особенность с определённой ярлыком, но тело функции в вашей выполнения не нуждается в одном из свойств. В таком случае сборщик не будет выдавать предупреждения о неиспользуемых свойствах функции, как это было бы, если бы вы указали имя свойства.</p>
<h4 id="Пренебрежение-частей-значения-с-помощью-вложенного-_"><a class="header" href="#Пренебрежение-частей-значения-с-помощью-вложенного-_">Пренебрежение частей значения с помощью вложенного <code>_</code></a></h4>
<p>Также, <code>_</code> можно использовать внутри образцов, чтобы пренебрегать какую-то часть значения, например, когда мы хотим проверить только определённую подробность, а остальные свойства нам не понадобятся в коде, который нужно выполнить. В приложении 18-18 показан код, ответственный за управление значениями настроек. Согласно бизнес-требованиям, пользователь не может изменить установленное значение свойства, но может удалить его и задать ему новое значение, если на данный мгновение оно отсутствует.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-18: Использование подчёркивания в образцах, соответствующих исходам <code>Some</code>, когда нам не нужно использовать значение внутри <code>Some</code></span></p>
<p>Этот код будет печатать <code>Can't overwrite an existing customized value</code>, а затем <code>setting is Some(5)</code>. В первой ветке нам не нужно сопоставлять или использовать значения внутри исхода <code>Some</code>, но нам нужно проверить случай, когда <code>setting_value</code> и <code>new_setting_value</code> являются исходом <code>Some</code>. В этом случае мы печатаем причину, почему мы не меняем значение <code>setting_value</code> и оно не меняется.</p>
<p>Во всех других случаях (если либо <code>setting_value</code>, либо <code>new_setting_value</code> являются исходом <code>None</code>), выраженных образцом <code>_</code> во второй ветке, мы хотим, чтобы <code>new_setting_value</code> стало равно <code>setting_value</code>.</p>
<p>Мы также можем использовать подчёркивание в нескольких местах в одном образце, чтобы пренебрегать определенные значения. Приложение 18-19 показывает пример пренебрежения второго и четвёртого значения в упорядоченном ряде из пяти элементов.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-19: Пренебрежение нескольких частей упорядоченного ряда</span></p>
<p>Этот код напечатает <code>Some numbers: 2, 8, 32</code>, а значения 4 и 16 будут пренебрежены.</p>
<h4 id="Пренебрежение-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени"><a class="header" href="#Пренебрежение-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени">Пренебрежение неиспользуемой переменной, начинающейся с символа <code>_</code> в имени</a></h4>
<p>Если вы создаёте переменную, но нигде её не используете, Ржавчина обычно выдаёт предупреждение, потому что неиспользуемая переменная может быть ошибкой. Но иногда полезно создать переменную, которую вы пока не используете, например, когда вы создаёте протовид или только начинаете дело. В этой случаи вы можете сказать Ржавчина не предупреждать вас о неиспользуемой переменной, начав имя переменной с подчёркивания. В приложении 18-20 мы создаём две неиспользуемые переменные, но когда мы собираем такой код, мы должны получить предупреждение только об одной из них.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Приложение 18-20: Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных</span></p>
<p>Здесь мы получаем предупреждение о том, что не используем переменную <code>y</code>, но мы не получаем предупреждения о неиспользовании переменной<code>_x</code>.</p>
<p>Обратите внимание, что есть небольшая разница между использованием только <code>_</code> и использованием имени, начинающегося с подчёркивания. правила написания <code>_x </code> по-прежнему привязывает значение к переменной, тогда как <code>_</code> не привязывает ничего. В приложении 18-21 представлена ошибка, показывающая, в каком случае это различие имеет значение.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<p><span class="caption">Приложение 18-21: Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения</span></p>
<p>Мы получим ошибку, поскольку значение <code>s</code> все равно будет перемещено в <code>_s</code>, что не позволит нам больше воспользоваться <code>s</code>. Однако использование подчёркивания само по себе никогда не приводит к привязке к значению. Приложение 18-22 собирается без ошибок, поскольку <code>s</code> не будет перемещён в <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-22. Использование подчёркивания не привязывает значение</span></p>
<p>Этот код работает правильно, потому что мы никогда не привязываем <code>s</code> к чему либо; оно не перемещается.</p>
<h4 id="Пренебрежение-оставшихся-частей-значения-с-помощью-"><a class="header" href="#Пренебрежение-оставшихся-частей-значения-с-помощью-">Пренебрежение оставшихся частей значения с помощью <code>..</code></a></h4>
<p>Со значениями, которые имеют много частей, можно использовать правила написания <code>..</code>, чтобы использовать только некоторые части и пренебрегать остальные, избегая необходимости перечислять подчёркивания для каждого пренебрегаемого значения. Образец <code>..</code> пренебрегает любые части значения, которые мы явно не сопоставили в остальной частью образца. В приложении 18-23 мы имеем устройство <code>Point</code>, которая содержит координату в трёхмерном пространстве. В выражении <code>match</code> мы хотим работать только с координатой <code>x</code> и пренебрегать значения полей <code>y</code> и <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-21: Пренебрежение полей устройства <code>Point</code> кроме поля <code>x</code> с помощью <code>..</code></span></p>
<p>Мы перечисляем значение <code>x</code> и затем просто включаем образец <code>..</code>. Это быстрее, чем перечислять <code>y: _</code> и <code>z: _</code>, особенно когда мы работаем со устройствами, которые имеют много полей, в случаейх, когда только одно или два поля представляют для нас влечение.</p>
<p>правила написания <code>..</code> раскроется до необходимого количества значений. В приложении 18-24 показано, как использовать <code>..</code> с упорядоченным рядом.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<p><span class="caption">Приложение 18-24: Сопоставление только первого и последнего значений в упорядоченном ряде и пренебрежение всех других значений</span></p>
<p>В этом коде первое и последнее значение соответствуют <code>first</code> и <code>last</code>. Устройство <code>..</code> будет соответствовать и пренебрегать всё, что находится между ними.</p>
<p>Однако использование <code>..</code> должно быть однозначным. Если неясно, какие значения предназначены для сопоставления, а какие следует пренебрегать, Ржавчина выдаст ошибку. В приложении 18-25 показан пример неоднозначного использования <code>..</code>, поэтому он не будет собираться.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<p><span class="caption">Приложение 18-25: Попытка использовать <code>..</code> неоднозначным способом</span></p>
<p>При сборки примера, мы получаем эту ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Rust не может определить, сколько значений в упорядоченном ряде нужно пренебрегать, прежде чем сопоставить значение с <code>second</code>, и сколько следующих значений пренебрегать после этого. Этот код может означать, что мы хотим пренебрегать <code>2</code>, связать <code>second</code> с <code>4</code>, а затем пренебрегать <code>8</code>, <code>16</code> и <code>32</code>; или что мы хотим пренебрегать <code>2</code> и <code>4</code>, связать <code>second</code> с <code>8</code>, а затем пренебрегать <code>16</code> и <code>32</code>; и так далее. Имя переменной <code>second</code> не означает ничего особенного для Rust, поэтому мы получаем ошибку сборщика, так как использование <code>..</code> в двух местах как здесь, является неоднозначным.</p>
<h3 id="Дополнительные-условия-оператора-сопоставления-match-guards"><a class="header" href="#Дополнительные-условия-оператора-сопоставления-match-guards">Дополнительные условия оператора сопоставления (Match Guards)</a></h3>
<p><em>Условие сопоставления</em> (match guard) является дополнительным условием <code>if</code>, указанным после образца в ветке <code>match</code>, которое также должно быть выполнено, чтобы ветка была выбрана. Условия сопоставления полезны для выражения более сложных мыслей, чем позволяет только образец.</p>
<p>Условие может использовать переменные, созданные в образце. В приложении 18-26 показан <code>match</code>, в котором первая ветка имеет образец <code>Some(x)</code>, а также имеет условие сопоставления, <code>if x % 2 == 0</code> (которое будет истинным, если число чётное).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-26: Добавление условия сопоставления в образец</span></p>
<p>В этом примере будет напечатано <code>The number 4 is even</code>. Когда <code>num</code> сравнивается с образцом в первой ветке, он совпадает, потому что <code>Some(4)</code> соответствует <code>Some(x)</code>. Затем условие сопоставления проверяет, равен ли 0 остаток от деления <code>x</code> на 2 и если это так, то выбирается первая ветка.</p>
<p>Если бы <code>num</code> вместо этого было <code>Some(5)</code>, условие в сопоставлении первой ветки было бы ложным, потому что остаток от 5 делённый на 2, равен 1, что не равно 0. Ржавчина тогда перешёл бы ко второй ветке, которое совпадает, потому что вторая ветка не имеет условия сопоставления и, следовательно, соответствует любому исходу <code>Some</code>.</p>
<p>Невозможно выразить условие <code>if x % 2 == 0</code> внутри образца, поэтому условие в сопоставлении даёт нам возможность выразить эту логику. Недостатком этой дополнительной выразительности является то, что сборщик не пытается проверять полноту, когда задействованы выражения с условием в сопоставлении.</p>
<p>В приложении 18-11 мы упомянули, что можно использовать условия сопоставления для решения нашей сбоев затенения образца. Напомним, что внутри образца в выражении <code>match</code> была создана новая переменная, вместо использования внешней к <code>match</code> переменной. Эта новая переменная означала, что мы не могли выполнить сравнение с помощью значения внешней переменной. В приложении 18-27 показано, как мы можем использовать условие сопоставления для решения этой сбоев.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<p><span class="caption">Приложение 18-27. Использование условия сопоставления для проверки на равенство со значением внешней переменной</span></p>
<p>Этот код теперь напечатает <code>Default case, x = Some(5)</code>. Образец во второй ветке не вводит новую переменную <code>y</code>, которая будет затенять внешнюю <code>y</code>, это означает, что теперь можно использовать внешнюю переменную <code>y</code> в условии сопоставления. Вместо указания образца как <code>Some(y)</code>, который бы затенял бы внешнюю <code>y</code>, мы указываем <code>Some(n)</code>. Это создаёт новую переменную <code>n</code>, которая ничего не затеняет, так как переменной <code>n</code> нет вне устройства <code>match</code>.</p>
<p>Условие сопоставления <code>if n == y</code> не является образцом и следовательно, не вводит новые переменные. Переменная <code>y</code> <em>и есть</em> внешняя <code>y</code>, а не новая затенённая <code>y</code>, и теперь мы можем искать элемент, который будет иметь то же значение, что и внешняя <code>y</code>, путём сравнения <code>n</code> и <code>y</code>.</p>
<p>Вы также можете использовать оператор <em>или</em> <code>|</code> в условии сопоставления, чтобы указать несколько образцов; условие сопоставления будет применяться ко всем образцам. В приложении 18-28 показан приоритет соединения условия сопоставления с образцом, который использует <code>|</code>. Важной частью этого примера является то, что условие сопоставления <code>if y</code> применяется к <code>4</code>, <code>5</code>, <em>и</em> к <code>6</code>, хотя это может выглядеть как будто <code>if y</code> относится только к <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-28: Соединение нескольких образцов с условием сопоставления</span></p>
<p>Условие сопоставления гласит, что ветка совпадает, только если значение <code>x</code> равно <code>4</code>, <code>5</code> или <code>6</code>, <em>и</em> если <code>y</code> равно <code>true</code>. Когда этот код выполняется, образец первой ветки совпадает, потому что <code>x</code> равно <code>4</code>, но условие сопоставления <code>if y</code> равно false, поэтому первая ветка не выбрана. Код переходит ко второй ветке, которая совпадает, и эта программа печатает <code>no</code>. Причина в том, что условие <code>if</code> применяется ко всему образцу <code>4 | 5 | 6</code>, а не только к последнему значению <code>6</code>. Другими словами, приоритет условия сопоставления по отношению к образцу ведёт себя так:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>а не так:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>После запуска кода, старшинство в поведении становится очевидным: если условие сопоставления применялось бы только к конечному значению в списке, указанном с помощью оператора <code>|</code>, то ветка бы совпала и программа напечатала бы <code>yes</code>.</p>
<h3 id="Связывание-"><a class="header" href="#Связывание-">Связывание <code>@</code></a></h3>
<p>Оператор <em>at</em> (<code>@</code>) позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение образцу. В приложении 18-29 показан пример, в котором мы хотим проверить, что перечисление <code>Message::Hello</code> со значением поля <code>id</code> находится в ряде <code>3..=7</code>. Но мы также хотим привязать такое значение к переменной <code>id_variable</code>, чтобы использовать его внутри кода данной ветки. Мы могли бы назвать эту переменную <code>id</code>, так же как поле, но для этого примера мы будем использовать другое имя.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 18-29: Использование <code>@</code> для привязывания значения в образце, с одновременной его проверкой</span></p>
<p>В этом примере будет напечатано <code>Found an id in range: 5</code>. Указывая <code>id_variable @</code> перед рядом <code>3..=7</code>, мы захватываем любое значение, попадающее в ряд, одновременно проверяя, что это значение соответствует ряду в образце.</p>
<p>Во второй ветке, где у нас в образце указан только ряд, код этой ветки не имеет переменной, которая содержит действительное значение поля <code>id</code>. Значение поля <code>id</code> могло бы быть 10, 11 или 12, но код, соответствующий этому образцу, не знает, чему оно равно. Код образца не может использовать значение из поля <code>id</code>, потому что мы не сохранили значение <code>id</code> в переменной.</p>
<p>В последней ветке, где мы указали переменную без ряда, у нас есть значение, доступное для использования в коде ветки, в переменной с именем <code>id</code>. Причина в том, что мы использовали упрощённый правила написания полей устройства. Но мы не применяли никакого сравнения со значением в поле <code>id</code> в этой ветке, как мы это делали в первых двух ветках: любое значение будет соответствовать этому образцу.</p>
<p>Использование <code>@</code> позволяет проверять значение и сохранять его в переменной в пределах одного образца.</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Образцы Ржавчина очень помогают различать разные виды данных. При использовании их в выражениях <code>match</code>, Ржавчина заверяет, что ваши образцы охватывают все возможные значения, потому что иначе ваша программа не собирается. Образцы в указаниях <code>let</code> и свойствах функций делают такие устройства более полезными, позволяя разбивать элементы на более мелкие части, одновременно присваивая их значения переменным. Мы можем создавать простые или сложные образцы в соответствии с нашими потребностями.</p>
<p>Далее, в предпоследней главе книги, мы рассмотрим некоторые продвинутые особенности различных возможностей Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
