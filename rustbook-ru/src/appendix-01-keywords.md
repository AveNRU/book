## Приложение A: Ключевые слова

Следующий список содержит ключевые слова, забронированные для текущего или будущего использования в языке Ржавчина. Как таковые их нельзя использовать в качестве определителей (за исключением сырых определителей, которые мы обсудим в разделе [«Сырые определители]<!-- ignore -->»). определительы — это имена функций, переменных, свойств, полей устройств, звеньев, ящиков, постоянных переменных, макросов, постоянных переменных, свойств, видов, свойств или времён жизни.

### Используемые в настоящее время ключевые слова

Ниже приведён список используемых в настоящее время ключевых слов с их описанием.

-  `as` — выполнить простое преобразование, уточнить определенную свойство, которую содержит предмет, или переименовать элемент в выражении `use`
- `async` — возврат `Future` вместо запрета текущего потока
- `await` — остановка выполнения до готовности итога `Future`
- `break` — немедленный выход из круговорота
- `const` — определение постоянного элемента или неизменяемого сырого указателя
- `continue` — досрочный переход к следующему повторению круговорота
- `crate` — ссылка на корень дополнения в пути к звену
- `dyn` — изменяемая отсылка к особенности предмета
- `else` — иные  ветви для устройств управления потока `if` и `if let`
- `enum` — определение перечислений
- `extern` — связывание внешней функции или переменной
- `false` — разумный ложный запись
- `fn` — определение функции или вида указателя на функцию
- `for` — замкнуто перебирать элементы из повторителя, выполнить признак или указывать время жизни с более высоким рейтингом.
- `if` — ветвление на основе итога условного выражения
- `impl` — выполнение встроенной возможности или возможности особенности
- `in` — часть правил написания круговорота `for`
- `let` — объявление (связывание) переменной
- `loop` — безусловный круговорот
- `match` — сопоставление значения с образцами
- `mod` — определение звена
- `move` — перекладывание владения на замыкание всеми захваченными элементами
- `mut` — обозначение изменчивости в ссылках, сырах указателей и привязках к образцу
- `pub` — изменитель открытой доступность полей устройств, разделов `impl` и звеньев
- `ref` — привязка по ссылке
- `return` — возвращает итог из функции
- `Self` — псевдоним для определяемого или исполняемого вида
- `self` — предмет текущего способа или звена
- `static` — вездесущая переменная или время жизни, продолжающееся на протяжении всего выполнения программы
- `struct` — определение устройства
- `super` — родительский звено текущего звена
- `trait` — определение особенности
- `true` — разумный истинный запись
- `type` — определение псевдонима вида или связанного вида
- `union` - определить [объединение]<!-- ignore -->; является ключевым словом только при использовании в объявлении объединения
- `unsafe` — обозначение небезопасного рукописи, функций, особенностей и их выполнений
- `use` — ввод имён в область видимости
- `where` — ограничение вида
- `while` — условный круговорот, основанный на итоге выражения

### Ключевые слова, забронированные для будущего использования

Следующие ключевые слова ещё не имеют никакой возможности, но забронированы Ржавчина для возможного использования в будущем.

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Сырые определители

*Сырые определители* — это правила написания, позволяющие использовать ключевые слова там, где обычно они не могут быть. Для создания и использования сырого определителя к ключевому слову добавляется приставка `r#`.

Например, ключевое слово `match`. Если вы попытаетесь собрать следующую функцию, использующую в качестве имени `match`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

вы получите ошибку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ошибка говорит о том, что вы не можете использовать ключевое слово `match` в качестве определителя функции. Чтобы получить возможность использования слова `match` в качестве имени функции, нужно использовать правила написания «сырых определителей», например так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Эта рукопись собирается без ошибок. Обратите внимание, что приставка `r#` в определении имени функции указан так же, как он указан в месте её вызова в `main`.

Сырые определители позволяют вам использовать любое слово, которое вы выберете, в качестве определителя, даже если это слово окажется забронированным ключевым словом. Это даёт нам больше свободы в выборе имён определителей, а также позволяет нам встраиваться с программами, написанными на языке, где эти слова не являются ключевыми. Кроме того, необработанные определители позволяют вам использовать библиотеки, написанные в исполнениях Ржавчины, отличной от используемой в вашем ящике. Например, `try` не является ключевым словом в выпуске 2015 года, но является в выпуске 2018 года. Если вы зависите от библиотеки, написанной с использованием исполнения 2015 года и имеющей функцию `try`, вам потребуется использовать правила написания сырого определителя, в данном случае `r#try`, для вызова этой функции из рукописи исполнения 2018 года. См. [Приложение E]<!-- ignore --> для получения дополнительных сведений о изданиях Ржавчины.


[«Сырые определители]: #raw-identifiers
[объединение]: ../reference/items/unions.html
[Приложение E]: appendix-05-editions.html