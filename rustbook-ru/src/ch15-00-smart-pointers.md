# Умные указатели

*Указатель* — это общая подход для переменной, которая содержит адрес участка памяти. Этот адрес «относится к», или «указывает на» некоторые другие данные. Наиболее общая разновидность указателя в Ржавчина — это ссылка, о которой вы узнали из главы 4. Ссылки обозначаются символом `&` и заимствуют значение, на которое указывают. Они не имеют каких-либо особых возможностей, кроме как ссылаться на данные, и не имеют никаких накладных расходов.

*Умные указатели*, с другой стороны, являются устройствами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности. Подход умных указателей не неповторима для Rust: умные указатели возникли в C++ и существуют в других языках. В Ржавчина есть разные умные указатели, определённые в встроенной библиотеке, которые обеспечивают возможность, выходящую за рамки ссылок. Одним из примеров, который мы рассмотрим в этой главе, является вид умного указателя *reference counting* (подсчёт ссылок). Этот указатель позволяет иметь несколько владельцев с помощью отслеживания количества владельцев и, когда владельцев не остаётся, очищает данные.

Rust с его подходом владения и заимствования имеет дополнительное различие между ссылками и умными указателями: в то время, как ссылки только заимствуют данные, умные указатели часто *владеют* данными, на которые указывают.

Ранее мы уже сталкивались с умными указателями в этой книге, хотя и не называли их так, например `String` и `Vec<T>` в главе 8. Оба этих вида считаются умными указателями, потому что они владеют некоторой областью памяти и позволяют ею управлять. У них также есть метаданные и дополнительные возможности или заверения. `String`, например, хранит свой размер в виде метаданных и заверяет, что содержимое строки всегда будет в кодировке UTF-8.

Умные указатели обычно выполняются с помощью устройств. Присущей чертой, которая отличает умный указатель от обычной устройства, является то, что для умных указателей выполнены особенности `Deref` и `Drop`. Особенность `Deref` позволяет образцу умного указателя вести себя как ссылка, так что вы можете написать код, работающий с ним как со ссылкой, так и как с умным указателем. Особенность `Drop` позволяет написать код, который будет запускаться когда образец умного указателя выйдет из области видимости. В этой главе мы обсудим оба особенности и выясним, почему они важны для умных указателей.

Учитывая, что образец умного указателя является общим образцом разработки, часто используемым в Rust, эта глава не описывает все существующие умные указатели. Множество библиотек имеют свои умные указатели, и вы также можете написать свои. Мы охватим наиболее распространённые умные указатели из встроенной библиотеки:

- `Box<T>` для распределения значений в куче (памяти)
- `Rc<T>` вид счётчика ссылок, который допускает множественное владение
- Виды `Ref<T>` и `RefMut<T>`, доступ к которым осуществляется через вид `RefCell<T>`, который обеспечивает правила заимствования во время выполнения вместо времени сборки

Дополнительно мы рассмотрим образец *внутренней изменчивости (interior mutability)*, где неизменяемый вид предоставляет API для изменения своего внутреннего значения. Мы также обсудим *ссылочные зацикленности (reference cycles)*: как они могут приводить к утечке памяти и как это предотвратить.

Приступим!
