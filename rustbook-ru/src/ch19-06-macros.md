## Макросы

Мы использовали макросы, такие как `println!` на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Понятие *макрос* относится к семейству возможностей в Rust. Это *декларативные* (declarative) макросы с помощью `macro_rules!` и три вида *процедурных* (procedural) макросов:

- Пользовательские (выводимые) `#[derive]` макросы, которые указывают код, добавленный с помощью свойства `derive`, используемые для структур и перечислений
- Макросы подобные свойствам (attribute-like), которые определяют настраиваемые свойства, используемые для любого элемента языка
- Похожие на функции (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream

Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.

### Разница между макросами и функциями

По сути, макросы являются способом написания кода, который записывает другой код, что известно как *мета программирование*. В Приложении C мы обсуждаем свойство `derive`, который генерирует за вас реализацию различных типажей. Мы также использовали макросы `println!` и `vec!` на протяжении книги. Все эти макросы *раскрываются* для генерации большего количества кода, чем исходный код написанный вами вручную.

Мета программирование полезно для уменьшения объёма кода, который вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.

Ярлык функции должна объявлять некоторое количество и вид этих свойств имеющихся у функции. Макросы, с другой стороны, могут принимать переменное число свойств: мы можем вызвать `println!("hello")` с одним переменнаяом или `println!("hello {}", name)` с двумя переменнойми. Также макросы раскрываются до того как сборщик преобразует смысл кода, поэтому макрос может, например, реализовать типаж заданного вида. Функция этого не может, потому что она вызывается во время выполнения и типаж должен быть реализован во время сборки.

Обратной стороной реализации макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте Ржавчина код, который записывает другой Ржавчина код. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.

Другое важное различие между макросами и функциями заключается в том, что вы должны объявить макросы или добавить их в область видимости *прежде* чем можете вызывать их в файле, в отличии от функций, которые вы можете объявить где угодно и вызывать из любого места.

### Декларативные макросы с `macro_rules!` для общего мета программирования

Наиболее широко используемой способом макросов в Ржавчина являются *декларативные макросы*. Они также иногда упоминаются как "макросы на примере", "`macro_rules!` макрос" или просто "макросы". По своей сути декларативные макросы позволяют писать нечто похожее на выражение `match` в  Rust. Как обсуждалось в главе 6, `match` выражения являются управляющими структурами, которые принимают некоторое выражение, итог значения выражения сопоставляют с шаблонами, а затем запускают код для сопоставляемой ветки. Макросы также сравнивают значение с шаблонами, которые связаны с определенным кодом: в этой случаи значение является записью исходного кода Rust, переданным в макрос. Шаблоны сравниваются со структурами этого исходного кода и при совпадении код, связанный с каждым шаблоном, заменяет код переданный макросу. Все это происходит во время сборки.

Для определения макроса используется устройство `macro_rules!`. Давайте рассмотрим, как использовать `macro_rules!` глядя на то, как объявлен макрос `vec!`. В главе 8 рассказано, как можно использовать макрос `vec!` для создания нового вектора с определёнными значениями. Например, следующий макрос создаёт новый вектор, содержащий три целых числа:

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

Мы также могли использовать макрос `vec!` для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не смогли бы использовать функцию, чтобы сделать то же самое, потому что мы не знали бы заранее количество или вид значений.

В приложении 19-28 приведено несколько упрощённое определение макроса `vec!`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-28/src/lib.rs}}
```

<span class="caption">Приложение 19-28: Упрощённая исполнение определения макроса <code>vec!</code></span>

> Примечание: действительное определение макроса `vec!` в встроенной библиотеке содержит код для предварительного выделения правильного объёма памяти. Этот код является переработкой, которую мы здесь не используем, чтобы сделать пример проще.

Изложение `#[macro_export]` указывает, что данный макрос должен быть доступен всякий раз, когда ящик с объявленным макросом, добавлен в область видимости. Без этой изложении макрос нельзя добавить в область видимости.

Затем мы начинаем объявление макроса с помощью  `macro_rules!` и имени макроса, который объявляется *без* восклицательного знака. Название, в данном случае `vec`, после которого следуют фигурные скобки, указывающие тело определения макроса.

Структура в теле макроса `vec!` похожа на структуру `match` выражения. Здесь у нас есть одна ветвь с шаблоном `( $( $x:expr ),* )`, затем следует ветвь `=>` и раздел кода, связанный с этим шаблоном. Если шаблон сопоставлен успешно, то соответствующий раздел кода будет создан. Учитывая, что данный код является единственным шаблоном в этом макросе, существует только один действительный способ сопоставления, любой другой шаблон приведёт к ошибке. Более сложные макросы будут иметь более одной ветви.

Допустимый правила написания шаблона в определениях макросов отличается от правил написания шаблона рассмотренного в главе 18, потому что шаблоны макроса сопоставляются со структурами кода Rust, а не со значениями. Давайте пройдёмся по тому, какие части шаблона в приложении 19-28 что означают; полный правила написания шаблонов макроса можно найти в [Справочнике по Rust].

Во-первых, мы используем набор скобок, чтобы охватить весь шаблон. Мы используем знак доллара ( `$`) для объявления переменной в системе макросов, которая будет содержать код на Rust, соответствующий шаблону. Знак доллара показывает, что это макропеременная, а не обычная переменная Rust. Далее следует набор скобок, в котором определятся значения, соответствующие шаблону в скобках, для использования в коде замены. Внутри `$()` находится `$x:expr`, которое соответствует любому выражению Ржавчина и даёт выражению имя `$x`.

Запятая, следующая за `$()` указывает на то, что буквенный символ-разделитель запятая может дополнительно появиться после кода, который соответствует коду в `$()`. Звёздочка `*` указывает, что шаблон соответствует ноль или больше раз тому, что предшествует `*`.

Когда вызывается этот макрос с помощью `vec![1, 2, 3];` шаблон `$x` соответствует три раза всем трём выражениям `1`, `2` и `3`.

Теперь давайте посмотрим на шаблон в теле кода, связанного с этой ветвью: `temp_vec.push()` внутри `$()*` генерируется для каждой части, которая соответствует символу `$()` в шаблоне ноль или более раз в зависимости от того, сколько раз шаблон сопоставлен. Символ `$x` заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с `vec![1, 2, 3];`, созданный код, заменяющий этот вызов макроса будет следующим:

```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

Мы определили макрос, который может принимать любое количество переменных любого вида и может генерировать код для создания вектора, содержащего указанные элементы.

Чтобы узнать больше о том, как писать макросы, обратитесь к онлайн-документации или другим ресурсам, таким как [«Маленькая книга макросов Rust»] , начатая Дэниелом Кипом и продолженная Лукасом Виртом.

### Процедурные макросы для генерации кода из свойств

Вторая разновидность макросов - это *процедурные макросы* (procedural macros), которые действуют как функции (и являются видом процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают над этим кодом и создают некоторый код в качестве вывода, а не выполняют сопоставления с шаблонами и замену кода другим кодом, как это делают декларативные макросы. Процедурные макросы могут быть трёх видов: "пользовательского вывода" (custom-derive), "похожие на свойство" (attribute-like) и "похожие на функцию" (function-like), все они работают схожим образом.

При создании процедурных макросов объявления должны находиться в собственном ящике целенаправленного вида. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. В приложении 19-29 показано, как задать процедурный макрос, где `some_attribute` является заполнителем для использования целенаправленного макроса.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

<span class="caption">Приложение 19-29: Пример определения процедурного макроса</span>

Функция, которая определяет процедурный макрос, принимает `TokenStream` в качестве входных данных и создаёт `TokenStream` в качестве вывода. Вид `TokenStream` объявлен ящиком `proc_macro`, включённым в Ржавчина и представляет собой последовательность токенов. Это ядро макроса: исходный код над которым работает макрос, является входным `TokenStream`, а код создаваемый макросом является выходным `TokenStream`. К функции имеет также прикреплённый свойство, определяющий какой вид процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же ящике.

Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие разновидности отличающимися.

### Как написать пользовательский `derive` макрос

Давайте создадим ящик с именем `hello_macro`, который определяет типаж с именем `HelloMacro` и имеет одну с ним сопряженную функцию с именем `hello_macro`. Вместо того, чтобы пользователи нашего ящика самостоятельно реализовывали типаж `HelloMacro` для каждого из своих видов, мы предоставим им процедурный макрос, чтобы они могли определять свой вид с помощью свойства `#[derive(HelloMacro)]` и получили реализацию по умолчанию для функции `hello_macro`. Реализация по умолчанию выведет `Hello, Macro! My name is TypeName!`, где `TypeName` - это имя вида, для которого был определён этот типаж. Другими словами, мы напишем ящик, использование которого позволит другому программисту писать код показанный в приложении 19-30.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-30/src/main.rs}}
```

<span class="caption">Приложение 19-30: Код, который сможет писать пользователь нашего ящика при использовании нашего процедурного макроса</span>

Этот код напечатает `Hello, Macro! My name is Pancakes!`, когда мы закончим. Первый шаг - создать новый, библиотечный ящик так:

```console
$ cargo new hello_macro --lib
```

Далее, мы определим типаж `HelloMacro` и сопряженную с ним функцию:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/hello_macro/src/lib.rs}}
```

У нас есть типаж и его функция. На этом этапе пользователь ящика может реализовать типаж для достижения желаемой функциональности, так:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/pancakes/src/main.rs}}
```

Тем не менее, ему придётся написать разделреализации для каждого вида, который он хотел использовать вместе с `hello_macro`; а мы хотим избавить их от необходимости делать эту работу.

Кроме того, мы пока не можем предоставить функцию `hello_macro` с реализацией по умолчанию, которая будет печатать имя вида, для которого реализован типаж: Ржавчина не имеет возможностей рефлексии (reflection), поэтому он не может выполнить поиск имени вида во время выполнения кода. Нам нужен макрос для генерации кода во время сборки.

Следующим шагом является определение процедурного макроса. На мгновение написания этой статьи процедурные макросы должны быть в собственном ящике. Со временем это ограничение может быть отменено. Соглашение о структурировании ящиков и макросов является следующим: для ящика с именем `foo`, его пользовательский, ящик с выводимым процедурным макросом называется `foo_derive`. Давайте начнём с создания нового ящика с именем `hello_macro_derive` внутри проекта `hello_macro`:

```console
$ cargo new hello_macro_derive --lib
```

Наши два ящика тесно связаны, поэтому мы создаём процедурный макрос-ящик в папке ящика `hello_macro`. Если мы изменим определение типажа в `hello_macro`, то нам придётся также изменить реализацию процедурного макроса в `hello_macro_derive`. Два ящика нужно будет обнародовать отдельно и программисты, использующие эти ящики, должны будут добавить их как зависимости, а затем добавить их в область видимости. Мы могли вместо этого сделать так, что ящик `hello_macro` использует `hello_macro_derive` как зависимость и реэкспортирует код процедурного макроса. Однако то, как мы структурировали проект, делает возможным программистам использовать `hello_macro` даже если они не хотят `derive` функциональность.

Нам нужно объявить ящик `hello_macro_derive` как процедурный макрос-ящик. Также понадобятся функционал из ящиков `syn` и `quote`, как вы увидите через мгновение, поэтому нам нужно добавить их как зависимости. Добавьте следующее в файл *Cargo.toml* для `hello_macro_derive`:

<span class="filename">Файл: hello_macro_derive/Cargo.toml</span>

```toml
{{#include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}
```

Чтобы начать определение процедурного макроса, поместите код приложения 19-31 в ваш файл *src/lib.rs* ящика `hello_macro_derive`. Обратите внимание, что этот код не ссобирается пока мы не добавим определение для функции `impl_hello_macro`.

<span class="filename">Файл: hello_macro_derive/src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/src/lib.rs}}
```

<span class="caption">Приложение 19-31: Код, который потребуется в большинстве процедурных макро ящиков для обработки Ржавчина кода</span>

Обратите внимание, что мы разделили код на функцию `hello_macro_derive`, которая отвечает за синтаксический анализ `TokenStream` и функцию `impl_hello_macro`, которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса удобнее. Код во внешней функции ( `hello_macro_derive` в данном случае) будет одинаковым для почти любого процедурного макрос ящика, который вы видите или создаёте. Код, который вы указываете в теле внутренней функции (в данном случае `impl_hello_macro` ) будет отличаться в зависимости от цели вашего процедурного макроса.

Мы представили три новых ящика: `proc_macro` [`syn`] и [`quote`]. Макрос `proc_macro` поставляется с Rust, поэтому нам не нужно было добавлять его в зависимости внутри *Cargo.toml*. Макрос `proc_macro` - это API сборщика, который позволяет нам читать и управлять Ржавчина кодом из нашего кода.

Ящик `syn` разбирает Ржавчина код из строки в структуру данных над которой мы может выполнять действия. Ящик `quote` превращает структуры данных `syn` обратно в код Rust. Эти ящики упрощают разбор любого вида Ржавчина кода, который мы хотели бы обрабатывать: написание полного синтаксического анализатора для кода Ржавчина не является простой задачей.

Функция `hello_macro_derive` будет вызываться, когда пользователь нашей библиотеки указывает своему виду `#[derive(HelloMacro)]`. Это возможно, потому что мы определяли функцию `hello_macro_derive` с помощью `proc_macro_derive` и указали имя `HelloMacro`, которое соответствует имени нашего типажа; это соглашение, которому следует большинство процедурных макросов.

Функция `hello_macro_derive` сначала преобразует `input` из `TokenStream` в структуру данных, которую мы можем затем преобразовать и над которой выполнять действия. Здесь ящик `syn` вступает в игру. Функция `parse` в `syn` принимает `TokenStream` и возвращает структуру `DeriveInput`, представляющую разобранный код Rust. Приложение 19-32 показывает соответствующие части структуры `DeriveInput`, которые мы получаем при разборе строки `struct Pancakes;`:

```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

<span class="caption">Приложение 19-32: Образец <code>DeriveInput</code> получаемый, когда разбирается код имеющий свойство макроса из приложения 19-30</span>

Поля этой структуры показывают, что код Rust, который мы разобрали, является разделструктуры с `ident` (определителем, означающим имя) `Pancakes`. В этой структуре есть больше полей для описания всех видов кода Rust; проверьте [документацию `syn` о структуре `DeriveInput`] для получения дополнительной сведений.

Вскоре мы определим функцию `impl_hello_macro`, в которой построим новый, дополнительный код Rust. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является `TokenStream`. Возвращаемый `TokenStream` добавляется в код, написанный пользователями макроса, поэтому, когда они соберут свой ящик, они получат дополнительную функциональность, которую мы предоставляем в изменённом `TokenStream`.

Возможно, вы заметили, что мы вызываем `unwrap` чтобы выполнить панику в функции `hello_macro_derive`, если вызов функции `syn::parse` потерпит неудачу. Наш процедурный макрос должен паниковать при ошибках, потому что функции `proc_macro_derive` должны возвращать `TokenStream`, а не вид `Result` для соответствия API процедурного макроса. Мы упроисполнения этот пример с помощью `unwrap`, но в рабочем коде вы должны предоставить более определенные сообщения об ошибках, если что-то пошло не правильно, используя `panic!` или `expect`.

Теперь, когда у нас есть код для преобразования определеного Ржавчина кода из `TokenStream` в образец `DeriveInput`, давайте создадим код реализующий типаж `HelloMacro` у определеного вида, как показано в приложении 19-33.

<span class="filename">Файл: hello_macro_derive/src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-33/hello_macro/hello_macro_derive/src/lib.rs:here}}
```

<span class="caption">Приложение 19-33: Реализация типажа <code>HelloMacro</code> с использованием проанализированного кода Rust.</span>

Мы получаем образец структуры `Ident` содержащий имя (определитель) определеного вида с использованием `ast.ident`. Структура в приложении 19-32 показывает, что когда мы запускаем функцию `impl_hello_macro` для кода из приложения 19-30, то получаемый `ident` будет иметь поле `ident` со значением `"Pancakes"`. Таким образом, переменная `name` в приложении 19-33 будет содержать образец структуры `Ident`, что при печати выдаст строку `"Pancakes"`, что является именем структуры в приложении 19-30.

Макрос `quote!` позволяет определить код Rust, который мы хотим вернуть. Сборщик ожидает что-то отличное от прямого итога выполнения макроса `quote!`, поэтому нужно преобразовать его в `TokenStream`. Мы делаем это путём вызова способа `into`, который использует промежуточное представление и возвращает значение требуемого вида `TokenStream`.

Макрос `quote!` также предоставляет очень полезную механику шаблонов: мы можем ввести `#name` и `quote!` заменит его значением из переменной `name`. Вы можете даже сделать некоторое повторение, подобное тому, как работают обычные макросы. Проверьте [документацию ящика `quote`] для подробного введения.

Мы хотим, чтобы наш процедурный макрос генерировал реализацию нашего типажа `HelloMacro` для вида, который определял пользователь, который мы можем получить, используя `#name`. Реализация типажа имеет одну функцию `hello_macro`, тело которой содержит функциональность, которую мы хотим предоставить: напечатать `Hello, Macro! My name is` с именем определеного вида.

Макрос `stringify!` используемый здесь, встроен в Rust. Он принимает Ржавчина выражение, такое как `1 + 2` и во время сборки сборщик превращает выражение в строковый запись, такой как `"1 + 2"`. Он отличается от макросов `format!` или `println!`, которые вычисляют выражение, а затем превращают итог в виде вида `String`. Существует возможность того, что введённый `#name` может оказаться выражением для печати буквально как есть, поэтому здесь мы используем `stringify!`. Использование `stringify!` также экономит выделение памяти путём преобразования `#name` в строковый запись во время сборки.

На этом этапе приказ `cargo build` должна завершиться успешно для обоих `hello_macro` и `hello_macro_derive`. Давайте подключим эти ящики к коду в приложении 19-30, чтобы увидеть процедурный макрос в действии! Создайте новый двоичный проект в папке ваших *проектов* с использованием приказы `cargo new pancakes`. Нам нужно добавить `hello_macro` и `hello_macro_derive` в качестве зависимостей для ящика `pancakes` в файл *Cargo.toml*. Если вы публикуете свои исполнения `hello_macro` и `hello_macro_derive` на сайт [crates.io](https://crates.io/), они будут обычными зависимостями; если нет, вы можете указать их как `path` зависимости следующим образом:

```toml
{{#include ../listings/ch19-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}
```

Поместите код в приложении 19-30 в *src/main.rs* и выполните `cargo run`: он должен вывести `Hello, Macro! My name is Pancakes!`. Реализация типажа `HelloMacro` из процедурного макроса была включена без необходимости его реализации ящиком `pancakes`; `#[derive(HelloMacro)]` добавил реализацию типажа.

Далее давайте рассмотрим, как другие виды процедурных макросов отличаются от пользовательских выводимых макросов.

### Макросы, похожие на свойство

Подобные свойствам макросы похожи на пользовательские выводимые макросы, но вместо генерации кода для `derive` свойства, они позволяют создавать новые свойства. Они являются также более гибкими: `derive` работает только для структур и перечислений; свойство-подобные могут применяться и к другим элементам, таким как функции. Вот пример использования  имеющего свойство макроса: допустим, у вас есть свойство именованный `route` который определяет функции при использовании фреймворка для веб-приложений:

```rust,ignore
#[route(GET, "/")]
fn index() {
```

Данный свойство `#[route]` будет определён платспособом как процедурный макрос. Ярлык функции определения макроса будет выглядеть так:

```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

Здесь есть два свойства вида `TokenStream`. Первый для содержимого свойства: часть `GET, "/"` . Второй это тело элемента, к которому прикреплён свойство: в данном случае `fn index() {}` и остальная часть тела функции.

Кроме того, имеющие свойства макросы работают так же как и пользовательские выводимые макросы: вы создаёте ящик с видом `proc-macro` и реализуете функцию, которая генерирует код, который хотите!

### Макросы, похожие на функции

Макросы, похожие на функции, выглядят подобно вызову функций. Подобно макросам `macro_rules!` они являются более гибкими, чем функции; например, они могут принимать неизвестное количество переменных. Тем не менее, макросы `macro_rules!` можно объявлять только с использованием правил написания подобного сопоставлению, который мы обсуждали ранее в разделе <a data-md-type="raw_html" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">"Декларативные макросы `macro_rules!` для общего мета программирования"</a>. Макросы, похожие на функции, принимают свойство <code>TokenStream</code> и их определение управляет этим `TokenStream`, используя код Rust, как это делают два других вида процедурных макроса. Примером подобного функционально подобного макроса является макрос `sql!`, который можно вызвать так:

```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

Этот макрос будет разбирать SQL указанию внутри него и проверять, что она синтаксически правильная, что является гораздо более сложной обработкой, чем то что может сделать макрос `macro_rules!`. Макрос `sql!` мог бы быть определён так:

```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

Это определение похоже на ярлык пользовательского выводимого макроса: мы получаем токены, которые находятся внутри скобок и возвращаем код, который мы хотели создать.

## Итоги

Фух! Теперь у вас в распоряжении есть некоторые возможности Rust, которые вы не будете часто использовать, но вы будете знать, что они доступны в особых обстоятельствах. Мы представили несколько сложных тем, чтобы при появлении сообщения с предложением исправить ошибку или в коде других людей, вы могли бы распознать эти подходы и правила написания. Используйте эту главу как справочник, который поможет вам найти решение.

Далее мы применим в действительностивсе, что обсуждали на протяжении всей книги, и выполним ещё один проект!


[Справочнике по Rust]: ../reference/macros-by-example.html
[«Маленькая книга макросов Rust»]: https://veykril.github.io/tlborm/
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
[документацию `syn` о структуре `DeriveInput`]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
[документацию ящика `quote`]: https://docs.rs/quote