## Unsafe Rust

Во всех предыдущих главах этой книги мы обсуждали код на Rust, безопасность памяти в котором обеспечивается во время сборки. Однако внутри Rust скрывается другой язык - небезопасный Rust, который не обеспечивает безопасной работы с памятью. Этот язык называется *unsafe Rust* и работает также как и первый, но предоставляет вам дополнительные возможности.

Небезопасный Rust существует потому что по своей природе постоянной анализ довольно консервативен. Когда сборщик пытается определить, соответствует ли код заверениям, то он скорее отвергнет несколько допустимых программ, чем пропустит несколько недопустимых. Не смотря на то, что код *может* быть в порядке, если сборщик Rust не будет располагать достаточной сведениями, чтобы убедиться в этом, он отвергнет код. В таких случаях вы можете использовать небезопасный код, чтобы сказать сборщику: "Поверь мне, я знаю, что делаю". Однако имейте в виду, что вы используете небезопасный Rust на свой страх и риск: если вы неправильно используете небезопасный код, могут возникнуть сбоев, связанные с нарушением безопасности памяти, например, разыменование нулевого указателя.

Другая причина, по которой у Rust есть небезопасное альтер эго, заключается в том, что по существу аппаратное обеспечение компьютера небезопасно. Если Rust не позволял бы вам выполнять небезопасные действия, вы не могли бы выполнять определённые задачи. Rust должен позволить вам использовать системное, низкоуровневое программирование, такое как прямое взаимодействие с операционной системой, или даже написание вашей собственной операционной системы. Возможность написания низкоуровневого, системного кода является одной из целей языка. Давайте рассмотрим, что и как можно делать с небезопасным Rust.

### Небезопасные сверхспособности

Чтобы переключиться на небезопасный Rust, используйте ключевое слово `unsafe`, а затем начните новый блок, содержащий небезопасный код. В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем *небезопасными супер силами*. Эти супер силы включают в себя следующее:

- Разыменование сырого указателя
- Вызов небезопасной функции или небезопасного способа
- Доступ или изменение изменяемой постоянной переменной
- Реализация небезопасного типажа
- Доступ к полям в `union`

Важно понимать, что `unsafe` не отключает проверку заимствования или любые другие проверки безопасности Rust: если вы используете ссылку в небезопасном коде, она всё равно будет проверена. Единственное, что делает ключевое слово `unsafe` - даёт вам доступ к этим пяти возможностям, безопасность работы с памятью в которых не проверяет сборщик. Вы по-прежнему получаете некоторую степень безопасности внутри небезопасного раздела.

Кроме того, `unsafe` не означает, что код внутри этого раздела является неизбежно опасным или он точно будет иметь сбоев с безопасностью памяти: цель состоит в том, что вы, как программист, заверяете, что код внутри раздела `unsafe` будет обращаться к действительной памяти корректным образом.

Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных действия внутри разделов, помеченных как `unsafe`, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри `unsafe` разделов. Делайте `unsafe` разделы маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.

Чтобы наиболее изолировать небезопасный код, советуется заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже, когда будем обсуждать небезопасные функции и способы. Части встроенной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом. Оборачивание небезопасного кода в безопасную абстракцию предотвращает возможную утечку использования `unsafe` кода во всех местах, где вы или ваши пользователи могли бы захотеть напрямую использовать функциональность, реализованную `unsafe` кодом, потому что использование безопасной абстракции само безопасно.

Давайте поговорим о каждой из четырёх небезопасных сверх способностей, и по ходу дела рассмотрим некоторые абстракции, которые обеспечивают безопасный внешняя оболочка для небезопасного кода.

### Разыменование сырых указателей

В главе 4 раздела ["Недействительные ссылки"](ch04-02-references-and-borrowing.html#dangling-references)<!--  --> мы упоминали, что сборщик заверяет, что ссылки всегда действительны. Небезопасный Rust имеет два новых вида, называемых *сырыми указателями* (raw pointers), которые похожи на ссылки. Как и в случае ссылок, сырые указатели могут быть неизменяемыми или изменяемыми и записываться как `*const T` и `*mut T` соответственно. Звёздочка не является оператором разыменования; это часть имени вида. В среде сырых указателей *неизменяемый* (immutable) означает, что указателю нельзя напрямую присвоить что-то после того как он разыменован.

В отличие от ссылок и умных указателей, сырые указатели:

- могут пренебрегать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти
- не заверяют что ссылаются на действительную память
- могут быть null
- не реализуют самостоятельную очистку памяти

Отказавшись от этих заверений, вы можете обменять безопасность  на большую производительность или возможность взаимодействия с другим языком или оборудованием, где заверения Rust не применяются.

В приложении 19-1 показано, как создать неизменяемый и изменяемый сырой указатель из ссылок.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}
```

<span class="caption">Приложение 19-1: Создание необработанных указателей из ссылок</span>

Обратите внимание, что мы не используем ключевое слово `unsafe` в этом коде. Можно создавать сырые указатели в безопасном коде; мы просто не можем разыменовывать сырые указатели за пределами небезопасного раздела, как вы увидите чуть позже.

Мы создали сырые указатели, используя `as` для приведения неизменяемой и изменяемой ссылки к соответствующим им видам сырых указателей. Поскольку мы создали их непосредственно из ссылок, которые обязательно являются действительными, мы знаем, что эти определенные сырые указатели являются действительными, но мы не можем делать такое же предположение о любом сыром указателе.

Чтобы отобразить это, создадим сырой указатель, в достоверности которого мы не можем быть так уверены. В приложении 19-2 показано, как создать необработанный указатель на произвольное место в памяти. Попытка использовать произвольную память является непредсказуемой: по этому адресу могут быть данные, а могут и не быть, сборщик может перерабатывать код так, что доступа к памяти не будет, или программа может завершиться с ошибкой сегментации. Обычно нет веских причин писать такой код, но это возможно.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}
```

<span class="caption">Приложение 19-2: Создание сырого указателя на произвольный адрес памяти</span>

Напомним, что можно создавать сырые указатели в безопасном коде, но нельзя *разыменовывать* сырые указатели и читать данные, на которые они указывают. В приложении 19-3 мы используем оператор разыменования `*` для сырого указателя, который требует `unsafe` раздела.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}
```

<span class="caption">Приложение 19-3: Разыменование сырых указателей в разделе <code>unsafe</code></span>

Создание указателей безопасно. Только при попытке доступа к предмету по адресу в указателе мы можем получить недопустимое значение.

Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали `*const i32` и `*mut i32`, которые ссылаются на одну и ту же область памяти, где хранится `num`. Если мы попытаемся создать неизменяемую и изменяемую ссылку на `num` вместо сырых указателей, такой код не ссобирается, т.к. будут нарушены правила заимствования, запрещающие наличие изменяемой ссылки одновременно с неизменяемыми ссылками. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый указатель на одну и ту же область памяти и изменять данные с помощью изменяемого указателя, возможно создавая эффект гонки данных. Будьте осторожны!

С учётом всех этих опасностей, зачем тогда использовать сырые указатели? Одним из основных применений является взаимодействие с кодом C, как вы увидите в следующем разделе ["Вызов небезопасной функции или способа"](#calling-an-unsafe-function-or-method)<!--  -->. Другой случай это создание безопасных абстракций, которые не понимает анализатор заимствований. Мы введём понятие небезопасных функций и затем рассмотрим пример безопасной абстракции, которая использует небезопасный код.

### Вызов небезопасной функции или способа

Второй вид действий, которые можно выполнять в небезопасном разделе - это вызов небезопасных функций. Небезопасные функции и способы выглядят точно так же, как обычные функции и способы, но перед остальным определением у них есть дополнительное `unsafe`. Ключевое слово `unsafe` в данном среде указывает на то, что к функции предъявляются требования, которые мы должны соблюдать при вызове этой функции, поскольку Rust не может обеспечить, что мы их выполняем. Вызывая небезопасную функцию внутри раздела `unsafe`, мы говорим, что прочитали документацию к этой функции и берём на себя ответственность за соблюдение её условий.

Вот небезопасная функция с именем `dangerous` которая ничего не делает в своём теле:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}
```

Мы должны вызвать функцию `dangerous` в отдельном `unsafe` разделе. Если мы попробуем вызвать `dangerous` без `unsafe` раздела, мы получим ошибку:

```console
{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}
```

С помощью раздела `unsafe` мы сообщаем Rust, что прочитали документацию к функции, поняли, как правильно её использовать, и убедились, что выполняем контракт функции.

Тела небезопасных функций являются в действительности `unsafe` разделами, поэтому для выполнения других небезопасных действий внутри небезопасной функции не нужно добавлять ещё один `unsafe` блок.

#### Создание безопасных абстракций вокруг небезопасного кода

То, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. На самом деле, обёртывание небезопасного кода в безопасную функцию - это обычная абстракция. В качестве примера рассмотрим функцию `split_at_mut` из встроенной библиотеки, которая требует некоторого небезопасного кода. Рассмотрим, как мы могли бы её реализовать. Этот безопасный способ определён для изменяемых срезов: он берет один срез и превращает его в два, разделяя срез по порядковому указателю, указанному в качестве переменной. В приложении 19-4 показано, как использовать `split_at_mut`.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}
```

<span class="caption">Приложение 19-4: Использование безопасной функции <code>split_at_mut</code></span>

Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации могла бы выглядеть примерно как в приложении 19-5, который не собирается. Для простоты мы реализуем `split_at_mut` как функцию, а не как способ, и только для значений вида `i32`, а не обобщённого вида `T`.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}
```

<span class="caption">Приложение 19-5: Попытка реализации <code>split_at_mut</code> с использованием только безопасного Rust</span>

Эта функция сначала получает общую длину среза. Затем она проверяет (assert), что порядковый указатель, переданный в качестве свойства, находится в границах среза, сравнивая его с длиной. Assert означает, что если мы передадим порядковый указатель, который больше, чем длина среза, функция запаникует ещё до попытки использования этого порядкового указателя.

Затем мы возвращаем два изменяемых фрагмента в кортеже: один от начала исходного фрагмента до `mid` порядкового указателя (не включая сам mid), а другой - от `mid` (включая сам mid) до конца фрагмента.

При попытке собрать код в приложении 19-5, мы получим ошибку.

```console
{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}
```

Анализатор заимствований Rust не может понять, что мы заимствуем различные части среза, он понимает лишь, что мы хотим осуществить заимствование частей одного среза дважды. Заимствование различных частей среза в принципе в порядке вещей, потому что они не перекрываются, но Rust недостаточно умён, чтобы это понять. Когда мы знаем, что код верный, но Rust этого не понимает, значит пришло время прибегнуть к небезопасному коду.

Приложение 19-6 отображает, как можно использовать `unsafe` блок, сырой указатель и вызовы небезопасных функций чтобы `split_at_mut` заработала:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}
```

<span class="caption">Приложение 19-6. Использование небезопасного кода в реализации функции <code>split_at_mut</code></span>

Напомним, из раздела ["Вид срез"]<!-- ignore --> главы 4, что срезы состоят из указателя на некоторые данные и длины. Мы используем способ `len` для получения длины среза и способ `as_mut_ptr` для доступа к сырому указателю среза. Поскольку у нас есть изменяемый срез на значения вида `i32`, функция `as_mut_ptr` возвращает сырой указатель вида `*mut i32`, который мы сохранили в переменной `ptr`.

Далее проверяем, что порядковый указатель`mid` находится в границах среза. Затем мы обращаемся к небезопасному коду: функция `slice::from_raw_parts_mut` принимает сырой указатель, длину и создаёт срез. Мы используем эту функцию для создания среза, начинающегося с `ptr` и имеющего длину в `mid` элементов. Затем мы вызываем способ `add` у `ptr` с `mid` в качестве переменной, чтобы получить сырой указатель, который начинается с `mid`, и создаём срез, используя этот указатель и оставшееся количество элементов после `mid` в качестве длины.

Функция `slice::from_raw_parts_mut` является небезопасной, потому что она принимает необработанный указатель и должна полагаться на то, что этот указатель действителен. Способ `add` для необработанных указателей также небезопасен, поскольку он должен считать, что местоположение смещения также является действительным указателем. Поэтому мы были вынуждены разместить `unsafe` разделвокруг наших вызовов `slice::from_raw_parts_mut` и `add`, чтобы иметь возможность вызвать их. Посмотрев на код и добавив утверждение, что `mid` должен быть меньше или равен `len`, мы можем сказать, что все необработанные указатели, используемые в разделе `unsafe`, будут корректными указателями на данные внутри среза. Это приемлемое и уместное использование `unsafe`.

Обратите внимание, что нам не нужно помечать результирующую функцию `split_at_mut` как `unsafe`, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с помощью реализации функции, которая использует код `unsafe` раздела безопасным образом, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.

Напротив, использование `slice::from_raw_parts_mut` в приложении 19-7 приведёт к вероятному сбою при использовании среза. Этот код использует произвольный адрес памяти и создаёт срез из 10000 элементов.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}
```

<span class="caption">Приложение 19-7: Создание среза из произвольного адреса памяти</span>

Мы не владеем памятью в этом произвольном месте, и нет никакой заверения, что созданный этим кодом фрагмент содержит допустимые значения `i32`. Попытка использовать `values` так, как будто это допустимый срез, приводит к неопределённому поведению.

#### Использование `extern` функций для вызова внешнего кода

Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на другом языке. Для этого в Rust есть ключевое слово `extern`, которое облегчает создание и использование *внешней оболочки внешних функций (Foreign Function Interface - FFI)*. FFI - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.

Приложение 19-8 отображает, как настроить встраивание с функцией `abs` из встроенной библиотеки C. Функции, объявленные внутри разделов `extern`, всегда небезопасны для вызова из кода Rust. Причина в том, что другие языки не обеспечивают соблюдение правил и заверений Rust, Rust также не может проверить заверения, поэтому ответственность за безопасность ложится на программиста.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}
```

<span class="caption">Приложение 19-8: Объявление и вызов <code>extern</code> функции, написанной на другом языке программирования</span>

Внутри раздела `extern "C"` мы перечисляем имена и сигнатуры внешних функций из другого языка, которые мы хотим вызвать. Часть `"C"` определяет какой *application binary interface* (ABI - двоичный внешняя оболочка приложений) использует внешняя функция. Внешнюю оболочку ABI определяет как вызвать функцию на уровне ассемблера. Использование ABI `"C"` является наиболее часто используемым и следует правилам ABI внешней оболочки языка Си.

> #### Вызов функций Rust из других языков
>
> Также можно использовать `extern` для создания внешней оболочки, позволяющего другим языкам вызывать функции Rust. Вместо того чтобы создавать целый раздел`extern`, мы добавляем ключевое слово `extern` и указываем ABI для использования непосредственно перед ключевым словом `fn` для необходимой функции. Нам также нужно добавить изложение `#[no_mangle]`, чтобы сказать сборщику Rust не искажать имя этой функции. *Искажение* - это когда сборщик меняет имя, которое мы дали функции, на другое имя, которое содержит больше сведений для других частей процесса сборки, но менее читабельно для человека. Сборщик каждого языка программирования искажает имена по-разному, поэтому, чтобы функция Rust могла быть использована другими языками, мы должны отключить искажение имён в сборщике Rust.
>
> В следующем примере мы делаем функцию `call_from_c` доступной из кода на C, после того как она будет собрана в разделяемую библиотеку и прилинкована с C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> Такое использование `extern` не требует `unsafe`.

### Получение доступа и внесение изменений в изменяемую постоянную переменную

В этой книге мы ещё не говорили о *вездесущих переменных*, которые Rust поддерживает, но с которыми могут возникнуть сбоев из-за действующих в Rust правил владения. Если два потока обращаются к одной и той же изменяемой вездесущей переменной, это может привести к гонке данных.

Вездесущие переменные в Rust называют *постоянными* (static). Приложение 19-9 отображает пример объявления и использования в качестве значения постоянной переменной, имеющей вид строкового среза:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}
```

<span class="caption">Приложение 19-9: Определение и использование неизменяемой постоянной переменной</span>

Постоянные переменные похожи на константы, которые мы обсуждали в разделе [“Различия между переменными и константами”](ch03-01-variables-and-mutability.html#constants)<!-- ignore --> главы 3. Имена постоянных переменных по общему соглашению пишутся в наставлении `SCREAMING_SNAKE_CASE`, и мы <em>должны</em> указывать вид переменной, которым в данном случае является <code>&amp;'static str</code>. Постоянные переменные могут хранить только ссылки со временем жизни <code>'static</code>, это означает что сборщик Rust может вывести время жизни и нам не нужно прописывать его явно. Доступ к неизменяемой постоянной переменной является безопасным.

Тонкое различие между константами и неизменяемыми постоянными переменными заключается в том, что значения в постоянной переменной имеют определенный адрес в памяти. При использовании значения всегда будут доступны одни и те же данные. Константы, с другой стороны, могут повторять свои данные при каждом использовании. Ещё одно отличие заключается в том, что постоянные переменные могут быть изменяемыми. Обращение к изменяемым постоянном переменным и их изменение является *небезопасным*. В приложении 19-10 показано, как объявить, получить доступ и модифицировать изменяемую постоянную переменную с именем `COUNTER`.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}
```

<span class="caption">Приложение 19-10: Чтение из изменяемой постоянной переменной или запись в неё небезопасны</span>

Как и с обычными переменными, мы определяем изменяемость с помощью ключевого слова `mut`. Любой код, который читает из или пишет в переменную `COUNTER` должен находиться в `unsafe` разделе. Этот код собирается и печатает `COUNTER: 3`, как и следовало ожидать, потому что выполняется в одном потоке. Наличие нескольких потоков с доступом к `COUNTER` приведёт к случаи гонки данных.

Наличие изменяемых данных, которые доступны вездесуще, делает трудным реализацию заверения отсутствия гонок данных, поэтому Rust считает изменяемые постоянные переменные небезопасными. Там, где это возможно, предпочтительно использовать техники многопоточности и умные указатели, направленные на многопоточное исполнение, которые мы обсуждали в главе 16. Таким образом, сборщик сможет проверить, что обращение к данным, доступным из разных потоков, выполняется безопасно.

### Реализация небезопасных типажей

Мы можем использовать `unsafe` для реализации небезопасного трейта. Трейт является небезопасным, если хотя бы один из его способов имеет некоторый инвариант, который сборщик не может проверить. Мы объявляем трейты `unsafe`, добавляя ключевое слово `unsafe` перед `trait` и помечая реализацию трейта как `unsafe`, как показано в приложении 19-11.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}
```

<span class="caption">Приложение 19-11: Определение и реализация небезопасного трейта</span>

Используя `unsafe impl`, мы даём обещание поддерживать инварианты, которые сборщик не может проверить.

Для примера вспомним маркерные типажи `Sync` и `Send`, которые мы обсуждали в разделе <a data-md-type="raw_html" href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">"Расширяемый одновременность с помощью типажей `Sync` и `Send`"</a><!-- ignore --> главы 16: сборщик реализует эти типажи самостоятельно , если наши виды полностью состоят из видов `Send` и `Sync`. Если мы создадим вид, который содержит вид, не являющийся `Send` или `Sync`, такой, как сырой указатель, и мы хотим пометить этот вид как `Send` или `Sync`, мы должны использовать `unsafe` блок. Rust не может проверить, что наш вид поддерживает заверения того, что он может быть безопасно передан между потоками или доступен из нескольких потоков; поэтому нам нужно добавить эти проверки вручную и указать это с помощью `unsafe`.

### Доступ к полям объединений (union)

Последнее действие, которое работает только с `unsafe` - это доступ к полям *union*. `union` похож на `struct`, но в каждом определенном образце одновременно может использоваться только одно объявленное поле. Объединения в основном используются для взаимодействия с объединениями в коде на языке Си. Доступ к полям объединений небезопасен, поскольку Rust не может обязательно определить вид данных, которые в данный мгновение хранятся в образце объединения. Подробнее об объединениях вы можете узнать в [the Rust Reference].

### Когда использовать небезопасный код

Использование `unsafe` для выполнения одного из пяти действий (супер способностей), которые только что обсуждались, не является ошибочным или не одобренным. Но получить корректный `unsafe` код сложнее, потому что сборщик не может помочь в обеспечении безопасности памяти. Если у вас есть причина использовать `unsafe` код, вы можете делать это, а наличие явной `unsafe` изложении облегчает отслеживание источника неполадок. если они возникают.


["Вид срез"]: ch04-03-slices.html#the-slice-type
[the Rust Reference]: ../reference/items/unions.html