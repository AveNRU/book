## Использование `Box<T>` для ссылки на данные в куче

Наиболее простой умный указатель - это *box*, чей вид записывается как `Box<T>`. Такие переменные позволяют хранить данные в куче, а не в стеке. То, что остаётся в стеке, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между стеком и кучей.

У Box нет неполадок с производительностью, кроме хранения данных в куче вместо стека. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих случаейх:

- Когда у вас есть вид, размер которого невозможно определить во время сборки, а вы хотите использовать значение этого вида в среде, требующем точного размера.
- Когда у вас есть большой размер данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут скопированы
- Когда вы хотите получить значение во владение и вас важно только то, что оно относится к виду, реализующему определённый трейт, а не то, является ли оно значением какого-то определенного вида

Мы выясним первую случай в разделе ["Реализация рекурсивных видов с помощью Box"](#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-Boxes)<!-- ignore -->. Во втором случае, передача владения на большой размер данных может занять много времени, потому что данные копируются через стек. Для повышения производительности в этой случаи, мы можем хранить большое количество данных в куче с помощью Box. Затем только небольшое количество данных указателя копируется в стеке, в то время как данные, на которые он ссылается, остаются в одном месте кучи. Третий случай известен как *типаж предмет* (trait object) и глава 17 посвящает целый раздел ["Использование типаж предметов, которые допускают значения разных видов"]<!-- ignore --> только этой теме. Итак, то, что вы узнаете здесь, вы примените снова в Главе 17!

### Использование `Box<T>` для хранения данных в куче

Прежде чем мы обсудим этот вариант использования `Box<T>`, мы рассмотрим правила написания и то, как взаимодействовать со значениями, хранящимися в `Box<T>`.

В приложении 15-1 показано, как использовать поле для хранения значения `i32` в куче:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}
```

<span class="caption">Приложение 15-1: Сохранение значения <code>i32</code> в куче с использованием box</span>

Мы объявляем переменную `b` со значением `Box`, указывающим на число `5`, размещённое в куче. Эта программа выведет `b = 5`; в этом случае мы получаем доступ к данным в box так же, как если бы эти данные находились в стеке. Как и любое другое значение, когда box выйдет из области видимости, как `b` в конце `main`, он будет удалён. Деаллокация происходит как для box ( хранящегося в стеке), так и для данных, на которые он указывает (хранящихся в куче).

Размещать одиночные значения в куче не слишком целесообразно, поэтому вряд ли вы будете часто использовать box'ы таким образом. В большинстве случаев более уместно размещать такие значения, как `i32`, в стеке, где они и сохраняются по умолчанию. Давайте рассмотрим случай, когда box позволяет нам определить виды, которые мы не могли бы иметь, если бы у нас не было box.

### Включение рекурсивных видов с помощью Boxes

Значение *рекурсивного вида* может иметь другое значение такого же вида как свой компонент. Рекурсивные виды представляют собой неполадку, поскольку во время сборки Rust должен знать, сколько места занимает вид. Однако вложенность значений рекурсивных видов предположительно может продолжаться бесконечно, поэтому Rust не может определить, сколько места потребуется. Поскольку box имеет известный размер, мы можем включить рекурсивные виды, добавив box в определение рекурсивного вида.

В качестве примера рекурсивного вида рассмотрим *cons list*. Это вид данных, часто встречающийся в функциональных языках программирования. Вид cons list, который мы определим, достаточно прост, за исключением наличия рекурсии; поэтому подходы, заложенные в примере, с которым мы будем работать, пригодятся вам в любой более сложной случаи, связанной с рекурсивными видами.

#### Больше сведений о cons списке

*cons list* - это структура данных из языка программирования Lisp и его диалектов, представляющая собой набор вложенных пар и являющаяся Lisp-исполнением связного списка. Его название происходит от функции `cons` (сокращение от "construct function") в Lisp, которая создает пару из двух своих переменных. Вызывая `cons` для пары, которая состоит из некоторого значения и другой пары, мы можем конструировать списки cons, состоящие из рекурсивных пар.

Вот, пример cons list в виде псевдокода, содержащий список 1, 2, 3, где каждая пара заключена в круглые скобки:

```text
(1, (2, (3, Nil)))
```

Каждый элемент в cons списке содержит два элемента: значение текущего элемента и следующий элемент. Последний элемент в списке содержит только значение называемое `Nil` без следующего элемента. Cons список создаётся путём рекурсивного вызова функции `cons`. Каноничное имя для обозначения основного случая рекурсии - `Nil`. Обратите внимание, что это не то же самое, что понятие “null” или “nil” из главы 6, которая является недействительным или отсутствующим значением.

Cons list не является часто используемой структурой данных в Rust. В большинстве случаев, когда вам нужен список элементов при использовании Rust, лучше использовать `Vec<T>`. Другие, более сложные рекурсивные виды данных *полезны* в определённых случаейх, но благодаря тому, что в этой главе мы начнём с cons list, мы сможем выяснить, как box позволяет нам определить рекурсивный вид данных без особого напряжения.

Приложение 15-2 содержит объявление перечисления cons списка. Обратите внимание, что этот код не будет собираться, потому что вид `List` не имеет известного размера, что мы и выясним.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}
```

<span class="caption">Приложение 15-2: Первая попытка определить перечисление в качестве структуры данных cons list, состоящей из <code>i32</code> значений.</span>

> Примечание: В данном примере мы реализуем cons list, который содержит только значения `i32`. Мы могли бы реализовать его с помощью generics, о которых мы говорили в главе 10, чтобы определить вид cons list, который мог бы хранить значения любого вида.

Использование вида `List` для хранения списка `1, 2, 3` будет выглядеть как код в приложении 15-3:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}
```

<span class="caption">Приложение 15-3: Использование перечисления <code>List</code> для хранения списка <code>1, 2, 3</code></span>

Первое значение `Cons` содержит `1` и другой `List`. Это значение `List` является следующим значением `Cons`, которое содержит `2` и другой `List`. Это значение `List` является ещё один значением `Cons`, которое содержит `3` и значение `List`, которое наконец является `Nil`, не рекурсивным вариантом, сигнализирующим об окончании списка.

Если мы попытаемся собрать код в приложении 15-3, мы получим ошибку, показанную в приложении 15-4:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
```

<span class="caption">Приложение 15-4: Ошибка, которую мы получаем при попытке определить рекурсивное перечисление</span>

Ошибка говорит о том, что этот вид "имеет бесконечный размер". Причина в том, что мы определили `List` в виде, которая является рекурсивной: она непосредственно хранит другое значение своего собственного вида. В итоге Rust не может определить, сколько места ему нужно для хранения значения `List`. Давайте разберёмся, почему мы получаем эту ошибку. Сначала мы рассмотрим, как Rust решает, сколько места ему нужно для хранения значения нерекурсивного вида.

#### Вычисление размера нерекурсивного вида

Вспомните перечисление `Message` определённое в приложении 6-2, когда обсуждали объявление enum  в главе 6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

Чтобы определить, сколько памяти выделять под значение `Message`, Rust проходит каждый из вариантов, чтобы увидеть, какой вариант требует наибольшее количество памяти. Rust видит, что для `Message::Quit` не требуется места, `Message::Move` хватает места для хранения двух значений `i32` и т.д. Так как будет использоваться только один вариант, то наибольшее пространство, которое потребуется для значения `Message`, это пространство, которое потребуется для хранения самого большого из вариантов перечисления.

Сравните это с тем, что происходит, когда Rust пытается определить, сколько места необходимо рекурсивному виду, такому как перечисление `List` в приложении 15-2. Сборщик смотрит на вариант `Cons`, который содержит значение вида `i32` и значение вида `List`. Следовательно, `Cons` нужно пространство, равное размеру `i32` плюс размер `List`. Чтобы выяснить, сколько памяти необходимо виду `List`, сборщик смотрит на варианты, начиная с `Cons`. Вариант `Cons` содержит значение вида `i32` и значение вида `List`, и этот процесс продолжается бесконечно, как показано на рисунке 15-1.

 <img alt="Бесконечный список Cons" src="img/trpl15-01.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-1: Бесконечный <code>List</code>, состоящий из нескончаемого числа вариантов <code>Cons</code></span>

#### Использование `Box<T>` для получения рекурсивного вида с известным размером

Поскольку Rust не может определить, сколько места нужно выделить для видов с рекурсивным определением, сборщик выдаёт ошибку с этим полезным предложением:

<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->

```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

В данном предложении "перенаправление" означает, что вместо того, чтобы непосредственно хранить само значение, мы должны изменить структуру данных, так чтобы хранить его косвенно - хранить указатель на это значение.

Поскольку `Box<T>` является указателем, Rust всегда знает, сколько места нужно `Box<T>`: размер указателя не меняется в зависимости от объёма данных, на которые он указывает. Это означает, что мы можем поместить `Box<T>` внутрь образца `Cons` вместо значения `List` напрямую. `Box<T>` будет указывать на значение очередного `List`, который будет находиться в куче, а не внутри образца `Cons`. Мировозренческо у нас все ещё есть список, созданный из списков, содержащих другие списки, но эта реализация теперь больше похожа на размещение элементов рядом друг с другом, а не внутри друг друга.

Мы можем изменить определение перечисления `List` в приложении 15-2 и использование `List` в приложении 15-3 на код из приложения 15-5, который будет собираться:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
```

<span class="caption">Приложение 15-5: Определение <code>List</code>, которое использует <code>Box&lt;T&gt;</code> для того, чтобы иметь вычисляемый размер</span>

`Cons` требуется объём `i32` плюс место для хранения данных указателя box. `Nil` не хранит никаких значений, поэтому ему нужно меньше места, чем `Cons`. Теперь мы знаем, что любое значение `List` займёт размер `i32` плюс размер данных указателя box. Используя box, мы разорвали бесконечную рекурсивную цепочку, поэтому сборщик может определить размер, необходимый для хранения значения `List`. На рисунке 15-2 показано, как теперь выглядит `Cons`.

 <img alt="Бесконечный список Cons" src="img/trpl15-02.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-2: <code>List</code>, который не является бесконечно большим, потому что <code>Cons</code> хранит <code>Box</code>.</span>

Box-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других особых возможностей, подобных тем, которые мы увидим у других видов умных указателей. У них также нет накладных расходов на производительность, которые несут эти особые возможности, поэтому они могут быть полезны в таких случаях, как cons list, где перенаправление - единственная функция, которая нам нужна. В главе 17 мы также рассмотрим другие случаи использования box.

Вид `Box<T>` является умным указателем, поскольку он реализует трейт `Deref`, который позволяет обрабатывать значения `Box<T>` как ссылки. Когда значение `Box<T>` выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря реализации типажа `Drop`. Эти два трейта будут ещё более значимыми для функциональности, предоставляемой другими видами умных указателей, которые мы обсудим в оставшейся части этой главы. Давайте рассмотрим эти два типажа более подробно.


["Использование типаж предметов, которые допускают значения разных видов"]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types