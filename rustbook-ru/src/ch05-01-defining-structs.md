## Определение и объявление устройств

Устройства похожи на упорядоченные ряды, рассмотренные в разделе ["Упорядоченные ряды"]<!-- ignore -->, так как оба хранят несколько связанных значений. Как и упорядоченные ряды, части устройств могут быть разных видов. В отличие от упорядоченных рядов, в устройстве необходимо именовать каждую часть данных для понимания смысла значений. Добавление этих имён обеспечивает большую гибкость устройств по сравнению с упорядоченнымм рядами: не нужно полагаться на порядок данных для указания значений образца или доступа к ним.

Для определения устройства указывается ключевое слово `struct` и её название. Название должно описывать значение частей данных, объединенных вместе. Далее, в узорчатых скобках для каждой новой части данных поочерёдно определяются имя части данных и её вид. Каждая пара <code>имя: тип</code> называется *полем*. Приложение 5-1 описывает устройство для хранения сведений об учётной записи пользователя:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-01/src/main.rs:here}}
```

<span class="caption">Приложение 5-1: Определение устройства <code>User</code></span>

После определения устройства можно создавать её *образец*, назначая определённое значение каждому полю с соответствующим видом данных. Чтобы создать образец, мы указываем имя устройства, затем добавляем узорчатые скобки и включаем в них пары `ключ: значение` (key: value), где ключами являются имена полей, а значениями являются данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления полей в описании устройства (но всё-таки желательно для удобства чтения). Другими словами, объявление устройства - это как образец нашего вида, в то время как образец устройства использует этот образец, заполняя его определёнными данными, для создания значений нашего вида. Например, можно объявить пользователя как в приложении 5-2:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-02/src/main.rs:here}}
```

<span class="caption">Приложение 5-2: Создание образца устройства <code>User</code></span>

Чтобы получить определенное значение из устройства, мы используем запись через точку. Например, чтобы получить доступ к адресу электронной почты этого пользователя, мы используем `user1.email`. Если образец является изменяемым, мы можем поменять значение, используя точечную наставление и присвоение к определенному полю. В Приложении 5-3 показано, как изменить значение в поле `email` изменяемого образца `User`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-03/src/main.rs:here}}
```

<span class="caption">Приложение 5-3: Изменение значения в поле <code>email</code> образца <code>User</code></span>

Стоит отметить, что весь образец устройства должен быть изменяемым; Ржавчина не позволяет помечать изменяемыми отдельные поля. Как и для любого другого выражения, мы можем использовать выражение создания устройства в качестве последнего выражения тела функции для неявного возврата нового образца.

На приложении 5-4 функция `build_user` возвращает образец `User` с указанным адресом и именем. Поле `active` получает значение `true`, а поле `sign_in_count` получает значение `1`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-04/src/main.rs:here}}
```

<span class="caption">Приложение 5-4: Функция <code>build_user</code>, которая принимает email и имя пользователя и возвращает образец <code>User</code></span>

Имеет смысл называть свойства функции теми же именами, что и поля устройства, но необходимость повторять `email` и `username` для названий полей и переменных несколько утомительна. Если устройства имеет много полей,  повторение каждого имени станет ещё более раздражающим. К счастью, есть удобное сокращение!

<!-- Old heading. Do not remove or links may break. -->

<a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a>

### Использование сокращённой объявления поля

Так как имена входных свойств функции и полей устройства являются полностью равноценными в приложении 5-4, возможно использовать правила написания *сокращённой объявления поля*, чтобы переписать `build_user` так, чтобы он работал точно также, но не содержал повторений для `username` и `email`, как в приложении 5-5.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-05/src/main.rs:here}}
```

<span class="caption">Приложение 5-5: функция <code>build_user</code> использует сокращённую объявление полей, потому что её входные свойства <code>username</code> и <code>email</code> имеют имена подобные именам полей устройства</span>

Здесь происходит создание нового образца устройства `User`, которая имеет поле с именем `email`. Мы хотим установить поле устройства `email` значением входного свойства `email` функции `build_user`. Так как поле `email` и входной свойство функции `email` имеют одинаковое название, можно писать просто `email` вместо рукописи `email: email`.

### Создание образца устройства из образца другой устройства с помощью правил написания обновления устройства

Часто бывает полезно создать новый образец устройства, который включает большинство значений из другого образца, но некоторые из них изменяет. Это можно сделать с помощью *правил написания обновления устройства*.

Сначала в приложении 5-6 показано, как обычно создаётся новый образец `User` в `user2` без правил написания обновления. Мы задаём новое значение для `email`, но в остальном используем те же значения из `user1`, которые были заданы в приложении 5-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-06/src/main.rs:here}}
```

<span class="caption">Приложение 5-6: Создание нового образца <code>User</code> с использованием некоторых значений из образца <code>user1</code></span>

Используя правила написания обновления устройства, можно получить тот же итог, используя меньше рукописи как показано в приложении 5-7. правила написания `..` указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного образца.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-07/src/main.rs:here}}
```

<span class="caption">Приложение 5-7: Использование правил написания обновления устройства для установки нового значения <code>email</code> для образца <code>User</code>, но использование остальных значений из образца <code>user1</code></span>

Рукопись в приложении 5-7 также создаёт образец в `user2`, который имеет другое значение для `email`, но с тем же значением для полей `username`, `active` и `sign_in_count` из `user1`. Приказчик `..user1` должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в `user1`, но можно указать значения для любого количества полей в любом порядке, независимо от порядка полей в определении устройства.

Стоит отметить, что правила написания обновления устройства использует `=` как присваивание. Это связано с перемещением данных, как мы видели в разделе [«Взаимодействие переменных и данных с помощью перемещения»]<!-- ignore -->. В этом примере мы больше не можем использовать `user1` после создания `user2`, потому что `String` в поле `username` из `user1` было перемещено в `user2`. Если бы мы задали `user2` новые значения `String` для `email` и `username`, и таким образом, использовали только значения `active` и `sign_in_count` из `user1`, то `user1` всё ещё был бы действительным после создания `user2`. Оба вида `active` и `sign_in_count` выполняют сущность `Copy`, поэтому они ведут себя так, как мы обсуждали в разделе [«Данные из обоймы: повторение»]<!-- ignore -->.

### Упорядоченные в ряд устройства: устройства без именованных полей для создания разных видов

Ржавчина также поддерживает устройства, похожие на упорядоченные ряды, которые называются *упорядоченные в ряд устройства*. Упорядоченные в ряд устройства обладают дополнительным смыслом, который даёт имя устройства, но при этом не имеют имён, связанных с их полями. Скорее, они просто хранят виды полей. Упорядоченные в ряд устройства полезны, когда вы хотите дать имя всему упорядоченному ряду и сделать упорядоченный ряд отличным от других упорядоченных рядов, и когда именование каждого поля, как в обычной устройстве, было бы многословным или избыточным.

Чтобы определить упорядоченную в ряд устройство, начните с ключевого слова `struct` и имени устройства, за которым следуют виды в упорядоченном ряде. Например, здесь мы определяем и используем две упорядоченные в ряд устройства с именами `Color` и `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-01-tuple-structs/src/main.rs}}
```

Обратите внимание, что значения `black` и `origin` — это разные виды, потому что они являются образцами разных упорядоченных в ряд устройств. Каждая определяемая вами устройство имеет собственный вид, даже если поля внутри устройства могут быть одинаковые виды. Например, функция, принимающая свойство вида `Color`, не может принимать `Point` в качестве переменной, даже если оба вида состоят из трёх значений `i32`. В остальном образцы упорядоченных в ряд устройств похожи на упорядоченные ряды в том смысле, что вы можете разъединять их на отдельные части и использовать `.`, за которой следует порядковый указатель для доступа к отдельному значению.

### Единично-подобные устройства: устройства без полей

Также можно определять устройства, не имеющие полей! Они называются *единично-подобными устройствами*, поскольку ведут себя подобно `()`, единичному виду, о котором мы говорили в разделе ["Упорядоченные ряды"](ch03-02-data-types.html#the-tuple-type)<!-- ignore -->. Единично-подобные устройства могут быть полезны, когда требуется выполнить сущность для некоторого вида, но у вас нет данных, которые нужно хранить в самом виде. Мы обсудим сущности в главе 10. Вот пример объявления и создание образца единичной устройства с именем `AlwaysEqual`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-04-unit-like-structs/src/main.rs}}
```

Чтобы определить `AlwaysEqual`, мы используем ключевое слово `struct`, желаемое имя, а затем точку с запятой. Нет необходимости в узорчатых или круглых скобках! Затем мы можем получить образец `AlwaysEqual` в переменной `subject` подобным образом: используя имя, которое мы определили, без узорчатых и круглых скобок. Представим, что в дальнейшем мы выполняем поведение для этого вида таким образом, что каждый образец `AlwaysEqual` всегда будет равен каждому образцу любого другого вида, возможно, с целью получения ожидаемого итога для проверки. Для выполнения такого поведения нам не нужны никакие данные! В главе 10 вы увидите, как определять черты и выполнить их для любого вида, включая единично-подобные устройства.

> ### Владение данными устройства
>
> В определении устройства `User` в приложении 5-1 мы использовали владеющий вид `String` вместо вида строковый срез `&str`. Это осознанный выбор, поскольку мы хотим, чтобы каждый образец этого устройства владел всеми своими данными и чтобы эти данные были действительны до тех пор, пока действительно всё устройства.
>
> Устройства также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого необходимо использовать возможность Ржавчина *время жизни*, которую мы обсудим в главе 10. Время жизни заверяет, что данные, на которые ссылается устройства, будут действительны до тех пор, пока существует устройства. Допустим, если попытаться сохранить ссылку в устройстве без указания времени жизни, как в следующем примере; это не сработает:
>
> <span class="filename">Файл: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore,does_not_compile
> struct User {
>     active: bool,
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
> }
>
> fn main() {
>     let user1 = User {
>         active: true,
>         username: "someusername123",
>         email: "someone@example.com",
>         sign_in_count: 1,
>     };
> }
> ```
>
> Сборщик будет жаловаться на необходимость определения времени жизни ссылок:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:3:15
>   |
> 3 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 ~     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:4:12
>   |
> 4 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 |     username: &str,
> 4 ~     email: &'a str,
>   |
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs` due to 2 previous errors
> ```
>
> В главе 10 мы обсудим, как исправить эти ошибки, чтобы иметь возможность хранить ссылки в устройствах, а пока мы исправим подобные ошибки, используя владеющие виды вроде `String` вместо ссылок `&str`.

<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->


["Упорядоченные ряды"]: ch03-02-data-types.html#the-tuple-type
[«Взаимодействие переменных и данных с помощью перемещения»]: ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move
[«Данные из обоймы: повторение»]: ch04-01-what-is-ownership.html#stack-only-data-copy