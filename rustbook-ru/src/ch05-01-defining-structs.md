## Определение и объявление структур

Структуры похожи на кортежи, рассмотренные в разделе ["Кортежи"]<!-- ignore -->, так как оба хранят несколько связанных значений. Как и кортежи, части структур могут быть разных видов. В отличие от кортежей, в структуре необходимо именовать каждую часть данных для понимания смысла значений. Добавление этих имён обеспечивает большую гибкость структур по сравнению с кортежами: не нужно полагаться на порядок данных для указания значений образца или доступа к ним.

Для определения структуры указывается ключевое слово `struct` и её название. Название должно описывать значение частей данных, сгруппированных вместе. Далее, в фигурных скобках для каждой новой части данных поочерёдно определяются имя части данных и её вид. Каждая пара <code>имя: тип</code> называется *полем*. Приложение 5-1 описывает структуру для хранения сведений об учётной записи пользователя:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-01/src/main.rs:here}}
```

<span class="caption">Приложение 5-1: Определение структуры <code>User</code></span>

После определения структуры можно создавать её *образец*, назначая определённое значение каждому полю с соответствующим видом данных. Чтобы создать образец, мы указываем имя структуры, затем добавляем фигурные скобки и включаем в них пары `ключ: значение` (key: value), где ключами являются имена полей, а значениями являются данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления полей в описании структуры (но всё-таки желательно для удобства чтения). Другими словами, объявление структуры - это как шаблон нашего вида, в то время как образец структуры использует этот шаблон, заполняя его определёнными данными, для создания значений нашего вида. Например, можно объявить пользователя как в приложении 5-2:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-02/src/main.rs:here}}
```

<span class="caption">Приложение 5-2: Создание образца структуры <code>User</code></span>

Чтобы получить определенное значение из структуры, мы используем запись через точку. Например, чтобы получить доступ к адресу электронной почты этого пользователя, мы используем `user1.email`. Если образец является изменяемым, мы можем поменять значение, используя точечную наставление и присвоение к определенному полю. В Приложении 5-3 показано, как изменить значение в поле `email` изменяемого образца `User`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-03/src/main.rs:here}}
```

<span class="caption">Приложение 5-3: Изменение значения в поле <code>email</code> образца <code>User</code></span>

Стоит отметить, что весь образец структуры должен быть изменяемым; Rust не позволяет помечать изменяемыми отдельные поля. Как и для любого другого выражения, мы можем использовать выражение создания структуры в качестве последнего выражения тела функции для неявного возврата нового образца.

На приложении 5-4 функция `build_user` возвращает образец `User` с указанным адресом и именем. Поле `active` получает значение `true`, а поле `sign_in_count` получает значение `1`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-04/src/main.rs:here}}
```

<span class="caption">Приложение 5-4: Функция <code>build_user</code>, которая принимает email и имя пользователя и возвращает образец <code>User</code></span>

Имеет смысл называть свойства функции теми же именами, что и поля структуры, но необходимость повторять `email` и `username` для названий полей и переменных несколько утомительна. Если структура имеет много полей,  повторение каждого имени станет ещё более раздражающим. К счастью, есть удобное сокращение!

<!-- Old heading. Do not remove or links may break. -->

<a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a>

### Использование сокращённой объявления поля

Так как имена входных свойств функции и полей структуры являются полностью равноценными в приложении 5-4, возможно использовать правила написания *сокращённой объявления поля*, чтобы переписать `build_user` так, чтобы он работал точно также, но не содержал повторений для `username` и `email`, как в приложении 5-5.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-05/src/main.rs:here}}
```

<span class="caption">Приложение 5-5: функция <code>build_user</code> использует сокращённую объявление полей, потому что её входные свойства <code>username</code> и <code>email</code> имеют имена подобные именам полей структуры</span>

Здесь происходит создание нового образца структуры `User`, которая имеет поле с именем `email`. Мы хотим установить поле структуры `email` значением входного свойства `email` функции `build_user`. Так как поле `email` и входной свойство функции `email` имеют одинаковое название, можно писать просто `email` вместо кода `email: email`.

### Создание образца структуры из образца другой структуры с помощью правил написания обновления структуры

Часто бывает полезно создать новый образец структуры, который включает большинство значений из другого образца, но некоторые из них изменяет. Это можно сделать с помощью *правил написания обновления структуры*.

Сначала в приложении 5-6 показано, как обычно создаётся новый образец `User` в `user2` без правил написания обновления. Мы задаём новое значение для `email`, но в остальном используем те же значения из `user1`, которые были заданы в приложении 5-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-06/src/main.rs:here}}
```

<span class="caption">Приложение 5-6: Создание нового образца <code>User</code> с использованием некоторых значений из образца <code>user1</code></span>

Используя правила написания обновления структуры, можно получить тот же эффект, используя меньше кода как показано в приложении 5-7. правила написания `..` указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного образца.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-07/src/main.rs:here}}
```

<span class="caption">Приложение 5-7: Использование правил написания обновления структуры для установки нового значения <code>email</code> для образца <code>User</code>, но использование остальных значений из образца <code>user1</code></span>

Код в приложении 5-7 также создаёт образец в `user2`, который имеет другое значение для `email`, но с тем же значением для полей `username`, `active` и `sign_in_count` из `user1`. Оператор `..user1` должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в `user1`, но можно указать значения для любого количества полей в любом порядке, независимо от порядка полей в определении структуры.

Стоит отметить, что правила написания обновления структуры использует `=` как присваивание. Это связано с перемещением данных, как мы видели в разделе [«Взаимодействие переменных и данных с помощью перемещения»]<!-- ignore -->. В этом примере мы больше не можем использовать `user1` после создания `user2`, потому что `String` в поле `username` из `user1` было перемещено в `user2`. Если бы мы задали `user2` новые значения `String` для `email` и `username`, и таким образом, использовали только значения `active` и `sign_in_count` из `user1`, то `user1` всё ещё был бы действительным после создания `user2`. Оба вида `active` и `sign_in_count` реализуют типаж `Copy`, поэтому они ведут себя так, как мы обсуждали в разделе [«Стековые данные: копирование»]<!-- ignore -->.

### Кортежные структуры: структуры без именованных полей для создания разных видов

Rust также поддерживает структуры, похожие на кортежи, которые называются *кортежные структуры*. Кортежные структуры обладают дополнительным смыслом, который даёт имя структуры, но при этом не имеют имён, связанных с их полями. Скорее, они просто хранят виды полей. Кортежные структуры полезны, когда вы хотите дать имя всему кортежу и сделать кортеж отличным от других кортежей, и когда именование каждого поля, как в обычной структуре, было бы многословным или избыточным.

Чтобы определить кортежную структуру, начните с ключевого слова `struct` и имени структуры, за которым следуют виды в кортеже. Например, здесь мы определяем и используем две кортежные структуры с именами `Color` и `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-01-tuple-structs/src/main.rs}}
```

Обратите внимание, что значения `black` и `origin` — это разные виды, потому что они являются образцами разных кортежных структур. Каждая определяемая вами структура имеет собственный вид, даже если поля внутри структуры могут иметь одинаковые виды. Например, функция, принимающая свойство вида `Color`, не может принимать `Point` в качестве переменной, даже если оба вида состоят из трёх значений `i32`. В остальном образцы кортежных структур похожи на кортежи в том смысле, что вы можете деструктурировать их на отдельные части и использовать `.`, за которой следует порядковый указательдля доступа к отдельному значению.

### Единично-подобные структуры: структуры без полей

Также можно определять структуры, не имеющие полей! Они называются *единично-подобными структурами*, поскольку ведут себя подобно `()`, единичному виду, о котором мы говорили в разделе ["Кортежи"](ch03-02-data-types.html#the-tuple-type)<!-- ignore -->. Единично-подобные структуры могут быть полезны, когда требуется реализовать типаж для некоторого вида, но у вас нет данных, которые нужно хранить в самом виде. Мы обсудим типажи в главе 10. Вот пример объявления и создание образца единичной структуры с именем `AlwaysEqual`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-04-unit-like-structs/src/main.rs}}
```

Чтобы определить `AlwaysEqual`, мы используем ключевое слово `struct`, желаемое имя, а затем точку с запятой. Нет необходимости в фигурных или круглых скобках! Затем мы можем получить образец `AlwaysEqual` в переменной `subject` подобным образом: используя имя, которое мы определили, без фигурных и круглых скобок. Представим, что в дальнейшем мы реализуем поведение для этого вида таким образом, что каждый образец `AlwaysEqual` всегда будет равен каждому образцу любого другого вида, возможно, с целью получения ожидаемого итога для проверки. Для реализации такого поведения нам не нужны никакие данные! В главе 10 вы увидите, как определять черты и реализовывать их для любого вида, включая единично-подобные структуры.

> ### Владение данными структуры
>
> В определении структуры `User` в приложении 5-1 мы использовали владеющий вид `String` вместо вида строковый срез `&str`. Это осознанный выбор, поскольку мы хотим, чтобы каждый образец этой структуры владел всеми своими данными и чтобы эти данные были действительны до тех пор, пока действительна вся структура.
>
> Структуры также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого необходимо использовать возможность Rust *время жизни*, которую мы обсудим в главе 10. Время жизни заверяет, что данные, на которые ссылается структура, будут действительны до тех пор, пока существует структура. Допустим, если попытаться сохранить ссылку в структуре без указания времени жизни, как в следующем примере; это не сработает:
>
> <span class="filename">Файл: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore,does_not_compile
> struct User {
>     active: bool,
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
> }
>
> fn main() {
>     let user1 = User {
>         active: true,
>         username: "someusername123",
>         email: "someone@example.com",
>         sign_in_count: 1,
>     };
> }
> ```
>
> Сборщик будет жаловаться на необходимость определения времени жизни ссылок:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:3:15
>   |
> 3 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 ~     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:4:12
>   |
> 4 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 |     username: &str,
> 4 ~     email: &'a str,
>   |
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs` due to 2 previous errors
> ```
>
> В главе 10 мы обсудим, как исправить эти ошибки, чтобы иметь возможность хранить ссылки в структурах, а пока мы исправим подобные ошибки, используя владеющие виды вроде `String` вместо ссылок `&str`.

<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->


["Кортежи"]: ch03-02-data-types.html#the-tuple-type
[«Взаимодействие переменных и данных с помощью перемещения»]: ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move
[«Стековые данные: копирование»]: ch04-01-what-is-ownership.html#stack-only-data-copy