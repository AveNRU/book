## Разделение модулей на разные файлы

До сих пор все примеры в этой главе определяли несколько модулей в одном файле. Когда модули становятся большими, вы можете захотеть переместить их определения в отдельные файлы, чтобы упростить навигацию по коду.

Например, давайте начнём с кода из приложения 7-17, в котором было несколько модулей ресторана. Мы будем извлекать модули в файлы вместо того, чтобы определять все модули в корневом модуле ящика. В нашем случае корневой модуль ящика - *src/lib.rs*, но это разделение также работает и с двоичными ящиками, у которых корневой модуль ящика — *src/main.rs*.

Сначала мы извлечём модуль `front_of_house` в свой собственный файл. Удалите код внутри фигурных скобок для модуля `front_of_house`, оставив только объявление `mod front_of_house;`, так что теперь *src/lib.rs* содержит код, показанный в приложении 7-21. Обратите внимание, что этот вариант не ссобирается, пока мы не создадим файл *src/front_of_house.rs* из приложении 7-22.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-21-and-22/src/lib.rs}}
```

<span class="caption">Приложение 7-21. Объявление модуля <code>front_of_house</code>, чьё содержимое будет в <em>src/front_of_house.rs</em></span>

Затем поместим код, который был в фигурных скобках, в новый файл с именем *src/front_of_house.rs*, как показано в приложении 7-22. Сборщик знает, что нужно искать в этом файле, потому что он наткнулся в корневом модуле ящика на объявление модуля с именем `front_of_house`.

<span class="filename">Файл: src/front_of_house.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-21-and-22/src/front_of_house.rs}}
```

<span class="caption">Приложение 7-22. Определение содержимого модуля <code>front_of_house</code> в файле <em>src/front_of_house.rs</em></span>

Обратите внимание, что вам нужно только *один раз* загрузить файл с помощью объявления `mod` в вашем дереве модулей. Как только сборщик узнает, что файл является частью проекта (и узнает, где в дереве модулей находится код из-за того, куда вы помеисполнения указанию `mod`), другие файлы в вашем проекте должны ссылаться на код загруженного файла, используя путь к месту, где он был объявлен, как описано в разделе [«Пути для ссылки на элемент в дереве модулей»]<!-- ignore -->. Другими словами, `mod` — это *не* действие «включения», которую вы могли видеть в других языках программирования.

Далее мы извлечём модуль `hosting` в его собственный файл. Этап немного отличается, потому что `hosting` является дочерним модулем для `front_of_house`, а не корневого модуля. Мы поместим файл для `hosting` в новый папка, который будет назван по имени его предка в дереве модулей, в данном случае это *src/front_of_house/*.

Чтобы начать перенос `hosting`, мы меняем *src/front_of_house.rs* так, чтобы он содержал только объявление модуля `hosting`:

<span class="filename">Файл: src/front_of_house.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-02-extracting-hosting/src/front_of_house.rs}}
```

Затем мы создаём папка *src/front_of_house* и файл *hosting.rs*, в котором будут  определения, сделанные в модуле `hosting`:

<span class="filename">Файл: src/front_of_house/hosting.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-02-extracting-hosting/src/front_of_house/hosting.rs}}
```

Если вместо этого мы поместим *hosting.rs* в папка *src*, сборщик будет думать, что код в *hosting.rs* это модуль `hosting`, объявленный в корне ящика, а не объявленный как дочерний модуль `front_of_house`. Правила сборщика для проверки какие файлы содержат код каких модулей предполагают, что папки и файлы точно соответствуют дереву модулей.

> ### Иные пути к файлам
>
> До сих пор мы рассматривали наиболее идиоматические пути к файлам, используемые сборщиком Rust, но Ржавчина также поддерживает и старый исполнение пути к файлу. Для модуля с именем `front_of_house`, объявленного в корневом модуле ящика, сборщик будет искать код модуля в:
>
> - *src/front_of_house.rs* (что мы рассматривали)
> - *src/front_of_house/mod.rs* (старый исполнение, всё ещё поддерживаемый путь)
>
> Для модуля с именем `hosting`, который является подмодулем `front_of_house`, сборщик будет искать код модуля в:
>
> - *src/front_of_house/hosting.rs* (что мы рассматривали)
> - *src/front_of_house/hosting/mod.rs* (старый исполнение, всё ещё поддерживаемый путь)
>
> Если вы используете оба исполнения для одного и того же модуля, вы получите ошибку сборщика. Использование сочетания обоих стилей для разных модулей в одном проекте разрешено, но это может сбивать с толку людей, перемещающихся по вашему проекту.
>
> Основным недостатком исполнения, в котором используются файлы с именами *mod.rs*, является то, что в вашем проекте может оказаться много файлов с именами *mod.rs*, что может привести к путанице, если вы одновременно откроете их в редакторе.

Мы перенесли код каждого модуля в отдельный файл, а дерево модулей осталось прежним. Вызовы функций в `eat_at_restaurant` будут работать без каких-либо изменений, несмотря на то, что определения находятся в разных файлах. Этот способ позволяет перемещать модули в новые файлы по мере увеличения их размеров.

Обратите внимание, что указание `pub use crate::front_of_house::hosting` в *src/lib.rs* также не изменилась, и `use` не влияет на то, какие файлы собираются как часть ящика. Ключевое слово `mod` объявляет модули, и Ржавчина ищет в файле с тем же именем, что и у модуля, код, который входит в этот модуль.

## Итог

Rust позволяет разбить дополнение на несколько ящиков и ящик - на модули, так что вы можете ссылаться на элементы, определённые в одном модуле, из другого модуля. Это можно делать при помощи указания абсолютных или относительных путей. Эти пути можно добавить в область видимости указанием `use`, поэтому вы можете пользоваться более короткими путями для многократного использования элементов в этой области видимости. Код модуля по умолчанию является приватным, но можно сделать определения общедоступными, добавив ключевое слово `pub`.

В следующей главе мы рассмотрим некоторые собрания структур данных из встроенной библиотеки, которые вы можете использовать в своём правильноно согласованном коде.


[«Пути для ссылки на элемент в дереве модулей»]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html