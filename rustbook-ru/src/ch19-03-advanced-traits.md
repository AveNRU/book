## Продвинутые типажи

Мы познакомились с особенностями в разделе ["Особенности: Определение общего поведения"](ch10-02-traits.html#traits-defining-shared-behavior)<!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Rust, мы можем перейти к более подробному рассмотрению.

### Указание видов-заполнителей в определениях особенностей с сопряженными видами

*Сопряженные виды* связывают вид-заполнитель с типажом таким образом, что определения способов типажа могут использовать эти виды-заполнители в своих ярлыках. Для именно реализации типажа вместо типа-заполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить типажи, использующие некоторые виды, без необходимости точно знать, что это за виды, пока типажи не будут реализованы.

Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Сопряженные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.

Одним из примеров особенности с сопряженным видом является типаж `Iterator` из встроенной библиотеки. Сопряженный вид называется `Item` и символизирует вид значений, по которым повторяется вид, реализующий типаж `Iterator`. Определение особенности <code>Iterator</code> показано в приложении 19-12.

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}
```

<span class="caption">Приложение 19-12: Определение особенности <code>Iterator</code>, который имеет сопряженный вид <code>Item</code></span>

Вид `Item` является заполнителем и определение способа `next` показывает, что он будет возвращать значения вида `Option<Self::Item>`. Разработчики типажа `Iterator` определят определенный вид для `Item`, а способ `next` вернёт `Option` содержащий значение этого определенного вида.

Сопряженные виды могут показаться подходом похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя подходами, мы рассмотрим реализацию типажа `Iterator` для вида с именем `Counter`, который указывает, что вид `Item` равен `u32`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

Этот правила написания весьма напоминает обобщённые виды. Так почему же типаж `Iterator` не определён обобщённым видом, как показано в приложении 19-13?

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}
```

<span class="caption">Приложение 19-13: Гипотетическое определение типажа <code>Iterator</code> используя обобщённые виды</span>

Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны определять виды в каждой реализации; потому что мы также можем реализовать `Iterator<String> for Counter` или любого другого вида, мы могли бы иметь несколько реализации `Iterator` для `Counter`. Другими словами, когда типаж имеет обобщённый свойство, он может быть реализован для вида несколько раз, каждый раз меняя определенные виды свойств обобщённого вида. Когда мы используем способ `next` у `Counter`, нам пришлось бы предоставить изложении вида, указывая какую реализацию `Iterator` мы хотим использовать.

С сопряженными видами не нужно определять виды, потому что мы не можем реализовать типаж у вида несколько раз. В приложении 19-12 с определением, использующим сопряженные виды можно выбрать только один вид `Item`, потому что может быть только одно объявление `impl Iterator for Counter`. Нам не нужно указывать, что нужен повторительзначений вида `u32` везде, где мы вызываем `next` у `Counter`.

Сопряженные виды также становятся частью договора типажа: разработчики типажа должны предоставить вид, который заменит сопряженный заполнитель вида. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошей опытом является документирование связанного вида в документации по API.

### Свойства обобщённого вида по умолчанию и перегрузка операторов

Когда мы используем свойства обобщённого вида, мы можем указать определенный вид по умолчанию для обобщённого вида. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида с помощью правил написания  `<PlaceholderType=ConcreteType>`.

Отличным примером, когда этот способ полезен, является *перегрузка оператора* (operator overloading), когда вы настраиваете поведение оператора (например, `+` ) для определённых случаев.

Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Но можно перегрузить перечисленные действия и соответствующие им типажи из `std::ops` путём реализации типажей, связанных с этими операторами. Например, в приложении 19-14 мы перегружаем оператор `+`, чтобы складывать два образца `Point`. Мы делаем это реализуя типаж `Add` для структуры `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
```

<span class="caption">Приложение 19-14: Реализация типажа <code>Add</code> для перегрузки оператора <code>+</code> для образцов <code>Point</code></span>

Способ `add` складывает значения `x` двух образцов `Point` и значения `y` у `Point` для создания нового образца `Point`. Типаж `Add` имеет сопряженный вид с именем `Output`, который определяет вид, возвращаемый из способа `add`.

Обобщённый вид по умолчанию в этом коде находится в типаже `Add` . Вот его определение:

```rust
trait Add<Rhs = Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

Этот код должен выглядеть знакомым: типаж с одним способом и сопряженным видом. Новый правила написания это `RHS=Self`. Такой правила написания называется *свойства вида по умолчанию* (default type parameters). Свойство обобщённого вида `RHS` (сокращённо “right hand side”) определяет вид свойства `rhs` в способе `add`. Если мы не укажем определенный вид для `RHS` при реализации типажа `Add`, то видом для `RHS` по умолчанию будет `Self`, который будет видом для которого реализуется типаж `Add`.

Когда мы реализовали `Add` для структуры `Point`, мы использовали обычное значение для `RHS`, потому что хотели сложить два образца `Point`. Давайте посмотрим на пример реализации типажа `Add`, где мы хотим пользовательский вид `RHS` вместо использования вида по умолчанию.

У нас есть две разные структуры `Millimeters` и `Meters`, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида в другую структуру известно как шаблон *newtype*, который мы более подробно опишем в разделе ["Шаблон Newtype для реализация внешних типажей у внешних видов"]<!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь реализацию типажа `Add`, которая делает правильное преобразование единиц. Можно реализовать <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве `Rhs`, как показано в приложении 19-15.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}
```

<span class="caption">Приложение 19-15: Реализация типажа <code>Add</code> для структуры  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span>

Чтобы сложить `Millimeters` и `Meters`, мы указываем `impl Add<Meters>`, чтобы указать значение свойства вида `RHS` (Meters) вместо использования значения по умолчанию `Self` (Millimeters).

Свойства вида по умолчанию используются в двух основных случаях:

- Чтобы расширить вид без внесения изменений ломающих существующий код
- Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей

Типаж `Add` из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида, но типаж `Add` позволяет сделать больше. Использование свойства вида по умолчанию в объявлении типажа `Add` означает, что не нужно указывать дополнительный свойство большую часть времени. Другими словами, большая часть кода реализации не нужна, что делает использование типажа проще.

Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида к существующему типажу, можно дать ему значение по умолчанию, чтобы разрешить расширение функциональности типажа без нарушения кода существующей реализации.

### Полностью квалифицированный правила написания для устранения неоднозначности: вызов способов с одинаковым именем

В Ржавчина ничего не мешает типажу иметь способ с одинаковым именем, таким же как способ другого типажа и Ржавчина не мешает реализовывать оба таких типажа у одного вида. Также возможно реализовать способ с таким же именем непосредственно у вида, такой как и способы у типажей.

При вызове способов с одинаковыми именами в Ржавчина нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим код в приложении 19-16, где мы определили два типажа: `Pilot` и `Wizard`, у обоих есть способ `fly`. Затем мы реализуем оба типажа у вида `Human` в котором уже реализован способ с именем `fly`. Каждый способ `fly` делает что-то своё.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
```

<span class="caption">Приложение 19-16: Два типажа определены с способом <code>fly</code> и реализованы у вида <code>Human</code>, а также способ <code>fly</code> реализован непосредственно у <code>Human</code></span>

Когда мы вызываем `fly` у образца `Human`, то сборщик по умолчанию вызывает способ, который непосредственно реализован для вида, как показано в приложении 19-17.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
```

<span class="caption">Приложение 19-17: Вызов <code>fly</code> у образца <code>Human</code></span>

Запуск этого кода напечатает `*waving arms furiously*` , показывая, что Ржавчина называется способ `fly` реализованный непосредственно у `Human`.

Чтобы вызвать способы `fly` у типажа `Pilot` или типажа `Wizard` нужно использовать более явный правила написания, указывая какой способ `fly` мы имеем в виду. Приложение 19-18 отображает такой правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
```

<span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span>

Указание имени типажа перед именем способа проясняет сборщику Rust, какую именно реализацию `fly` мы хотим вызвать. Мы могли бы также написать `Human::fly(&person)`, что эквивалентно используемому нами `person.fly()` в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.

Выполнение этого кода выводит следующее:

```console
{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
```

Поскольку способ `fly` принимает свойство `self`, если у нас было два *вида* оба реализующих один *типаж*, то Ржавчина может понять, какую реализацию типажа использовать в зависимости от вида `self`.

Однако, сопряженные функции, не являющиеся способами, не имеют свойства `self`. Когда существует несколько видов или типажей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Ржавчина не всегда знает, какой вид вы имеете в виду, если только вы не используете *полный правила написания*. Например, в приложении 19-19 мы создаём типаж для приюта животных, который хочет назвать всех маленьких собак *Spot*. Мы создаём типаж `Animal` со связанной с ним функцией `baby_name`, не являющейся способом. Типаж `Animal` реализован для структуры `Dog`, для которой мы также напрямую предоставляем связанную функцию `baby_name`, не являющуюся способом.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
```

<span class="caption">Приложение 19-19: Типаж с сопряженной функцией и вид с сопряженной функцией с тем же именем, которая тоже реализует типаж</span>

Мы реализовали код для приюта для животных, который хочет назвать всех щенков именем Spot, в сопряженной функции `baby_name`, которая определена для `Dog`. Вид `Dog` также реализует типаж `Animal`, который описывает свойства, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в реализации `Animal` у `Dog` в функции `baby_name` сопряженной с типажом `Animal`.

В `main` мы вызываем функцию `Dog::baby_name`, которая вызывает сопряженную функцию определённую напрямую у `Dog`. Этот код печатает следующее:

```console
{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
```

Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию `baby_name`, которая является частью типажа `Animal` реализованного у `Dog`, так чтобы код печатал `A baby dog is called a puppy`. Техника указания имени типажа использованная в приложении 19-18 здесь не помогает; если мы изменим `main` код как в приложении 19-20, мы получим ошибку сборки.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}
```

<span class="caption">Приложение 19-20. Попытка вызвать функцию <code>baby_name</code> из типажа <code>Animal</code>, но Ржавчина не знает какую реализацию использовать</span>

Поскольку `Animal::baby_name` не имеет свойства `self`, и могут быть другие виды, реализующие типаж `Animal`, Ржавчина не может понять, какую реализацию `Animal::baby_name` мы хотим использовать. Мы получим эту ошибку сборщика:

```console
{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
```

Чтобы устранить неоднозначность и сказать Rust, что мы хотим использовать реализацию `Animal` для `Dog`, нужно использовать полный правила написания. Приложение 19-21 отображает, как использовать полный правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
```

<span class="caption">Приложение 19-21: Использование полного правил написания для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у типажа <code>Animal</code> реализованную в <code>Dog</code></span>

Мы указываем изложение вида в угловых скобках, которая указывает на то что мы хотим вызвать способ `baby_name` из типажа `Animal` реализованный в `Dog`, также указывая что мы хотим рассматривать вид `Dog` в качестве `Animal` для вызова этой функции. Этот код теперь напечатает то, что мы хотим:

```console
{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
```

В общем, полный правила написания определяется следующим образом:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

Для сопряженных функций, которые не являются способами, будет отсутствовать `receiver` (предмет приёмника): будет только список переменных. Вы можете использовать полный правила написания везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого правил написания, которую Ржавчина может понять из другой сведений в программе. Вам нужно использовать более подробный правила написания только в тех случаях, когда существует несколько реализаций, использующих одно и то же название, и Ржавчина нужно помочь определить, какую реализацию вы хотите вызвать.

### Использование супер типажей для требования функциональности одного типажа в рамках другого типажа

Иногда вы можете написать определение типажа, которое зависит от другого типажа: для вида, реализующего первый типаж, вы хотите потребовать, чтобы этот вид также реализовал второй типаж. Вы должны сделать это, чтобы ваше определение типажа могло использовать связанные элементы второго типажа. Типаж, на который опирается ваше определение типажа, называется *supertrait* вашего типажа.

Например, мы хотим создать типаж `OutlinePrint` с способом `outline_print`, который будет печатать значение обрамлённое звёздочками. Мы хотим чтобы структура `Point`, реализующая типаж встроенной библиотеки `Display`, вывела на печать `(x, y)` при вызове `outline_print` у образца `Point`, который имеет значение `1` для `x` и значение `3` для `y`. Она должна напечатать следующее:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

В реализации `outline_print` мы хотим использовать функциональность типажа `Display`. Поэтому нам нужно указать, что типаж `OutlinePrint` будет работать только для видов, которые также реализуют `Display` и предоставляют функциональность, которая нужна в `OutlinePrint`. Мы можем сделать это в объявлении типажа, указав `OutlinePrint: Display`. Этот способ похож на добавление ограничения в типаж. В приложении 19-22 показана реализация типажа `OutlinePrint`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
```

<span class="caption">Приложение 19-22: Реализация типажа <code>OutlinePrint</code> которая требует функциональности типажа <code>Display</code></span>

Поскольку мы указали, что типаж `OutlinePrint` требует типажа `Display`, мы можем использовать функцию `to_string`, которая самостоятельно реализована для любого вида реализующего `Display`. Если бы мы попытались использовать `to_string` не добавляя двоеточие и не указывая типаж `Display` после имени типажа, мы получили бы сообщение о том, что способ с именем `to_string` не был найден у вида `&Self` в текущей области видимости.

Давайте посмотрим что происходит, если мы пытаемся реализовать типаж `OutlinePrint` для вида, который не реализует `Display`, например структура `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

Мы получаем сообщение о том, что требуется реализация `Display`, но её нет:

```console
{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

Чтобы исправить, мы реализуем `Display` у структуры `Point` и выполняем требуемое ограничение `OutlinePrint`, вот так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

Тогда реализация типажа `OutlinePrint` для структуры `Point` будет собрана успешно и мы можем вызвать `outline_print` у образца `Point` для отображения значения обрамлённое звёздочками.

### Шаблон Newtype для реализация внешних типажей у внешних видов

В разделе ["Реализация типажа у типа"](ch10-02-traits.html#implementing-a-trait-on-a-type)<!-- ignore --> главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается реализовать типаж у вида, если либо типаж, либо вид являются местными для нашего ящика. Можно обойти это ограничение, используя *шаблон нового вида* (newtype pattern), который включает в себя создание нового вида в кортежной структуре. (Мы рассмотрели кортежные структуры  в разделе ["Использование структур кортежей без именованных полей для создания различных видов"]<!--  --> главы 5.) Структура кортежа будет иметь одно поле и будет тонкой оболочкой для вида которому мы хотим реализовать типаж. Тогда вид оболочки является местным для нашего ящика и мы можем реализовать типаж для местной обёртки. *Newtype* это понятие, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого шаблона и вид оболочки исключается во время сборки.

В качестве примера, мы хотим реализовать типаж `Display` для вида `Vec<T>`, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что типаж `Display` и вид `Vec<T>` объявлены вне нашего ящика. Мы можем сделать структуру `Wrapper`, которая содержит образец `Vec<T>`; тогда мы можем реализовать `Display` у структуры `Wrapper` и использовать значение `Vec<T>` как показано в приложении 19-23.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
```

<span class="caption">Приложение 19-23. Создание вида <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для реализации <code>Display</code></span>

Реализация `Display` использует `self.0` для доступа к внутреннему `Vec<T>`, потому что `Wrapper` это структура кортежа, а `Vec<T>` это элемент с порядковым указателем 0 в кортеже. Затем мы можем использовать функциональные возможности вида `Display` у `Wrapper`.

Недостатком использования этой техники является то, что `Wrapper` является новым видом, поэтому он не имеет способов для значения, которое он держит в себе. Мы должны были бы реализовать все способы для `Vec<T>` непосредственно во `Wrapper`, так чтобы эти способы делегировались внутреннему `self.0`, что позволило бы нам обращаться с `Wrapper` точно так же, как с `Vec<T>`. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида, реализуя типаж `Deref` (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью `Deref` типажа"</a><!-- ignore --> главы 15) у `Wrapper` для возвращения внутреннего вида, то это было бы решением. Если мы не хотим, чтобы вид `Wrapper` имел все способы внутреннего вида, например, для ограничения поведения вида `Wrapper`, то пришлось бы вручную реализовать только те способы, которые нам нужны.

Этот шаблон newtype также полезен, даже когда типажи не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов Rust.


["Шаблон Newtype для реализация внешних типажей у внешних видов"]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
["Использование структур кортежей без именованных полей для создания различных видов"]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types