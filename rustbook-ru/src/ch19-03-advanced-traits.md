## Продвинутые сущности

Мы познакомились с сущностями в разделе ["Сущности: Определение общего поведения"](ch10-02-traits.html#traits-defining-shared-behavior)<!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Ржавчина мы можем перейти к более подробному рассмотрению.

### Указание видов-исполнителей в определениях сущностей с сопряженными видами

*Сопряженные виды* связывают вид-исполнитель с сущностью таким образом, что определения способов сущности могут использовать эти виды-исполнители в своих ярлыках. Для именно выполнения сущности вместо вида-исполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить сущности, использующие некоторые виды, без необходимости точно знать, что это за виды, пока сущности не будут выполнены.

Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Сопряженные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.

Одним из примеров сущности с сопряженным видом является сущность `Iterator` из встроенной библиотеки. Сопряженный вид называется `Item` и представляет вид значений, по которым повторяется вид, выполняющий сущность `Iterator`. Определение сущности <code>Iterator</code> показано в приложении 19-12.

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}
```

<span class="caption">Приложение 19-12: Определение сущности <code>Iterator</code>, который имеет сопряженный вид <code>Item</code></span>

Вид `Item` является исполнителем и определение способа `next` показывает, что он будет возвращать значения вида `Option<Self::Item>`. Разработчики сущности `Iterator` определят определенный вид для `Item`, а способ `next` вернёт `Option` содержащий значение этого определенного вида.

Сопряженные виды могут показаться подходом похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя подходами, мы рассмотрим выполнение сущности `Iterator` для вида с именем `Counter`, который указывает, что вид `Item` равен `u32`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

Эти правила написания весьма напоминает обобщённые виды. Так почему же сущность `Iterator` не определена обобщённым видом, как показано в приложении 19-13?

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}
```

<span class="caption">Приложение 19-13: Гипотетическое определение сущности <code>Iterator</code> используя обобщённые виды</span>

Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны определять виды в каждой выполнения; потому что мы также можем выполнить `Iterator<String> for Counter` или любого другого вида, мы могли бы иметь несколько выполнения `Iterator` для `Counter`. Другими словами, когда сущность имеет Обобщённое свойство, он может быть выполнен для вида несколько раз, каждый раз меняя определенные виды свойств обобщённого вида. Когда мы используем способ `next` у `Counter`, нам пришлось бы предоставить изложении вида, указывая какую выполнение `Iterator` мы хотим использовать.

С сопряженными видами не нужно определять виды, потому что мы не можем выполнить сущность у вида несколько раз. В приложении 19-12 с определением, использующим сопряженные виды можно выбрать только один вид `Item`, потому что может быть только одно объявление `impl Iterator for Counter`. Нам не нужно указывать, что нужен повторитель значений вида `u32` везде, где мы вызываем `next` у `Counter`.

Сопряженные виды также становятся частью договора сущности: разработчики сущности должны предоставить вид, который заменит сопряженный исполнитель вида. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошим опытом является документирование связанного вида в пособии по API.

### Свойства обобщённого вида по умолчанию и перегрузка приказчиков

Когда мы используем свойства обобщённого вида, мы можем указать определенный вид по умолчанию для обобщённого вида. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида с помощью правил написания  `<PlaceholderType=ConcreteType>`.

Отличным примером, когда этот способ полезен, является *перегрузка приказчика* (operator overloading), когда вы настраиваете поведение приказчика (например, `+` ) для определённых случаев.

Ржавчина не позволяет создавать собственные приказчики или перегружать произвольные приказчики. Но можно перегрузить перечисленные действия и соответствующие им сущности из `std::ops` путём выполнения сущностей, связанных с этими приказчиками. Например, в приложении 19-14 мы перегружаем приказчик `+`, чтобы складывать два образца `Point`. Мы делаем это выполняя сущность `Add` для устройства `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
```

<span class="caption">Приложение 19-14: Выполнение сущности <code>Add</code> для перегрузки приказчика <code>+</code> для образцов <code>Point</code></span>

Способ `add` складывает значения `x` двух образцов `Point` и значения `y` у `Point` для создания нового образца `Point`. Сущность `Add` имеет сопряженный вид с именем `Output`, который определяет вид, возвращаемый из способа `add`.

Обобщённый вид по умолчанию в этой рукописи находится в сущности `Add` . Вот его определение:

```rust
trait Add<Rhs = Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

Эта рукопись должна выглядеть знакомой: сущность с одним способом и сопряженным видом. Новые правила написания это `RHS=Self`. Такие правила написания называются *свойства вида по умолчанию* (default type parameters). Свойство обобщённого вида `RHS` (сокращённо “right hand side”) определяет вид свойства `rhs` в способе `add`. Если мы не укажем определенный вид для `RHS` при выполнения сущности `Add`, то видом для `RHS` по умолчанию будет `Self`, который будет видом для которого выполняется сущность `Add`.

Когда мы выполнили `Add` для устройства `Point`, мы использовали обычное значение для `RHS`, потому что хотели сложить два образца `Point`. Давайте посмотрим на пример выполнения сущности `Add`, где мы хотим пользовательский вид `RHS` вместо использования вида по умолчанию.

У нас есть две разные устройства `Millimeters` и `Meters`, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида в другое устройство известно как образец *newtype*, который мы более подробно опишем в разделе ["Образец Newtype для выполнение внешних сущностей у внешних видов"]<!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь выполнение сущности `Add`, которая делает правильное преобразование единиц. Можно выполнить <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве `Rhs`, как показано в приложении 19-15.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}
```

<span class="caption">Приложение 19-15: Выполнение сущности <code>Add</code> для устройства  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span>

Чтобы сложить `Millimeters` и `Meters`, мы указываем `impl Add<Meters>`, чтобы указать значение свойства вида `RHS` (Meters) вместо использования значения по умолчанию `Self` (Millimeters).

Свойства вида по умолчанию используются в двух основных случаях:

- Чтобы расширить вид без внесения изменений ломающих существующую рукопись
- Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей

Сущность `Add` из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида, но сущность `Add` позволяет сделать больше. Использование свойства вида по умолчанию в объявлении сущности `Add` означает, что не нужно указывать дополнительное свойство большую часть времени. Другими словами, большая часть рукописи выполнения не нужна, что делает использование сущности проще.

Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида к существующему сущности, можно дать ему значение по умолчанию, чтобы разрешить расширение возможности сущности без нарушения рукописи существующей выполнения.

### Полностью квалифицированный правила написания для устранения неоднозначности: вызов способов с одинаковым именем

В Ржавчине ничего не мешает сущности иметь способ с одинаковым именем, таким же как способ другого сущности и Ржавчина не мешает выполнить оба таких сущности у одного вида. Также возможно выполнить способ с таким же именем непосредственно у вида, такой как и способы у сущностей.

При вызове способов с одинаковыми именами в Ржавчине нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим рукопись в приложении 19-16, где мы определили два сущности: `Pilot` и `Wizard`, у обоих есть способ `fly`. Затем мы выполняем обе сущности у вида `Human` в котором уже выполнен способ с именем `fly`. Каждый способ `fly` делает что-то своё.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
```

<span class="caption">Приложение 19-16: Два сущности определены с способом <code>fly</code> и выполнены у вида <code>Human</code>, а также способ <code>fly</code> выполнен непосредственно у <code>Human</code></span>

Когда мы вызываем `fly` у образца `Human`, то сборщик по умолчанию вызывает способ, который непосредственно выполнен для вида, как показано в приложении 19-17.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
```

<span class="caption">Приложение 19-17: Вызов <code>fly</code> у образца <code>Human</code></span>

Запуск этой рукописи выведет `*waving arms furiously*` , показывая, что Ржавчина называется способ `fly` выполненный непосредственно у `Human`.

Чтобы вызвать способы `fly` у сущности `Pilot` или сущности `Wizard` нужно использовать более явные правила написания, указывая какой способ `fly` мы имеем в виду. Приложение 19-18 отображает такие правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
```

<span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span>

Указание имени сущности перед именем способа проясняет сборщику Ржавчина, какую именно выполнение `fly` мы хотим вызвать. Мы могли бы также написать `Human::fly(&person)`, что равнозначно используемому нами `person.fly()` в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.

Выполнение этой рукописи выводит следующее:

```console
{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
```

Поскольку способ `fly` принимает свойство `self`, если у нас было два *вида* оба выполняющих один *сущность*, то Ржавчина может понять, какую выполнение сущности использовать в зависимости от вида `self`.

Однако, сопряженные функции, не являющиеся способами, не имеют свойства `self`. Когда существует несколько видов или сущностей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Ржавчина не всегда знает, какой вид вы имеете в виду, если только вы не используете *полные правила написания*. Например, в приложении 19-19 мы создаём сущность для приюта животных, который хочет назвать всех маленьких собак *Spot*. Мы создаём сущность `Animal` со связанной с ним функцией `baby_name`, не являющейся способом. Сущность `Animal` выполнен для устройства `Dog`, для которой мы также напрямую предоставляем связанную функцию `baby_name`, не являющуюся способом.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
```

<span class="caption">Приложение 19-19: Сущность с сопряженной функцией и вид с сопряженной функцией с тем же именем, которая тоже выполняет сущность</span>

Мы выполнили рукопись для приюта для животных, который хочет назвать всех щенков именем Spot, в сопряженной функции `baby_name`, которая определена для `Dog`. Вид `Dog` также выполняет сущность `Animal`, который описывает свойства, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в выполнения `Animal` у `Dog` в функции `baby_name` сопряженной с сущностью `Animal`.

В `main` мы вызываем функцию `Dog::baby_name`, которая вызывает сопряженную функцию определённую напрямую у `Dog`. Эта рукопись выводит следующее:

```console
{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
```

Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию `baby_name`, которая является частью сущности `Animal` выполненного у `Dog`, так чтобы рукопись выводил `A baby dog is called a puppy`. Техника указания имени сущности использованная в приложении 19-18 здесь не помогает; если мы изменим `main` рукопись как в приложении 19-20, мы получим ошибку сборки.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}
```

<span class="caption">Приложение 19-20. Попытка вызвать функцию <code>baby_name</code> из сущности <code>Animal</code>, но Ржавчина не знает какую выполнение использовать</span>

Поскольку `Animal::baby_name` не имеет свойства `self`, и могут быть другие виды, выполняющие сущность `Animal`, Ржавчина не может понять, какую выполнение `Animal::baby_name` мы хотим использовать. Мы получим эту ошибку сборщика:

```console
{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
```

Чтобы устранить неоднозначность и сказать Ржавчине, что мы хотим использовать выполнение `Animal` для `Dog`, нужно использовать полные правила написания. Приложение 19-21 отображает, как использовать полные правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
```

<span class="caption">Приложение 19-21: Использование полного правил написания для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у сущности <code>Animal</code> выполненную в <code>Dog</code></span>

Мы указываем изложение вида в угловых скобках, которая указывает на то что мы хотим вызвать способ `baby_name` из сущности `Animal` выполненный в `Dog`, также указывая что мы хотим рассматривать вид `Dog` в качестве `Animal` для вызова этой функции. Эта рукопись теперь выведет то, что мы хотим:

```console
{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
```

В общем, полные правила написания определяется следующим образом:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

Для сопряженных функций, которые не являются способами, будет отсутствовать `receiver` (предмет приёмника): будет только список переменных. Вы можете использовать полные правила написания везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого правил написания, которую Ржавчина может понять из другой сведений в программе. Вам нужно использовать более подробный правила написания только в тех случаях, когда существует несколько выполнений, использующих одно и то же название, и Ржавчина нужно помочь определить, какую выполнение вы хотите вызвать.

### Использование супер сущностей для требования возможности одного сущности в рамках другого сущности

Иногда вы можете написать определение сущности, которое зависит от другого сущности: для вида, выполняющего первый сущность, вы хотите потребовать, чтобы этот вид также выполнил второй сущность. Вы должны сделать это, чтобы ваше определение сущности могло использовать связанные элементы второго сущности. Сущность, на который опирается ваше определение сущности, называется *supertrait* вашего сущности.

Например, мы хотим создать сущность `OutlinePrint` с способом `outline_print`, который будет выводить значение обрамлённое звёздочками. Мы хотим чтобы устройства `Point`, выполняющая сущность встроенной библиотеки `Display`, отправила на вывод `(x, y)` при вызове `outline_print` у образца `Point`, который имеет значение `1` для `x` и значение `3` для `y`. Она должна вывести следующее:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

В выполнения `outline_print` мы хотим использовать возможность сущности `Display`. Поэтому нам нужно указать, что сущность `OutlinePrint` будет работать только для видов, которые также выполняют `Display` и предоставляют возможность, которая нужна в `OutlinePrint`. Мы можем сделать это в объявлении сущности, указав `OutlinePrint: Display`. Этот способ похож на добавление ограничения в сущность. В приложении 19-22 показана выполнение сущности `OutlinePrint`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
```

<span class="caption">Приложение 19-22: Выполнение сущности <code>OutlinePrint</code> которая требует возможности сущности <code>Display</code></span>

Поскольку мы указали, что сущность `OutlinePrint` требует сущности `Display`, мы можем использовать функцию `to_string`, которая самостоятельно выполнена для любого вида выполняющего `Display`. Если бы мы попытались использовать `to_string` не добавляя двоеточие и не указывая сущность `Display` после имени сущности, мы получили бы сообщение о том, что способ с именем `to_string` не был найден у вида `&Self` в текущей области видимости.

Давайте посмотрим что происходит, если мы пытаемся выполнить сущность `OutlinePrint` для вида, который не выполняет `Display`, например устройства `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

Мы получаем сообщение о том, что требуется выполнение `Display`, но её нет:

```console
{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

Чтобы исправить, мы выполняем `Display` у устройства `Point` и выполняем требуемое ограничение `OutlinePrint`, вот так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

Тогда выполнение сущности `OutlinePrint` для устройства `Point` будет собрана успешно и мы можем вызвать `outline_print` у образца `Point` для отображения значения обрамлённое звёздочками.

### Образец Newtype для выполнение внешних сущностей у внешних видов

В разделе ["Выполнение сущности у вида"](ch10-02-traits.html#implementing-a-trait-on-a-type)<!-- ignore --> главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается выполнить сущность у вида, если либо сущность, либо вид являются местными для нашего ящика. Можно обойти это ограничение, используя *образец нового вида* (newtype pattern), который включает в себя создание нового вида в упорядоченной в ряд стопке. (Мы рассмотрели упорядоченные в ряд устройства  в разделе ["Использование стопок упорядоченных рядов без именованных полей для создания различных видов"]<!--  --> главы 5.) Устройства упорядоченного ряда будет иметь одно поле и будет тонкой оболочкой для вида которому мы хотим выполнить сущность. Тогда вид оболочки является местным для нашего ящика и мы можем выполнить сущность для местной обёртки. *Newtype* это понятие, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого образца и вид оболочки исключается во время сборки.

В качестве примера, мы хотим выполнить сущность `Display` для вида `Vec<T>`, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что сущность `Display` и вид `Vec<T>` объявлены вне нашего ящика. Мы можем сделать устройство `Wrapper`, которая содержит образец `Vec<T>`; тогда мы можем выполнить `Display` у устройства `Wrapper` и использовать значение `Vec<T>` как показано в приложении 19-23.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
```

<span class="caption">Приложение 19-23. Создание вида <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для выполнения <code>Display</code></span>

Выполнение `Display` использует `self.0` для доступа к внутреннему `Vec<T>`, потому что `Wrapper` это устройства упорядоченного ряда, а `Vec<T>` это элемент с порядковым указателем 0 в упорядоченном ряде. Затем мы можем использовать полезные  возможности вида `Display` у `Wrapper`.

Недостатком использования этой техники является то, что `Wrapper` является новым видом, поэтому он не имеет способов для значения, которое он держит в себе. Мы должны были бы выполнить все способы для `Vec<T>` непосредственно во `Wrapper`, так чтобы эти способы делегировались внутреннему `self.0`, что позволило бы нам обращаться с `Wrapper` точно так же, как с `Vec<T>`. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида, выполняя сущность `Deref` (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью `Deref` сущности"</a><!-- ignore --> главы 15) у `Wrapper` для возвращения внутреннего вида, то это было бы решением. Если мы не хотим, чтобы вид `Wrapper` имел все способы внутреннего вида, например, для ограничения поведения вида `Wrapper`, то пришлось бы вручную выполнить только те способы, которые нам нужны.

Этот образец newtype также полезен, даже когда сущности не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов Ржавчины.


["Образец Newtype для выполнение внешних сущностей у внешних видов"]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
["Использование стопок упорядоченных рядов без именованных полей для создания различных видов"]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types