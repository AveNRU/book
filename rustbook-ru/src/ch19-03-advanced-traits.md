## Продвинутые особенности

Мы познакомились с особенностями в разделе ["Особенности: Определение общего поведения"](ch10-02-traits.html#traits-defining-shared-behavior)<!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Ржавчина мы можем перейти к более подробному рассмотрению.

### Указание видов-заполнителей в определениях особенностей с сопряженными видами

*Сопряженные виды* связывают вид-заполнитель с особенностью таким образом, что определения способов особенности могут использовать эти виды-заполнители в своих ярлыках. Для именно выполнения особенности вместо вида-заполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить особенности, использующие некоторые виды, без необходимости точно знать, что это за виды, пока особенности не будут выполнены.

Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Сопряженные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.

Одним из примеров особенности с сопряженным видом является особенность `Iterator` из встроенной библиотеки. Сопряженный вид называется `Item` и символизирует вид значений, по которым повторяется вид, выполняющий особенность `Iterator`. Определение особенности <code>Iterator</code> показано в приложении 19-12.

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}
```

<span class="caption">Приложение 19-12: Определение особенности <code>Iterator</code>, который имеет сопряженный вид <code>Item</code></span>

Вид `Item` является заполнителем и определение способа `next` показывает, что он будет возвращать значения вида `Option<Self::Item>`. Разработчики особенности `Iterator` определят определенный вид для `Item`, а способ `next` вернёт `Option` содержащий значение этого определенного вида.

Сопряженные виды могут показаться подходом похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя подходами, мы рассмотрим выполнение особенности `Iterator` для вида с именем `Counter`, который указывает, что вид `Item` равен `u32`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

Этот правила написания весьма напоминает обобщённые виды. Так почему же особенность `Iterator` не определён обобщённым видом, как показано в приложении 19-13?

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}
```

<span class="caption">Приложение 19-13: Гипотетическое определение особенности <code>Iterator</code> используя обобщённые виды</span>

Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны определять виды в каждой выполнения; потому что мы также можем выполнить `Iterator<String> for Counter` или любого другого вида, мы могли бы иметь несколько выполнения `Iterator` для `Counter`. Другими словами, когда особенность имеет обобщённый свойство, он может быть выполнен для вида несколько раз, каждый раз меняя определенные виды свойств обобщённого вида. Когда мы используем способ `next` у `Counter`, нам пришлось бы предоставить изложении вида, указывая какую выполнение `Iterator` мы хотим использовать.

С сопряженными видами не нужно определять виды, потому что мы не можем выполнить особенность у вида несколько раз. В приложении 19-12 с определением, использующим сопряженные виды можно выбрать только один вид `Item`, потому что может быть только одно объявление `impl Iterator for Counter`. Нам не нужно указывать, что нужен повторитель значений вида `u32` везде, где мы вызываем `next` у `Counter`.

Сопряженные виды также становятся частью договора особенности: разработчики особенности должны предоставить вид, который заменит сопряженный заполнитель вида. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошей опытом является документирование связанного вида в документации по API.

### Свойства обобщённого вида по умолчанию и перегрузка операторов

Когда мы используем свойства обобщённого вида, мы можем указать определенный вид по умолчанию для обобщённого вида. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида с помощью правил написания  `<PlaceholderType=ConcreteType>`.

Отличным примером, когда этот способ полезен, является *перегрузка оператора* (operator overloading), когда вы настраиваете поведение оператора (например, `+` ) для определённых случаев.

Ржавчина не позволяет создавать собственные операторы или перегружать произвольные операторы. Но можно перегрузить перечисленные действия и соответствующие им особенности из `std::ops` путём выполнения особенностей, связанных с этими операторами. Например, в приложении 19-14 мы перегружаем оператор `+`, чтобы складывать два образца `Point`. Мы делаем это выполняя особенность `Add` для устройства `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
```

<span class="caption">Приложение 19-14: Выполнение особенности <code>Add</code> для перегрузки оператора <code>+</code> для образцов <code>Point</code></span>

Способ `add` складывает значения `x` двух образцов `Point` и значения `y` у `Point` для создания нового образца `Point`. Особенность `Add` имеет сопряженный вид с именем `Output`, который определяет вид, возвращаемый из способа `add`.

Обобщённый вид по умолчанию в этом коде находится в особенности `Add` . Вот его определение:

```rust
trait Add<Rhs = Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

Этот код должен выглядеть знакомым: особенность с одним способом и сопряженным видом. Новый правила написания это `RHS=Self`. Такой правила написания называется *свойства вида по умолчанию* (default type parameters). Свойство обобщённого вида `RHS` (сокращённо “right hand side”) определяет вид свойства `rhs` в способе `add`. Если мы не укажем определенный вид для `RHS` при выполнения особенности `Add`, то видом для `RHS` по умолчанию будет `Self`, который будет видом для которого выполняется особенность `Add`.

Когда мы выполнили `Add` для устройства `Point`, мы использовали обычное значение для `RHS`, потому что хотели сложить два образца `Point`. Давайте посмотрим на пример выполнения особенности `Add`, где мы хотим пользовательский вид `RHS` вместо использования вида по умолчанию.

У нас есть две разные устройства `Millimeters` и `Meters`, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида в другую устройство известно как образец *newtype*, который мы более подробно опишем в разделе ["Образец Newtype для выполнение внешних особенностей у внешних видов"]<!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь выполнение особенности `Add`, которая делает правильное преобразование единиц. Можно выполнить <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве `Rhs`, как показано в приложении 19-15.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}
```

<span class="caption">Приложение 19-15: Выполнение особенности <code>Add</code> для устройства  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span>

Чтобы сложить `Millimeters` и `Meters`, мы указываем `impl Add<Meters>`, чтобы указать значение свойства вида `RHS` (Meters) вместо использования значения по умолчанию `Self` (Millimeters).

Свойства вида по умолчанию используются в двух основных случаях:

- Чтобы расширить вид без внесения изменений ломающих существующий код
- Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей

Особенность `Add` из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида, но особенность `Add` позволяет сделать больше. Использование свойства вида по умолчанию в объявлении особенности `Add` означает, что не нужно указывать дополнительный свойство большую часть времени. Другими словами, большая часть кода выполнения не нужна, что делает использование особенности проще.

Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида к существующему особенности, можно дать ему значение по умолчанию, чтобы разрешить расширение возможности особенности без нарушения кода существующей выполнения.

### Полностью квалифицированный правила написания для устранения неоднозначности: вызов способов с одинаковым именем

В Ржавчина ничего не мешает особенности иметь способ с одинаковым именем, таким же как способ другого особенности и Ржавчина не мешает выполнить оба таких особенности у одного вида. Также возможно выполнить способ с таким же именем непосредственно у вида, такой как и способы у особенностей.

При вызове способов с одинаковыми именами в Ржавчина нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим код в приложении 19-16, где мы определили два особенности: `Pilot` и `Wizard`, у обоих есть способ `fly`. Затем мы выполняем оба особенности у вида `Human` в котором уже выполнен способ с именем `fly`. Каждый способ `fly` делает что-то своё.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
```

<span class="caption">Приложение 19-16: Два особенности определены с способом <code>fly</code> и выполнены у вида <code>Human</code>, а также способ <code>fly</code> выполнен непосредственно у <code>Human</code></span>

Когда мы вызываем `fly` у образца `Human`, то сборщик по умолчанию вызывает способ, который непосредственно выполнен для вида, как показано в приложении 19-17.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
```

<span class="caption">Приложение 19-17: Вызов <code>fly</code> у образца <code>Human</code></span>

Запуск этого кода напечатает `*waving arms furiously*` , показывая, что Ржавчина называется способ `fly` выполненный непосредственно у `Human`.

Чтобы вызвать способы `fly` у особенности `Pilot` или особенности `Wizard` нужно использовать более явный правила написания, указывая какой способ `fly` мы имеем в виду. Приложение 19-18 отображает такой правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
```

<span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span>

Указание имени особенности перед именем способа проясняет сборщику Ржавчина, какую именно выполнение `fly` мы хотим вызвать. Мы могли бы также написать `Human::fly(&person)`, что эквивалентно используемому нами `person.fly()` в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.

Выполнение этого кода выводит следующее:

```console
{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
```

Поскольку способ `fly` принимает свойство `self`, если у нас было два *вида* оба выполняющих один *особенность*, то Ржавчина может понять, какую выполнение особенности использовать в зависимости от вида `self`.

Однако, сопряженные функции, не являющиеся способами, не имеют свойства `self`. Когда существует несколько видов или особенностей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Ржавчина не всегда знает, какой вид вы имеете в виду, если только вы не используете *полный правила написания*. Например, в приложении 19-19 мы создаём особенность для приюта животных, который хочет назвать всех маленьких собак *Spot*. Мы создаём особенность `Animal` со связанной с ним функцией `baby_name`, не являющейся способом. Особенность `Animal` выполнен для устройства `Dog`, для которой мы также напрямую предоставляем связанную функцию `baby_name`, не являющуюся способом.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
```

<span class="caption">Приложение 19-19: Особенность с сопряженной функцией и вид с сопряженной функцией с тем же именем, которая тоже выполняет особенность</span>

Мы выполнили код для приюта для животных, который хочет назвать всех щенков именем Spot, в сопряженной функции `baby_name`, которая определена для `Dog`. Вид `Dog` также выполняет особенность `Animal`, который описывает свойства, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в выполнения `Animal` у `Dog` в функции `baby_name` сопряженной с особенностью `Animal`.

В `main` мы вызываем функцию `Dog::baby_name`, которая вызывает сопряженную функцию определённую напрямую у `Dog`. Этот код печатает следующее:

```console
{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
```

Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию `baby_name`, которая является частью особенности `Animal` выполненного у `Dog`, так чтобы код печатал `A baby dog is called a puppy`. Техника указания имени особенности использованная в приложении 19-18 здесь не помогает; если мы изменим `main` код как в приложении 19-20, мы получим ошибку сборки.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}
```

<span class="caption">Приложение 19-20. Попытка вызвать функцию <code>baby_name</code> из особенности <code>Animal</code>, но Ржавчина не знает какую выполнение использовать</span>

Поскольку `Animal::baby_name` не имеет свойства `self`, и могут быть другие виды, выполняющие особенность `Animal`, Ржавчина не может понять, какую выполнение `Animal::baby_name` мы хотим использовать. Мы получим эту ошибку сборщика:

```console
{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
```

Чтобы устранить неоднозначность и сказать Ржавчине, что мы хотим использовать выполнение `Animal` для `Dog`, нужно использовать полный правила написания. Приложение 19-21 отображает, как использовать полный правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
```

<span class="caption">Приложение 19-21: Использование полного правил написания для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у особенности <code>Animal</code> выполненную в <code>Dog</code></span>

Мы указываем изложение вида в угловых скобках, которая указывает на то что мы хотим вызвать способ `baby_name` из особенности `Animal` выполненный в `Dog`, также указывая что мы хотим рассматривать вид `Dog` в качестве `Animal` для вызова этой функции. Этот код теперь напечатает то, что мы хотим:

```console
{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
```

В общем, полный правила написания определяется следующим образом:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

Для сопряженных функций, которые не являются способами, будет отсутствовать `receiver` (предмет приёмника): будет только список переменных. Вы можете использовать полный правила написания везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого правил написания, которую Ржавчина может понять из другой сведений в программе. Вам нужно использовать более подробный правила написания только в тех случаях, когда существует несколько выполнений, использующих одно и то же название, и Ржавчина нужно помочь определить, какую выполнение вы хотите вызвать.

### Использование супер особенностей для требования возможности одного особенности в рамках другого особенности

Иногда вы можете написать определение особенности, которое зависит от другого особенности: для вида, выполняющего первый особенность, вы хотите потребовать, чтобы этот вид также выполнил второй особенность. Вы должны сделать это, чтобы ваше определение особенности могло использовать связанные элементы второго особенности. Особенность, на который опирается ваше определение особенности, называется *supertrait* вашего особенности.

Например, мы хотим создать особенность `OutlinePrint` с способом `outline_print`, который будет печатать значение обрамлённое звёздочками. Мы хотим чтобы устройства `Point`, выполняющая особенность встроенной библиотеки `Display`, вывела на печать `(x, y)` при вызове `outline_print` у образца `Point`, который имеет значение `1` для `x` и значение `3` для `y`. Она должна напечатать следующее:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

В выполнения `outline_print` мы хотим использовать возможность особенности `Display`. Поэтому нам нужно указать, что особенность `OutlinePrint` будет работать только для видов, которые также выполняют `Display` и предоставляют возможность, которая нужна в `OutlinePrint`. Мы можем сделать это в объявлении особенности, указав `OutlinePrint: Display`. Этот способ похож на добавление ограничения в особенность. В приложении 19-22 показана выполнение особенности `OutlinePrint`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
```

<span class="caption">Приложение 19-22: Выполнение особенности <code>OutlinePrint</code> которая требует возможности особенности <code>Display</code></span>

Поскольку мы указали, что особенность `OutlinePrint` требует особенности `Display`, мы можем использовать функцию `to_string`, которая самостоятельно выполнена для любого вида выполняющего `Display`. Если бы мы попытались использовать `to_string` не добавляя двоеточие и не указывая особенность `Display` после имени особенности, мы получили бы сообщение о том, что способ с именем `to_string` не был найден у вида `&Self` в текущей области видимости.

Давайте посмотрим что происходит, если мы пытаемся выполнить особенность `OutlinePrint` для вида, который не выполняет `Display`, например устройства `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

Мы получаем сообщение о том, что требуется выполнение `Display`, но её нет:

```console
{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

Чтобы исправить, мы выполняем `Display` у устройства `Point` и выполняем требуемое ограничение `OutlinePrint`, вот так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

Тогда выполнение особенности `OutlinePrint` для устройства `Point` будет собрана успешно и мы можем вызвать `outline_print` у образца `Point` для отображения значения обрамлённое звёздочками.

### Образец Newtype для выполнение внешних особенностей у внешних видов

В разделе ["Выполнение особенности у вида"](ch10-02-traits.html#implementing-a-trait-on-a-type)<!-- ignore --> главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается выполнить особенность у вида, если либо особенность, либо вид являются местными для нашего ящика. Можно обойти это ограничение, используя *образец нового вида* (newtype pattern), который включает в себя создание нового вида в упорядоченной в ряд устройстве. (Мы рассмотрели упорядоченные в ряд устройства  в разделе ["Использование устройств упорядоченных рядов без именованных полей для создания различных видов"]<!--  --> главы 5.) Устройства упорядоченного ряда будет иметь одно поле и будет тонкой оболочкой для вида которому мы хотим выполнить особенность. Тогда вид оболочки является местным для нашего ящика и мы можем выполнить особенность для местной обёртки. *Newtype* это понятие, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого образца и вид оболочки исключается во время сборки.

В качестве примера, мы хотим выполнить особенность `Display` для вида `Vec<T>`, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что особенность `Display` и вид `Vec<T>` объявлены вне нашего ящика. Мы можем сделать устройство `Wrapper`, которая содержит образец `Vec<T>`; тогда мы можем выполнить `Display` у устройства `Wrapper` и использовать значение `Vec<T>` как показано в приложении 19-23.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
```

<span class="caption">Приложение 19-23. Создание вида <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для выполнения <code>Display</code></span>

Выполнение `Display` использует `self.0` для доступа к внутреннему `Vec<T>`, потому что `Wrapper` это устройства упорядоченного ряда, а `Vec<T>` это элемент с порядковым указателем 0 в упорядоченном ряде. Затем мы можем использовать полезные  возможности вида `Display` у `Wrapper`.

Недостатком использования этой техники является то, что `Wrapper` является новым видом, поэтому он не имеет способов для значения, которое он держит в себе. Мы должны были бы выполнить все способы для `Vec<T>` непосредственно во `Wrapper`, так чтобы эти способы делегировались внутреннему `self.0`, что позволило бы нам обращаться с `Wrapper` точно так же, как с `Vec<T>`. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида, выполняя особенность `Deref` (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью `Deref` особенности"</a><!-- ignore --> главы 15) у `Wrapper` для возвращения внутреннего вида, то это было бы решением. Если мы не хотим, чтобы вид `Wrapper` имел все способы внутреннего вида, например, для ограничения поведения вида `Wrapper`, то пришлось бы вручную выполнить только те способы, которые нам нужны.

Этот образец newtype также полезен, даже когда особенности не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов Ржавчины.


["Образец Newtype для выполнение внешних особенностей у внешних видов"]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
["Использование устройств упорядоченных рядов без именованных полей для создания различных видов"]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types