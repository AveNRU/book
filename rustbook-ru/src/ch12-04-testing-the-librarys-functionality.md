## Развитие возможности библиотеки разработкой на основе проверок

<<<<<<< HEAD
Теперь, когда мы извлекли ход мыслей в *src/lib.rs* и оставили разбор переменных приказной строки и обработку ошибок в *src/main.rs*, стало гораздо проще писать проверки для основной возможности нашего рукописи. Мы можем вызывать функции напрямую с различными переменнойми и проверить возвращаемые значения без необходимости вызова нашего двоичного файла из приказной строки.
=======
Теперь, когда мы извлекли ход мыслей в *src/lib.rs* и оставили разбор переменных приказной строки и обработку ошибок в *src/main.rs*, стало гораздо проще писать проверки для основной возможности нашей рукописи. Мы можем вызывать функции напрямую с различными переменнойми и проверить возвращаемые значения без необходимости вызова нашего двоичного файла из приказной строки.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196

В этом разделе в программу `minigrep` мы добавим ход мыслей поиска с использованием этапа разработки через проверка (TDD), который следует этим шагам:

1. Напишите проверка, который завершается неудачей, и запустите его, чтобы убедиться, что он не сработал именно по той причине, которую вы ожидаете.
2. Пишите или изменяйте ровно столько рукописи, чтобы успешно выполнился новый проверку.
<<<<<<< HEAD
3. Выполните переработка рукописи рукописи, который вы только что добавили или изменили, и убедитесь, что проверки продолжают проходить.
=======
3. Выполните переработку рукописи, который вы только что добавили или изменили, и убедитесь, что проверки продолжают проходить.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196
4. Повторите с шага 1!

Хотя это всего лишь один из многих способов написания программного обеспечения, TDD может помочь в разработке рукописи. Написание проверки перед написанием рукописи, обеспечивающего прохождение проверки, помогает поддерживать высокое покрытие проверкими на протяжении всего этапа разработки.

Мы проверим выполнение возможности, которая делает поиск строки запроса в содержимом файла и создание списка строк, соответствующих запросу. Мы добавим эту возможность в функцию под названием `search`.

### Написание проверки с ошибкой

Поскольку они нам больше не нужны, давайте удалим указания с `println!`, которые мы использовали для проверки поведения программы в *src/lib.rs* и *src/main.rs*. Затем в *src/lib.rs* мы добавим звено `tests` с проверочной функцией, как делали это в [главе 11]<!-- ignore -->. Проверочная функция определяет поведение, которое мы хотим проверить в функции `search`: она должна принимать запрос и писание для поиска, а возвращать только те строки из писания, которые содержат запрос. В приложении 12-15 показан этот проверка, который пока не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

<span class="caption">Приложение 12-15: Создание безуспешного проверки для функции <code>search</code>, которую мы хотим создать</span>

<<<<<<< HEAD
Этот проверка ищет строку `"duct"`. Текст, в котором мы ищем, состоит из трёх строк, только одна из которых содержит `"duct"` (обратите внимание, что обратная косая черта после открывающей двойной кавычки говорит Ржавчина не помещать знак новой строки в начало содержимого этого строкового записи). Мы проверяем, что значение, возвращаемое функцией `search`, содержит только ожидаемую нами строку.
=======
Этот проверка ищет строку `"duct"`. писание,  в котором мы ищем, состоит из трёх строк, только одна из которых содержит `"duct"` (обратите внимание, что обратная косая черта после открывающей двойной кавычки говорит Ржавчина не помещать знак новой строки в начало содержимого этого строкового записи). Мы проверяем, что значение, возвращаемое функцией `search`, содержит только ожидаемую нами строку.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196

Мы не можем запустить этот проверка и увидеть сбой, потому что проверка даже не собирается: функции `search` ещё не существует! В соответствии с принципами TDD мы добавим ровно столько рукописи, чтобы проверка собирался и запускался, добавив определение функции `search`, которая всегда возвращает пустой вектор, как показано в приложении 12-16. Потом проверка должен собраться и потерпеть неудачу при запуске, потому что пустой вектор не равен вектору, содержащему строку `"safe, fast, productive."`

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

<span class="caption">Приложение 12-16. Определение функции <code>search</code>, достаточное, чтобы проверка собрался</span>

Заметьте, что в ярлыке `search` нужно явно указать время жизни `'a` для переменной `contents` и возвращаемого значения. Напомним из [Главы 10]<!-- ignore -->, что свойства времени жизни указывают с временем жизни какого переменной связано время жизни возвращаемого значения. В данном случае мы говорим, что возвращаемый вектор должен содержать срезы строк, ссылающиеся на содержимое переменной `contents` (а не переменной `query`).

Другими словами, мы говорим Ржавчина что данные, возвращаемые функцией `search`, будут жить до тех пор, пока живут данные, переданные в функцию `search` через переменная `contents`. Это важно! Чтобы ссылки были действительными, данные, на которые ссылаются *с помощью* срезов тоже должны быть действительными; если сборщик предполагает, что мы делаем строковые срезы переменной `query`, а не переменной `contents`, он неправильно выполнит проверку безопасности.

Если мы забудем изложении времени жизни и попробуем собрать эту функцию, то получим следующую ошибку:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

<<<<<<< HEAD
Ржавчина не может понять, какой из двух переменных нам нужен, поэтому нужно сказать ему об этом. Так как `contents` является тем переменнаяом, который содержит весь наш текст, и мы хотим вернуть части этого текста, которые совпали при поиске, мы понимаем, что `contents` является переменнаяом, который должен быть связан с возвращаемым значением временем жизни.
=======
Ржавчина не может понять, какой из двух переменных нам нужен, поэтому нужно сказать ему об этом. Так как `contents` является тем переменнаяом, который содержит весь наш писание,  и мы хотим вернуть части этого писания, которые совпали при поиске, мы понимаем, что `contents` является переменнаяом, который должен быть связан с возвращаемым значением временем жизни.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196

Другие языки программирования не требуют от вас связывания в ярлыке переменных с возвращаемыми значениями, но после определённой опытов вам станет проще. Можете сравнить этот пример с разделом [«Проверка ссылок с временами жизни»](ch10-03-lifetime-syntax.html#validating-references-with-lifetimes)<!-- ignore --> главы 10.

Запустим проверку:

```console
{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
```

Отлично. Наш проверка не сработал, как мы и ожидали. Давайте сделаем так, чтобы он срабатывал!

### Написание рукописи для прохождения проверки

Сейчас наш проверка не проходит, потому что мы всегда возвращаем пустой вектор. Чтобы исправить это и выполнить `search`, наша программа должна выполнить следующие шаги:

- Повторение по каждой строке содержимого.
- Проверить, содержит ли данная строка искомую.
- Если это так, добавить её в список значений, которые мы возвращаем.
- Если это не так, ничего не делать.
- Вернуть список итогов.

Давайте проработаем каждый шаг, начиная с перебора строк.

#### Перебор строк с помощью способа `lines`

В Ржавчине есть полезный способ для построчной повторения строк, удобно названный `lines`, как показано в приложении 12-17. Обратите внимание, рукопись пока не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

<span class="caption">Приложение 12-17: Повторение по каждой строке из <code>contents</code></span>

<<<<<<< HEAD
Способ `lines` возвращает повторитель . Мы подробно поговорим об повторителях в [Главе 13]<!-- ignore -->, но вспомните, что вы видели этот способ использования повторителя в [Приложении 3-5]<!-- ignore -->, где мы использовали круговорот `for` с повторителем, чтобы выполнить некоторый рукопись для каждого элемента в собрания.
=======
Способ `lines` возвращает повторитель . Мы подробно поговорим об повторителях в [Главе 13]<!-- ignore -->, но вспомните, что вы видели этот способ использования повторителя в [Приложении 3-5]<!-- ignore -->, где мы использовали круговорот `for` с повторителем, чтобы выполнить некоторую рукопись для каждого элемента в собрания.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196

#### Поиск в каждой строке писания запроса

Далее мы проверяем, содержит ли текущая строка нашу искомую строку. К счастью, у строк есть полезный способ `contains`, который именно это и делает! Добавьте вызов способа `contains` в функции `search`, как показано в приложении 12-18. Обратите внимание, что это все ещё не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

<span class="caption">Приложение 12-18. Добавление проверки, содержится ли <code>query</code> в строке</span>

На данный мгновение мы наращиваем возможность. Чтобы заставить это собираться, нам нужно вернуть значение из тела функции, как мы указали в ярлыке функции.

#### Сохранение совпавшей строки

Чтобы завершить эту функцию, нам нужен способ сохранить совпадающие строки, которые мы хотим вернуть. Для этого мы можем создать изменяемый вектор перед круговоротом `for` и вызывать способ `push` для сохранения `line` в векторе. После круговорота `for` мы возвращаем вектор, как показано в приложении 12-19.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

<span class="caption">Приложение 12-19: Сохраняем совпавшие строки, чтобы впоследствии их можно было вернуть</span>

Теперь функция `search` должна возвратить только строки, содержащие `query`, и проверка должен пройти. Запустим его:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

Наш проверка пройден, значит он работает!

На этом этапе мы могли бы рассмотреть возможности изменения выполнения функции поиска, сохраняя прохождение проверок и поддерживая имеющуюся возможность. Рукопись в функции поиска не так уж плох, но он не использует некоторые полезные функции повторителей. Вернёмся к этому примеру в [главе 13](ch13-02-iterators.html)<!-- ignore -->, где будем исследовать повторители подробно, и посмотрим как его улучшить.

#### Использование функции `search` в функции `run`

Теперь, когда функция `search` работает и проверена, нужно вызвать `search` из нашей функции `run`. Нам нужно передать значение `config.query` и `contents`, которые `run` читает из файла, в функцию `search`. Тогда `run` напечатает каждую строку, возвращаемую из `search`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

Мы по-прежнему используем круговорот `for` для возврата каждой строки из функции `search` и её печати.

Теперь вся программа должна работать! Давайте попробуем сначала запустить её со словом «frog», которое должно вернуть только одну строчку из стихотворения Эмили Дикинсон:

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

Здорово! Теперь давайте попробуем слово, которое будет соответствовать нескольким строкам, например «body»:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

И наконец, давайте удостоверимся, что мы не получаем никаких строк, когда ищем слово, отсутствующее в стихотворении, например «monomorphization»:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

Отлично! Мы создали собственную простое-исполнение обычного средства и научились тому, как внутренне выстроить приложения. Мы также немного узнали о файловом вводе и выводе, временах жизни, проверке и разборе переменных приказной строки.

Чтобы завершить этот дело, мы кратко выполним пару вещей: как работать с переменными окружения и как печатать в обычный поток ошибок, обе из которых полезны при написании окно выводаных программ.


[главе 11]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[Главы 10]: ch10-03-lifetime-syntax.html
[Приложении 3-5]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[Главе 13]: ch13-02-iterators.html