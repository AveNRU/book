## Свойства предметно-направленных языков

В сообществе программистов нет единого мнения о том, какими свойствами должен обладать язык, чтобы считаться предметно-направленным. На Ржавчине повлияли многие парадигмы программирования, включая ООП - например, в главе 13 мы изучали особенности, пришедшие из функционального программирования. Однозначно можно утверждать, что ООП-языкам присущи следующие присущие особенности: предметы, инкапсуляция и наследование. Давайте рассмотрим, что каждая из них означает и поддерживает ли их Ржавчина.

### Предметы содержат данные и поведение

Книга *Приёмы предметно-направленного разработки. Образцы разработки* Erich Gamma, Richard Helm, Ralph Johnson, и John Vlissides (Addison-Wesley Professional, 1994), в просторечии называемая *Книга банды четырёх*, представляет собой сборник примеров предметно-направленного разработки. В ней даётся следующее определение ООП:

> Предметно-направленные программы состоят из предметов. *Предмет* представляет собой сущность, своего рода дополнение, с данными и процедурами, которые работают с этими данными. Процедуры обычно называются *способами* или *действиеми*.

В соответствии с этим определением, Ржавчина является предметно-направленным языком - в устройствах и перечислениях содержатся данные, а в х `impl` определяются способы для них. Хотя устройства и перечисления, имеющие способы, не *называются* предметами, они обеспечивают  возможность, соответствующую определению предметов в книге банды четырёх.

### Инкапсуляция, скрывающая подробности выполнения

Другим особенностью, обычно связанным с предметно-направленным программированием, является мысль *инкапсуляции*: подробности выполнения предмета недоступны для рукописи, использующего этот предмет. Единственный способ взаимодействия с предметом — через его открытый внешняя оболочка; рукопись, использующий этот предмет, не должен иметь возможности взаимодействовать с внутренними свойствами предметами напрямую изменять его данные или поведение. Инкапсуляция позволяет изменять и ресоздавать внутренние свойства предмета без необходимости изменять рукопись, который использует предмет.

В главе 7 мы уже говорили о том, как управлять инкапсуляцией: мы можем использовать ключевое слово `pub`, чтобы определить, какие звенья, виды, функции и способы в нашей рукописи будут открытыми, а всё остальное по умолчанию будет закрытыми. Например, мы можем определить устройство `AveragedCollection`, в которой есть поле, содержащее вектор значений `i32`. Также, устройства будет иметь поле, содержащее среднее арифметическое чисел этого вектора, таким образом, среднее не нужно будет вычислять каждый раз, когда оно кому-то понадобится. Другими словами, `AveragedCollection` будет кэшировать вычисленное среднее для нас. В приложении 17-1 приведено определение устройства `AveragedCollection`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}
```

<span class="caption">Приложение 17-1: устройства <code>AveragedCollection</code> содержит список целых чисел и их среднее арифметическое.</span>

Обратите внимание, что устройства помечена ключевым словом `pub`, что позволяет другому рукописи её использовать, однако, поля устройства остаются недоступными. Это важно, потому что мы хотим обеспечить обновление среднего значения при добавлении или удалении элемента из списка. Мы можем получить нужное поведение, определив в устройстве способы `add`, `remove` и `average`, как показано в примере 17-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}
```

<span class="caption">Приложение 17-2: Выполнение открытых способов <code>add</code>,<code>remove</code>, и <code>average</code> для <code>AveragedCollection</code></span>

Открытые способы `add`, `remove` и `average` являются единственным способом получить или изменить данные в образце `AveragedCollection`. Когда элемент добавляется в `list` способом `add`, или удаляется с помощью способа `remove`, рукопись выполнения каждого из этих способов вызывает закрытый способ `update_average`, который позаботится об обновлении поля `average`.

Мы оставляем поля `list` и `average` закрытыми, чтобы внешний рукопись не мог добавлять или удалять элементы непосредственно в поле `list`; в противном случае поле `average` может оказаться не согласовано при подобном вмешательстве. Способ `average` возвращает значение в поле `average`, что позволяет внешнему рукописи читать значение `average`, но не изменять его.

Поскольку мы инкапсулировали подробности выполнения устройства `AveragedCollection`, мы можем легко изменить такие особенности, как устройства данных, в будущем. Например, мы могли бы использовать `HashSet<i32>` вместо `Vec<i32>` для поля `list`. Благодаря тому, что ярлыки открытых способов `add`, `remove` и `average` остаются неизменными, рукопись, использующий `AveragedCollection`, также не будет нуждаться в изменении. У нас бы не получилось этого достичь, если бы мы сделали поле `list` доступным внешнему рукописи: `HashSet<i32>` и`Vec<i32>` имеют разные способы для добавления и удаления элементов, поэтому внешний рукопись, вероятно, должен измениться, если он изменяет `list` напрямую.

Если инкапсуляция является обязательным особенностью для определения языка как предметно-направленного, то Ржавчина соответствует этому требованию. Возможность использовать или не использовать изменитель доступа `pub` для различных частей рукописи позволяет скрыть подробности выполнения.

### Наследование как система видов и способ совместного использования рукописи

*Наследование* — это рычаг, с помощью которого предмет может унаследовать элементы из определения другого предмета. то есть получить данные и поведение родительского предмета без необходимости повторно их определять.

Если язык должен иметь наследование, чтобы быть предметно-направленным, то Ржавчина таким не является. Здесь нет способа определить устройство, наследующую поля и выполнения способов родительской устройства, без использования макроса.

Однако, если вы привыкли иметь наследование в своём наборе средств для программирования, вы можете использовать другие решения в Ржавчине, в зависимости от того, по какой причине вы изначально хотите использовать наследование.

Вы могли бы выбрать наследование по двум основным причинам. Одна из них - возможность повторного использования рукописи: вы можете выполнить определённое поведение для одного вида, а наследование позволит вам повторно использовать эту выполнение для другого вида. В Ржавчине для этого есть ограниченный способ, использующий выполнение способа особенности по умолчанию, который вы видели в приложении 10-14, когда мы добавили выполнение по умолчанию в способе `summarize` особенности `Summary`. Любой вид, выполняющий свойство `Summary` будет иметь доступный способ `summarize` без дополнительного рукописи. Это похоже на то, как родительский класс имеет выполнение способа, и класс-наследник тоже имеет выполнение способа. Мы также можем переопределить выполнение по умолчанию для способа `summarize`, когда выполняем особенность `Summary`, что похоже на дочерний класс, переопределяющий выполнение способа, унаследованного от родительского класса.

Вторая причина использования наследования относится к системе видов: чтобы иметь возможность использовать дочерний вид в тех же места, что и родительский. Эта возможность также называется *полиморфизм* и означает возможность подменять предметы во время исполнения, если они имеют одинаковые свойства.

> ### Полиморфизм
>
> Для многих людей полиморфизм является родственным наследования. Но на самом деле это более общая подход, относящаяся к рукописи, который может работать с данными нескольких видов. Обычно такими видами выступают подклассы при наследовании.
>
> Вместо этого Ржавчина использует обобщённые виды для абстрагирования от видов, и ограничения особенностей (trait bounds) для указания того, какие возможности эти виды должны предоставлять. Это иногда называют *ограниченным свойствоическим полиморфизмом*.

Наследование, как подход к разработке, в последнее время утратило распространенность во многих языках программирования, поскольку часто существует риск, что мы будем наследовать рукопись чаще, чем это необходимо. Подклассы не всегда должны обладать всеми свойствами родительского класса, но при использовании наследования другого исхода нет. Это может сделать внешний вид программы менее гибким. Кроме этого, появляется возможность вызова у подклассов способов, которые не имеют смысла или вызывают ошибки, потому что эти способы неприменимы к подклассу. Кроме того, в некоторых языках разрешается только одиночное наследование (т.е. подкласс может наследоваться только от одного класса), что ещё больше ограничивает гибкость разработки программы.

По этим причинам в Ржавчине применяется иной подход, с использованием особенностей-предметов вместо наследования. Давайте посмотрим как особенности-предметы выполняют полиморфизм в Ржавчине.
