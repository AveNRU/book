## Характеристики объектно-ориентированных языков

В сообществе программистов нет единого мнения о том, какими свойствами должен обладать язык, чтобы считаться объектно-ориентированным. На Rust повлияли многие парадигмы программирования, включая ООП - например, в главе 13 мы изучали особенности, пришедшие из функционального программирования. Однозначно можно утверждать, что ООП-языкам присущи следующие характерные особенности: объекты, инкапсуляция и наследование. Давайте рассмотрим, что каждая из них означает и поддерживает ли их Rust.

### Объекты содержат данные и поведение

Книга *Приёмы объектно-ориентированного проектирования. Паттерны проектирования* Erich Gamma, Richard Helm, Ralph Johnson, и John Vlissides (Addison-Wesley Professional, 1994), в просторечии называемая *Книга банды четырёх*, представляет собой сборник примеров объектно-ориентированного проектирования. В ней даётся следующее определение ООП:

> Объектно-ориентированные программы состоят из объектов. *Объект* представляет собой сущность, своего рода дополнение, с данными и процедурами, которые работают с этими данными. Процедуры обычно называются *способами* или *действиеми*.

В соответствии с этим определением, Rust является объектно-ориентированным языком - в структурах и перечислениях содержатся данные, а в х `impl` определяются способы для них. Хотя структуры и перечисления, имеющие способы, не *называются* объектами, они обеспечивают  функциональность, соответствующую определению объектов в книге банды четырёх.

### Инкапсуляция, скрывающая подробности реализации

Другим особенностью, обычно связанным с объектно-ориентированным программированием, является мысль *инкапсуляции*: подробности реализации объекта недоступны для кода, использующего этот объект. Единственный способ взаимодействия с объектом — через его публичный внешняя оболочка; код, использующий этот объект, не должен иметь возможности взаимодействовать с внутренними свойствами объекта и напрямую изменять его данные или поведение. Инкапсуляция позволяет изменять и реорганизовывать внутренние свойства объекта без необходимости изменять код, который использует объект.

В главе 7 мы уже говорили о том, как управлять инкапсуляцией: мы можем использовать ключевое слово `pub`, чтобы определить, какие модули, виды, функции и способы в нашем коде будут публичными, а всё остальное по умолчанию будет приватными. Например, мы можем определить структуру `AveragedCollection`, в которой есть поле, содержащее вектор значений `i32`. Также, структура будет иметь поле, содержащее среднее арифметическое чисел этого вектора, таким образом, среднее не нужно будет вычислять каждый раз, когда оно кому-то понадобится. Другими словами, `AveragedCollection` будет кэшировать вычисленное среднее для нас. В приложении 17-1 приведено определение структуры `AveragedCollection`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}
```

<span class="caption">Приложение 17-1: структура <code>AveragedCollection</code> содержит список целых чисел и их среднее арифметическое.</span>

Обратите внимание, что структура помечена ключевым словом `pub`, что позволяет другому коду её использовать, однако, поля структуры остаются недоступными. Это важно, потому что мы хотим обеспечить обновление среднего значения при добавлении или удалении элемента из списка. Мы можем получить нужное поведение, определив в структуре способы `add`, `remove` и `average`, как показано в примере 17-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}
```

<span class="caption">Приложение 17-2: Реализация публичных способов <code>add</code>,<code>remove</code>, и <code>average</code> для <code>AveragedCollection</code></span>

Публичные способы `add`, `remove` и `average` являются единственным способом получить или изменить данные в экземпляре `AveragedCollection`. Когда элемент добавляется в `list` способом `add`, или удаляется с помощью способа `remove`, код реализации каждого из этих способов вызывает приватный способ `update_average`, который позаботится об обновлении поля `average`.

Мы оставляем поля `list` и `average` приватными, чтобы внешний код не мог добавлять или удалять элементы непосредственно в поле `list`; в противном случае поле `average` может оказаться не синхронизировано при подобном вмешательстве. Способ `average` возвращает значение в поле `average`, что позволяет внешнему коду читать значение `average`, но не изменять его.

Поскольку мы инкапсулировали подробности реализации структуры `AveragedCollection`, мы можем легко изменить такие особенности, как структура данных, в будущем. Например, мы могли бы использовать `HashSet<i32>` вместо `Vec<i32>` для поля `list`. Благодаря тому, что сигнатуры публичных способов `add`, `remove` и `average` остаются неизменными, код, использующий `AveragedCollection`, также не будет нуждаться в изменении. У нас бы не получилось этого достичь, если бы мы сделали поле `list` доступным внешнему коду: `HashSet<i32>` и`Vec<i32>` имеют разные способы для добавления и удаления элементов, поэтому внешний код, вероятно, должен измениться, если он модифицирует `list` напрямую.

Если инкапсуляция является обязательным особенностью для определения языка как объектно-ориентированного, то Rust соответствует этому требованию. Возможность использовать или не использовать модификатор доступа `pub` для различных частей кода позволяет скрыть подробности реализации.

### Наследование как система видов и способ совместного использования кода

*Наследование* — это механизм, с помощью которого объект может унаследовать элементы из определения другого объекта, то есть получить данные и поведение родительского объекта без необходимости повторно их определять.

Если язык должен иметь наследование, чтобы быть объектно-ориентированным, то Rust таким не является. Здесь нет способа определить структуру, наследующую поля и реализации способов родительской структуры, без использования макроса.

Однако, если вы привыкли иметь наследование в своём наборе средств для программирования, вы можете использовать другие решения в Rust, в зависимости от того, по какой причине вы изначально хотите использовать наследование.

Вы могли бы выбрать наследование по двум основным причинам. Одна из них - возможность повторного использования кода: вы можете реализовать определённое поведение для одного вида, а наследование позволит вам повторно использовать эту реализацию для другого вида. В Rust для этого есть ограниченный способ, использующий реализацию способа типажа по умолчанию, который вы видели в приложении 10-14, когда мы добавили реализацию по умолчанию в способе `summarize` типажа `Summary`. Любой вид, реализующий свойство `Summary` будет иметь доступный способ `summarize` без дополнительного кода. Это похоже на то, как родительский класс имеет реализацию способа, и класс-наследник тоже имеет реализацию способа. Мы также можем переопределить реализацию по умолчанию для способа `summarize`, когда реализуем типаж `Summary`, что похоже на дочерний класс, переопределяющий реализацию способа, унаследованного от родительского класса.

Вторая причина использования наследования относится к системе видов: чтобы иметь возможность использовать дочерний вид в тех же места, что и родительский. Эта возможность также называется *полиморфизм* и означает возможность подменять объекты во время исполнения, если они имеют одинаковые характеристики.

> ### Полиморфизм
>
> Для многих людей полиморфизм является синонимом наследования. Но на самом деле это более общая концепция, относящаяся к коду, который может работать с данными нескольких видов. Обычно такими видами выступают подклассы при наследовании.
>
> Вместо этого Rust использует обобщённые виды для абстрагирования от видов, и ограничения типажей (trait bounds) для указания того, какие возможности эти виды должны предоставлять. Это иногда называют *ограниченным свойствоическим полиморфизмом*.

Наследование, как подход к разработке, в последнее время утратило популярность во многих языках программирования, поскольку часто существует риск, что мы будем наследовать код чаще, чем это необходимо. Подклассы не всегда должны обладать всеми характеристиками родительского класса, но при использовании наследования другого варианта нет. Это может сделать дизайн программы менее гибким. Кроме этого, появляется возможность вызова у подклассов способов, которые не имеют смысла или вызывают ошибки, потому что эти способы неприменимы к подклассу. Кроме того, в некоторых языках разрешается только одиночное наследование (т.е. подкласс может наследоваться только от одного класса), что ещё больше ограничивает гибкость разработки программы.

По этим причинам в Rust применяется иной подход, с использованием типажей-объектов вместо наследования. Давайте посмотрим как типажи-объекты реализуют полиморфизм в Rust.
