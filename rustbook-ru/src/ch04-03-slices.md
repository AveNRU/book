## Вид срезы

*Срезы* позволяют ссылаться на непрерывную последовательность элементов в собрания, а не на всю собрание. Срез является своего рода ссылкой, поэтому он не имеет права владения.

Вот небольшая неполадка программирования: напишите функцию, которая принимает строку слов, разделённых пробелами, и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробела в строке, вся строка должна состоять из одного слова, поэтому должна быть возвращена вся строка.

Давайте рассмотрим, как бы мы написали ярлык этой функции без использования срезов, чтобы понять неполадку, которую решат срезы:

```rust,ignore
fn first_word(s: &String) -> ?
```

Функция `first_word` имеет `&String` в качестве свойства. Мы не хотим владения, так что всё в порядке. Но что мы должны вернуть? На самом деле у нас нет способа говорить о *части* строки. Однако мы могли бы вернуть порядковый указатель конца слова, обозначенного пробелом. Давайте попробуем, как показано в Приложении 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
```

<span class="caption">Приложение 4-7. Функция <code>first_word</code>, возвращающая значение порядкового указателя байта в свойство <code>String</code></span>

Поскольку нам нужно просмотреть `String` поэлементно и проверить, является ли значение пробелом, мы преобразуем нашу `String` в массив байтов с помощью способа `as_bytes`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}
```

Далее, мы создаём <em>повторитель </em> по массиву байт используя способ `iter`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}
```

Мы обсудим повторители более подробно в [Главе 13]<!-- ignore -->. На данный мгновение знайте, что `iter` — это способ, который возвращает каждый элемент в собрания, а `enumerate` оборачивает итог `iter` и вместо этого возвращает каждый элемент как часть упорядоченного ряда. Первый элемент упорядоченного ряда, возвращаемый из `enumerate`, является порядковым указателем, а второй элемент — ссылкой на элемент. Это немного удобнее, чем вычислять порядковый указатель самостоятельно.

Поскольку способ `enumerate` возвращает упорядоченный ряд, мы можем использовать образцы для разъединения этого упорядоченного ряда. Мы подробнее обсудим образцы в [Главе 6.]<!-- ignore -->. В круговороте `for` мы указываем образец, имеющий `i` для порядкового указателя в упорядоченном ряде и `&item` для одного байта в упорядоченном ряде. Поскольку мы получаем ссылку на элемент из `.iter().enumerate()`, мы используем `&` в образце.

Внутри круговорота `for` мы ищем байт, представляющий пробел, используя правила написания байтового записи. Если мы находим пробел, мы возвращаем положение. В противном случае мы возвращаем длину строки с помощью `s.len()`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}
```

Теперь у нас есть способ узнать порядковый указатель байта указывающего на конец первого слова в строке, но есть неполадка. Мы возвращаем сам `usize`, но это число имеет значение только в среде `&String`. Другими словами, поскольку это значение отдельное от `String`, то нет заверения, что оно все ещё будет действительным в будущем. Рассмотрим программу из приложения 4-8, которая использует функцию `first_word` приложения 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
```

<span class="caption">Приложение 4-8. Сохранение итога вызова функции <code>first_word</code> и последующего изменения содержимого <code>String</code></span>

Данная программа собирается без ошибок и будет успешно работать, даже после того как мы воспользуемся переменной `word` после вызова `s.clear()`. Так как значение `word` совсем не связано с состоянием переменной `s`, то `word` сохраняет своё значение `5` без изменений. Мы бы могли воспользоваться значением `5` чтобы получить первое слово из переменной `s`, но это приведёт к ошибке, потому что содержимое `s` изменилось после того как мы сохранили `5` в переменной `word` (стало пустой строкой в вызове `s.clear()`).

Необходимость беспокоиться о том, что порядковый указатель в переменной `word` не согласуется с данными в переменной  `s` является утомительной и подверженной ошибкам! Управление этими порядковыми указателями становится ещё более хрупким, если мы напишем функцию `second_word`. Её ярлык могла бы выглядеть так:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

Теперь мы отслеживаем начальный *и* конечный порядковый указатель, и у нас есть ещё больше значений, которые были рассчитаны на основе данных в определённом состоянии, но вообще не привязаны к этому состоянию. У нас есть три несвязанные переменные, которые необходимо согласовать.

К счастью в Ржавчине есть решение данной сбоев: строковые срезы.

### Строковые срезы

Строковый срез - это ссылка на часть строки `String` и он выглядит следующим образом:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
```

Вместо ссылки на всю `String` `hello` является ссылкой на часть `String`, указанную в дополнительном куске рукописи `[0..5]`. Мы создаём срезы, используя рядв квадратных скобках, указав `[starting_index..ending_index]`, где `starting_index` — это первая позиция, а`ending_index` конечный_порядковый указатель— это на единицу больше, чем последняя позиция в срезе. Внутри устройства данных среза хранит начальную положение и длину среза, что соответствует `ending_index` - `starting_index`. Итак, в случае `let world = &s[6..11];`, `world` будет срезом, содержащим указатель на байт с порядковым указателем 6 `s` со значением длины `5`.

Рисунок 4-6 отображает это на диаграмме.

 <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="">

<span class="caption">Рисунок 4-6: Строковый срез ссылается на часть <code>String</code></span>

С правилами написания Ржавчина `..`, если вы хотите начать с порядкового указателя 0, вы можете отбросить значение перед двумя точками. Другими словами, они равны:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

Таким же образом, если ваш срез включает последний байт `String`, вы можете отбросить конечный номер. Это означает, что они равны:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

Вы также можете отбросить оба значения, чтобы получить часть всей строки. Итак, они равны:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

<<<<<<< HEAD
>  Примечание. Порядковые указатели ряда срезов строк должны располагаться на допустимых границах знаков UTF-8. Если вы попытаетесь создать отрывок строки нарушая границы знака в котором больше одного байта, ваша программа завершится с ошибкой. В целях введения срезов строк мы предполагаем, что в этом разделе используется только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе [«Сохранение закодированного текста UTF-8 со строками»].<!-- ignore --> раздел главы 8.
=======
>  Примечание. Порядковые указатели ряда срезов строк должны располагаться на допустимых границах знаков UTF-8. Если вы попытаетесь создать отрывок строки нарушая границы знака в котором больше одного байта, ваша программа завершится с ошибкой. В целях введения срезов строк мы предполагаем, что в этом разделе используется только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе [«Сохранение закодированного писания UTF-8 со строками»].<!-- ignore --> раздел главы 8.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196
>

Давайте используем полученную сведения и перепишем способ `first_word` так, чтобы он возвращал срез. Для обозначения вида "срез строки" существует запись `&str`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
```

Мы получаем порядковый указатель конца слова так же, как в приложении 4.7, ища первое вхождение пробела. Когда мы находим пробел, мы возвращаем отрывок строки, используя начало строки и порядковый указатель пробела в качестве начального и конечного порядковых указателей.

Теперь, когда мы вызываем `first_word`, мы возвращаем одно значение, привязанное к основным данным. Значение состоит из ссылки на начальную точку среза и количества элементов в срезе.

Подобным образом можно переписать и второй способ `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

<<<<<<< HEAD
Теперь у нас есть простой API, который гораздо сложнее испортить, потому что сборщик заверяет, что ссылки в `String` останутся действительными. Помните ошибку в программе в приложении 4-8, когда мы получили порядковый указательдо конца первого слова, но затем очиисполнения строку, так что наш порядковый указательстал недействительным? Этот рукопись был разумно неправильным, но не показывал немедленных ошибок. Неполадки проявятся позже, если мы попытаемся использовать порядковый указательпервого слова с пустой строкой. Срезы делают эту ошибку невозможной и сообщают нам о неполадке с нашим рукописью гораздо раньше. Так, использование исполнения способа `first_word` со срезом вернёт ошибку сборки:
=======
Теперь у нас есть простой API, который гораздо сложнее испортить, потому что сборщик заверяет, что ссылки в `String` останутся действительными. Помните ошибку в программе в приложении 4-8, когда мы получили порядковый указатель до конца первого слова, но затем очистили строку, так что наш порядковый указатель стал недействительным? Эту рукопись был разумно неправильным, но не показывал немедленных ошибок. Неполадки проявятся позже, если мы попытаемся использовать порядковый указатель первого слова с пустой строкой. Срезы делают эту ошибку невозможной и сообщают нам о неполадке с нашим рукописью гораздо раньше. Так, использование исполнения способа `first_word` со срезом вернёт ошибку сборки:
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}
```

Ошибка сборки:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
```

Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на что-то, мы не можем также взять изменяемую ссылку. Поскольку для `clear` необходимо обрезать `String`, необходимо получить изменяемую ссылку. `println!` после вызова `clear` использует ссылку в `word`, поэтому неизменяемая ссылка в этот мгновение всё ещё должна быть действительной. Ржавчина запрещает одновременное существование изменяемой ссылки в виде`clear` и неизменяемой ссылки в `word`, и сборка завершается ошибкой. Ржавчина не только упростил использование нашего API, но и устранил целый класс ошибок во время сборки!

<!-- Old heading. Do not remove or links may break. -->

<a id="string-literals-are-slices"></a>

#### Строковые записи - это срезы

Напомним, что мы говорили о строковых записях, хранящихся внутри двоичного файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые записи:

```rust
let s = "Hello, world!";
```

Вид `s` здесь `&str`: это срез, указывающий на эту определенную точку двоичного файла. Вот почему строковые записи неизменяемы; `&str` — неизменяемая ссылка.

#### Строковые срезы как свойства

Знание того, что вы можете брать срезы записей и `String` значений, приводит нас к ещё одному улучшению `first_word`, и это его ярлык:

```rust,ignore
fn first_word(s: &String) -> &str {
```

Более опытный пользователь Rustacean вместо этого написал бы ярлык, показанную в приложении 4.9, потому что это позволяет нам использовать одну и ту же функцию как для значений `&String`, так и для значений `&str`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}
```

<span class="caption">Приложение 4-9: Улучшение функции <code>first_word</code> используя вид строкового среза для свойства <code>s</code></span>

Если у нас есть отрывок строки, мы можем передать его напрямую. Если у нас есть `String`, мы можем передать часть `String` или ссылку на `String`. Эта гибкость использует преимущества *приведения deref*, функции, которую мы рассмотрим в [разделе «Неявное приведение Deref с функциями и способами».]<!-- ignore --> раздел главы 15.

Определение функции для получения отрывка строки вместо ссылки на `String` делает наш API более общим и полезным без потери какой-либо возможности:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
```

### Другие срезы

Срезы строк, как вы можете себе представить, отличительны для строк. Но есть и более общий вид среза. Рассмотрим этот массив:

```rust
let a = [1, 2, 3, 4, 5];
```

Точно так же, как мы можем захотеть сослаться на часть строки, мы можем захотеть сослаться на часть массива. Мы бы сделали так:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

Этот срез имеет вид `&[i32]`. Он работает так же, как и срезы строк, сохраняя ссылку на первый элемент и его длину. Вы будете использовать этот вид отрывка для всех видов других собраний. Мы подробно обсудим эти собрания, когда будем говорить о векторах в главе 8.

## Итоги

Подходы владения, заимствования и срезов обеспечивают безопасность памяти в программах на Ржавчине во время сборки. Язык Ржавчина даёт вам управление над использованием памяти так же, как и другие языки системного программирования, но то, что владелец данных самостоятельно очищает эти данные, когда владелец выходит за рамки, означает, что вам не нужно писать и отлаживать дополнительный рукопись, чтобы получить этот управление.

Владение влияет на множество других частей и подходов языка Ржавчина. Мы будем говорить об этих подходах на протяжении оставшихся частей книги. Давайте перейдём к Главе 5 и рассмотрим объединение частей данных в устройства `struct`.


[Главе 13]: ch13-02-iterators.html
[Главе 6.]: ch06-02-match.html#patterns-that-bind-to-values
[«Сохранение закодированного писания UTF-8 со строками»]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[разделе «Неявное приведение Deref с функциями и способами».]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods