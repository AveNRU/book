## правила написания способа

*Способы* похожи на функции: мы объявляем их с помощью ключевого слова `fn` и имени, они могут иметь свойства и возвращаемое значение, и они содержат код, запускающийся в случае вызова способа. В отличие от функций, способы определяются в среде структуры (или предмета перечисления или типажа, которые мы рассмотрим в [главе 6)]<!-- ignore --> и [главе 17]<!-- ignore --> соответственно), а их первым свойствоом всегда является `self`, представляющий собой образец структуры, с которой вызывается этот способ.

### Определение способов

Давайте изменим функцию `area` так, чтобы она имела образец `Rectangle` в качестве входного свойства и сделаем её способом `area`, определённым для структуры `Rectangle`, как показано в приложении 5-13:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-13/src/main.rs}}
```

<span class="caption">Приложение 5-13: Определение способа <code>area</code> для структуры <code>Rectangle</code></span>

Чтобы определить функцию в среде `Rectangle`, мы создаём раздел`impl` (implementation - реализация) для `Rectangle`. Всё в `impl` будет связано с видом `Rectangle`. Затем мы перемещаем функцию `area` внутрь фигурных скобок `impl` и меняем первый (и в данном случае единственный) свойство на `self` в сигнатуре и в теле. В `main`, где мы вызвали функцию `area` и передали `rect1` в качестве переменной, теперь мы можем использовать *правила написания способа* для вызова способа `area` нашего образца `Rectangle`. правила написания способа идёт после образца: мы добавляем точку, за которой следует имя способа, круглые скобки и любые переменные.

В сигнатуре `area` мы используем `&self` вместо `rectangle: &Rectangle`. `&self` на самом деле является сокращением от `self: &Self`. Внутри раздела `impl` вид `Self` является псевдонимом вида, для которого реализован раздел`impl`. Способы обязаны иметь свойство с именем `self` вида `Self`, поэтому Rust позволяет вам сокращать его, используя только имя `self` на месте первого свойства. Обратите внимание, что нам по-прежнему нужно использовать `&` перед сокращением `self`, чтобы указать на то, что этот способ заимствует образец `Self`, точно так же, как мы делали это в `rectangle: &Rectangle`. Как и любой другой свойство, способы могут брать во владение `self`, заимствовать неизменяемый `self`, как мы поступили в данном случае, или заимствовать изменяемый `self`.

Мы выбрали `&self` здесь по той же причине, по которой использовали `&Rectangle` в исполнения кода с функцией: мы не хотим брать структуру во владение, мы просто хотим прочитать данные в структуре, а не писать в неё. Если бы мы хотели изменить образец, на котором мы вызывали способ силами самого способа, то мы бы использовали `&mut self` в качестве первого свойства. Наличие способа, который берёт образец во владение, используя только `self` в качестве первого свойства, является редким; эта техника обычно используется, когда способ превращает `self` во что-то ещё, и вы хотите запретить вызывающей стороне использовать исходный образец после превращения.

Основная причина использования способов вместо функций, помимо правил написания способа, где нет необходимости повторять вид `self` в сигнатуре каждого способа, заключается в организации кода. Мы помеисполнения все, что мы можем сделать с образцом вида, в один `impl` вместо того, чтобы заставлять будущих пользователей нашего кода искать доступный функционал `Rectangle` в разных местах предоставляемой нами библиотеки.

Обратите внимание, что мы можем дать способу то же имя, что и одному из полей структуры. Например, для `Rectangle` мы можем определить способ, также названный `width`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-06-method-field-interaction/src/main.rs:here}}
```

Здесь мы определили, чтобы способ `width` возвращал значение `true`, если значение в поле `width` образца больше `0`, и значение `false`, если значение равно `0`, но мы можем использовать поле в способе с тем же именем для любых целей. В `main`, когда мы ставим после `rect1.width` круглые скобки, Rust знает, что мы имеем в виду способ `width`. Когда мы не используем круглые скобки, Rust понимает, что мы имеем в виду поле `width`.

Часто, но не всегда, когда мы создаём способы с тем же именем, что и у поля, мы хотим, чтобы он только возвращал значение одноимённого поля и больше ничего не делал. Подобные способы называются *геттерами*, и Rust не реализует их самостоятельно для полей структуры, как это делают некоторые другие языки. Геттеры полезны, поскольку вы можете сделать поле приватным, а способ публичным и, таким образом, включить доступ только для чтения к этому полю как часть общедоступного API вида. Мы обсудим, что такое публичность и приватность, и как обозначить поле или способ в качестве публичного или приватного в [главе 7]<!-- ignore -->.

> ### Где используется оператор `->`?
>
> В языках C и C++, используются два различных оператора для вызова способов: используется `.`, если вызывается способ непосредственно у образца структуры и используется `->`, если вызывается способ для указателя на предмет. Другими словами, если `object` является указателем, то вызовы способа `object->something()` и ` (*object).something()` являются подобными.
>
> Rust не имеет эквивалента оператора `->`, наоборот, в Rust есть функциональность называемая *самостоятельное обращение по ссылке и разыменование* (automatic referencing and dereferencing). Вызов способов является одним из немногих мест в Rust, в котором есть такое поведение.
>
> Вот как это работает: когда вы вызываете способ `object.something()`, Rust самостоятельно добавляет `&`, `&mut` или  `*`, таким образом, чтобы `object` соответствовал сигнатуре способа. Другими словами, это то же самое:
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> Первый пример выглядит намного понятнее. Самостоятельный вывод ссылки работает потому, что способы имеют понятного получателя - вид `self`. Учитывая получателя и имя способа, Rust может точно определить, что в данном случае делает код: читает ли способ (`&self`), делает ли изменение (`&mut self`) или поглощает (`self`). Тотобстоятельство, что Rust делает заимствование неявным для принимающего способа, в значительной степени способствует тому, чтобы сделать владение эргономичным на опыте.

### Способы с несколькими свойствами

Давайте применим в использовании способов, реализовав второй способ в структуре `Rectangle`. На этот раз мы хотим, чтобы образец `Rectangle` брал другой образец `Rectangle` и возвращал `true`, если второй `Rectangle` может полностью поместиться внутри `self` (первый `Rectangle`); в противном случае он должен вернуть `false`. То есть, как только мы определим способ `can_hold`, мы хотим иметь возможность написать программу, показанную в Приложении 5-14.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-14/src/main.rs}}
```

<span class="caption">Приложение 5-14: Использование ещё не написанного способа <code>can_hold</code></span>

Ожидаемый итог будет выглядеть следующим образом, т.к. оба размера в образце `rect2` меньше, чем размеры в образце `rect1`, а `rect3` шире, чем `rect1`:

```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

Мы знаем, что хотим определить способ, поэтому он будет находится в `impl Rectangle` разделе. Имя способа будет `can_hold`, и оно будет принимать неизменяемое заимствование на другой `Rectangle` в качестве свойства. Мы можем сказать, какой это будет вид свойства, посмотрев на код вызывающего способа: способ `rect1.can_hold(&rect2)` передаёт в него  `&rect2` , который является неизменяемым заимствованием образца `rect2` вида `Rectangle`. В этом есть смысл, потому что нам нужно только читать `rect2` (а не писать, что означало бы, что нужно изменяемое заимствование), и мы хотим, чтобы `main` сохранил право собственности на образец `rect2`, чтобы мы могли использовать его снова после вызов способа `can_hold`. Возвращаемое значение `can_hold` имеет булевый вид, а реализация проверяет, являются ли ширина и высота `self` больше, чем ширина и высота другого `Rectangle` соответственно. Давайте добавим новый способ `can_hold` в `impl` разделиз приложения 5-13, как показано в приложении 5-15.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-15/src/main.rs:here}}
```

<span class="caption">Приложение 5-15: Реализация способа <code>can_hold</code> для <code>Rectangle</code>, принимающего другой образец <code>Rectangle</code> в качестве свойства</span>

Когда мы запустим код с функцией `main` приложения 5-14, мы получим желаемый вывод. Способы могут принимать несколько свойств, которые мы добавляем в сигнатуру после первого  свойства `self`, и эти свойства работают так же, как свойства в функциях.

### Ассопряженные функции

Все функции, определённые в разделе `impl`, называются *ассопряженными функциями*, потому что они ассопряжены с видом, указанным после ключевого слова `impl`. Мы можем определить ассопряженные функции, которые не имеют `self` в качестве первого свойства (и, следовательно, не являются способами), потому что им не нужен образец вида для работы. Мы уже использовали одну подобную функцию: функцию `String::from`, определённую для вида `String`.

Ассопряженные функции, не являющиеся способами, часто используются для конструкторов, возвращающих новый образец структуры. Их часто называют `new`, но `new` не является особым именем и не встроена в язык. Например, мы можем предоставить ассопряженную функцию с именем `square`, которая будет иметь один свойство размера и использовать его как ширину и высоту, что упростит создание квадратного `Rectangle`, вместо того, чтобы указывать одно и то же значение дважды:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-03-associated-functions/src/main.rs:here}}
```

Ключевые слова `Self` в возвращаемом виде и в теле функции являются псевдонимами для вида, указанного после ключевого слова `impl`, которым в данном случае является `Rectangle`.

Чтобы вызвать эту связанную функцию, используется правила написания `::` с именем структуры; например `let sq = Rectangle::square(3);`. Эта функция находится в пространстве имён структуры. правила написания `::` используется как для связанных функций, так и для пространств имён, созданных модулями. Мы обсудим модули в [главе 7]<!-- ignore -->.

### Несколько разделов `impl`

Каждая структура может иметь несколько `impl`. Например, Приложение 5-15 эквивалентен коду, показанному в приложении 5-16, в котором каждый способ находится в своём собственном разделе `impl`.

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-16/src/main.rs:here}}
```

<span class="caption">Приложение 5-16: Переписанный Приложения 5-15 с использованием нескольких <code>impl</code></span>

Здесь нет причин разделять способы на несколько `impl`, но это допустимый правила написания. Мы увидим случай, когда несколько `impl` могут оказаться полезными, в Главе 10, рассматривающей обобщённые виды и свойства.

## Итоги

Структуры позволяют создавать собственные виды, которые имеют смысл в вашей предметной области. Используя структуры, вы храните ассопряженные друг с другом фрагменты данных и даёте название частям данных, чтобы ваш код был более понятным. Способы позволяют определить поведение, которое имеют образцы ваших структур, а ассопряженные функции позволяют привязать функциональность к вашей структуре, не обращаясь к её образцу.

Но структуры — не единственный способ создавать собственные виды: давайте обратимся к перечислениям в Rust, чтобы добавить ещё один средство в свой арсенал.


[главе 6)]: ch06-00-enums.html
[главе 17]: ch17-02-trait-objects.md
[главе 7]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
[главе 7]: ch07-02-defining-modules-to-control-scope-and-privacy.html
