# Проект с вводом/выводом (I/O): создание окно выводаного приложения

В этой главе вы примените многие знания, полученные ранее, а также познакомитесь с ещё неизученными API встроенной библиотеки. Мы создадим окно выводаное приложение, которое будет взаимодействовать с файлом и с окно выводаным вводом / выводом, чтобы попрактиковаться в некоторых концепциях Rust, с которыми вы уже знакомы.

Скорость, безопасность, сборка в один исполняемый файл и кроссплатформенность делают Rust наилучшим языком для создания окно выводаных средств, так что в нашем проекте мы создадим свою собственную исполнение классической утилиты поиска `grep`, что расшифровывается, как "вездесущеее средство поиска и печати" (**g**lobally search a **r**egular **e**xpression and **p**rint). В простейшем случае `grep` используется для поиска в выбранном файле указанного текста. Для этого утилита `grep` получает имя файла и текст в качестве переменных. Далее она читает файл, находит и выводит строки, содержащие искомый текст.

Попутно мы покажем, как сделать так, чтобы наше окно выводаное приложение использовало возможности окна вызова, которые используются многими другими окно выводаными средствами. Мы будем читать значение переменной окружения, чтобы позволить пользователю настроить поведение нашего средства. Мы также будем печатать сообщения об ошибках в стандартный окно выводаный поток ошибок ( `stderr` ) вместо принятого вывода ( `stdout` ), чтобы, к примеру, пользователь мог перенаправить успешный вывод в файл, в то время, как сообщения об ошибках останутся на экране.

Один из участников Rust-сообщества, Andrew Gallant, уже реализовал полнофункциональный, очень быстрый подобие программы `grep` и назвал его `ripgrep`. По сравнению с ним, наша исполнение будет довольно простой, но эта глава даст вам знания, которые нужны для понимания существующих проектов, таких как <code>ripgrep</code>.

Наш проект `grep` будет использовать ранее изученные концепции:

- Организация кода (используя то, что вы узнали о модулях в [ главе 7]<!--  -->)
- Использование векторов и строк (собрания, [глава 8]<!--  -->)
- Обработка ошибок ([Глава 9]<!--  -->)
- Использование типажей и времени жизни там, где это необходимо ([глава 10]<!--  -->)
- Написание тестов ( [Глава 11]<!--  -->)

Мы также кратко представим замыкания, повторители и объекты типажи, которые будут объяснены подробно в главах [13]<!--  --> и [17]<!--  -->.


[ главе 7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[глава 8]: ch08-00-common-collections.html
[Глава 9]: ch09-00-error-handling.html
[глава 10]: ch10-00-generics.html
[Глава 11]: ch11-00-testing.html
[13]: ch13-00-functional-features.html
[17]: ch17-00-oop.html