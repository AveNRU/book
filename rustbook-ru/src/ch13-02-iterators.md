## Обработка последовательности элементов с помощью повторителей

Использование паттерна Повторитель помогает при необходимости поочерёдного выполнения какой-либо действия над элементами последовательности. Повторитель отвечает за логику перебора элементов и определение особенности завершения последовательности. Используя повторители, вам не нужно самостоятельно реализовывать всю эту логику.

В Rust повторители *ленивые (lazy)*, то есть они не делают ничего, пока вы не вызовете особые способы, потребляющие повторитель, чтобы задействовать его. Например, код в приложении 13-10 создаёт повторительэлементов вектора `v1`, вызывая способ `iter`, определённый у `Vec<T>`. Сам по себе этот код не делает ничего полезного.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

<span class="caption">Приложение 13-10: Создание повторителя</span>

Повторитель хранится в переменной `v1_iter`. Создав повторитель, мы можем использовать его различными способами. В приложении 3-5 главы 3 мы совершали обход элементов массива используя цикл `for` для выполнения какого-то кода над каждым из его элементов. Под капотом это неявно создавало, а затем потребляло повторитель, но до сих пор мы не касались того, как именно это работает.

В примере из приложения 13-11 мы отделили создание повторителя от его использования в цикле for. В цикле for, использующем повторительв v1_iter, каждый элемент повторителя участвует только в одной повторения цикла, в ходе которой выводится на экран его значение.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

<span class="caption">Приложение 13-11: Использование повторителя в цикле <code>for</code></span>

В языках, стандартные библиотеки которых не предоставляют повторители, вы, скорее всего, напишите эту же функциональность так: создадите переменную со значением 0 затем, в цикле, использовав её для получения элемента вектора по порядковому указателю, будете увеличивать её значение, и так, пока оно не достигнет числа равного количеству элементов в векторе.

Повторители выполняют всю эту логику за вас, сокращая количество повторяющегося кода, который возможно может быть написан неправильно. Повторители дают вам гибкость, позволяя использовать одинаковые принципы работы с различными видами последовательностей, а не только со структурами данных, которые можно упорядочивать, например, векторами. Давайте рассмотрим, как повторители это делают.

### Типаж `Iterator` и способ `next`

Все повторители реализуют типаж `Iterator`, который определён в встроенной библиотеке. Его определение выглядит так:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

Обратите внимание данное объявление использует новый правила написания: `type Item` и `Self::Item`, которые определяют *ассопряженный вид* (associated type) с этим типажом. Мы подробнее поговорим о ассопряженных видах в главе 19. Сейчас вам нужно знать, что этот код требует от реализаций типажа `Iterator` определить требуемый им вид `Item` и данный вид `Item` используется в способе `next`. Другими словами, вид `Item` будет являться видом элемента, который возвращает повторитель.

Типаж `Iterator` требует, чтобы разработчики определяли только один способ: способ `next`, который возвращает один элемент повторителя за раз обёрнутый в вариант `Some` и когда повторение завершена, возвращает `None`.

Мы можем вызывать способ `next` у повторителей напрямую; в приложении 13-12 показано, какие значения возвращаются при повторных вызовах `next` у повторителя, созданного из вектора.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}
```

<span class="caption">Приложение 13-12: Вызов способа <code>next</code> повторителя</span>

Обратите внимание, что нам нужно сделать переменную `v1_iter` изменяемой: вызов способа `next` повторителя изменяет внутреннее состояние повторителя, которое повторительиспользует для отслеживания того, где он находится в последовательности. Другими словами, этот код *потребляет* (consume) или использует повторитель. Каждый вызов `next` потребляет элемент из повторителя. Нам не нужно было делать изменяемой `v1_iter` при использовании цикла `for`, потому что цикл забрал во владение `v1_iter` и сделал её изменяемой неявно для нас.

Заметьте также, что значения, которые мы получаем при вызовах `next` являются неизменяемыми ссылками на значения в векторе. Способ `iter` создаёт повторительпо неизменяемым ссылкам. Если мы хотим создать повторитель, который становится владельцем `v1` и возвращает принадлежащие ему значения, мы можем вызвать `into_iter` вместо `iter`. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать `iter_mut` вместо `iter`.

### Способы, которые потребляют повторитель

У типажа `Iterator` есть несколько способов, реализация которых по умолчанию предоставляется встроенной библиотекой; вы можете узнать об этих способах, просмотрев документацию API встроенной библиотеки для `Iterator`. Некоторые из этих способов вызывают `next` в своём определении, поэтому вам необходимо реализовать способ `next` при реализации типажа `Iterator`.

Способы, вызывающие `next`, называются *потребляющими адаптерами*, поскольку их вызов потребляет повторитель. Примером может служить способ `sum`, который забирает во владение повторительи перебирает элементы, многократно вызывая `next`, тем самым потребляя повторитель. В процессе повторения он добавляет каждый элемент к текущей сумме и возвращает итоговое значение по завершении повторения. В приложении 13-13 приведён проверка, отображающий использование способа `sum`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}
```

<span class="caption">Приложение 13-13: Вызов способа <code>sum</code> для получения суммы всех элементов в повторителе</span>

Мы не можем использовать `v1_iter` после вызова способа `sum`, потому что `sum` забирает во владение повторительу которого вызван способ.

### Способы, которые создают другие повторители

*Адаптеры повторителей* - это способы, определённые для трейта `Iterator`, которые не потребляют повторитель. Вместо этого они создают различные повторители, изменяя некоторые особенности исходного повторителя.

В приложении 13-14 показан пример вызова способа адаптера повторителя `map`, который принимает замыкание и вызывает его для каждого элемента по мере повторения элементов. Способ `map` возвращает новый повторитель, который создаёт изменённые элементы. Замыкание здесь создаёт новый повторитель, в котором каждый элемент из вектора будет увеличен на 1:

<span class="filename">Файл: src/main.rs</span>

```rust,not_desired_behavior
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
```

<span class="caption">Приложение 13-14: Вызов адаптера повторителя <code>map</code> для создания нового повторителя</span>

Однако этот код выдаёт предупреждение:

```console
{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
```

Код в приложении 13-14 ничего не делает; указанное нами замыкание никогда не вызывается. Предупреждение напоминает нам, почему: адаптеры повторителей ленивы, и здесь нам нужно потребить повторитель.

Чтобы устранить это предупреждение и потребить повторитель, мы воспользуемся способом `collect`, который мы использовали в главе 12 с `env::args` в приложении 12-1. Этот способ потребляет повторительи собирает полученные значения в собрание указанного вида.

В приложении 13-15 мы собираем в вектор итоги перебора повторителя, который возвращается в итоге вызова `map`. Этот вектор в итоге будет содержать каждый элемент исходного вектора, увеличенный на 1.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
```

<span class="caption">Приложение 13-15: Вызов способа <code>map</code> для создания нового повторителя, а затем вызов способа <code>collect</code> для потребления нового повторителя и создания вектора</span>

Поскольку `map` принимает замыкание, мы можем указать любую действие, которую хотим выполнить над каждым элементом. Это отличный пример того, как замыкания позволяют задавать желаемое поведение, используя при этом особенности повторения, которые обеспечивает трейт `Iterator`.

Вы можете выстроить цепочку из нескольких вызовов адаптеров повторителя для выполнения сложных действий в удобочитаемом виде. Но поскольку все повторители являются "ленивыми", для получения итогов вызовов адаптеров повторителя необходимо вызвать один из способов потребляющего адаптера.

### Использование замыканий, которые захватывают переменные окружения

Многие адаптеры повторителей принимают замыкания в качестве переменных, и обычно замыкания, которые мы будем указывать в качестве переменных адаптерам повторителей, это замыкания, которые определяют (захватывают) своё окружение.

В этом примере мы будем использовать способ `filter`, который принимает замыкание. Замыкание получает элемент из повторителя и возвращает `bool`. Если замыкание возвращает `true`, значение будет включено в повторение, создаваемую `filter`. Если замыкание возвращает `false`, значение не будет включено.

В приложении 13-16 мы используем `filter` с замыканием, которое захватывает переменную `shoe_size` из своего окружения для повторения по собрания образцов структуры `Shoe`. Он будет возвращать обувь только указанного размера.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}
```

<span class="caption">Приложение 13-16. Использование способа <code>filter</code> с замыканием, определяющим <code>shoe_size</code></span>

Функция `shoes_in_size` принимает в качестве свойств вектор с образцами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера.

В теле `shoes_in_my_size` мы вызываем `into_iter` чтобы создать повторитель, который становится владельцем вектора. Затем мы вызываем `filter`, чтобы превратить этот повторительв другой, который содержит только элементы, для которых замыкание возвращает `true`.

Замыкание захватывает свойство `shoe_size` из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов `collect` собирает значения, возвращаемые адаптированным повторителем, в вектор, возвращаемый функцией.

Проверка показывает, что когда мы вызываем `shoes_in_my_size`, мы возвращаем только туфли, размер которых совпадает с указанным нами значением.
