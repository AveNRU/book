# Обобщённые виды, особенности и время жизни

Каждый язык программирования имеет в своём арсенале производительные средства борьбы с повторением рукописи. В Ржавчине одним из таких средств являются обобщённые виды данных - *generics*. Это абстрактные подставные виды на место которых возможно поставить какой-либо определенный вид или другое свойство. Когда мы пишем рукопись, мы можем выразить поведение обобщённых видов или их связь с другими обобщёнными видами, не зная какой вид будет использован на их месте при сборки и запуске рукописи.

Функции могут принимать свойства некоторого "обобщённого" вида вместо привычных "определенных" видов, вроде `i32` или `String`. Подобно, функция принимает свойства с неизвестными заранее значениями, чтобы выполнять одинаковые действия над несколькими определенными значениями. На самом деле мы уже использовали обобщённые виды данных в Главе 6 (`Option<T>`), в Главе 8 (`Vec<T>` и `HashMap<K, V>`) и в Главе 9 (`Result<T, E>`). В этой главе вы узнаете, как определить собственные виды данных, функции и способы, используя возможности обобщённых видов.

Прежде всего, мы рассмотрим как для уменьшения повторения извлечь из рукописи некоторую общую возможность. Далее, мы будем использовать тот же рычаг для создания обобщённой функции из двух функций, которые отличаются только видом их свойств. Мы также объясним, как использовать обобщённые виды данных при определении устройств и перечислений.

После этого мы изучим как использовать особенности (traits) для определения поведения в обобщённом виде. Можно соединенять особенности с обобщёнными видами, чтобы обобщённый вид мог принимать только такие виды, которые имеют определённое поведение, а не все подряд.

В конце мы обсудим *времена жизни (lifetimes)*, вариации обобщённых видов, которые дают сборщику сведения о том, как сроки жизни ссылок относятся друг к другу. Времена жизни позволяют нам указать дополнительную сведения об "одолженных" (borrowed) значениях, которая позволит сборщику удостовериться в соблюдения правил используемых ссылок в тех случаях, когда сборщик не может сделать это самостоятельно .

## Удаление повторения рукописи с помощью выделения общей возможности

В обобщениях мы можем заменить определенный вид на "заполнитель" (placeholder), обозначающую несколько видов, что позволяет удалить повторяющийся рукопись. Прежде чем углубляться в правила написания обобщённых видов, давайте сначала посмотрим, как удалить повторение, не задействуя гибкие виды, путём извлечения функции, которая заменяет определённые значения заполнителем, представляющим несколько значений. Затем мы применим ту же технику для извлечения гибкой функции! Изучив, как распознать повторяющийся рукопись, который можно извлечь в функцию, вы начнёте распознавать повторяющийся рукопись, который может использовать обобщённые виды.

Начнём с короткой программы в приложении 10-1, которая находит наибольшее число в списке.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}
```

<span class="caption">Приложение 10-1: Поиск наибольшего числа в списке чисел</span>

Сохраним список целых чисел в переменной `number_list` и поместим первое значение из списка в переменную `largest`. Далее, переберём все элементы списка, и, если текущий элемент больше числа сохранённого в переменной `largest`, заменим значение в этой переменной. Если текущий элемент меньше или равен "наибольшему", найденному ранее, значение переменной оставим прежним и перейдём к следующему элементу списка. После перебора всех элементов списка переменная `largest` должна содержать наибольшее значение, которое в нашем случае будет равно 100.

Теперь перед нами стоит задача найти наибольшее число в двух разных списках. Для этого мы можем повторять рукопись из приложения 10-1 и использовать ту же ход мыслей в двух разных местах программы, как показано в приложении 10-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}
```

<span class="caption">Приложение 10-2: Рукопись для поиска наибольшего числа в <em>двух</em> списках чисел</span>

Несмотря на то, что рукопись программы работает, повторение рукописи утомительно и подвержено ошибкам. При внесении изменений мы должны не забыть обновить каждое место, где рукопись повторяется.

<<<<<<< HEAD
Для устранения повторения мы можем создать дополнительную абстракцию с помощью функции которая сможет работать с любым списком целых чисел переданным ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает рукопись более ясным и позволяет абстрактным образом выполнить алгоритм поиска наибольшего числа в списке.
=======
Для устранения повторения мы можем создать дополнительную абстракцию с помощью функции которая сможет работать с любым списком целых чисел переданным ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает рукопись более ясным и позволяет абстрактным образом выполнить распорядок поиска наибольшего числа в списке.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196

В приложении 10-3 мы извлекаем рукопись, который находит наибольшее число, в функцию с именем  `largest`. Затем мы вызываем функцию, чтобы найти наибольшее число в двух списках из приложения 10-2. Мы также можем использовать эту функцию для любого другого списка значений `i32` , который может встретиться позже.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}
```

<span class="caption">Приложение 10-3: Абстрактный рукопись для поиска наибольшего числа в двух списках</span>

Функция `largest` имеет свойство с именем `list`, который представляет любой срез значений вида `i32`, которые мы можем передать в неё. В итоге вызова функции, рукопись выполнится с определенными, переданными в неё значениями.

Итак, вот шаги выполненные для изменения рукописи из приложения 10-2 в приложение 10-3:

1. Определить повторяющийся рукопись.
<<<<<<< HEAD
2. Извлечь повторяющийся рукопись и поместить его в тело функции, определив входные и выходные значения этого рукописи в ярлыке функции.
=======
2. Извлечь повторяющийся рукопись и поместить его в тело функции, определив входные и выходные значения этой рукописи в ярлыке функции.
>>>>>>> 8026f7cc37a623b7a0968ae296cbb5f4118ea196
3. Обновить и заменить два участка повторяющегося рукописи вызовом одной функции.

Далее, чтобы уменьшить повторение рукописи, мы воспользуемся теми же шагами для обобщённых видов. Обобщённые виды позволяют работать над абстрактными видами таким же образом, как тело функции может работать над абстрактным списком `list` вместо определенных значений.

Например, у нас есть две функции: одна ищет наибольший элемент внутри среза значений вида `i32`, а другая внутри среза значений вида `char`. Как уменьшить такое повторение? Давайте выяснять!


