# Обобщённые виды, особенности и время жизни

Каждый язык программирования имеет в своём арсенале эффективные средства борьбы с повторением кода. В Ржавчина одним из таких средств являются обобщённые виды данных - *generics*. Это абстрактные подставные виды на место которых возможно поставить какой-либо определенный вид или другое свойство. Когда мы пишем код, мы можем выразить поведение обобщённых видов или их связь с другими обобщёнными видами, не зная какой вид будет использован на их месте при сборки и запуске кода.

Функции могут принимать свойства некоторого "обобщённого" вида вместо привычных "определенных" видов, вроде `i32` или `String`. Подобно, функция принимает свойства с неизвестными заранее значениями, чтобы выполнять одинаковые действия над несколькими определенными значениями. На самом деле мы уже использовали обобщённые виды данных в Главе 6 (`Option<T>`), в Главе 8 (`Vec<T>` и `HashMap<K, V>`) и в Главе 9 (`Result<T, E>`). В этой главе вы узнаете, как определить собственные виды данных, функции и способы, используя возможности обобщённых видов.

Прежде всего, мы рассмотрим как для уменьшения повторения извлечь из кода некоторую общую возможность. Далее, мы будем использовать тот же рычаг для создания обобщённой функции из двух функций, которые отличаются только видом их свойств. Мы также объясним, как использовать обобщённые виды данных при определении устройств и перечислений.

После этого мы изучим как использовать особенности (traits) для определения поведения в обобщённом виде. Можно соединенять особенности с обобщёнными видами, чтобы обобщённый вид мог принимать только такие виды, которые имеют определённое поведение, а не все подряд.

В конце мы обсудим *времена жизни (lifetimes)*, вариации обобщённых видов, которые дают сборщику сведения о том, как сроки жизни ссылок относятся друг к другу. Времена жизни позволяют нам указать дополнительную сведения об "одолженных" (borrowed) значениях, которая позволит сборщику удостовериться в соблюдения правил используемых ссылок в тех случаейх, когда сборщик не может сделать это самостоятельно .

## Удаление повторения кода с помощью выделения общей возможности

В обобщениях мы можем заменить определенный вид на "заполнитель" (placeholder), обозначающую несколько видов, что позволяет удалить повторяющийся код. Прежде чем углубляться в правила написания обобщённых видов, давайте сначала посмотрим, как удалить повторение, не задействуя гибкие виды, путём извлечения функции, которая заменяет определённые значения заполнителем, представляющим несколько значений. Затем мы применим ту же технику для извлечения гибкой функции! Изучив, как распознать повторяющийся код, который можно извлечь в функцию, вы начнёте распознавать повторяющийся код, который может использовать обобщённые виды.

Начнём с короткой программы в приложении 10-1, которая находит наибольшее число в списке.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}
```

<span class="caption">Приложение 10-1: Поиск наибольшего числа в списке чисел</span>

Сохраним список целых чисел в переменной `number_list` и поместим первое значение из списка в переменную `largest`. Далее, переберём все элементы списка, и, если текущий элемент больше числа сохранённого в переменной `largest`, заменим значение в этой переменной. Если текущий элемент меньше или равен "наибольшему", найденному ранее, значение переменной оставим прежним и перейдём к следующему элементу списка. После перебора всех элементов списка переменная `largest` должна содержать наибольшее значение, которое в нашем случае будет равно 100.

Теперь перед нами стоит задача найти наибольшее число в двух разных списках. Для этого мы можем повторять код из приложения 10-1 и использовать ту же логику в двух разных местах программы, как показано в приложении 10-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}
```

<span class="caption">Приложение 10-2: Код для поиска наибольшего числа в <em>двух</em> списках чисел</span>

Несмотря на то, что код программы работает, повторение кода утомительно и подвержено ошибкам. При внесении изменений мы должны не забыть обновить каждое место, где код повторяется.

Для устранения повторения мы можем создать дополнительную абстракцию с помощью функции которая сможет работать с любым списком целых чисел переданным ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает код более ясным и позволяет абстрактным образом выполнить алгоритм поиска наибольшего числа в списке.

В приложении 10-3 мы извлекаем код, который находит наибольшее число, в функцию с именем  `largest`. Затем мы вызываем функцию, чтобы найти наибольшее число в двух списках из приложения 10-2. Мы также можем использовать эту функцию для любого другого списка значений `i32` , который может встретиться позже.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}
```

<span class="caption">Приложение 10-3: Абстрактный код для поиска наибольшего числа в двух списках</span>

Функция `largest` имеет свойство с именем `list`, который представляет любой срез значений вида `i32`, которые мы можем передать в неё. В итоге вызова функции, код выполнится с определенными, переданными в неё значениями.

Итак, вот шаги выполненные для изменения кода из приложения 10-2 в приложение 10-3:

1. Определить повторяющийся код.
2. Извлечь повторяющийся код и поместить его в тело функции, определив входные и выходные значения этого кода в ярлыке функции.
3. Обновить и заменить два участка повторяющегося кода вызовом одной функции.

Далее, чтобы уменьшить повторение кода, мы воспользуемся теми же шагами для обобщённых видов. Обобщённые виды позволяют работать над абстрактными видами таким же образом, как тело функции может работать над абстрактным списком `list` вместо определенных значений.

Например, у нас есть две функции: одна ищет наибольший элемент внутри среза значений вида `i32`, а другая внутри среза значений вида `char`. Как уменьшить такое повторение? Давайте выяснять!


