## Расширенная многопоточность с помощью типажей `Sync` и `Send`

Важно, что сам язык Rust имеет *очень* мало возможностей для многопоточности. Почти все функции многопоточности о которых мы говорили в этой главе, были частью встроенной библиотеки, а не языка. Ваши варианты работы с многопоточностью не ограничиваются языком или встроенной библиотекой; Вы можете написать свой собственный многопоточный функционал или использовать возможности написанные другими.

Тем не менее, в язык встроены две концепции многопоточности: `std::marker` типажи `Sync` и `Send`.

### Разрешение передачи во владение между потоками с помощью `Send`

Маркерный типаж `Send` указывает, что владение видом реализующим `Send`, может передаваться между потоками. Почти каждый вид Rust является видом `Send`, но есть некоторые исключения, вроде `Rc<T>`: он не может быть `Send`, потому что если вы клонировали значение `Rc<T>` и попытались передать владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно. По этой причине `Rc<T>` реализован для использования в однопоточных ситуациях, когда вы не хотите платить за снижение производительности.

Следовательно, система видов Rust и ограничений типажа заверяют, что вы никогда не сможете случайно небезопасно отправлять значение `Rc<T>` между потоками. Когда мы попытались сделать это в приложении 16-14, мы получили ошибку, `the trait Send is not implemented for Rc<Mutex<i32>>`. Когда мы переключились на `Arc<T>`, который является видом `Send`, то код собрался.

Любой вид полностью состоящий из видов `Send` самостоятельно помечается как `Send`. Почти все примитивные виды являются `Send`, кроме сырых указателей, которые мы обсудим в главе 19.

### Разрешение доступа из нескольких потоков с `Sync`

Маркерный типаж `Sync` указывает, что на вид реализующий `Sync` можно безопасно ссылаться из нескольких потоков. Другими словами, любой вид `T` является видом `Sync`, если `&T` (ссылка на `T` ) является видом `Send`, что означает что ссылку можно безопасно отправить в другой поток. Подобно `Send`, примитивные виды являются видом `Sync`, а виды полностью скомбинированные из видов `Sync`, также являются `Sync` видом.

Умный указатель `Rc<T>` не является `Sync` видом по тем же причинам, по которым он не является `Send`. Вид `RefCell<T>` (о котором мы говорили в главе 15) и семейство связанных видов `Cell<T>` не являются `Sync`. Реализация проверки заимствования, которую делает вид `RefCell<T>` во время выполнения программы не является поточно-безопасной. Умный указатель `Mutex<T>` является видом `Sync` и может использоваться для совместного доступа из нескольких потоков, как вы уже видели в разделе <a data-md-type="raw_html" href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">«Совместное использование `Mutex<T>` между несколькими потоками»</a> <!-- ignore -->.

### Реализация `Send` и `Sync` вручную небезопасна

Поскольку виды созданные из типажей `Send` и `Sync` самостоятельно также являются видами `Send` и `Sync`, мы не должны реализовывать эти типажи вручную. Являясь маркерными типажами у них нет никаких способов для реализации. Они просто полезны для реализации инвариантов, связанных с многопоточностью.

Ручная реализация этих типажей включает в себя реализацию небезопасного кода Rust. Мы поговорим об использовании небезопасного кода Rust в главе 19; на данный момент важная сведения заключается в том, что для создания новых многопоточных видов, не состоящих из частей `Send` и `Sync` необходимо тщательно продумать заверения безопасности. В [Rustonomicon] есть больше сведений об этих заверениях и о том как их соблюдать.

## Итоги

Это не последний случай, когда вы увидите многопоточность в этой книге: проект в главе 20 будет использовать концепции этой главы для более реалистичного случая, чем небольшие примеры обсуждаемые здесь.

Как упоминалось ранее, поскольку в языке Rust очень мало того, с помощью чего можно управлять многопоточностью, многие решения  реализованы в виде крейтов. Они развиваются быстрее, чем стандартная библиотека, поэтому обязательно поищите в Интернете текущие современные крейты.

Стандартная библиотека Rust предоставляет потоки для передачи сообщений и виды умных указателей, такие как `Mutex<T>` и `Arc<T>`, которые можно безопасно использовать в многопоточных средах. Система видов и анализатор заимствований заверяют, что код использующий эти решения не будет содержать гонки данных или недействительные ссылки. Получив компилирующийся код, вы можете быть уверены, что он будет успешно работать в нескольких потоках без ошибок, которые трудно обнаружить в других языках. Многопоточное программирование больше не является концепцией, которую стоит опасаться: иди вперёд и сделай свои программы многопоточными безбоязненно!

Далее мы поговорим об идиоматичных способах моделирования проблем и структурирования решений по мере усложнения ваших программ на Rust. Кроме того, мы обсудим как идиомы Rust связаны с теми, с которыми вы, возможно, знакомы по объектно-ориентированному программированию.


[Rustonomicon]: ../nomicon/index.html