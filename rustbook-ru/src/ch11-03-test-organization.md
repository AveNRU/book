## Организация тестов

Как упоминалось в начале главы, тестирование является сложной дисциплиной и разные люди используют разную терминологию и организацию. Сообщество Rust думает о тестах с точки зрения двух основных разрядов: *модульные тесты* и *встроенные тесты*. Модульные тесты это небольшие и более сфокусированные на тестировании одного модуля в отдельности или могут тестироваться приватные внешние оболочки. Встраиваемые тесты являются полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные внешние оболочки и потенциально выполняя тестирование нескольких модулей в одном тесте.

Написание обоих видов тестов важно для обеспечения того, чтобы кусочки вашей библиотеки по отдельности и вместе делали то, что вы ожидаете.

### Модульные тесты

Целью модульных тестов является тестирование каждого раздела кода, изолированное от остального функционала, чтобы можно было быстро понять, что работает некорректно или не так как ожидается. Мы разместим модульные тесты в папке *src*, в каждый тестируемый файл. Но в Rust принято создавать тестирующий модуль `tests` и код теста сохранять в файлы с таким же именем, как компоненты которые предстоит тестировать. Также необходимо добавить изложение `cfg(test)` к этому модулю.

#### Модуль тестов и изложение `#[cfg(test)]`

Изложение `#[cfg(test)]` у модуля с тестами указывает Rust собирать и запускать только код тестов, когда выполняется приказ `cargo test`, а не когда запускается `cargo build`. Это экономит время сборки, если вы только хотите собрать библиотеку и сэкономить место для результирующих собранных артефактов, потому что тесты не будут включены. Вы увидите что, по причине того, что встроенные тесты помещаются в другой каталог им не нужна изложение `#[cfg(test)]`. Тем не менее, так как модульные тесты идут в тех же файлах что и основной код, вы будете использовать `#[cfg(test)]` чтобы указать, что они не должны быть включены в собранный результат.

Напомним, что когда мы генерировали новый проект `adder` в первом разделе этой главы, то Cargo сгенерировал для нас код ниже:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

Этот код является самостоятельно сгенерированным тестовым модулем. Атрибут `cfg` предназначен для *настройке* и говорит Rust, что следующий элемент должен быть включён только учитывая определённую опцию настройке. В этом случае опцией настройке является `test`, который предоставлен в Rust для сборки и запуска текущих тестов. Используя атрибут `cfg`, Cargo собирает только тестовый код при активном запуске тестов приказом `cargo test`. Это включает в себя любые вспомогательные функции, которые могут быть в этом модуле в дополнение к функциям помеченным `#[test]`.

#### Тестирование приватных функций (private)

Сообщество программистов не имеет однозначного мнения по поводу тестировать или нет приватные функции. В некоторых языках весьма сложно или даже невозможно тестировать такие функции. Независимо от того, какой технологии тестирования вы придерживаетесь, в Rust приватные функции можно тестировать. Рассмотрим приложение 11-12 с приватной функцией `internal_adder`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}
```

<span class="caption">Приложение 11-12: Тестирование приватных функций</span>

Обратите внимание, что функция `internal_adder` не помечена как `pub`. Тесты — это просто Rust код, а модуль `tests` — это ещё один модуль. Как мы обсуждали в разделе [“Пути для ссылки на элемент в дереве модулей“]<!--  -->, элементы в дочерних модулях могут использовать элементы из своих родительских модулей. В этом тесте мы помещаем все элементы родительского модуля `test` в область видимости с помощью `use super::*` и затем тест может вызывать `internal_adder`. Если вы считаете, что приватные функции не нужно тестировать, то Rust не заставит вас это сделать.

### Встраиваемые тесты

В Rust встроенные тесты являются полностью внешними по отношению к вашей библиотеке. Они используют вашу библиотеку так же, как любой другой код, что означает, что они могут вызывать только функции, которые являются частью публичного API библиотеки. Их целью является проверка, много ли частей вашей библиотеки работают вместе правильно. У модулей кода правильно работающих самостоятельно, могут возникнуть проблемы при встраивани, поэтому тестовое покрытие встроенного кода также важно. Для создания встроенных тестов сначала нужен каталог *tests* .

#### Каталог *tests*

Мы создаём папку *tests* в корневой папке вашего проекта, рядом с папкой *src*. Cargo знает, что искать файлы с встроенными тестами нужно в этой папки. После этого мы можем создать столько тестовых файлов, сколько захотим, и Cargo ссобирает каждый из файлов в отдельный крейт.

Давайте создадим встроенный тест. Рядом с кодом из приложения 11-12, который всё ещё в файле *src/lib.rs*, создайте каталог *tests*, создайте новый файл с именем *tests/integration_test.rs*. Структура папок должна выглядеть так:

```text
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

Введите код из приложения 11-13 в файл *tests/integration_test.rs* file:

<span class="filename">Файл: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}
```

<span class="caption">Приложение 11-13: Встраиваемая тест функция из крейта <code>adder</code></span>

Каждый файл в каталоге `tests` представляет собой отдельный крейт, поэтому нам нужно подключить нашу библиотеку в область видимости каждого тестового крейта. По этой причине мы добавляем `use adder` в верхней части кода, что не нужно нам делать в модульных тестах.

Нам не нужно комментировать код в *tests/integration_test.rs* с помощью `#[cfg(test)]`. Cargo особым образом обрабатывает каталог `tests` и собирает файлы в этом каталоге только тогда, когда мы запускаем приказ `cargo test`. Запустите `cargo test` сейчас:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
```

Выходные данные представлены тремя разделами: модульные тесты, встроенные тесты и тесты документации. Обратите внимание, что если какой-нибудь тест в одной из секций не пройдёт, последующие секции выполняться не будут. Например, если модульный тест провалился, не будет выведено результатов встроенных и документационных тестов, потому что эти тесты будут выполняться только в том случае, если все модульные тесты завершатся успешно.

Первый раздел для модульных тестов такой же, как мы видели: одна строка для каждого модульного теста (один с именем `internal`, который мы добавили в приложении 11-12), а затем сводная строка для модульных тестов.

Раздел встроенных тестов начинается со строки `Running tests/integration_test.rs`. Далее идёт строка для каждой тестовой функции в этом встроенном тесте и итоговая строка для результатов встроенного теста непосредственно перед началом раздела `Doc-tests adder`.

Каждый файл встроенного теста имеет свой собственный раздел, поэтому, если мы добавим больше файлов в каталог *tests*, то здесь будет больше разделов встроенного теста.

Мы всё ещё можем запустить определённую функцию в встроенных тестах, указав имя тест функции в качестве переменной в `cargo test`. Чтобы запустить все тесты в определенном файле встроенных тестов, используйте переменная `--test` сопровождаемый именем файла у приказы `cargo test`:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
```

Этот приказ запускает только тесты в файле *tests/integration_test.rs*.

#### Подмодули в встроенных тестах

По мере добавления большего количества встроенных тестов, можно создать более одного файла в каталоге  *tests*, чтобы легче организовывать их; например, вы можете сгруппировать функции тестирования по функциональности, которую они проверяют. Как упоминалось ранее, каждый файл в каталоге *tests* собран как отдельный крейт, что полезно для создания отдельных областей видимости, чтобы более точно создавать видимость то, как конечные пользователи будут использовать ваш крейт. Однако это означает, что файлы в каталоге *tests* ведут себя не так, как файлы в *src*, как вы узнали в Главе 7 относительно того как разделить код на модули и файлы.

Различное поведение файлов в каталоге *tests* наиболее заметно, когда у вас есть набор вспомогательных функций, которые будут полезны в нескольких встроенных тестовых файлах. Представим, что вы пытаетесь выполнить действия, описанные в разделе [«Разделение модулей в разные файлы»](ch07-05-separating-modules-into-different-files.html)<!--  --> главы 7, чтобы извлечь их в общий модуль. Например, вы создали файл *tests/common.rs* и поместили в него функцию `setup`, содержащую некоторый код, который вы будете вызывать из разных тестовых функций в нескольких тестовых файлах

<span class="filename">Файл: tests/common.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}
```

Когда мы снова запустим тесты, мы увидим новый раздел в результатах тестов для файла *common.rs*, хотя этот файл не содержит никаких тестовых функций, более того, мы даже не вызывали функцию `setup` откуда либо:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
```

Упоминание файла `common` и появление в результатах выполнения тестов сообщения вида `running 0 tests` - это не то, чего мы хотели. Мы только хотели выделить некоторый общий код, который будет использоваться другими файлами встроенных тестов.

Чтобы модуль `common` больше не появлялся в результатах выполнения тестов, вместо файла *tests/common.rs* мы создадим файл *tests/common/mod.rs*. Директория проекта теперь выглядит следующим образом:

```text
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

Здесь используется более раннее соглашение об именовании файлов, которое Rust также понимает. Мы говорили об этом в разделе [“Иные пути к файлам”] главы 7. Именование файла таким образом говорит, что Rust не должен рассматривать модуль `common` как файл встроенных тестов. Когда мы перемещаем код функции <code>setup</code> в файл *tests/common/mod.rs* и удаляем файл *tests/common.rs*, дополнительный раздел больше не будет отображаться в результатах тестов. Файлы в подкаталогах каталога <em>tests</em> не собираются как отдельные крейты или не появляются в результатах выполнения тестов.

После того, как мы создали файл *tests/common/mod.rs*, мы можем использовать его в любых файлах встроенных тестов как обычный модуль. Вот пример вызова функции `setup` из теста `it_adds_two` в файле *tests/integration_test.rs*:

<span class="filename">Файл: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}
```

Обратите внимание, что  объявление `mod common;` совпадает с объявлением модуля, которое отображено в приложении 7-21. Затем в тестовой функции мы можем вызвать функцию `common::setup()`.

#### Встраиваемые тесты для двоичных крейтов

Если наш проект является двоичным крейтом, который содержит только *src/main.rs* и не содержит *src/lib.rs*, мы не сможем создать встроенные тесты в папке *tests* и подключить функции определённые в файле *src/main.rs* в область видимости с помощью указания `use`. Только библиотечные крейты могут предоставлять функции, которые можно использовать в других крейтах; двоичные крейты предназначены только для самостоятельного запуска.

Это одна из причин, почему проекты на Rust, которые генерируют исполняемые модули, обычно имеют простой файл *src/main.rs*, который в свою очередь вызывает логику, которая находится в файле *src/lib.rs*. Используя такую структуру, встроенные тесты *могут* проверить библиотечный крейт, используя оператор `use` для подключения важного функционала. Если этот важный функционал работает, то и небольшое количество кода в файле *src/main.rs* также будет работать, а значит этот небольшой объём кода не нуждается в проверке.

## Итоги

Средства тестирования языка Rust предоставляют способ задать ожидаемое поведение кода, чтобы убедиться, что он всё ещё соответствует вашим ожиданиям даже после внесения изменений. Модульные тесты проверяют различные части библиотеки по отдельности и могут тестировать приватные подробности реализации. Встраиваемые тесты проверяют, что части библиотеки работают корректно сообща. Эти тесты используют для тестирования кода открытый API библиотеки, таким же образом, как его будет использовать внешний код. Хотя система видов Rust и правила владения помогают предотвратить некоторые виды ошибок, тесты по-прежнему важны для уменьшения количества логических ошибок, связанных с поведением вашего кода.

Давайте объединим  знания, полученные в этой и предыдущей главах, чтобы поработать над проектом!


[“Пути для ссылки на элемент в дереве модулей“]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[“Иные пути к файлам”]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths