# Управление растущими проектами с помощью дополнений, ящиков и модулей

По мере роста кодовой хранилища ваших программ, создание проекта будет иметь большое значение, ведь отслеживание всей программы в голове будет становиться всё более сложным.  Группируя связанные функции и разделяя код по основным функциональностям <em>(фичам, feature)</em>, вы делаете более прозрачным понимание о том, где искать код реализующий определённую функцию и где стоит вносить изменения для того чтобы изменить её поведение.

Программы, которые мы писали до сих пор, были в одном файле одного модуля. По мере роста проекта, мы можем создавать код иначе, разделив его на несколько модулей и несколько файлов. Дополнение может содержать несколько двоичных ящиков и дополнительно один ящик библиотеки. Дополнение может включать в себя много двоичных ящиков и дополнительно один библиотечный ящик. По мере роста дополнения вы можете извлекать части программы в отдельные ящики, которые затем станут внешними зависимостями для основного кода нашей программы. Эта глава охватывает все эти техники. В свою очередь для очень крупных проектов, состоящих из набора взаимосвязанных дополнений развивающихся вместе, Cargo предоставляет рабочие пространства, *workspaces*, их мы рассмотрим за пределами данной главы, в разделе ["Рабочие пространства Cargo"] Главы 14.

Мы также обсудим инкапсуляцию подробностей, которая позволяет использовать код снова на более высоком уровне: единожды реализовав какую-то действие, другой код может вызывать этот код через публичный внешняя оболочка, не зная как работает реализация. То, как вы пишете код, определяет какие части общедоступны для использования другим кодом и какие части являются закрытыми деталями реализации для которых вы оставляете право на изменения только за собой. Это ещё один способ ограничить количество подробностей, которые вы должны держать в голове.

Связанное понятие - это область видимости: вложенный среда в котором написан код имеющий набор имён, которые определены «в текущей области видимости». При чтении, письме и сборки кода, программистам и сборщикам необходимо знать, относится ли определенное имя в определённом месте к переменной, к функции, к структуре, к перечислению, к модулю, к постоянных значенийе или другому элементу и что означает этот элемент. Можно создавать области видимости и изменять какие имена входят или выходят за их рамки. Нельзя иметь два элемента с тем же именем в одной области; есть доступные средства для разрешения несоответствий имён.

Rust имеет ряд функций, которые позволяют управлять согласованием кода, в том числе управлять тем какие подробности открыты, какие подробности являются частными, какие имена есть в каждой области вашей программы. Эти функции иногда вместе именуемые *модульной системой* включают в себя:

- **Дополнения:** Функционал Cargo позволяющий собирать, проверять и делиться ящиками
- **Ящики:** Дерево модулей, которое создаёт библиотечный или исполняемый файл
- **Модули** и **use:** Позволяют вместе управлять устройство, область видимости и скрытие путей
- **Пути:** способ именования элемента, такого как структура, функция или модуль

В этой главе мы рассмотрим все эти функции, обсудим как они взаимодействуют и объясним, как использовать их для управления областью видимости. К концу у вас должно появиться солидное понимание модульной системы и умение работать с областями видимости на уровне искуссника!


["Рабочие пространства Cargo"]: ch14-03-cargo-workspaces.html