## Виды Данных

Каждое значение в Rust относится к определённому *виду данных*, который указывает на вид данных, что позволяет Rust знать, как работать с этими данными. Мы рассмотрим два подмножества видов данных: скалярные и составные.

Не забывайте, что Rust является *статически типизированным* (statically typed) языком. Это означает, что он должен знать виды всех переменных во время сборки. Обычно сборщик может предположить, какой вид используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько видов, необходимо добавлять изложение вида вручную. Например, когда мы преобразовали `String` в число с помощью вызова `parse` в разделе [«Сравнение предположения с загаданным номером»](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number) главы 2, мы должны добавить такую изложение:<!-- ignore -->

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

Если мы не добавим изложение вида `: u32`, показанную в предыдущем коде, Rust отобразит следующую ошибку, которая означает, что сборщику нужно от нас больше сведений, чтобы узнать, какой вид мы хотим использовать:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

В будущем вы увидите различные изложении для разных видов данных.

### Скалярные виды данных

*Скалярный* вид представляет собой единичное значение. В Rust есть четыре основных скалярных вида: целочисленный, числа с плавающей точкой, логический и символы. Вы наверняка знакомы с этими видами по другим языкам программирования. Давайте разберёмся, как они работают в Rust.

#### Целочисленные виды

Целочисленный вид (*integer*) — это число без дробной части. В главе 2 мы использовали один целочисленный вид — вид `u32`. Такое объявление вида указывает, что значение, с которым оно связано, должно быть целым числом без знака (виды целых чисел со знаком начинаются с `i` вместо `u`), которое занимает 32 бита памяти. В Таблице 3-1 показаны встроенные целочисленные виды в Rust. Мы можем использовать любой из этих вариантов для объявления вида целочисленного значения.

<span class="caption">Таблица 3-1: целочисленные виды в Rust</span>

Длина | Со знаком | Без знака
--- | --- | ---
8 бит | `i8` | `u8`
16 бит | `i16` | `u16`
32 бита | `i32` | `u32`
64 бита | `i64` | `u64`
128 бит | `i128` | `u128`
архитектурно-зависимая | `isize` | `usize`

Каждый вариант может быть как со знаком, так и без знака и имеет явный размер. Такая характеристика вида как *знаковый* и *беззнаковый* определяет возможность числа быть отрицательным. Другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, число отображается со знаком плюс или со знаком минус; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся с использованием [дополнительного кода].

Каждый вариант со знаком может хранить числа от -(2 <sup>n - 1</sup> ) до 2 <sup>n - 1</sup> - 1 включительно, где *n* — количество битов, которые использует этот вариант. Таким образом, `i8` может хранить числа от -(2 <sup>7</sup> ) до 2 <sup>7</sup> - 1, что равно значениям от -128 до 127. Варианты без знака могут хранить числа от 0 до 2 <sup>n</sup> - 1, поэтому `u8` может хранить числа от 0 до 2 <sup>8</sup> - 1, что равно значениям от 0 до 255.

Кроме того, виды `isize` и `usize` зависят от архитектуры компьютера, на котором выполняется программа, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.

Вы можете записывать целочисленные литералы в любой из форм, показанных в таблице 3-2. Заметьте, что числовые литералы, имеющие несколько числовых видов, допускают использование суффикса вида, например `57u8`, для обозначения вида. Числовые литералы также могут использовать `_` в качестве визуального разделителя для облегчения чтения числа, например `1_000`, который будет иметь такое же значение, как если бы было задано `1000`.

<span class="caption">Таблица 3-2: Целочисленные литералы в Rust</span>

Числовой литерал | Пример
--- | ---
Десятичный | `98_222`
Шестнадцатеричный | `0xff`
восьмеричный | `0o77`
Двоичный | `0b1111_0000`
Байт (только `u8`) | `b'A'`

Как же узнать, какой вид целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные виды по умолчанию `i32`. Основной случай, в котором вы должны использовать `isize` или `usize`, — это упорядочевание какой-либо собрания.

>  <h>Целочисленное переполнение</h> Допустим, имеется переменная вида `u8`, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого ряда, например, 256, произойдёт *целочисленное переполнение*, что может привести к одному из двух вариантов поведения. Если выполняется сборка в режиме отладки, Rust включает проверку на целочисленное переполнение, приводящую вашу программу к *панике* во время выполнения, когда возникает такое поведение. Rust использует термин *паника(panicking)*, когда программа завершается с ошибкой. Мы обсудим панику более подробно в разделе ["Неустранимые ошибки с `panic!`"] в главе 9. . При сборки в режиме release с флагом `--release`, Rust *не* включает проверки на целочисленное переполнение, которое вызывает панику. Вместо этого, в случае переполнения, Rust выполняет *обёртывание второго дополнения*. Проще говоря, значения, превышающие максимальное значение, которое может хранить вид, "оборачиваются" к минимальному из значений, которые может хранить вид. В случае `u8` значение 256 становится 0, значение 257 становится 1, и так далее. Программа не запаникует, но переменная будет иметь значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Полагаться на поведение обёртывания целочисленного переполнения считается ошибкой. Для явной обработки возможности переполнения существует семейство способов, предоставляемых встроенной библиотекой для примитивных числовых видов:
>  - Обёртывание во всех режимах с помощью способов `wrapping_*`, таких как `wrapping_add`.
> - Возврат значения `None` при переполнении с помощью способов `checked_*`.
> - Возврат значения и логический индикатор, указывающий, произошло ли переполнение при использовании способов `overflowing_*`.
> - Насыщение минимальным или максимальным значением с помощью способов `saturating_*`.
>

#### Числа с плавающей запятой

Также в Rust есть два примитивных вида для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Виды с плавающей точкой в Rust - это f32 и f64, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется вид f64, поскольку на современных процессорах он работает примерно с той же скоростью, как и f32, но обладает большей точностью. Все виды с плавающей запятой являются знаковыми.

Вот пример, отображающий числа с плавающей запятой в действии:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

Числа с плавающей запятой представлены в соответствии со стандартом IEEE-754. Вид `f32` является плавающей запятой одинарной точности, а `f64` - двойной точности.

#### Числовые действия

Rust поддерживает основные математические действия, привычные для всех видов чисел: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующий код показывает, как можно использовать каждую числовую действие в указания `let`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

Каждое выражение в этих указаниях использует математический оператор и вычисляется в одно значение, которое связывается с переменной. [Приложении B](appendix-02-operators.html) содержит список всех операторов, которые предоставляет Rust.

#### Логический вид данных

Как и в большинстве других языков программирования, логический вид в Rust имеет два возможных значения: `true` и `false`. Значения логических видов имеют размер в один байт. Логический вид в Rust задаётся с помощью `bool`. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

Основной способ использования логических значений - это использование условий, таких как выражение `if`. Мы рассмотрим, как выражения `if` работают в Rust в разделе ["Поток управления"].

#### Символьный вид данных

Вид `char` в Rust является самым примитивным алфавитным видом языка. Вот несколько примеров объявления значений `char`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

Заметьте, мы указываем литералы `char` с одинарными кавычками, в отличие от строковых литералов, для которых используются двойные кавычки. Вид `char` в Rust имеет размер четыре байта и представляет собой скалярное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины - все это допустимые значения вида `char` в Rust. Скалярные значения Unicode находятся в ряде от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно. Однако "символ" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "символ", может не совпадать с тем, что такое `char` в Rust. Мы подробно обсудим эту тему в главе 8 "Хранение текста в кодировке UTF-8 с помощью строк".

### Составные виды данных

*Составные виды* могут группировать различные значения в один вид. В Rust есть два примитивных составных вида: кортежи и массивы.

#### Кортежи

*Кортеж*- это универсальный способ объединения нескольких значений с различными видами в один составной вид. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.

Мы создаём кортеж, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждая позиция в кортеже имеет вид, причём виды различных значений в кортеже не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные изложении видов:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

Переменная `tup` связана со всем кортежем, поскольку кортеж является одним составным элементом. Чтобы получить отдельные значения из кортежа, можно использовать сопоставление с образцом для деструктуризации значения кортежа, например, так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

Эта программа сначала создаёт кортеж и связывает его с переменной `tup`. Затем с помощью шаблона `let` берётся `tup` и превращается в три отдельные переменные, `x`, `y` и `z`. Это называется *деструктуризацией*, поскольку разбивает единый кортеж на три части. Наконец, программа печатает значение `y`, которое равно `6.4`.

Мы также можем получить доступ к элементу кортежа напрямую, используя точку (`.`), за которой следует порядковый казательзначения, требуемого для доступа. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

Эта программа создаёт кортеж `x`, а затем обращается к каждому элементу кортежа, используя соответствующие порядковые указатели. Как и в большинстве языков программирования, первый порядковый казательв кортеже равен 0.

Кортеж, не имеющий значений, имеет особое имя  *единичный вид (unit)*. Это значение и соответствующий ему вид записываются как `()` и представляет собой пустое значение или пустой возвращаемый вид. Выражения неявно возвращают значение единичного вида, если не возвращают никакого другого значения.

#### Массивы

Другим способом создания собрания из нескольких значений является массив *array*. В отличие от кортежа, каждый элемент массива должен иметь один и тот же вид. В отличие от массивов в некоторых других языках, массивы в Rust имеют фиксированную длину.

Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

Массивы удобно использовать, если данные необходимо разместить в стеке, а не в куче (мы подробнее обсудим стек и кучу в [Главе 4]) или если требуется, чтобы количество элементов всегда было фиксированным. Однако массив не так гибок, как вектор. *Вектор* - это подобный вид собрания, предоставляемый встроенной библиотекой, который *может* увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор. Более подробно векторы рассматриваются в [Главе 8].

Однако массивы более полезны, когда вы знаете, что количество элементов не нужно будет изменять. Например, если бы вы использовали названия месяцев в программе, вы, вероятно, использовали бы массив, а не вектор, потому что вы знаете, что он всегда будет содержать 12 элементов:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

Вид массива записывается следующим образом: в квадратных скобках обозначается вид элементов массива, а затем, через точку с запятой, количество элементов. Например:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

Здесь `i32` является видом каждого элемента массива. После точки с запятой указано число `5`, показывающее, что массив содержит 5 элементов.

Вы также можете объявить массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо вида. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:

```rust
let a = [3; 5];
```

Массив в переменной `a` будет включать `5` элементов, значение которых будет равно `3`. Данная запись подобна коду `let a = [3, 3, 3, 3, 3];`, но является более краткой.

##### Доступ к элементам массива

Массив — это единый фрагмент памяти известного фиксированного размера, который может быть размещён в стеке. Вы можете получить доступ к элементам массива с помощью упорядочевания, например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

В этом примере переменная с именем first получит значение 1, потому что это значение находится по порядковому указателю [0] в массиве. Переменная с именем second получит значение 2 по порядковому указателю [1] в массиве.

##### Некорректный доступ к элементу массива

Давайте посмотрим, что произойдёт, если попытаться получить доступ к элементу массива, находящемуся за его пределами. Допустим, вы запускаете данный код, похожий на игру в угадывание из Главы 2, чтобы получить от пользователя порядковый казательмассива:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

Этот код успешно собирается. Если запустить этот код с помощью `cargo run` и ввести `0`, `1`, `2`, `3` или `4`, программа напечатает соответствующее значение по данному порядковому указателю в массиве. Если вместо этого ввести число за пределами массива, например, `10`, то программа выведет следующее:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Программа столкнулась с ошибкой во *времени выполнения* на этапе применения недопустимого значения в действия упорядочевания. Программа завершилась с сообщением об ошибке и не выполнила финальную указанию `println!`. При попытке доступа к элементу с помощью упорядочевания Rust проверяет, что указанный порядковый казательменьше длины массива. Если порядковый казательбольше или равен длине, Rust паникует. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что сборщик не может знать, какое значение введёт пользователь при последующем выполнении кода.

Это пример принципов безопасности памяти Rust в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный порядковый указатель, доступ к памяти может быть некорректным. Rust защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу. В главе 9 подробнее обсуждается обработка ошибок в Rust и то, как вы можете написать читаемый, безопасный код, который не вызывает панику и не разрешает некорректный доступ к памяти.


[дополнительного кода]: https://en.wikipedia.org/wiki/Two%27s_complement
["Поток управления"]: ch03-05-control-flow.html#control-flow
[Главе 4]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[Главе 8]: ch08-01-vectors.html
["Неустранимые ошибки с `panic!`"]: ch09-01-unrecoverable-errors-with-panic.html