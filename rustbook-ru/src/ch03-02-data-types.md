## Виды Данных

Каждое значение в Ржавчина относится к определённому *виду данных*, который указывает на вид данных, что позволяет Ржавчина знать, как работать с этими данными. Мы рассмотрим два подмножества видов данных: одиночные и составные.

Не забывайте, что Ржавчина является *постоянно строго определенным* (statically typed) языком. Это означает, что он должен знать виды всех переменных во время сборки. Обычно сборщик может предположить, какой вид используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько видов, необходимо добавлять изложение вида вручную. Например, когда мы преобразовали `String` в число с помощью вызова `parse` в разделе [«Сравнение предположения с загаданным номером»](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number) главы 2, мы должны добавить такую изложение:<!-- ignore -->

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

Если мы не добавим изложение вида `: u32`, показанную в предыдущем коде, Ржавчина отобразит следующую ошибку, которая означает, что сборщику нужно от нас больше сведений, чтобы узнать, какой вид мы хотим использовать:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

В будущем вы увидите различные изложении для разных видов данных.

### Одиночные виды данных

*Одиночный* вид представляет собой единичное значение. В Ржавчина есть четыре основных одиночных вида: целочисленный, числа с плавающей точкой, логический и символы. Вы наверняка знакомы с этими видами по другим языкам программирования. Давайте разберёмся, как они работают в Rust.

#### Целочисленные виды

Целочисленный вид (*integer*) — это число без дробной части. В главе 2 мы использовали один целочисленный вид — вид `u32`. Такое объявление вида указывает, что значение, с которым оно связано, должно быть целым числом без знака (виды целых чисел со знаком начинаются с `i` вместо `u`), которое занимает 32 бита памяти. В Таблице 3-1 показаны встроенные целочисленные виды в Rust. Мы можем использовать любой из этих исходов для объявления вида целочисленного значения.

<span class="caption">Таблица 3-1: целочисленные виды в Rust</span>

Длина | Со знаком | Без знака
--- | --- | ---
8 бит | `i8` | `u8`
16 бит | `i16` | `u16`
32 бита | `i32` | `u32`
64 бита | `i64` | `u64`
128 бит | `i128` | `u128`
архитектурно-зависимая | `isize` | `usize`

Каждый исход может быть как со знаком, так и без знака и имеет явный размер. Такая свойство вида как *знаковый* и *беззнаковый* определяет возможность числа быть отрицательным. Другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, число отображается со знаком плюс или со знаком -; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся с использованием [дополнительного кода].

Каждый исход со знаком может хранить числа от -(2 <sup>n - 1</sup> ) до 2 <sup>n - 1</sup> - 1 включительно, где *n* — количество битов, которые использует этот исход. Таким образом, `i8` может хранить числа от -(2 <sup>7</sup> ) до 2 <sup>7</sup> - 1, что равно значениям от -128 до 127. Исходы без знака могут хранить числа от 0 до 2 <sup>n</sup> - 1, поэтому `u8` может хранить числа от 0 до 2 <sup>8</sup> - 1, что равно значениям от 0 до 255.

Кроме того, виды `isize` и `usize` зависят от архитектуры компьютера, на котором выполняется программа, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.

Вы можете записывать целочисленные записи в любой из разновидностей, показанных в таблице 3-2. Заметьте, что числовые записи, имеющие несколько числовых видов, допускают использование вставки вида, например `57u8`, для обозначения вида. Числовые записи также могут использовать `_` в качестве визуального разделителя для облегчения чтения числа, например `1_000`, который будет иметь такое же значение, как если бы было задано `1000`.

<span class="caption">Таблица 3-2: Целочисленные записи в Rust</span>

Числовой запись | Пример
--- | ---
Десятичный | `98_222`
Шестнадцатеричный | `0xff`
восьмеричный | `0o77`
Двоичный | `0b1111_0000`
Байт (только `u8`) | `b'A'`

Как же узнать, какой вид целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные виды по умолчанию `i32`. Основной случай, в котором вы должны использовать `isize` или `usize`, — это упорядочевание какой-либо собрания.

>  <h>Целочисленное переполнение</h> Допустим, имеется переменная вида `u8`, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого ряда, например, 256, произойдёт *целочисленное переполнение*, что может привести к одному из двух исходов поведения. Если выполняется сборка в режиме отладки, Ржавчина включает проверку на целочисленное переполнение, приводящую вашу программу к *панике* во время выполнения, когда возникает такое поведение. Ржавчина использует понятие *паника(panicking)*, когда программа завершается с ошибкой. Мы обсудим панику более подробно в разделе ["Неустранимые ошибки с `panic!`"] в главе 9. . При сборки в режиме release с флагом `--release`, Ржавчина *не* включает проверки на целочисленное переполнение, которое вызывает панику. Вместо этого, в случае переполнения, Ржавчина выполняет *обёртывание второго дополнения*. Проще говоря, значения, превышающие наибольшее значение, которое может хранить вид, "оборачиваются" к наименьшему из значений, которые может хранить вид. В случае `u8` значение 256 становится 0, значение 257 становится 1, и так далее. Программа не запаникует, но переменная будет иметь значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Полагаться на поведение обёртывания целочисленного переполнения считается ошибкой. Для явной обработки возможности переполнения существует семейство способов, предоставляемых встроенной библиотекой для простых числовых видов:
>  - Обёртывание во всех режимах с помощью способов `wrapping_*`, таких как `wrapping_add`.
> - Возврат значения `None` при переполнении с помощью способов `checked_*`.
> - Возврат значения и логический индикатор, указывающий, произошло ли переполнение при использовании способов `overflowing_*`.
> - Насыщение наименьшим или наибольшим значением с помощью способов `saturating_*`.
>

#### Числа с плавающей запятой

Также в Ржавчина есть два простых вида для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Виды с плавающей точкой в Ржавчина - это f32 и f64, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется вид f64, поскольку на современных процессорах он работает примерно с той же скоростью, как и f32, но обладает большей точностью. Все виды с плавающей запятой являются знаковыми.

Вот пример, отображающий числа с плавающей запятой в действии:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

Числа с плавающей запятой представлены в соответствии со исполнением IEEE-754. Вид `f32` является плавающей запятой одинарной точности, а `f64` - двойной точности.

#### Числовые действия

Rust поддерживает основные математические действия, привычные для всех видов чисел: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующий код показывает, как можно использовать каждую числовую действие в указания `let`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

Каждое выражение в этих указаниях использует математический оператор и вычисляется в одно значение, которое связывается с переменной. [Приложении B](appendix-02-operators.html) содержит список всех операторов, которые предоставляет Rust.

#### Логический вид данных

Как и в большинстве других языков программирования, логический вид в Ржавчина имеет два возможных значения: `true` и `false`. Значения логических видов имеют размер в один байт. Логический вид в Ржавчина задаётся с помощью `bool`. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

Основной способ использования логических значений - это использование условий, таких как выражение `if`. Мы рассмотрим, как выражения `if` работают в Ржавчина в разделе ["Поток управления"].

#### Символьный вид данных

Вид `char` в Ржавчина является самым простым алфавитным видом языка. Вот несколько примеров объявления значений `char`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

Заметьте, мы указываем записи `char` с одинарными кавычками, в отличие от строковых записей, для которых используются двойные кавычки. Вид `char` в Ржавчина имеет размер четыре байта и представляет собой одиночное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины - все это допустимые значения вида `char` в Rust. Одиночные значения Unicode находятся в ряде от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно. Однако "символ" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "символ", может не совпадать с тем, что такое `char` в Rust. Мы подробно обсудим эту тему в главе 8 "Хранение текста в кодировке UTF-8 с помощью строк".

### Составные виды данных

*Составные виды* могут объединять различные значения в один вид. В Ржавчина есть два простых составных вида: упорядоченные ряды и массивы.

#### Упорядоченные ряды

*Упорядоченный ряд*- это гибкий способ объединения нескольких значений с различными видами в один составной вид. Упорядоченные ряды имеют конечную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.

Мы создаём упорядоченный ряд, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждая позиция в упорядоченном ряде имеет вид, причём виды различных значений в упорядоченном ряде не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные изложении видов:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

Переменная `tup` связана со всем упорядоченным рядом, поскольку упорядоченный ряд является одним составным элементом. Чтобы получить отдельные значения из упорядоченного ряда, можно использовать сопоставление с образцом для разъединения значения упорядоченного ряда, например, так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

Эта программа сначала создаёт упорядоченный ряд и связывает его с переменной `tup`. Затем с помощью образца `let` берётся `tup` и превращается в три отдельные переменные, `x`, `y` и `z`. Это называется *разъединением*, поскольку разбивает единый упорядоченный ряд на три части. Наконец, программа печатает значение `y`, которое равно `6.4`.

Мы также можем получить доступ к элементу упорядоченного ряда напрямую, используя точку (`.`), за которой следует порядковый указательзначения, требуемого для доступа. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

Эта программа создаёт упорядоченный ряд `x`, а затем обращается к каждому элементу упорядоченного ряда, используя соответствующие порядковые указатели. Как и в большинстве языков программирования, первый порядковый указательв упорядоченном ряде равен 0.

Упорядоченный ряд, не имеющий значений, имеет особое имя  *единичный вид (unit)*. Это значение и соответствующий ему вид записываются как `()` и представляет собой пустое значение или пустой возвращаемый вид. Выражения неявно возвращают значение единичного вида, если не возвращают никакого другого значения.

#### Массивы

Другим способом создания собрания из нескольких значений является массив *array*. В отличие от упорядоченного ряда, каждый элемент массива должен иметь один и тот же вид. В отличие от массивов в некоторых других языках, массивы в Ржавчина имеют конечную длину.

Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

Массивы удобно использовать, если данные необходимо разместить в обойме, а не в куче (мы подробнее обсудим обойма и кучу в [Главе 4]) или если требуется, чтобы количество элементов всегда было конечным. Однако массив не так гибок, как вектор. *Вектор* - это подобный вид собрания, предоставляемый встроенной библиотекой, который *может* увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор. Более подробно векторы рассматриваются в [Главе 8].

Однако массивы более полезны, когда вы знаете, что количество элементов не нужно будет изменять. Например, если бы вы использовали названия месяцев в программе, вы, вероятно, использовали бы массив, а не вектор, потому что вы знаете, что он всегда будет содержать 12 элементов:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

Вид массива записывается следующим образом: в квадратных скобках обозначается вид элементов массива, а затем, через точку с запятой, количество элементов. Например:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

Здесь `i32` является видом каждого элемента массива. После точки с запятой указано число `5`, показывающее, что массив содержит 5 элементов.

Вы также можете объявить массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо вида. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:

```rust
let a = [3; 5];
```

Массив в переменной `a` будет включать `5` элементов, значение которых будет равно `3`. Данная запись подобна коду `let a = [3, 3, 3, 3, 3];`, но является более краткой.

##### Доступ к элементам массива

Массив — это единый отрывок памяти известного конечного размера, который может быть размещён в обойме. Вы можете получить доступ к элементам массива с помощью упорядочевания, например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

В этом примере переменная с именем first получит значение 1, потому что это значение находится по порядковому указателю [0] в массиве. Переменная с именем second получит значение 2 по порядковому указателю [1] в массиве.

##### Неправильный доступ к элементу массива

Давайте посмотрим, что произойдёт, если попытаться получить доступ к элементу массива, находящемуся за его пределами. Допустим, вы запускаете данный код, похожий на игру в угадывание из Главы 2, чтобы получить от пользователя порядковый указательмассива:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

Этот код успешно собирается. Если запустить этот код с помощью `cargo run` и ввести `0`, `1`, `2`, `3` или `4`, программа напечатает соответствующее значение по данному порядковому указателю в массиве. Если вместо этого ввести число за пределами массива, например, `10`, то программа выведет следующее:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Программа столкнулась с ошибкой во *времени выполнения* на этапе применения недопустимого значения в действия упорядочевания. Программа завершилась с сообщением об ошибке и не выполнила конечную указанию `println!`. При попытке доступа к элементу с помощью упорядочевания Ржавчина проверяет, что указанный порядковый указательменьше длины массива. Если порядковый указательбольше или равен длине, Ржавчина паникует. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что сборщик не может знать, какое значение введёт пользователь при последующем выполнении кода.

Это пример принципов безопасности памяти Ржавчина в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный порядковый указатель, доступ к памяти может быть неправильным. Ржавчина защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу. В главе 9 подробнее обсуждается обработка ошибок в Ржавчина и то, как вы можете написать читаемый, безопасный код, который не вызывает панику и не разрешает неправильный доступ к памяти.


[дополнительного кода]: https://en.wikipedia.org/wiki/Two%27s_complement
["Поток управления"]: ch03-05-control-flow.html#control-flow
[Главе 4]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[Главе 8]: ch08-01-vectors.html
["Неустранимые ошибки с `panic!`"]: ch09-01-unrecoverable-errors-with-panic.html