## Обобщённые виды данных

Мы используем обобщённые виды данных для объявления функций или структур, которые затем можно использовать с различными определенными видами данных. Давайте сначала посмотрим, как объявлять функции, структуры, перечисления и способы, используя обобщённые виды данных. Затем мы обсудим, как обобщённые виды данных влияют на производительность кода.

### В объявлении функций

Когда мы объявляем функцию с обобщёнными видами, мы размещаем обобщённые виды в ярлыке функции, где мы обычно указываем виды данных переменных и возвращаемого значения. Используя обобщённые виды, мы делаем код более гибким и предоставляем большую функциональность при вызове нашей функции, предотвращая повторение кода.

Рассмотрим пример с функцией `largest`. Приложение 10-4 показывает две функции, каждая из которых находит самое большое значение в срезе своего вида. Позже мы объединим их в одну функцию, использующую обобщённые виды данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

<span class="caption">Приложение 10-4: две функции, отличающиеся только именем и видом обрабатываемых данных</span>

Функция `largest_i32` уже встречалась нам: мы извлекли её в приложении 10-3, когда боролись с повторением кода — она находит наибольшее значение вида `i32` в срезе. Функция `largest_char` находит самое большое значение вида `char` в срезе. Тело у этих функций одинаковое, поэтому давайте избавимся от повторяемлшл кода, используя свойство обобщённого вида в одной функции.

Для свойствоизации видов данных в новой объявляемой функции нам нужно дать имя обобщённому виду — так же, как мы это делаем для переменных функций. Можно использовать любой определитель для имени свойства вида, но мы будем использовать `T`, потому что по соглашению имена свойств в Ржавчина должны быть короткими (обычно длиной в один символ), а именование видов в Ржавчина делается в наставлении UpperCamelCase. Сокращение слова «type» до одной буквы `T` является обычным выбором большинства программистов, использующих язык Rust.

Когда мы используем свойство в теле функции, мы должны объявить имя свойства в ярлыке, чтобы сборщик знал, что означает это имя. Подобно когда мы используем имя вида свойства в ярлыке функции, мы должны объявить это имя раньше, чем мы его используем. Чтобы определить обобщённую функцию `largest`, поместим объявление имён свойств в треугольные скобки `<>` между именем функции и списком свойств, как здесь:

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```

Объявление читается так: функция `largest` является обобщённой по виду `T`. Эта функция имеет один свойство с именем `list`, который является срезом значений с видом данных `T`. Функция `largest` возвращает значение этого же вида `T`.

Приложение 10-5 показывает определение функции `largest` с использованием обобщённых видов данных в её ярлыке. Приложение также показывает, как мы можем вызвать функцию со срезом данных вида `i32` или `char`. Данный код пока не будет собираться, но мы исправим это к концу раздела.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

<span class="caption">Приложение 10-5: функция <code>largest</code>, использующая свойства обобщённого типа; пока ещё не собирается</span>

Если мы соберем программу сейчас, мы получим следующую ошибку:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

В подсказке упоминается `std::cmp::PartialOrd`, который является *типажом*. Мы поговорим про типажи в следующем разделе. Сейчас ошибка в функции `largest` указывает, что функция не будет работать для всех возможных видов `T`. Так как мы хотим сравнивать значения вида `T` в теле функции, мы можем использовать только те виды, данные которых можно упорядочить: можем упорядочить — значит, можем и сравнить. Чтобы можно было задействовать сравнения, обычная библиотека имеет типаж `std::cmp::PartialOrd`, который вы можете реализовать для видов (смотрите дополнение С для большей сведений про данный типаж). Следуя совету в сообщении сборщика, ограничим вид `T` теми вариантами, которые поддерживают типаж `PartialOrd`, и тогда пример успешно  ссобирается, так как обычная библиотека реализует `PartialOrd` как для вида `i32`, так и для вида `char`.

### В определении структур

Мы также можем определить структуры, использующие обобщённые виды в одном или нескольких своих полях, с помощью правил написания `<>`. Приложение 10-6 показывает, как определить структуру `Point<T>`, чтобы хранить поля координат `x` и `y` любого вида данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

<span class="caption">Приложение 10-6: структура <code>Point</code>, содержащая поля <code>x</code> и <code>y</code> вида <code>T</code></span>

правила написания использования обобщённых видов в определении структуры очень похож на правила написания в определении функции. Сначала мы объявляем имена видов свойств внутри треугольных скобок сразу после названия структуры. Затем мы можем использовать обобщённые виды в определении структуры в тех местах, где ранее мы указывали бы определенные виды.

Так как мы используем только один обобщённый вид данных для определения структуры `Point<T>`, это определение означает, что структура `Point<T>` является обобщённой с видом `T`, и <em>оба</em> поля `x` и <code>y</code> имеют одинаковый вид, каким бы он не являлся. Если мы создадим образец структуры `Point<T>` со значениями разных видов, как показано в приложении 10-7, наш код не ссобирается.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

<span class="caption">Приложение 10-7: поля <code>x</code> и <code>y</code> должны быть одного вида, так как они имеют один и тот же обобщённый вид <code>T</code></span>

В этом примере, когда мы присваиваем целочисленное значение 5 переменной `x` , мы сообщаем сборщику, что обобщённый вид `T` будет целым числом для этого образца `Point<T>`. Затем, когда мы указываем значение 4.0 (имеющее вид, отличный от целого числа) для `y`, который по нашему определению должен иметь тот же вид, что и `x`, мы получим ошибку несоответствия видов:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

Чтобы определить структуру `Point`, где оба значения `x` и `y` являются обобщёнными, но различными видами, можно использовать несколько свойств обобщённого вида. Например, в приложении 10-8 мы изменим определение `Point` таким образом, чтобы оно использовало обобщённые виды `T` и `U`, где `x` имеет вид `T` а `y` имеет вид `U`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

<span class="caption">Приложение 10-8: структура <code>Point&lt;T, U&gt;</code> обобщена для двух видов, так что <code>x</code> и <code>y</code> могут быть значениями разных видов</span>

Теперь разрешены все показанные образцы вида `Point`! В объявлении можно использовать сколь угодно много свойств обобщённого вида, но если делать это в большом количестве, код будет тяжело читать. Если в вашем коде требуется много обобщённых видов, возможно, стоит разбить его на более мелкие части.

### В определениях перечислений

Как и структуры, перечисления также могут хранить обобщённые виды в своих вариантах. Давайте ещё раз посмотрим на перечисление `Option<T>`, предоставленное встроенной библиотекой, которое мы использовали в главе 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Это определение теперь должно быть вам более понятно. Как видите,  перечисление `Option<T>` является обобщённым по виду `T` и имеет два варианта: вариант `Some`, который содержит одно значение вида `T`, и вариант `None`, который не содержит никакого значения. Используя перечисление `Option<T>`, можно выразить абстрактную подход необязательного значения — и так как `Option<T>` является обобщённым, можно использовать эту абстракцию независимо от того, каким будет вид необязательного значения.

Перечисления также могут использовать несколько обобщённых видов. Определение перечисления `Result`, которое мы упоминали в главе 9, является примером такого использования:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Перечисление `Result` имеет два обобщённых вида: `T` и `E` — и два варианта:  `Ok`, который содержит вид `T`, и `Err`, содержащий вид `E`. С таким определением удобно использовать перечисление `Result` везде, где действия могут быть выполнены успешно (возвращая значение вида `T`) или неуспешно (возвращая ошибку вида `E`). Это то, что мы делали при открытии файла в приложении 9-3, где `T` заполнялось видом `std::fs::File`, если файл был открыт успешно, либо `E` заполнялось видом  `std::io::Error`, если при открытии файла возникали какие-либо сбоев.

Если вы встречаете в коде случаи, когда несколько определений структур или перечислений отличаются только видами содержащихся в них значений, вы можете устранить повторение, используя обобщённые виды.

### В определении способов

Мы можем реализовать способы для структур и перечислений (как мы делали в главе 5) и в определениях этих способов также использовать обобщённые виды. В приложении 10-9 показана структура `Point<T>`, которую мы определили в приложении 10-6, с добавленным для неё способом `x`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

<span class="caption">Приложение 10-9: Реализация способа с именем <code>x</code> у структуры <code>Point&lt;T&gt;</code>, которая будет возвращать ссылку на поле <code>x</code> вида <code>T</code></span>

Здесь мы определили способ с именем `x` у структуры `Point<T>`, который возвращает ссылку на данные в поле `x`.

Обратите внимание, что мы должны объявить `T` сразу после `impl` .  В этом случае мы можем использовать `T` для указания на то, что реализуем способ для вида `Point<T>`. Объявив `T` гибким видом сразу после `impl` , Ржавчина может определить, что вид в угловых скобках в `Point` является гибким, а не определенным видом. Мы могли бы выбрать другое имя для этого обобщённого свойства, отличное от имени, использованного в определении структуры, но обычно используют одно и то же имя. Способы, написанные внутри раздела `impl` , который использует обобщённый вид, будут определены для любого образца вида, независимо от того, какой определенный вид в конечном итоге будет подставлен вместо этого обобщённого.

Мы можем также указать ограничения, какие обобщённые виды разрешено использовать при определении способов. Например, мы могли бы реализовать способы только для образцов вида `Point<f32>`, а не для образцов `Point<T>`, в которых используется произвольный обобщённый вид. В приложении 10-10 мы используем определенный вид `f32`, что означает, что мы не определяем никакие виды после `impl`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

<span class="caption">Приложение 10-10: раздел<code>impl</code>, который применяется только к структуре, имеющей определенный вид для свойства обобщённого вида <code>T</code></span>

Этот код означает, что вид `Point<f32>` будет иметь способ с именем `distance_from_origin`, а другие образцы `Point<T>`, где `T` имеет вид, отличный от `f32`, не будут иметь этого способа. Способ вычисляет, насколько далеко наша точка находится от точки с координатами (0.0, 0.0), и использует математические действия, доступные только для видов с плавающей точкой.

Свойства обобщённого вида, которые мы используем в определении структуры, не всегда совпадают с подобиями, использующимися в ярлыках способов этой структуры. Чтобы пример был более очевидным, в приложении 10-11 используются обобщённые виды `X1` и `Y1` для определения структуры `Point` и виды `X2` `Y2` для ярлыки способа `mixup`. Способ создаёт новый образец структуры `Point`, где значение `x` берётся из `self` `Point` (имеющей вид `X1`), а значение `y` - из переданной структуры `Point` (где эта переменная имеет вид `Y2`).

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

<span class="caption">Приложение 10-11: способ, использующий обобщённые виды, отличающиеся от видов, используемых в определении структуры</span>

В функции `main` мы определили вид `Point`, который имеет вид `i32` для `x` (со значением `5` ) и вид `f64` для `y` (со значением `10.4`). Переменная `p2` является структурой `Point`, которая имеет строковый срез для `x` (со значением `«Hello»`) и `char` для `y` (со значением `c`). Вызов `mixup` на `p1` с переменнаяом `p2` создаст для нас образец структуры `p3`, который будет иметь вид `i32` для `x` (потому что `x` взят из `p1`). Переменная `p3` будет иметь вид `char`  для  `y` (потому что `y` взят из `p2`). Вызов макроса `println! ` выведет `p3.x = 5, p3.y = c`.

Цель этого примера — отобразить случай, в которой некоторые обобщённые свойства объявлены с помощью `impl`, а некоторые объявлены в определении способа. Здесь обобщённые свойства `X1` и `Y1` объявляются после `impl`, потому что они относятся к определению структуры. Обобщённые свойства `X2` и `Y2` объявляются после `fn mixup`, так как они относятся только к способу.

### Производительность кода, использующего обобщённые виды

Вы могли бы задаться вопросом, возникают ли какие-нибудь дополнительные издержки при использовании свойств обобщённого вида. Хорошая новость в том, что при использовании обобщённых видов ваша программа работает ничуть ни медленнее, чем если бы она работала с использованием определенных видов.

В Ржавчина это достигается во время сборки при помощи мономорфизации кода, использующего обобщённые виды. *Мономорфизация* — это этап превращения обобщённого кода в определенный код путём подстановки определенных видов, использующихся при сборки. В этом этапе сборщик выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой функции в приложении 10-5: он просматривает все места, где вызывается обобщённый код, и генерирует код для определенных видов, использовавшихся для вызова в обобщённом.

Давайте посмотрим, как это работает при использовании перечисления `Option<T>` из встроенной библиотеки:

```rust
let integer = Some(5);
let float = Some(5.0);
```

Когда Ржавчина собирает этот код, он выполняет мономорфизацию. Во время этого этапа сборщик считывает значения, которые были использованы в образцах `Option<T>`, и определяет два вида `Option<T>`: один для вида `i32`, а другой — для `f64`. Таким образом, он разворачивает обобщённое определение `Option<T>` в два определения, именно для `i32` и `f64`, тем самым заменяя обобщённое определение определенными.

Мономорфизированная исполнение кода выглядит примерно так (сборщик использует имена, отличные от тех, которые мы используем здесь для отображения):

<span class="filename">Файл: src/main.rs</span>

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

Обобщённое `Option<T>` заменяется определенными определениями, созданными сборщиком. Поскольку Ржавчина собирает обобщённый код в код, определяющий вид в каждом образце, мы не платим за использование обобщённых видов во время выполнения. Когда код запускается, он работает точно так же, как если бы мы сделали повторение каждое определение вручную. Этап мономорфизации делает обобщённые виды Ржавчина чрезвычайно эффективными во время выполнения.


