## Возможность опровержения: может ли образец не совпадать

Образцы бывают двух видов: опровержимые и неопровержимые. Образцы, которые будут соответствовать любому возможному переданному значению, являются *неопровержимыми* (irrefutable). Примером может быть `x` в указания `let x = 5;`, потому что `x` соответствует чему-либо и, следовательно, не может не совпадать. Образцы, которые могут не соответствовать некоторому возможному значению, являются *опровержимыми* (refutable). Примером может быть `Some(x)` в выражении `if let Some(x) = a_value`, потому что если значение в переменной `a_value` равно `None`, а не `Some`, то образец `Some(x)` не будет совпадать.

Свойства функций, указания `let` и циклы `for` могут принимать только неопровержимые образцы, поскольку программа не может сделать ничего значимого, если значения не совпадают. А выражения `if let` и `while let` принимают опровержимые и неопровержимые образцы, но сборщик предостерегает от неопровержимых образцов, поскольку по определению они предназначены для обработки возможного сбоя: возможность условного выражения заключается в его способности выполнять разный код в зависимости от успеха или неудачи.

В общем случае, вам не нужно беспокоиться о разнице между опровержимыми (refutable) и неопровержимыми (irrefutable) образцами; тем не менее, вам необходимо ознакомиться с подходом возможности опровержения, чтобы вы могли отреагировать на неё, увидев в сообщении об ошибке. В таких случаях вам потребуется изменить либо образец, либо устройство, с которой вы используете образец, в зависимости от предполагаемого поведения кода.

Давайте посмотрим на пример того, что происходит, когда мы пытаемся использовать опровержимый образец, где Ржавчина требует неопровержимый образец, и наоборот. В приложении 18-8 показана указание `let`, но для образца мы указали `Some(x)`, являющийся образцом, который можно опровергнуть. Как и следовало ожидать, этот код не будет собираться.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-08/src/main.rs:here}}
```

<span class="caption">Приложение 18-8: Попытка использовать опровержимый образец вместе с <code>let</code></span>

Если `some_option_value` было бы значением `None`, то оно не соответствовало бы образцу `Some(x)`, что означает, что образец является опровержимым. Тем не менее, указание `let` может принимать только неопровержимый образец, потому что нет правильного кода, который может что-то сделать со значением `None`. Во время сборки Ржавчина будет жаловаться на то, что мы пытались использовать опровержимый образец, для которого требуется неопровержимый образец:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-08/output.txt}}
```

Поскольку мы не покрыли (и не могли покрыть!) каждое допустимое значение с помощью образца `Some(x)`, то Ржавчина выдаёт ошибку сборки.

Чтобы исправить неполадку наличия опровержимого образца, там, где нужен неопровержимый образец, можно изменить код, использующий образец: вместо использования `let`, можно использовать `if let`. Затем, если образец не совпадает, выполнение кода внутри фигурных скобок будет пропущено, что даст возможность продолжить правильное выполнение. В приложении 18-9 показано, как исправить код из приложения 18-8.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-09/src/main.rs:here}}
```

<span class="caption">Приложение 18-9. Использование <code>if let</code> и раздела с опровергнутыми образцами вместо <code>let</code></span>

Код исправлен! Этот код совершенно правильный, хотя это означает, что мы не можем использовать неопровержимый образец без получения ошибки. Если мы используем образец `if let`, который всегда будет совпадать, то для примера `x`, показанного в приложении 18-10, сборщик выдаст предупреждение.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-10/src/main.rs:here}}
```

<span class="caption">Приложение 18-10. Попытка использовать неопровержимый образец с <code>if let</code></span>

Rust жалуется, что не имеет смысла использовать `if let` с неопровержимым образцом:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-10/output.txt}}
```

По этой причине совпадающие ветки выражений должны использовать опровержимые образцы, за исключением последнего, который должен сопоставлять любые оставшиеся значения с неопровержимым образцом. Ржавчина позволяет нам использовать неопровержимый образец в `match` только с одной веткой, но этот правила написания не особенно полезен и может быть заменён более простой указанием `let`.

Теперь, когда вы знаете, где использовать образцы и разницу между опровержимыми и неопровержимыми образцами, давайте рассмотрим весь правила написания, который мы можем использовать для создания образцов.
