## Функции

Функции широко распространены в рукописи Ржавчина. Вы уже познакомились с одной из самых важных функций в языке: функцией `main`, которая является точкой входа большинства программ. Вы также видели ключевое слово `fn`, позволяющее объявлять новые функции.

Рукопись Ржавчина использует *змеиный регистр (snake case)* как основной исполнение для имён функций и переменных, в котором все буквы строчные, а знак подчёркивания разделяет слова. Вот программа, содержащая пример определения функции:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

Для определения функции в Ржавчине необходимо указать `fn`, за которым следует имя функции и набор круглых скобок. Фигурные скобки указывают сборщику, где начинается и заканчивается тело функции.

Мы можем вызвать любую функцию, которую мы определили ранее, введя её имя и набор скобок следом. Поскольку в программе определена `another_function`, её можно вызвать из функции `main`. Обратите внимание, что `another_function` определена *после* функции `main` в исходном рукописи; мы могли бы определить её и раньше. Ржавчина не важно, где вы определяете свои функции, главное, чтобы они были определены где-то в той области видимости, которую может видеть вызывающий их рукопись.

Создадим новый двоичный дело с названием *functions* для дальнейшего изучения функций. Поместите пример `another_function` в файл *src/main.rs* и запустите его. Вы должны увидеть следующий вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

Строки выполняются в том порядке, в котором они расположены в функции `main`. Сначала печатается сообщение "Hello, world!", а затем вызывается `another_function`, которая также печатает сообщение.

### Свойства функции

Мы можем определить функции, имеющие *свойства*, которые представляют собой особые переменные, являющиеся частью ярлыки функции. Когда у функции есть свойства, необходимо предоставить ей определенные значения этих свойств. Технически определенные значения называются *переменные*, но в повседневном общении люди обычно используют слова *свойство* и *переменная* как взаимозаменяемые либо для переменных в определении функции, либо для определенных значений, передаваемых при вызове функции.

В этой исполнения `another_function` мы добавляем свойство:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

Попробуйте запустить эту программу. Должны получить следующий итог:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

Объявление `another_function` содержит один свойство с именем `x`. Вид `x` задан как `i32`. Когда мы передаём `5` в `another_function`, макрос `println!` помещает `5` на место пары фигурных скобок, содержащих `x` в строке вида.

В ярлыках функций вы *обязаны* указывать вид каждого свойства. Это намеренное решение во внешнем виде Ржавчины: требование наставлений видов в определениях функций позволяет сборщику в дальнейшем избежать необходимости использовать их в других местах рукописи, чтобы определить, какой вид вы имеете в виду. Сборщик также может выдавать более полезные сообщения об ошибках, если он знает, какие виды ожидает функция.

При определении нескольких свойств, разделяйте объявления свойств запятыми, как показано ниже:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

Этот пример создаёт функцию под именем `print_labeled_measurement` с двумя свойствами. Первый свойство называется `value` с видом `i32`. Второй называется `unit_label` и имеет вид `char`. Затем функция печатает текст, содержащий `value` и `unit_label`.

Попробуем запустить этот рукопись. Замените текущую программу дела *functions* в файле *src/main.rs* на предыдущий пример и запустите его с помощью `cargo run`:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

Поскольку мы вызвали функцию с `5` в качестве значения для `value` и `'h'` в качестве значения для `unit_label`, вывод программы содержит эти значения.

### Указания и выражения

Тела функций состоят из ряда указаний, необязательно заканчивающихся выражением. До сих пор функции, которые мы рассматривали, не включали завершающее выражение, но вы видели выражение как часть указания. Поскольку Ржавчина является языком, основанным на выражениях, это важное различие необходимо понимать. В других языках таких различий нет, поэтому давайте рассмотрим, что такое указания и выражения, и как их различия влияют на тела функций.

- **Указания** выполняют какое-либо действие и не возвращают значения.
- **Выражения** вычисляются до результирующего значения. Давайте рассмотрим несколько примеров.

На самом деле мы уже использовали указания и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова `let` является приказчиком. В Приложении 3-1, `let y = 6;` — это указание.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

<span class="caption">Приложение 3-1: Объявление функции <code>main</code>, содержащей одну указанию</span>

Определения функций также являются указанием. Весь предыдущий пример сам по себе является указанием.

Указания не возвращают значения. Следовательно вы не можете присвоить `let` указанию другой переменной, как это пытается сделать следующий рукопись. Вы получите ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

Если вы запустите эту программу, то ошибка будет выглядеть так:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

Указание `let y = 6` не возвращает значение, поэтому не с чем связать переменную `x`. Это отличается от поведения в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В таких языках можно писать рукопись `x = y = 6` и обе переменные `x` и `y` будут иметь значение `6`. Но в Ржавчине не так.

Выражения вычисляют значение и составляют большую часть остального рукописи, который вы напишете на Ржавчине. Рассмотрим математическую действие, к примеру `5 + 6`, которая является выражением, вычисляющим значение `11`. Выражения могут быть частью указаний: в приложении 3-1 `6` в указания `let y = 6;` является выражением, которое вычисляется в значение `6`. Вызов функции — это выражение. Вызов макроса — это выражение. Новый разделобласти видимости, созданный с помощью фигурных скобок, представляет собой выражение, например:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

Это выражение:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

это раздел, который в данном случае вычисляется в значение `4`. Это значение связывается с `y` как часть указания `let`. Обратите внимание, что строка `x + 1` не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения не содержат завершающих точек с запятой. Если вы добавите точку с запятой в конец выражения, вы превратите его в указанию, и тогда она не будет возвращать значение. Помните об этом, когда будете изучать возвращаемые значения функций и выражения.

### Функции с возвращаемыми значениями

Функции могут возвращать значения рукописи, который их вызывает. Мы не называем возвращаемые значения, но мы должны объявить их вид после стрелки ( `->` ). В Ржавчине возвращаемое значение функции является родственным значения конечного выражения в разделе тела функции. Вы можете раньше выйти из функции и вернуть значение, используя ключевое слово `return` и указав значение, но большинство функций неявно возвращают последнее выражение. Вот пример такой функции:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

В рукописи функции `five` нет вызовов функций, макросов или даже указаний  `let` — есть только одно число `5`. Это является безусловно правильной функцией в Ржавчине. Заметьте, что возвращаемый вид у данной функции определён как `-> i32`. Попробуйте запустить этот рукопись. Вывод будет таким:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

Значение `5` в `five` является возвращаемым функцией значением, поэтому возвращаемый вид - `i32`. Рассмотрим пример более подробно. Здесь есть два важных особенности: во-первых, строка `let x = five();` показывает использование возвращаемого функцией значения для объявления переменной. Так как функция `five` возвращает `5`, то эта строка эквивалентна следующей:

```rust
let x = 5;
```

Во-вторых, у функции `five` нет свойств и определён вид возвращаемого значения, но тело функции представляет собой одинокую `5` без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.

Рассмотрим другой пример:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

Запуск рукописи напечатает `The value of x is: 6`. Но если поставить точку с запятой в конце строки, содержащей `x + 1`, превратив её из выражения в указанию, мы получим ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

Сборка данного рукописи вызывает следующую ошибку:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

Основное сообщение об ошибке, `несовпадение видов`, раскрывает ключевую неполадку этого рукописи. Определение функции `plus_one` сообщает, что будет возвращено `i32`, но указания не вычисляются в значение, что и выражается единичным видом `()`. Следовательно, ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Ржавчина выдаёт сообщение, которое, возможно, поможет исправить эту неполадку: он предлагает удалить точку с запятой для устранения ошибки.
