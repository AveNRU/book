# Программируем игру в загадки

Давайте окунёмся в Ржавчине, вместе поработав над опытным делом! В этой главе вы познакомитесь с несколькими общими подходами Ржавчина показав, как использовать их в существующей программе. Вы узнаете о `let` , `match`, способах, сопряженных функциях, внешних дополнениях и многом другом! В следующих главах мы рассмотрим эти мысли более подробно. В этой главе вы просто примените в основах.

Мы выполняем привычную для начинающих программистов задачу — игру в загадки. Вот как это работает: программа порождает случайное целое число в ряде от 1 до 100. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра выведет поздравительное сообщение и завершится.

## Настройка нового дела

Для настройки нового дела перейдите в папку *projects*, которую вы создали в главе 1, и создайте новое дело с использованием Cargo, как показано ниже:

```console
$ cargo new guessing_game
$ cd guessing_game
```

Первый приказ, `cargo new`, принимает в качестве первой переменной имя дела (`guessing_game`). Второй приказ изменяет папку на новую папку дела.

Загляните в созданный файл *Cargo.toml*:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

Как вы уже видели в главе 1, `cargo new` создаёт программу «Hello, world!». Посмотрите файл *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

Теперь давайте соберем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью приказов `cargo run`:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

Приказ `run` пригодится, когда необходимо ускоренно выполнить повторение дела. Именно так мы собираемся делать в этом деле, быстро проверяя каждую повторение, прежде чем перейти к следующей.

Снова откройте файл *src/main.rs*. всю рукопись вы будете писать в нем.

## Обработка догадки

Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой виде. Начнём с того, что позволим игроку ввести догадку. Вставьте рукопись из приложения 2-1 в *src/main.rs*.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

<span class="caption">Приложение 2-1: рукопись, который получает догадку от пользователя и выводит её на экран</span>

Эта рукопись содержит много сведений, поэтому давайте рассмотрим его построчно. Чтобы получить пользовательский ввод и затем вывести итог, нам нужно включить в область видимости библиотеку ввода/вывода `io`. Библиотека `io` является частью встроенной библиотеки, известной как `std`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

По умолчанию в Ржавчине есть набор элементов, определённых в встроенной библиотеке, которые он добавляет в область видимости каждой программы. Этот набор называется *прелюдией*, и вы можете изучить его содержание [в пособия встроенной библиотеки].

Если вид, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью приказчика `use`. Использование библиотеки `std::io` предоставляет ряд полезных полезных возможностей, включая способность принимать пользовательский ввод.

Как уже отмечалось в главе 1, функция `main` является точкой входа в программу:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

Ключевое слово `fn` объявляет новую функцию, круглые скобки `()` показывают, что у функции нет входных свойств, узорчатая скобка `{` - обозначение начала тела функции.

Также в главе 1 упоминалось, что `println!` — это макрос, который выводит строку на экран:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

Эта рукопись показывает сведения о ходе игры и запрашивает пользовательский ввод.

### Хранение значений с помощью переменных

Далее мы создаём *переменную* для хранения пользовательского ввода, как показано ниже:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

Вот теперь программа становится важнее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем приказчик `let`. Вот ещё один пример:

```rust,ignore
let apples = 5;
```

Эта строка создаёт новую переменную с именем `apples` и привязывает её к значению 5. В Ржавчине переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту подход в разделе ["Переменные и изменчивость".]<!-- ignore --> в главе 3. Чтобы сделать переменную изменяемой, мы добавляем `mut` перед её именем:

```rust,ignore
let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая
```

>  Примечание: сочетание знаков `//` начинает примечание, который продолжается до конца строки. Ржавчина пренебрегает всё, что находится в примечаниях. Мы обсудим примечания более подробно в [Главе 3]<!-- ignore -->.
>

Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что `let mut guess` предоставит изменяемую переменную с именем `guess`. Знак равенства (`=`) сообщает Ржавчина что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с `guess`, которое является итогом вызова функции `String::new`, возвращающей новый образец `String`. <a data-md-type="raw_html" href="../std/string/struct.String.html">`String`</a> — это вид строки, предоставляемый встроенной библиотекой, который является расширяемым отрывком писания в представлении UTF-8.

Правила написания `::` в строке `::new` указывает, что `new` является сопряженной функцией вида `String`. *Сопряженная функция* — это функция, выполненная для вида, в данном случае `String`. Функция `new` создаёт новую пустую строку. Функцию `new` можно встретить во многих видах, это привычное название для функции, которая создаёт новое значение какого-либо вида.

В конечном итоге строка `let mut guess = String::new();` создала изменяемую переменную, которая связывается с новым пустым образцом `String`. Фух!

### Получение пользовательского ввода

Напомним: мы подключили возможность ввода/вывода из встроенной библиотеки с помощью `use std::io;` в первой строке программы. Теперь мы вызовем функцию `stdin` из звена `io`, которая позволит нам обрабатывать пользовательский ввод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

Если бы мы не подключили библиотеку `io` с помощью `use std::io` в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как `std::io::stdin`. Функция `stdin` возвращает образец [`std::io::Stdin`], который является видом, представляющим указатель принятого ввода для вашего окна вызова.

Далее строка `.read_line(&mut guess)` вызывает способ [`read_line`] на указателе принятого ввода для получения ввода от пользователя. Мы также передаём `&mut guess` в качестве переменной `read_line`, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача `read_line` — принять все, что пользователь вводит в обычный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве переменной. Строковый переменная должен быть изменяемым, чтобы способ мог изменить содержимое строки.

Знак `&` указывает, что этот переменная является *ссылкой*, которая предоставляет возможность нескольким частям вашей рукописи получить доступ к одному отрывку данных без необходимости воспроизводить эти данные в память несколько раз. Ссылки — это сложная полезная возможность, а одним из главных преимуществ Ржавчине является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать `&mut guess`, а не `&guess`. (В главе 4 ссылки будут описаны более подробно).

<!-- Old heading. Do not remove or links may break. -->

<a id="handling-potential-failure-with-the-result-type"></a>

### Обработка возможного сбоя с помощью способа `Result`

Мы всё ещё работаем над этой строкой рукописи. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной разумной строки. Следующая часть — способ:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

Мы могли бы написать эту рукопись так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове способа с помощью правил написания `.method_name()` часто целесообразно вводить новую строку и другие пробельные знаки, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.

Как упоминалось ранее, `read_line` помещает всё, что вводит пользователь, в строку, которую мы ему передаём, но также возвращает значение `Result`. <a data-md-type="raw_html" href="../std/result/enum.Result.html">`Result`</a><!-- ignore --> — это [*перечисление*]<!-- ignore -->, часто называемое *enum*, то есть вид, который может находиться в одном из нескольких возможных состояний. Мы называем каждое такое состояние *исходом*.

В [Главе 6](ch06-00-enums.html) рассмотрим перечисления более подробно. Задачей видов `Result` является кодирование сведений для обработки ошибок.

Исходами `Result` являются `Ok` и `Err`. Исход `Ok` указывает, что действие завершилась успешно, а внутри `Ok` находится успешно созданное значение. Исход `Err` означает, что действие не удалась, а `Err` содержит сведения о причинах неудачи.

Значения вида `Result`, как и значения любого вида, имеют определённые для них способы. У образца `Result` есть [способ `expect`]<!-- ignore -->, который можно вызвать. Если этот образец `Result` является значением `Err`, `expect` вызовет сбой программы и отобразит сообщение, которое вы передали в качестве переменной. Если способ `read_line` возвращает `Err`, то это, скорее всего, итог ошибки основной операционной системы. Если образец `Result` является значением `Ok`, `expect` возьмёт возвращаемое значение, которое удерживает `Ok`, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.

Если не вызвать `expect`, программа собирается, но будет получено предупреждение:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Ржавчина предупреждает о неиспользованном значении `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим со сбоем завершить программу при возникновении сбоев, поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в [главе 9].

### Вывод значений с помощью заполнителей `println!`

Кроме закрывающей узорчатой скобки, в рукописи на данное мгновение есть ещё только одно место для обсуждения:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

Эта рукопись выводит строку, которая теперь содержит ввод пользователя. Набор узорчатых скобок `{}` является заполнителем: думайте о `{}` как о маленьких клешнях краба, которые удерживают значение на месте. При выводе значения переменной имя переменной может заключаться в узорчатые скобки. При выводе итога вычисления выражения поместите пустые узорчатые скобки в строку вида, затем после строки вида укажите список выражений, разделённых запятыми, которые будут выведены в каждом заполнителе пустой узорчатой скобки в том же порядке. вывод переменной и итога выражения одним вызовом `println!` будет выглядеть так:

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

Эта рукопись выведет `x = 5 and y + 2 = 12`.

### Проверка первой части

Давайте проверим первую часть игры. Запустите её используя `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем выводим его.

## Создание тайного числа

Далее нам нужно создать тайное число, которое пользователь попытается угадать. Тайное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в ряде от 1 до 100, чтобы игра не была слишком сложной. Ржавчина пока не включает возможность случайных чисел в свою обычную библиотеку. Однако приказ Ржавчина предоставляет [ящик `rand`] с подобной возможностью.

### Использование ящика для получения дополнительного возможностей

Помните, что дополнение (crate) - это собрание файлов исходного рукописи Ржавчины. Дело, создаваемый нами, представляет собой <br> <em>двоичный дополнение (binary crate)</em>, который является исполняемым файлом. Дополнение <code>rand</code> - это <em>библиотечный дополнение (library crate)</em>, содержащий рукопись, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.

Согласование работы внешних дополнений является тем местом, где Cargo на самом деле блистает. Чтобы начать писать рукопись, использующий `rand`, необходимо изменить файл *Cargo.toml*, включив в него в качестве зависимости дополнение `rand`. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком разделы `[dependencies]`, созданным для вас Cargo. Обязательно укажите `rand` в точности так же, как здесь, с таким же номером исполнения, иначе примеры рукописи из этого урока могут не заработать.

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Имя файла: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:8:}}
```

В файле *Cargo.toml* всё, что следует за заголовком, является частью этой разделы, которая продолжается до тех пор, пока не начнётся следующая. В `[dependencies]` вы сообщаете Cargo, от каких внешних ящиков зависит ваш дело и какие исполнения этих ящиков вам нужны. В этом случае мы указываем ящик `rand` со определетелем смысловой исполнения `0.8.5`. Cargo понимает [смысловое управление исполнениями] (иногда называемое *SemVer*), которое является исполнением для описания исполнений. Число `0.8.5` на самом деле является сокращением от `^0.8.5`, что означает любую исполнение не ниже <code>0.8.5</code>, но ниже <code>0.9.0</code>.

Cargo рассчитывает, что эти исполнения имеют общедоступное API, совместимое с исполнением <code>0.8.5</code>, и вы получите последние исполнения исправлений, которые по-прежнему будут собираться с рукописью из этой главы. Не обеспечивается, что исполнение <code>0.9.0</code> или выше будет иметь тот же API, что и в следующих примерах.

Теперь, не меняя ничего в рукописи, давайте соберём дело, как показано в приложении 2-2.

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->

```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```

<span class="caption">Приложение 2-2: итог выполнения <code>cargo build</code> после добавления ящика rand в качестве зависимости</span>

Вы можете увидеть другие номера исполнений (но все они будут совместимы с рукописью благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.

Когда мы включаем внешнюю зависимость, Cargo берет последние исполнения всего, что нужно этой зависимости, из *реестра (registry)*, который является повтором данных с [Crates.io]. Crates.io — это место, где участники внутреннего устройства Ржавчина размещают свои дела с открытым исходной рукописью для использования другими.

После обновления реестра Cargo проверяет раздел `[dependencies]` и загружает все указанные в списке дополнения, которые ещё не были загружены. В нашем случае, хотя мы указали только `rand` в качестве зависимости, Cargo также захватил другие дополнения, от которых зависит работа `rand`. После загрузки дополнений Ржавчины собирает их, а затем собирает дело с имеющимися зависимостями.

Если сразу же запустить `cargo build` снова, не внося никаких изменений, то кроме строки `Finished` вы не получите никакого вывода. Cargo знает, что он уже загрузил и собрал зависимости, и вы не вносили никаких изменений в файл *Cargo.toml*. Cargo также знает, что вы ничего не изменили в своей рукописи, поэтому он не пересоберет и его. Если делать нечего, он просто завершает работу.

Если вы откроете файл *src/main.rs*, внесёте обыкновенное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле *src/main.rs*. Ваши зависимости не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и собрано для них.

#### Обеспечение воспроизводимых сборок с помощью файла *Cargo.lock*

В Cargo есть рычаг, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает вашу рукопись. Пока вы не укажете обратное, Cargo будет использовать только те исполнения зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит исполнение 0.8.6 дополнения `rand` , и она содержит важное исправление ошибки, но также отступление, которое может сломать вашу рукопись. Чтобы справиться с этим, Ржавчина создаёт файл *Cargo.lock* при первом запуске `cargo build`, поэтому теперь он есть в папке *guessing_game*.

Когда вы создаёте дело в первый раз, Cargo определяет все исполнения зависимостей, которые соответствуют условиям, а затем записывает их в файл *Cargo.lock*. Когда вы будете собирать свой дело в будущем, Cargo увидит, что файл *Cargo.lock* существует, и будет использовать указанные там исполнения, а не выполнять всю работу по выяснению исполнений заново. Это позволяет самостоятельно создавать воспроизводимую сборку. Другими словами, ваш дело останется на <code>0.8.5</code> до тех пор, пока вы явно не обновите его благодаря файлу *Cargo.lock*. Поскольку файл <em>Cargo.lock</em> важен для воспроизводимых сборок, он часто хранится в системе управления исполнениями вместе с остальным рукописью дела.

#### Обновление дополнения для получения нового исполнения

Если вы *захотите* обновить дополнение, Cargo предоставляет приказ `update`, которая пренебрегает файл *Cargo.lock* и определяет последние исполнения, соответствующие вашим согласно принятых требованийм из файла *Cargo.toml*. После этого Cargo запишет эти исполнения в файл *Cargo.lock*. Иначе по умолчанию Cargo будет искать только исполнения больше 0.8.5, но при этом меньше 0.9.0. Если дополнение <code>rand</code> имеет две новые исполнения — 0.8.6 и 0.9.0 — то при запуске <code>cargo update</code> вы увидите следующее:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```console
$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -> v0.8.6
```

Cargo пренебрегает исполнение 0.9.0. В этот мгновение также появится изменение в файле *Cargo.lock*, указывающее на то, что исполнение `rand`, которая теперь используется, равна 0.8.6. Чтобы использовать `rand` исполнения 0.9.0 или любой другой исполнения из последовательности 0.9.*x*, необходимо обновить файл *Cargo.toml* следующим образом:

```toml
[dependencies]
rand = "0.9.0"
```

В следующий раз, при запуске `cargo build`, Cargo обновит реестр доступных дополнений и пересмотрит ваши требования к `rand` в соответствии с новой исполнением, которую вы указали.

Можно много рассказать про [Cargo]<!-- ignore --> и [его внутреннее устройство]<!-- ignore --> которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Ржавчина разработчики имеют возможность писать меньшие дела, которые составлены из многих дополнений.

### Создание случайного числа

Давайте начнём использовать `rand`, чтобы создать число для угадывания. Следующим шагом будет обновление *src/main.rs*, как показано в приложении 2-3.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}
```

<span class="caption">Приложение 2-3: Добавление рукописи который порождает случайное число</span>

Сначала мы добавляем строку `use rand::Rng`. Сущность `Rng` определяет способы, выполняющие породители случайных чисел, и эту особенность должен быть в области видимости, чтобы эти способы можно было использовать. В главе 10 мы рассмотрим особенности подробно.

Затем мы добавляем две строки посередине. В первой строке мы вызываем функцию `rand::thread_rng`, дающую нам породитель случайных чисел, который мы собираемся использовать: тот самый, который является местным для текущего потока выполнения и запускается операционной системой. Затем мы вызываем его способ `gen_range`. Этот способ определяется `Rng`, который мы включили в область видимости с помощью приказчика `use rand::Rng`. Способ `gen_range` принимает в качестве переменной выражение ряда и порождает случайное число в этом ряде. Вид используемого выражения ряда принимает разновидность `start..=end` и включает нижнюю и верхнюю границы, поэтому, чтобы запросить число от 1 до 100, нам нужно указать `1..=100`.

> Примечание: непросто сразу разобраться, какие особенности использовать, какие способы и функции вызывать из дополнения, поэтому каждый дополнение имеет пособие с указаниями по его использованию. Ещё одной замечательной особенностью Cargo является выполнение приказы `cargo doc --open`, которая местно собирает пособие, предоставляемую всеми вашими зависимостями, и открывает её в обозревателе. К примеру, если важна другая возможность из дополнения `rand`, запустите `cargo doc --open` и нажмите `rand` в боковой панели слева.

Во второй новой строке мы увидим загаданное число. Во время разработки программы полезно иметь возможность её проверять, но в конечной исполнения мы это удалим. Конечно, ведь это совсем не похоже на игру, если программа выводит ответ сразу после запуска!

Попробуйте запустить программу несколько раз:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

Вы должны получить разные случайные числа, и все они должны быть числами в ряде от 1 до 100. Отличная работа!

## Сравнение догадки с тайным числом

Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем сравнить их. Этот шаг показан в приложении 2-4. Учтите, что эта рукопись ещё не собирается, подробнее мы объясним дальше.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}
```

<span class="caption">Приложение 2-4: Обработка возможных возвращаемых значений при сравнении двух чисел</span>

Сначала добавим ещё один приказчик `use`, который вводит способ с именем `std::cmp::Ordering` в область видимости из встроенной библиотеки. Способ `Ordering` является ещё одним перечислением и имеет исходы `Less`, `Greater` и `Equal`. Это три возможных исхода при сравнении двух величин.

После чего ниже добавляем пять новых строк, использующих вид `Ordering`. Способ `cmp` сравнивает два значения и может вызываться для всего, что можно сравнить. Он принимает ссылку на все, что требуется сравнить: здесь сравнивается `guess` с `secret_number`. В итоге возвращается исход перечисления `Ordering`, которое мы ввели в область видимости с помощью приказчика `use`. Для принятия решения о том, что делать дальше, мы используем выражение [`match`], определяющее, какой исход <code>Ordering</code> был возвращён из вызова `cmp` со значениями `guess` и `secret_number`.

Выражение `match` состоит из *веток (arms)*. Ветка состоит из *образца* для сопоставления и рукописи, которая будет запущен, если значение, переданное в `match`, соответствует образцу этой ветки. Ржавчина принимает значение, заданное `match`, и по очереди просматривает образец каждой ветки. Образцы и устройство `match` — это мощные возможности Ржавчины, позволяющие выразить множество случаев, с которыми может столкнуться ваша рукопись, и обеспечить их обработку. Эти возможности будут подробно раскрыты в главе 6 и главе 18 соответственно.

Давайте рассмотрим пример с выражением `match`, которое мы здесь используем. Скажем, пользователь угадал 50, а случайно созданное тайное число на этот раз — 38.

Когда рукопись сравнивает 50 с 38, способ `cmp` вернёт `Ordering::Greater`, поскольку 50 больше, чем 38. Выражение `match` получит значение `Ordering::Greater` и начнёт проверять образец в каждой ветке. Он просмотрит образец первой ветки, `Ordering::Less`, и увидит, что значение `Ordering::Greater` не соответствует `Ordering::Less`, поэтому пренебрегает рукопись этой ветки и перейдёт к следующей. Образец следующей ветки — `Ordering::Greater`, который *соответствует* `Ordering::Greater`! Рукопись этой ветки будет выполнен и выведет `Too big!` на экран. Выражение `match` заканчивается после первого успешного совпадения, поэтому в этом задумки оно не будет рассматривать последнюю ветку.

Однако рукопись в приложении 2-4 всё ещё не собирается. Давайте попробуем:

<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->

```console
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
```

Суть ошибки заключается в наличии *несовпадающих видов*. У Ржавчина строгая постоянная система видов. Однако в нем также есть рычаг вывода видов. Когда мы написали `let mut guess = String::new()`, Ржавчина смог сделать вывод, что `guess` должна быть `String` и не заставил указывать вид. С другой стороны, `secret_number` — это числовой вид. Несколько видов чисел в Ржавчине могут иметь значение от 1 до 100: `i32`, 32-битное число; `u32`, беззнаковое 32-битное число; `i64`, 64-битное число, и так далее. Если не указано иное, Ржавчина по умолчанию использует `i32`, который будет видом `secret_number`, если вы не добавите сведения о виде где-то ещё, чтобы заставить Ржавчина вывести другой числовой вид. Причина ошибки заключается в том, что Ржавчина не может сравнить строку и числовой вид.

В конечном итоге необходимо преобразовать `String`, считываемую программой в качестве входных данных, в существующий числовой вид, чтобы иметь возможность числового сравнения с загаданным числом. Для этого добавьте в тело функции `main` следующую строку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}
```

Вот эта строка:

```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

Мы создаём переменную с именем `guess`. Но подождите, разве в программе уже нет переменной с этим именем `guess`? Так и есть, но Ржавчина позволяет нам затенять предыдущее значение <code>guess</code> новым. <em>Затенение</em> позволяет нам повторно использовать имя переменной `guess`, чтобы избежать создания двух единственных переменных, таких как `guess_str` и `guess`, например. Мы рассмотрим это более подробно в главе 3, а пока знайте, что эта функция часто используется, когда необходимо преобразовать значение из одного вида в другой.

Мы связываем эту новую переменную с выражением `guess.trim().parse()`. Переменная `guess` в этом выражении относится к исходной переменной `guess`, которая содержала входные данные в виде строки. Способ `trim` на образце `String` удалит любые пробельные знаки в начале и конце строки для того, чтобы мы могли сопоставить строку с `u32`, который содержит только числовые данные. Пользователь должен нажать <span class="keystroke">enter</span>, чтобы выполнить `read_line` и ввести свою догадку, при этом в строку добавится знак новой строки. Например, если пользователь набирает <span class="keystroke">5</span> и нажимает <span class="keystroke">enter</span>, `guess` будет выглядеть так: `5\n`. Знак `\n` означает "новая строка". (В Windows нажатие <span class="keystroke">enter</span> сопровождается возвратом каретки и новой строкой, `\r\n`). Способ `trim` убирает `\n` или `\r\n`, оставляя только `5`.

Способ [`parse` строк]<!-- ignore --> преобразует строку в другой вид. Здесь мы используем его для преобразования строки в число. Нам нужно сообщить Ржавчина точный числовой вид, который мы хотим получить, используя `let guess: u32`. Двоеточие ( `:` ) после `guess` говорит Ржавчине, что мы определяем вид переменной. В Ржавчине есть несколько встроенных числовых видов; `u32`, показанный здесь, представляет собой 32-битное целое число без знака. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других видах чисел в главе 3.

Кроме того, изложение <code>u32</code> в этом примере программы и сравнение с <code>secret_number</code> означает, что Ржавчина сделает вывод, что <code>secret_number</code> должен быть <code>u32</code>. Итак, теперь сравнение будет между двумя значениями одного вида!

Способ `parse` будет работать только со знаками, которые разумно могут быть преобразованы в числа, и поэтому легко может вызвать ошибки. Если, например, строка содержит `A👍%`, преобразовать её в число невозможно. Так как способ `parse` может потерпеть неудачу, он возвращает вид `Result` — так же как и способ `read_line` (обсуждалось ранее в разделе <a data-md-type="raw_html" href="#handling-potential-failure-with-result">«Обработка возможной ошибки с помощью способа `Result`»</a>). Мы будем точно так же обрабатывать данный <code>Result</code>, вновь используя способ `expect`. Если `parse` вернёт исход `Result` `Err`, так как не смог создать число из строки, вызов `expect` со сбоем завершит игру и отобразит переданное ему сообщение. Если `parse` сможет успешно преобразовать строку в число, он вернёт исход `Result` `Ok`, а `expect` вернёт число, полученное из значения `Ok`.

Давайте запустим программу теперь:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Хорошо! Несмотря на то, что были добавлены пробелы в строке ввода, программа всё равно поняла, что пользователь имел в виду число 76. Запустите программу несколько раз, чтобы проверить разное поведение при различных видах ввода: задайте число правильно, задайте слишком большое число и задайте слишком маленькое число.

Сейчас у нас работает большая часть игры, но пользователь может сделать только одну догадку. Давайте изменим это, добавив круговорот!

## Возможность нескольких догадок с помощью круговоротов

Ключевое слово `loop` создаёт бесконечный круговорот. Мы добавляем круговорот, чтобы дать пользователям больше возможностей угадать число:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}
```

Как видите, мы переместили всё, начиная с подсказки ввода догадки, в круговорот. Не забудьте добавить ещё по четыре пробела на отступы строк внутри круговорота и запустите программу снова. Теперь программа будет бесконечно запрашивать ещё одну догадку, что в действительности создаёт новую неполадку. Похоже, пользователь не сможет выйти из игры!

Пользователь может прервать выполнение программы с помощью сочетания клавиш <span class="keystroke">ctrl+c</span>. Но есть и другой способ спастись от этого ненасытного монстра, о котором говорилось при обсуждении `parse` в [«Сравнение догадки с тайным числом»](#comparing-the-guess-to-the-secret-number): если пользователь введёт нечисловой ответ, программа завершится со сбоем. Мы можем воспользоваться этим, чтобы позволить пользователю выйти из игры, как показано здесь:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Ввод `quit` приведёт к выходу из игры, но, как вы заметите, так же будет и при любом другом нечисловом вводе. Однако это, мягко говоря, не разумно. Мы хотим, чтобы игра самостоятельно остановилась, когда будет угадано правильное число.

### Выход после правильной догадки

Давайте запрограммируем игру на выход при выигрыше пользователя, добавив приказчик `break`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}
```

Добавление строки `break` после `You win!` заставляет программу выйти из круговорота, когда пользователь правильно угадает тайное число. Выход из круговорота также означает выход из программы, так как круговорот является последней частью `main`.

### Обработка недопустимого ввода

Чтобы улучшить поведение игры, вместо со сбоем завершения программы, когда пользователь вводит не число, давайте заставим игру пренебрегать это обстоятельство, позволяя пользователю продолжить угадывание. Для этого необходимо изменить строку, в которой `guess` преобразуется из `String` в `u32`, как показано в приложении 2-5.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}
```

<span class="caption">Приложение 2-5. Пренебрежение нечисловой догадки и запрос другой догадки вместо завершения программы</span>

Мы заменяем вызов `expect` на выражение `match`, чтобы перейти от со сбоем завершения при ошибке к обработке ошибки. Помните, что `parse` возвращает вид `Result`, а `Result` — это перечисление, которое имеет исходы `Ok` и `Err`. Здесь мы используем выражение `match`, как и в случае с итогом `Ordering` способа `cmp`.

Если `parse` успешно преобразует строку в число, он вернёт значение `Ok`, содержащее полученное число. Это значение `Ok` будет соответствовать образцу первой ветки, а выражение `match` просто вернёт значение `num`, которое `parse` произвёл и поместил внутрь значения `Ok`. Это число окажется в нужной нам переменной `guess`, которую мы создали.

Если способ `parse` *не способен* превратить строку в число, он вернёт значение `Err`, которое содержит более подробные сведения об ошибке. Значение `Err` не совпадает с образцом `Ok(num)` в первой ветке `match`, но совпадает с образцом `Err(_)` второй ветки. Подчёркивание `_` является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений `Err`, независимо от того, какая сведения находится внутри. Поэтому программа выполнит рукопись второй ветки, `continue`, который сообщает программе перейти к следующему повторению `loop` и запросить ещё одну догадку. В этом случае программа правильно пренебрегает все ошибки, с которыми <code>parse</code> может столкнуться!

Всё в программе теперь должно работать как положено. Давайте попробуем:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Потрясающе! С помощью одной маленькой последней правки мы закончим игру в угадывание. Напомним, что программа все ещё выводит тайное число. Это хорошо подходило для проверки, но это портит игру. Давайте удалим `println!`, который выводит тайное число. В Приложении 2-6 показан окончательный исход рукописи.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}
```

<span class="caption">Приложение 2-6: полный рукопись игры</span>

На данное мгновение вы успешно создали игру в загадки. Поздравляем!

## Заключение

Это дело — отличный способ познакомить вас со многими новыми подходами Ржавчины: `let`, `match`, функции, использование внешних ящиков и многое другое. В следующих нескольких главах вы изучите эти подходы более подробно. Глава 3 охватывает понятия, которые есть в большинстве языков программирования, такие как переменные, виды данных и функции, и показывает, как использовать их в Ржавчине. В главе 4 рассматривается владение — особенность, которая отличает Ржавчину от других языков. В главе 5 обсуждаются устройства и правила написания способов, а в главе 6 объясняется, как работают перечисления.


[в пособия встроенной библиотеки]: ../std/prelude/index.html
["Переменные и изменчивость".]: ch03-01-variables-and-mutability.html#variables-and-mutability
[Главе 3]: ch03-04-comments.html
[`std::io::Stdin`]: ../std/io/struct.Stdin.html
[`read_line`]: ../std/io/struct.Stdin.html#method.read_line
[*перечисление*]: ch06-00-enums.html
[способ `expect`]: ../std/result/enum.Result.html#method.expect
[главе 9]: ch09-02-recoverable-errors-with-result.html
[смысловое управление исполнениями]: http://semver.org
[Crates.io]: https://crates.io/
[Cargo]: https://doc.rust-lang.org/cargo/
[его внутреннее устройство]: https://doc.rust-lang.org/cargo/reference/publishing.html
[`match`]: ch06-02-match.html
[`parse` строк]: ../std/primitive.str.html#method.parse