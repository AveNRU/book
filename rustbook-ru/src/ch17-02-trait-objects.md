## Использование особенность-предметов, допускающих значения разных видов

В главе 8 мы упоминали, что одним из ограничений векторов является то, что они могут хранить элементы только одного вида. Мы создали обходное решение в приложении 8-9, где мы определили перечисление `SpreadsheetCell` в котором были исходы для хранения целых чисел, чисел с плавающей точкой и писания. Это означало, что мы могли хранить разные виды данных в каждой ячейке и при этом иметь вектор, представляющий строку из ячеек. Это очень хорошее решение, когда наши взаимозаменяемые элементы вектора являются видами с конечным набором, известным при сборке рукописи.

Однако иногда мы хотим, чтобы пользователь нашей библиотеки мог расширить набор видов, которые допустимы в данном случае. Чтобы показать как этого добиться, мы создадим пример средства с графическим внешней оболочкой пользователя (GUI), который просматривает список элементов, вызывает способ `draw` для каждого из них, чтобы нарисовать его на экране - это обычная техника для средств GUI. Мы создадим библиотечный ящик с именем `gui`, содержащий устройство библиотеки GUI. Этот ящик мог бы включать некоторые готовые виды для использования, такие как `Button` или `TextField`. Кроме того, пользователи такого ящика `gui` захотят создавать свои собственные виды, которые могут быть нарисованы: например, кто-то мог бы добавить вид `Image`, а кто-то другой добавить вид `SelectBox`.

Мы не будем выполнить полноценную библиотеку GUI для этого примера, но покажем, как её части будут подходить друг к другу. На мгновение написания библиотеки мы не можем знать и определить все виды, которые могут захотеть создать другие программисты. Но мы знаем, что `gui` должен отслеживать множество значений различных видов и ему нужно вызывать способ `draw` для каждого из этих значений различного вида. Ему не нужно точно знать, что произойдёт, когда вызывается способ `draw`, просто у значения будет доступен такой способ для вызова.

Чтобы сделать это на языке с наследованием, можно определить класс с именем `Component` у которого есть способ с названием `draw`. Другие классы, такие как `Button`, `Image` и `SelectBox` наследуются от `Component` и следовательно, наследуют способ `draw`. Каждый из них может переопределить выполнение способа `draw`, чтобы определить своё пользовательское поведение, но площадка может обрабатывать все виды, как если бы они были образцами `Component` и вызывать `draw` у них. Но поскольку в Ржавчине нет наследования, нам нужен другой способ внутренне выстроить

 `gui` библиотеку, чтобы позволить пользователям расширять её новыми видами.

### Определение особенности для общего поведения

Чтобы выполнить поведение, которое мы хотим иметь в `gui`, определим особенность с именем `Draw`, который будет содержать один способ с названием `draw`. Затем мы можем определить вектор, который принимает *особенность-предмет*. Особенность-предмет указывает как на образец вида, выполняющего указанный особенность, так и на внутреннюю таблицу, используемую для поиска способов особенности указанного вида во время выполнения. Мы создаём особенность-предмет в таком порядке: используем какой-нибудь вид указателя, например ссылку `&` или умный указатель `Box<T>`, затем ключевое слово `dyn`, а затем указываем соответствующий особенность. (Мы будем говорить о причине того, что особенность-предметы должны использовать указатель в разделе ["Виды изменяемого размера и особенность `Sized` "]<!-- ignore --> главы 19). Мы можем использовать особенность-предметы вместо гибкого или определенного вида. Везде, где мы используем особенность-предмет, система видов Ржавчине проверит во время сборки, что любое значение, используемое в этом среде, будет выполнить нужный особенность у особенность-предмета. Следовательно, нам не нужно знать все возможные виды во время сборки.

Мы упоминали, что в Ржавчине мы воздерживаемся называть устройства и перечисления «предметами», чтобы отличать их от предметов в других языках. В устройстве или перечислении данные в полях устройства и поведение в разделах `impl` разделены, тогда как в других языках данные и поведение объединены в одну подход, часто обозначающуюся как предмет. Тем не менее, особенность-предметы *являются* более похожими на предметы на других языках, в том смысле, что они сочетают в себе данные и поведение. Но особенность-предметы отличаются от привычных предметов тем, что не позволяют добавлять данные к особенность-предмету. Особенность-предметы обычно не настолько полезны, как предметы в других языках: их определенная цель - обеспечить абстракцию через общее поведение.

В приложении 17.3 показано, как определить особенность с именем `Draw` с помощью одного способа с именем `draw`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-03/src/lib.rs}}
```

<span class="caption">Приложение 17-3: Определение особенности <code>Draw</code></span>

Этот правила написания должен выглядеть знакомым из наших дискуссий о том, как определять особенности в главе 10. Далее следует новый правила написания: в приложении 17.4 определена устройства с именем `Screen`, которая содержит вектор с именем `components`. Этот вектор имеет вид `Box<dyn Draw>`, который и является особенность-предметом; это замена для любого вида внутри `Box` который выполняет особенность `Draw`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-04/src/lib.rs:here}}
```

<span class="caption">Приложение 17-4: Определение устройства <code>Screen</code> с полем <code>components</code>, которое является вектором особенность-предметов, которые выполняют особенность <code>Draw</code></span>

В устройстве `Screen`, мы определим способ `run`, который будет вызывать способ `draw` каждого элемента вектора `components`, как показано в приложении 17-5:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-05/src/lib.rs:here}}
```

<span class="caption">Приложение 17-5: Выполнение способа <code>run</code> у устройства  <code>Screen</code>, который вызывает способ <code>draw</code> каждого составляющих из вектора</span>

Это работает иначе, чем определение устройства, которая использует свойство общего вида с ограничениями особенности. Обобщённый свойство вида может быть заменён только одним определенным видом, тогда как особенность-предметы позволяют нескольким определенным видам замещать особенность-предмет во время выполнения. Например, мы могли бы определить устройство `Screen` используя общий вид и ограничение особенности, как показано в приложении 17-6:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-06/src/lib.rs:here}}
```

<span class="caption">Приложение 17-6: Иная выполнение устройства <code>Screen</code> и способа <code>run</code>, используя обобщённый вид и ограничения особенности</span>

Это исход ограничивает нас образцом `Screen`, который имеет список составляющих всех видов `Button` или всех видов `TextField`. Если у вас когда-либо будут только однородные собрания, использование обобщений и ограничений особенности является предпочтительным, поскольку определения будут мономорфизированы во время сборки для использования с определенными видами.

С другой стороны, с помощью способа, использующего особенность-предметы, один образец `Screen` может содержать `Vec<T>` который содержит `Box<Button>`, также как и `Box<TextField>`. Давайте посмотрим как это работает, а затем поговорим о влиянии на производительность во время выполнения.

### Выполнения особенности

Теперь мы добавим несколько видов, выполняющих особенность `Draw`. Мы объявим вид `Button`. Опять же, действительная выполнение библиотеки GUI выходит за рамки этой книги, поэтому тело способа `draw` не будет иметь никакой полезной выполнения. Чтобы представить, как может выглядеть такая выполнение, устройства `Button` может иметь поля для `width`, `height` и `label`, как показано в приложении 17-7:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-07/src/lib.rs:here}}
```

<span class="caption">Приложение 17-7: Устройства <code>Button</code> выполняет особенность <code>Draw</code></span>

Поля `width`, `height` и `label` устройства `Button` будут отличаться от, например, полей других составляющих вроде вида `TextField`, которая могла бы иметь те же поля и дополнительно поле `placeholder`. Каждый из видов, который мы хотим нарисовать на экране будет выполнить особенность `Draw`, но будет использовать отличающийся рукопись способа `draw` для определения как именно рисовать определенный вид, например `Button` в этом примере (без действительного рукописи GUI, который выходит за рамки этой главы). Например, вид `Button` может иметь дополнительный раздел`impl`, содержащий способы, относящиеся к тому, что происходит, когда пользователь нажимает кнопку. Эти исходы способов не будут применяться к видам вроде `TextField`.

Если кто-то использующий нашу библиотеку решает выполнить устройство `SelectBox`, которая имеет `width`, `height` и поля `options`, он выполняет также и особенность `Draw` для вида `SelectBox`, как показано в приложении 17-8:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch17-oop/listing-17-08/src/main.rs:here}}
```

<span class="caption">Приложение 17-8: Другой ящик, использующий <code>gui</code> и выполняющий особенность <code>Draw</code> у устройства <code>SelectBox</code></span>

Пользователь нашей библиотеки теперь может написать свою функцию `main` для создания образца `Screen`. К образцу `Screen` он может добавить `SelectBox` и `Button`, поместив каждый из них в `Box<T>`, чтобы он стал особенность-предметом. Затем он может вызвать способ `run` у образца `Screen`, который вызовет `draw` для каждого из составляющих. Приложение 17-9 показывает эту выполнение:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch17-oop/listing-17-09/src/main.rs:here}}
```

<span class="caption">Приложение 17-9: Использование особенность-предметов для хранения значений разных видов, выполняющих один и тот же особенность</span>

Когда мы писали библиотеку, мы не знали, что кто-то может добавить вид `SelectBox`, но наша выполнение `Screen` могла работать с новым видом и рисовать его, потому что `SelectBox` выполняет особенность `Draw`, что означает, что он выполняет способ `draw`.

Эта подход, касающаяся только сообщений, на которые значение отвечает, в отличие от определенного вида у значения, подобна подходы *duck typing* в изменяемых строго определенных языках: если что-то ходит как утка и крякает как утка, то она должна быть утка! В выполнения способа `run` у `Screen` в приложении 17-5, `run` не нужно знать каким будет определенный вид каждого составляющих. Он не проверяет, является ли составляющая образцом `Button` или `SelectBox`, он просто вызывает способ `draw` составляющих. Указав `Box<dyn Draw>` в качестве вида значений в векторе `components`, мы определили `Screen` для значений у которых мы можем вызвать способ `draw`.

Преимущество использования особенность-предметов и системы видов Ржавчине для написания рукописи, похожего на рукопись с использованием подходы duck typing состоит в том, что нам не нужно во время выполнения  проверять выполняет ли значение в векторе определенный способ или беспокоиться о получении ошибок, если значение не выполняет способ, мы все равно вызываем способ. Ржавчина не собирает нашу рукопись, если значения не выполняют особенность, который нужен особенность-предмета..

Например, в приложении 17-10 показано, что произойдёт, если мы попытаемся создать `Screen` с `String` в качестве его составляющих:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-oop/listing-17-10/src/main.rs}}
```

<span class="caption">Приложение 17-10: Попытка использования вида, который не выполняет особенность для особенность-предмета</span>

Мы получим ошибку, потому что `String` не выполняет особенность `Draw`:

```console
{{#include ../listings/ch17-oop/listing-17-10/output.txt}}
```

Эта ошибка даёт понять, что либо мы передаём в составляющая `Screen` что-то, что мы не собирались передавать и мы тогда должны передать другой вид, либо мы должны выполнить особенность `Draw` у вида `String`, чтобы `Screen` мог вызывать `draw` у него.

### Особенность-предметы выполняют изменяемую управление (связывание)

Вспомните, в разделе [«Производительность рукописи, использующего обобщённые виды»](ch10-01-syntax.html#performance-of-code-using-generics)<!-- ignore --> в главе 10 наше обсуждение этапа мономорфизации, выполняемого сборщиком, когда мы используем ограничения особенностей для обобщённых видов: сборщик порождает частные выполнения функций и способов для каждого определенного вида, который мы применяем для свойства обобщённого вида. Рукопись, который получается в итоге мономорфизации, выполняет *постоянную управление* , то есть когда сборщик знает, какой способ вы вызываете во время сборки. Это противоположно *изменяемой управления*, когда сборщик не может определить во время сборки, какой способ вы вызываете. В случае изменяемой управления сборщик создает рукопись, который во время выполнения определит, какой способ нужно вызвать.

Когда мы используем особенность-предметы, ржавчина должна использовать изменяемую управление. Сборщик не знает всех видов, которые могут быть использованы с рукописью, использующим особенность-предметы, поэтому он не знает, какой способ выполнен для какого вида при вызове. Вместо этого, во время выполнения, Ржавчина использует указатели внутри особенность-предмета. чтобы узнать какой способ вызвать. Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при постоянной управления. Изменяемая управление также не позволяет сборщику выбрать встраивание рукописи способа, что в свою очередь делает невозможными некоторые переработки. Однако мы получили дополнительную гибкость в рукописи, который мы написали в приложении 17-5, и которую смогли поддержать в приложении 17-9, поэтому все "за" и "против" нужно рассматривать в совокупности.


["Виды изменяемого размера и особенность `Sized` "]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait