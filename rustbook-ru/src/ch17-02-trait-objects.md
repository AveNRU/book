## Использование типаж-предметов, допускающих значения разных видов

В главе 8 мы упоминали, что одним из ограничений векторов является то, что они могут хранить элементы только одного вида. Мы создали обходное решение в приложении 8-9, где мы определили перечисление `SpreadsheetCell` в котором были варианты для хранения целых чисел, чисел с плавающей точкой и текста. Это означало, что мы могли хранить разные виды данных в каждой ячейке и при этом иметь вектор, представляющий строку из ячеек. Это очень хорошее решение, когда наши взаимозаменяемые элементы вектора являются видами с конечным набором, известным при сборки кода.

Однако иногда мы хотим, чтобы пользователь нашей библиотеки мог расширить набор видов, которые допустимы в именно случаи. Чтобы показать как этого добиться, мы создадим пример средства с графическим внешней оболочкой пользователя (GUI), который просматривает список элементов, вызывает способ `draw` для каждого из них, чтобы нарисовать его на экране - это обычная техника для средств GUI. Мы создадим библиотечный крейт с именем `gui`, содержащий структуру библиотеки GUI. Этот крейт мог бы включать некоторые готовые виды для использования, такие как `Button` или `TextField`. Кроме того, пользователи такого крейта `gui` захотят создавать свои собственные виды, которые могут быть нарисованы: например, кто-то мог бы добавить вид `Image`, а кто-то другой добавить вид `SelectBox`.

Мы не будем реализовывать полноценную библиотеку GUI для этого примера, но покажем, как её части будут подходить друг к другу. На мгновение написания библиотеки мы не можем знать и определить все виды, которые могут захотеть создать другие программисты. Но мы знаем, что `gui` должен отслеживать множество значений различных видов и ему нужно вызывать способ `draw` для каждого из этих значений различного вида. Ему не нужно точно знать, что произойдёт, когда вызывается способ `draw`, просто у значения будет доступен такой способ для вызова.

Чтобы сделать это на языке с наследованием, можно определить класс с именем `Component` у которого есть способ с названием `draw`. Другие классы, такие как `Button`, `Image` и `SelectBox` наследуются от `Component` и следовательно, наследуют способ `draw`. Каждый из них может переопределить реализацию способа `draw`, чтобы определить своё пользовательское поведение, но площадка может обрабатывать все виды, как если бы они были образцами `Component` и вызывать `draw` у них. Но поскольку в Rust нет наследования, нам нужен другой способ структурировать `gui` библиотеку, чтобы позволить пользователям расширять её новыми видами.

### Определение типажа для общего поведения

Чтобы реализовать поведение, которое мы хотим иметь в `gui`, определим типаж с именем `Draw`, который будет содержать один способ с названием `draw`. Затем мы можем определить вектор, который принимает *типаж-предмет*. Типаж-предмет указывает как на образец вида, реализующего указанный типаж, так и на внутреннюю таблицу, используемую для поиска способов типажа указанного вида во время выполнения. Мы создаём типаж-предмет в таком порядке: используем какой-нибудь вид указателя, например ссылку `&` или умный указатель `Box<T>`, затем ключевое слово `dyn`, а затем указываем соответствующий типаж. (Мы будем говорить о причине того, что типаж-предметы должны использовать указатель в разделе ["Виды изменяемого размера и типаж `Sized` "]<!-- ignore --> главы 19). Мы можем использовать типаж-предметы вместо универсального или определенного вида. Везде, где мы используем типаж-предмет, система видов Rust проверит во время сборки, что любое значение, используемое в этом среде, будет реализовывать нужный типаж у типаж-предмета. Следовательно, нам не нужно знать все возможные виды во время сборки.

Мы упоминали, что в Rust мы воздерживаемся называть структуры и перечисления «предметами», чтобы отличать их от предметов в других языках. В структуре или перечислении данные в полях структуры и поведение в разделах `impl` разделены, тогда как в других языках данные и поведение объединены в одну подход, часто обозначающуюся как предмет. Тем не менее, типаж-предметы *являются* более похожими на предметы на других языках, в том смысле, что они сочетают в себе данные и поведение. Но типаж-предметы отличаются от привычных предметов тем, что не позволяют добавлять данные к типаж-предмету. Типаж-предметы обычно не настолько полезны, как предметы в других языках: их определенная цель - обеспечить абстракцию через общее поведение.

В приложении 17.3 показано, как определить типаж с именем `Draw` с помощью одного способа с именем `draw`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-03/src/lib.rs}}
```

<span class="caption">Приложение 17-3: Определение типажа <code>Draw</code></span>

Этот правила написания должен выглядеть знакомым из наших дискуссий о том, как определять типажи в главе 10. Далее следует новый правила написания: в приложении 17.4 определена структура с именем `Screen`, которая содержит вектор с именем `components`. Этот вектор имеет вид `Box<dyn Draw>`, который и является типаж-предметом; это замена для любого вида внутри `Box` который реализует типаж `Draw`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-04/src/lib.rs:here}}
```

<span class="caption">Приложение 17-4: Определение структуры <code>Screen</code> с полем <code>components</code>, которое является вектором типаж-предметов, которые реализуют типаж <code>Draw</code></span>

В структуре `Screen`, мы определим способ `run`, который будет вызывать способ `draw` каждого элемента вектора `components`, как показано в приложении 17-5:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-05/src/lib.rs:here}}
```

<span class="caption">Приложение 17-5: Реализация способа <code>run</code> у структуры  <code>Screen</code>, который вызывает способ <code>draw</code> каждого компонента из вектора</span>

Это работает иначе, чем определение структуры, которая использует свойство общего вида с ограничениями типажа. Обобщённый свойство вида может быть заменён только одним определенным видом, тогда как типаж-предметы позволяют нескольким определенным видам замещать типаж-предмет во время выполнения. Например, мы могли бы определить структуру `Screen` используя общий вид и ограничение типажа, как показано в приложении 17-6:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-06/src/lib.rs:here}}
```

<span class="caption">Приложение 17-6: Иная реализация структуры <code>Screen</code> и способа <code>run</code>, используя обобщённый вид и ограничения типажа</span>

Это вариант ограничивает нас образцом `Screen`, который имеет список компонентов всех видов `Button` или всех видов `TextField`. Если у вас когда-либо будут только однородные собрания, использование обобщений и ограничений типажа является предпочтительным, поскольку определения будут мономорфизированы во время сборки для использования с определенными видами.

С другой стороны, с помощью способа, использующего типаж-предметы, один образец `Screen` может содержать `Vec<T>` который содержит `Box<Button>`, также как и `Box<TextField>`. Давайте посмотрим как это работает, а затем поговорим о влиянии на производительность во время выполнения.

### Реализации типажа

Теперь мы добавим несколько видов, реализующих типаж `Draw`. Мы объявим вид `Button`. Опять же, действительная реализация библиотеки GUI выходит за рамки этой книги, поэтому тело способа `draw` не будет иметь никакой полезной реализации. Чтобы представить, как может выглядеть такая реализация, структура `Button` может иметь поля для `width`, `height` и `label`, как показано в приложении 17-7:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-07/src/lib.rs:here}}
```

<span class="caption">Приложение 17-7: Структура <code>Button</code> реализует типаж <code>Draw</code></span>

Поля `width`, `height` и `label` структуры `Button` будут отличаться от, например, полей других компонентов вроде вида `TextField`, которая могла бы иметь те же поля плюс поле `placeholder`. Каждый из видов, который мы хотим нарисовать на экране будет реализовывать типаж `Draw`, но будет использовать отличающийся код способа `draw` для определения как именно рисовать определенный вид, например `Button` в этом примере (без действительного кода GUI, который выходит за рамки этой главы). Например, вид `Button` может иметь дополнительный раздел`impl`, содержащий способы, относящиеся к тому, что происходит, когда пользователь нажимает кнопку. Эти варианты способов не будут применяться к видам вроде `TextField`.

Если кто-то использующий нашу библиотеку решает реализовать структуру `SelectBox`, которая имеет `width`, `height` и поля `options`, он реализует также и типаж `Draw` для вида `SelectBox`, как показано в приложении 17-8:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch17-oop/listing-17-08/src/main.rs:here}}
```

<span class="caption">Приложение 17-8: Другой крейт, использующий <code>gui</code> и реализующий типаж <code>Draw</code> у структуры <code>SelectBox</code></span>

Пользователь нашей библиотеки теперь может написать свою функцию `main` для создания образца `Screen`. К образцу `Screen` он может добавить `SelectBox` и `Button`, поместив каждый из них в `Box<T>`, чтобы он стал типаж-предметом. Затем он может вызвать способ `run` у образца `Screen`, который вызовет `draw` для каждого из компонентов. Приложение 17-9 показывает эту реализацию:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch17-oop/listing-17-09/src/main.rs:here}}
```

<span class="caption">Приложение 17-9: Использование типаж-предметов для хранения значений разных видов, реализующих один и тот же типаж</span>

Когда мы писали библиотеку, мы не знали, что кто-то может добавить вид `SelectBox`, но наша реализация `Screen` могла работать с новым видом и рисовать его, потому что `SelectBox` реализует типаж `Draw`, что означает, что он реализует способ `draw`.

Эта подход, касающаяся только сообщений, на которые значение отвечает, в отличие от определенного вида у значения, подобна подходы *duck typing* в изменяемых типизированных языках: если что-то ходит как утка и крякает как утка, то она должна быть утка! В реализации способа `run` у `Screen` в приложении 17-5, `run` не нужно знать каким будет определенный вид каждого компонента. Он не проверяет, является ли компонент образцом `Button` или `SelectBox`, он просто вызывает способ `draw` компонента. Указав `Box<dyn Draw>` в качестве вида значений в векторе `components`, мы определили `Screen` для значений у которых мы можем вызвать способ `draw`.

Преимущество использования типаж-предметов и системы видов Rust для написания кода, похожего на код с использованием подходы duck typing состоит в том, что нам не нужно во время выполнения  проверять реализует ли значение в векторе определенный способ или беспокоиться о получении ошибок, если значение не реализует способ, мы все равно вызываем способ. Rust не ссобирает наш код, если значения не реализуют типаж, который нужен типаж-предмета..

Например, в приложении 17-10 показано, что произойдёт, если мы попытаемся создать `Screen` с `String` в качестве его компонента:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-oop/listing-17-10/src/main.rs}}
```

<span class="caption">Приложение 17-10: Попытка использования вида, который не реализует типаж для типаж-предмета</span>

Мы получим ошибку, потому что `String` не реализует типаж `Draw`:

```console
{{#include ../listings/ch17-oop/listing-17-10/output.txt}}
```

Эта ошибка даёт понять, что либо мы передаём в компонент `Screen` что-то, что мы не собирались передавать и мы тогда должны передать другой вид, либо мы должны реализовать типаж `Draw` у вида `String`, чтобы `Screen` мог вызывать `draw` у него.

### Типаж-предметы выполняют изменяемую управление (связывание)

Вспомните, в разделе [«Производительность кода, использующего обобщённые виды»](ch10-01-syntax.html#performance-of-code-using-generics)<!-- ignore --> в главе 10 наше обсуждение процесса мономорфизации, выполняемого сборщиком, когда мы используем ограничения типажей для обобщённых видов: сборщик генерирует частные реализации функций и способов для каждого определенного вида, который мы применяем для свойства обобщённого вида. Код, который получается в итоге мономорфизации, выполняет *постоянную управление* , то есть когда сборщик знает, какой способ вы вызываете во время сборки. Это противоположно *изменяемой управления*, когда сборщик не может определить во время сборки, какой способ вы вызываете. В случае изменяемой управления сборщик создает код, который во время выполнения определит, какой способ нужно вызвать.

Когда мы используем типаж-предметы, Rust должен использовать изменяемую управление. Сборщик не знает всех видов, которые могут быть использованы с кодом, использующим типаж-предметы, поэтому он не знает, какой способ реализован для какого вида при вызове. Вместо этого, во время выполнения, Rust использует указатели внутри типаж-предмета. чтобы узнать какой способ вызвать. Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при постоянной управления. Изменяемая управление также не позволяет сборщику выбрать встраивание кода способа, что в свою очередь делает невозможными некоторые переработки. Однако мы получили дополнительную гибкость в коде, который мы написали в приложении 17-5, и которую смогли поддержать в приложении 17-9, поэтому все "за" и "против" нужно рассматривать в комплексе.


["Виды изменяемого размера и типаж `Sized` "]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait