## Публикация библиотеки в Crates.io

Мы использовали дополнения из [crates.io](https://crates.io/)<!--  --> в качестве зависимостей нашего проекта, но вы также можете поделиться своим кодом с другими людьми, обнародовав свои собственные дополнения. Реестр библиотек по адресу [crates.io](https://crates.io/)<!--  --> распространяет исходный код ваших дополнений, поэтому он в основном размещает код с открытым исходным кодом.

В Ржавчина и Cargo есть функции, которые облегчают поиск и использование обнародованного дополнения. Далее мы поговорим о некоторых из этих функций, а затем объясним, как обнародовать дополнение.

### Создание полезных примечаниев к документации

Правильноное документирование ваших дополнений поможет другим пользователям знать, как и когда их использовать, поэтому стоит потратить время на написание документации. В главе 3 мы обсуждали, как вносить примечания в код Rust, используя две косые черты, `//`. В Ржавчина также есть особый вид примечаниев к документации, который обычно называется *примечанием к документации*, который генерирует документацию HTML. HTML-код отображает содержимое примечаниев к документации для публичных элементов API, предназначенных для программистов, увлеченных в знании того, как *использовать* вашу библиотеку, в отличие от того, как она *реализована*.

Примечания к документации используют три слеша, `///` вместо двух и поддерживают наставление Markdown для изменения текста. Размещайте примечания к документации непосредственно перед элементом, который они документируют. В приложении 14-1 показаны примечания к документации для функции `add_one` в библиотеке с именем `my_crate`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-01/src/lib.rs}}
```

<span class="caption">Приложение 14-1: Примечание к документации для функции</span>

Здесь мы даём описание того, что делает функция `add_one`, начинаем раздел с заголовка `Examples`, а затем предоставляем код, который отображает, как использовать функцию `add_one`. Мы можем создать документацию HTML из этого примечания к документации, запустив `cargo doc`. Этот приказ запускает средство `rustdoc`, поставляемый с Rust, и помещает созданную HTML-документацию в папка *target/doc*.

Для удобства, запустив `cargo doc --open`, мы создадим HTML для документации вашей текущей библиотеки (а также документацию для всех зависимостей вашей библиотеки) и откроем итог в веб-браузере. Перейдите к функции `add_one` и вы увидите, как отображается текст в примечаниях к документации, что показано на рисунке 14-1:

 <img alt="HTML-документация для функции `add_one`` my_crate`" src="img/trpl14-01.png" class="center">

<span class="caption">Рисунок 14-1: HTML документация для функции <code>add_one</code></span>

#### Часто используемые разделы

Мы использовали Markdown заголовок `# Examples` в приложении 14-1 для создания раздела в HTML с заголовком "Examples". Вот некоторые другие разделы, которые авторы библиотек обычно используют в своей документации:

- **Panics**: Сценарии, в которых документированная функция может вызывать панику. Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих случаейх.
- **Ошибки**: Если функция возвращает `Result`, описание видов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных видов ошибок разными способами.
- **Безопасность**: Если функция является `unsafe` для вызова (мы обсуждаем безопасность в главе 19), должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты, которые функция ожидает от вызывающих сторон.

В подавляющем большинстве случаев примечания к документации не нуждаются во всех этих разделах, но это хорошая подсказка, напоминающая вам о тех особенностях вашего кода, о которых пользователям будет важно узнать.

#### Примечания к документации как проверки

Добавление примеров кода в примечания к документации может помочь отобразить, как использовать вашу библиотеку, и это даёт дополнительный бонус: запуск `cargo test` запустит примеры кода в вашей документации как проверки! Нет ничего лучше, чем документация с примерами. Но нет ничего хуже, чем примеры, которые не работают, потому что код изменился с особенности написания документации. Если мы запустим `cargo test` с документацией для функции `add_one` из приложения 14-1, мы увидим раздел итогов проверки, подобный этому:

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->

```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
```

Теперь, если мы изменим либо функцию, либо пример, так что `assert_eq!` в примере паникует, и снова запустим `cargo test`, мы увидим, что проверки документации обнаруживают, что пример и код не согласованы друг с другом!

#### Указание примечаний содержащихся элементов

Исполнение примечаниев к документам `//!` добавляет документацию к элементу, содержащему примечания, а не к элементам, следующим за примечаниями. Обычно мы используем эти примечания внутри корневого файла ящика (по соглашению *src/lib.rs* ) или внутри модуля для документирования ящика или модуля в целом.

Например, чтобы добавить документацию, описывающую назначение `my_crate` , содержащего функцию `add_one` , мы добавляем примечания к документации, начинающиеся с `//!` в начало файла *src/lib.rs* , как показано в приложении 14-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-02/src/lib.rs:here}}
```

<span class="caption">Приложение 14-2: Документация для ящика <code>my_crate</code> в целом</span>

Обратите внимание, что после последней строки, начинающейся с `//!`, нет никакого кода. Поскольку мы начали примечания с `//!` вместо `///`, мы документируем элемент, который содержит этот примечание, а не элемент, который следует за этим примечанием. В данном случае таким элементом является файл *src/lib.rs*, который является корнем crate. Эти примечания описывают весь ящик.

Когда мы запускаем `cargo doc --open`, эти примечания будут отображаться на первой странице документации для `my_crate` над списком публичных элементов в библиотеке, как показано на рисунке 14-2:

 <img alt="Документация для библиотеки `art`, в которой перечислены модули `types` и `utils`" src="img/trpl14-02.png" class="center">

<span class="caption">Рисунок 14-2: Предоставленная документация для <code>my_crate</code>, включая примечание, описывающие ящик в целом</span>

Примечания к документации внутри элементов полезны для описания ящиков и модулей особенно. Используйте их, чтобы объяснить общую цель дополнения, чтобы помочь вашим пользователям понять устройство ящика.

### Экспорт удобного общедоступного API с `pub use`<a id="exporting-a-convenient-public-api-with-pub-use"></a>

Структура вашего публичного API является основным обстоятельством при публикации ящика. Люди, которые используют вашу библиотеку, менее знакомы со структурой, чем вы и могут столкнуться с трудностями при поиске частей, которые они хотят использовать, если ваша библиотека имеет большую упорядочевание модулей.

В главе 7 мы рассмотрели, как сделать элементы общедоступными с помощью ключевого слова `pub` и ввести элементы в область видимости с помощью ключевого слова `use`. Однако структура, которая имеет смысл для вас при разработке ящика, может быть не очень удобной для пользователей. Вы можете согласовать структуру в виде упорядочевания с несколькими уровнями, но тогда люди, желающие использовать вид, который вы определили в глубине упорядочевания, могут столкнуться с неполадкой его поиска. Их также может раздражать необходимость вводить `use` `my_crate::some_module::another_module::UsefulType;` вместо `use` `my_crate::UsefulType;`.

Хорошей новостью является то, что если структура *не* удобна для использования другими из другой библиотеки, вам не нужно перестраивать внутреннюю устройство: вместо этого вы можете реэкспортировать элементы, чтобы сделать публичную структуру, отличную от вашей внутренней структуры, используя `pub use`. Реэкспорт берет открытый элемент в одном месте и делает его публичным в другом месте, как если бы он был определён в другом месте.

Например, скажем, мы создали библиотеку с именем `art` для расчетов художественных подходов. Внутри этой библиотеки есть два модуля: модуль `kinds` содержащий два перечисления с именами `PrimaryColor` и `SecondaryColor` и модуль `utils`, содержащий функцию с именем `mix`, как показано в приложении 14-3:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-03/src/lib.rs:here}}
```

<span class="caption">Приложение 14-3: Библиотека <code>art</code> с элементами, согласованными в модули <code>kinds</code> и <code>utils</code></span>

На рисунке 14-3 показано, как будет выглядеть титульная страница документации для этого ящика, созданный `cargo doc`:

 <img alt="Предоставлена Документация для библиотеки `art` с реэкспортом на первой странице" src="img/trpl14-03.png" class="center">

<span class="caption">Рисунок 14-3: Первая страница документации для <code>art</code>, в которой перечислены модули <code>kinds</code> и <code>utils</code></span>

Обратите внимание, что виды `PrimaryColor` и `SecondaryColor` не указаны на главной странице, равно как и функция `mix`. Мы должны нажать `kinds` и `utils`, чтобы увидеть их.

В другой библиотеке, которая зависит от этой библиотеки, потребуются операторы `use`, которые подключают элементы из `art` в область видимости, определяя структуру модуля, которая определена в данный мгновение. В приложении 14-4 показан пример ящика, в котором используются элементы `PrimaryColor` и `mix` из ящика `art`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-04/src/main.rs}}
```

<span class="caption">Приложение 14-4: Ящик использующий элементы из ящика <code>art</code> с экспортированной внутренней структурой</span>

Автору кода в приложении 14-4, который использует ящик `art`, пришлось выяснить, что `PrimaryColor` находится в модуле `kinds`, а `mix` - в модуле `utils`. Структура модуля `art` ящика больше подходит для разработчиков, работающих над `art` ящиком, чем для тех, кто его использует. Внутренняя структура не содержит никакой полезной сведений для того, кто пытается понять, как использовать ящик `art`, а скорее вызывает путаницу, поскольку разработчики, использующие его, должны понять, где искать, и должны указывать имена модулей в выражениях `use`.

Чтобы удалить внутреннюю устройство из общедоступного API, мы можем изменить код ящика `art` в приложении 14-3, чтобы добавить операторы `pub use` для повторного реэкспорта элементов на верхнем уровне, как показано в приложении 14-5:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-05/src/lib.rs:here}}
```

<span class="caption">Приложение 14-5: Добавление операторов <code>pub use</code> для реэкспорта элементов</span>

Документация API, которую `cargo doc` генерирует для этой библиотеки, теперь будет перечислять и связывать реэкспорты на главной странице, как показано на рисунке 14-4, упрощая поиск видов `PrimaryColor`, `SecondaryColor` и функции `mix`.

 <img alt="HTML-документация с примечанием для библиотеки в целом" src="img/trpl14-04.png" class="center">

<span class="caption">Рисунок 14-4: Первая страница документации для <code>art</code>,  которая перечисляет реэкспорт</span>

Пользователи ящика `art` могут по-прежнему видеть и использовать внутреннюю структуру из приложения 14-3, как показано в приложении 14-4, или они могут использовать более удобную структуру в приложении 14-5, как показано в приложении 14-6:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-06/src/main.rs:here}}
```

<span class="caption">Приложение 14-6: Программа, использующая реэкспортированные элементы из ящика <code>art</code></span>

В случаях, когда имеется много вложенных модулей, реэкспорт видов на верхнем уровне с помощью `pub use` может существенно повысить удобство работы для людей, использующих ящик. Ещё одно распространённое использование `pub use` - это реэкспорт определений зависимого модуля в текущем ящике, чтобы сделать определения этого ящика частью публичного API вашего ящика.

Создание полезной публичной структуры API - это больше искусство чем наука, и вы можете повторять, чтобы найти API, который лучше всего подойдёт вашим пользователям. Использование `pub use` даёт вам гибкость в том, как вы структурируете свою библиотеку внутри и отделяете эту внутреннюю структуру от того, что вы предоставляете пользователям. Посмотрите на код некоторых установленных ящиков, чтобы увидеть отличается ли их внутренняя структура от их публичного API.

### Настройка учётной записи Crates.io

Прежде чем вы сможете обнародовать любые библиотеки, вам необходимо создать учётную запись на [crates.io](https://crates.io/)<!--  --> и получить API токен. Для этого зайдите на домашнюю страницу [crates.io](https://crates.io/)<!--  --> и войдите в систему через учётную запись GitHub. (В настоящее время требуется наличие учётной записи GitHub, но сайт может поддерживать другие способы создания учётной записи в будущем.) Сразу после входа в систему перейдите в настройки своей учётной записи по адресу [https://crates.io/me/](https://crates.io/me/)<!--  --> и получите свой ключ API. Затем выполните приказ `cargo login` с вашим ключом API, например:

```console
$ cargo login abcdefghijklmnopqrstuvwxyz012345
```

Этот приказ сообщит Cargo о вашем API token и сохранит его местно в *~/.cargo/credentials*. Обратите внимание, что этот токен является *тайным*: не делитесь им ни с кем другим. Если вы по какой-либо причине поделитесь им с кем-либо, вы должны отозвать его и создать новый токен на [crates.io](https://crates.io/).

### Добавление метаданных в новую библиотеку

Допустим, у вас есть ящик, который вы хотите обнародовать. Перед публикацией вам нужно добавить некоторые метаданные в раздел `[package]` файла *Cargo.toml* ящика.

Вашему ящику понадобится не повторяющееся имя. Пока вы работаете над ящиком местно, вы можете назвать его как угодно. Однако названия ящиков на [crates.io](https://crates.io/)<!-- ignore --> определятся в мгновение первой публикации. Как только ящику присвоено название, никто другой не сможет обнародовать ящик с таким же именем. Перед тем как обнародовать ящик, поищите название, которое вы хотите использовать. Если такое имя уже используется, вам придётся подобрать другое и отредактировать поле `name` в файле *Cargo.toml* в разделе `[package]`, чтобы использовать новое имя в качестве публикуемого, например, так:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
```

Даже если вы выбрали не повторяющееся имя, когда вы запустите `cargo publish` чтобы обнародовать ящик, вы получите предупреждение, а затем ошибку:

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->

```console
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
```

Это ошибка, потому что вам не хватает важной сведений: необходимы описание и лицензия, чтобы люди знали, что делает ваш ящик и на каких условиях они могут его использовать. В поле *Cargo.toml* добавьте описание, состоящее из одного-двух предложений, поскольку оно будет появляться вместе с вашим ящиком в итогах поиска. Для поля `license` нужно указать значение *определителя лицензии*. В [Linux Foundation's Software Package Data Exchange (SPDX)] перечислены определители, которые можно использовать для этого значения. Например, чтобы указать, что вы лицензировали свой crate, используя лицензию MIT, добавьте определитель `MIT`:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
license = "MIT"
```

Если вы хотите использовать лицензию, которая отсутствует в SPDX, вам нужно поместить текст этой лицензии в файл, включите файл в свой проект, а затем используйте `license-file`, чтобы указать имя этого файла вместо использования ключа `license`.

Руководство по выбору лицензии для вашего проекта выходит за рамки этой книги. Многие люди в сообществе Ржавчина лицензируют свои проекты так же, как и Rust, используя двойную лицензию `MIT OR Apache 2.0`. Эта применение отображает, что вы также можете указать несколько определителей лицензий, разделённых `OR`, чтобы иметь несколько лицензий для вашего проекта.

С добавлением единственного имени, исполнения, вашего описания и лицензии, файл *Cargo.toml* для проекта, который готов к публикации может выглядеть следующим образом:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

[Документация Cargo](https://doc.rust-lang.org/cargo/) описывает другие метаданные, которые вы можете указать, чтобы другие могли легче находить и использовать ваш ящик.

### Публикация на Crates.io

Теперь, когда вы создали учётную запись, сохранили свой токен API, выбрали имя для своего ящика и указали необходимые метаданные, вы готовы к публикации! Публикация библиотеки загружает определённую исполнение в [crates.io](https://crates.io/)<!--  --> для использования другими.

Будьте осторожны, потому что публикация является *перманентной* действием. Исполнение никогда не сможет быть перезаписана, а код не подлежит удалению. Одна из основных целей [crates.io](https://crates.io/)<!-- ignore --> - служить постоянным архивом кода, чтобы сборки всех проектов, зависящих от crates из [crates.io](https://crates.io/)<!-- ignore --> продолжали работать. Предоставление возможности удаления исполнений сделало бы выполнение этой цели невозможным. При этом количество исполнений ящиков, которые вы можете обнародовать, не ограничено.

Запустите приказ `cargo publish` ещё раз. Сейчас эта приказ должна выполниться успешно:

<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->

```console
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```

Поздравляем! Теперь вы поделились своим кодом с сообществом Ржавчина и любой может легко добавить вашу библиотеку в качестве зависимости их проекта.

### Публикация новой исполнения существующей библиотеки

Когда вы внесли изменения в свой ящик и готовы выпустить новую исполнение, измените значение `version`, указанное в вашем файле *Cargo.toml* и повторите публикацию. Воспользуйтесь [Semantic Versioning rules], чтобы решить, какой номер следующей исполнения подходит для ваших изменений. Затем запустите `cargo publish`, чтобы загрузить новую исполнение.

<!-- Old link, do not remove -->

<a id="removing-versions-from-cratesio-with-cargo-yank"></a>

### Устранение устаревших исполнений с Crates.io с помощью `cargo yank`

Хотя вы не можете удалить предыдущие исполнения ящика, вы можете помешать любым будущим проектам добавлять его в качестве новой зависимости. Это полезно, когда исполнение ящика сломана по той или иной причине. В таких случаейх Cargo поддерживает *выламывание* (yanking) исполнения ящика.

Вычёркивание исполнения не позволяет новым проектам зависеть от этой исполнения, но при этом позволяет всем существующим проектам, зависящим от неё, продолжать работу. По сути, исключение означает, что все проекты с *Cargo.lock* не сломаются, а любые файлы *Cargo.lock*, которые будут генерироваться в будущем, не смогут использовать исключённую исполнение.

Чтобы вычеркнуть исполнение ящика, в папки ящика, который вы обнародовали ранее, выполните приказ `cargo yank` и укажите, какую исполнение вы хотите вычеркнуть. Например, если мы обнародовали ящик под названием `guessing_game` исполнения 1.0.1 и хотим вычеркнуть её, в папке проекта для `guessing_game` мы выполним:

<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->

```console
$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
```

Добавив в приказ `--undo`, вы также можете отменить выламывание и разрешить проектам начать зависеть от исполнения снова:

```console
$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
```

Вычёркивание *не удаляет* код. Оно не может, например, удалить случайно загруженные пароли. Если это произойдёт, вы должны немедленно сбросить эти пароли.


[Linux Foundation's Software Package Data Exchange (SPDX)]: http://spdx.org/licenses/
[Semantic Versioning rules]: http://semver.org/