## Дополнение Б: Операторы и обозначения

Это дополнение содержит глоссарий правил написания Rust, включая операторы и другие обозначения, которые появляются сами по себе или в среде путей, обобщений, типажей, макросов, атрибутов, комментариев, кортежей и скобок.

### Операторы

Таблица Б-1 содержит операторы языка Rust, пример появления оператора, короткое объяснение, возможность перегрузки оператора. Если оператор можно перегрузить, то показан типаж, с помощью которого его можно перегрузить.

<span class="caption">Таблица Б-1: Операторы</span>

Оператор | Пример | Объяснение | Перегружаемость
--- | --- | --- | ---
`!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Вызов макроса |
`!` | `!expr` | Побитовое или логическое отрицание | `Not`
`!=` | `expr != expr` | Сравнение "не равно" | `PartialEq`
`%` | `expr % expr` | Остаток от деления | `Rem`
`%=` | `var %= expr` | Остаток от деления и присваивание | `RemAssign`
`&` | `&expr`, `&mut expr` | Заимствование |
`&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Указывает что данный вид заимствуется |
`&` | `expr & expr` | Побитовое И | `BitAnd`
`&=` | `var &= expr` | Побитовое И и присваивание | `BitAndAssign`
`&&` | `expr && expr` | Логическое И |
`*` | `expr * expr` | Арифметическое умножение | `Mul`
`*=` | `var *= expr` | Арифметическое умножение и присваивание | `MulAssign`
`*` | `*expr` | Разыменование ссылки | `Deref`
`*` | `*const type`, `*mut type` | Указывает, что данный вид является сырым указателем |
`+` | `trait + trait`, `'a + trait` | Соединение ограничений вида |
`+` | `expr + expr` | Арифметическое сложение | `Add`
`+=` | `var += expr` | Арифметическое сложение и присваивание | `AddAssign`
`,` | `expr, expr` | Разделитель переменных и элементов |
`-` | `- expr` | Арифметическое отрицание | `Neg`
`-` | `expr - expr` | Арифметическое вычитание | `Sub`
`-` | `var -= expr` | Арифметическое вычитание и присваивание | `SubAssign`
`->` | `fn(...) -> type`, <code>&amp;vert;...&amp;vert; -&gt; type</code> | ... |
`.` | `expr.ident` | Доступ к элементу |
`..` | `..`, `expr..`, `..expr`, `expr..expr` | Указывает на рядчисел, исключая правый | `PartialOrd`
`..=` | `..=expr`, `expr..=expr` | Указывает на рядчисел, включая правый | `PartialOrd`
`..` | `..expr` | правила написания обновления структуры |
`..` | `variant(x, ..)`, `struct_type { x, .. }` | Привязка «И все остальное» |
`...` | `expr...expr` | (Устарело, используйте новый правила написания `..=`) Используется при определении инклюзивного ряда|
`/` | `expr / expr` | Арифметическое деление | `Div`
`/=` | `var /= expr` | Арифметическое деление и присваивание | `DivAssign`
`:` | `pat: type`, `ident: type` | Ограничения видов |
`:` | `ident: expr` | Объявление поля структуры |
`:` | `'a: loop {...}` | Метка цикла |
`;` | `expr;` | Признак конца указания и элемента |
`;` | `[...; len]` | Часть правил написания массива конечного размера |
`<<` | `expr << expr` | Битовый сдвиг влево | `Shl`
`<<=` | `var <<= expr` | Битовый сдвиг влево и присваивание | `ShlAssign`
`<` | `expr < expr` | Сравнение "меньше чем" | `PartialOrd`
`<=` | `expr <= expr` | Сравнение "меньше или равно" | `PartialOrd`
`=` | `var = expr`, `ident = type` | Присваивание/эквивалентность |
`==` | `expr == expr` | Сравнение "равно" | `PartialEq`
`=>` | `pat => expr` | Часть правил написания конструкции match |
`>` | `expr > expr` | Сравнение "больше чем" | `PartialOrd`
`>=` | `expr >= expr` | Сравнение "больше или равно" | `PartialOrd`
`>>` | `expr >> expr` | Битовый сдвиг вправо | `Shr`
`>>=` | `var >>= expr` | Битовый сдвиг вправо и присваивание | `ShrAssign`
`@` | `ident @ pat` | Pattern binding |
`^` | `expr ^ expr` | Побитовое исключающее ИЛИ | `BitXor`
`^=` | `var ^= expr` | Побитовое исключающее ИЛИ и присваивание | `BitXorAssign`
<code>&amp;vert;</code> | <code>pat &amp;vert; pat</code> | Иные шаблоны |
<code>&amp;vert;</code> | <code>expr &amp;vert; expr</code> | Побитовое ИЛИ | `BitOr`
<code>&amp;vert;=</code> | <code>var &amp;vert;= expr</code> | Побитовое ИЛИ и присваивание | `BitOrAssign`
<code>&amp;vert;&amp;vert;</code> | <code>expr &amp;vert;&amp;vert; expr</code> | Короткое логическое ИЛИ |
`?` | `expr?` | Возврат ошибки |

### Обозначения не-операторы

Следующий список содержит все символы, которые не работают как операторы; то есть они не ведут себя как вызов функции или способа.

Таблица Б-2 показывает символы, которые появляются сами по себе и допустимы в различных местах.

<span class="caption">Таблица Б-2: Автономный правила написания</span>

Обозначение | Объяснение
--- | ---
`'ident` | Именованное время жизни или метка цикла
`...u8`, `...i32`, `...f64`, `...usize`, etc. | Числовой запись определённого вида
`"..."` | Строковый запись
`r"..."`, `r#"..."#`, `r##"..."##`, etc. | Необработанный строковый запись, в котором не обрабатываются escape-символы
`b"..."` | Строковый запись байтов; создаёт массив байтов вместо строки
`br"..."`, `br#"..."#`, `br##"..."##`, etc. | Необработанный строковый байтовый запись, сочетание необработанного и байтового записи
`'...'` | Символьный запись
`b'...'` | ASCII байтовый запись
<code>&amp;vert;...&amp;vert; expr</code> | Замыкание
`!` | Всегда пустой вид для расходящихся функций
`_` | «Пренебрегаемое» связывание шаблонов; также используется для читабельности целочисленных записей

Таблица Б-3 показывает обозначения которые появляются в среде путей упорядочевания модулей

<span class="caption">Таблица Б-3. Правила написания, связанный с путями</span>

Обозначение | Объяснение
--- | ---
`ident::ident` | Путь к пространству имён
`::path` | Путь относительно корня крейта (т. е. явный абсолютный путь)
`self::path` | Путь относительно текущего модуля (т. е. явный относительный путь).
`super::path` | Путь относительно родительского модуля текущего модуля
`type::ident`, `<type as trait>::ident` | Ассопряженные константы, функции и виды
`<type>::...` | Ассопряженный элемент для вида, который не может быть назван прямо (например `<&T>::...`, `<[T]>::...`, etc.)
`trait::method(...)` | Устранение неоднозначности вызова способа путём именования типажа, который определяет его
`type::method(...)` | Устранение неоднозначности путём вызова способа через имя вида, для которого он определён
`<type as trait>::method(...)` | Устранение неоднозначности вызова способа путём именования типажа и вида

Таблица Б-4 показывает обозначения которые появляются в среде использования обобщённых видов свойств

<span class="caption">Таблица Б-4: Обобщения</span>

Обозначение | Объяснение
--- | ---
`path<...>` | Определяет свойства для обобщённых свойств в виде (e.g., `Vec<u8>`)
`path::<...>`, `method::<...>` | Определяет свойства для обобщённых свойств, функций, или способов в выражении. Часто называют turbofish (например `"42".parse::<i32>()`)
`fn ident<...> ...` | Определение обобщённой функции
`struct ident<...> ...` | Определение обобщённой структуры
`enum ident<...> ...` | Объявление обобщённого перечисления
`impl<...> ...` | Определение обобщённой реализации
`for<...> type` | Высокоуровневое связывание времени жизни
`type<ident=type>` | Обобщённый вид где один или более ассопряженных видов имеют определённое присваивание (например `Iterator<Item=T>`)

Таблица Б-5 показывает обозначения которые появляются в среде использования обобщённых видов свойств с ограничениями видов

<span class="caption">Таблица Б-5: Ограничения видов</span>

Обозначение | Объяснение
--- | ---
`T: U` | Обобщённый свойство `T` ограничивается до видов которые реализуют типаж `U`
`T: 'a` | Обобщённый вид `T` должен существовать не меньше чем `'a` (то есть вид не может иметь ссылки с временем жизни меньше чем `'a`)
`T: 'static` | Обобщённый вид `T` не имеет заимствованных ссылок кроме имеющих время жизни `'static`
`'b: 'a` | Обобщённое время жизни `'b` должно быть не меньше чем `'a`
`T: ?Sized` | Позволяет обобщённым видам свойства иметь изменяемый размер
`'a + trait`, `trait + trait` | Соединение ограничений видов

Таблица Б-6 показывает обозначения, которые появляются в среде вызова или определения макросов и указания атрибутов элемента.

<span class="caption">Таблица Б-6: Макросы и атрибуты</span>

Обозначение | Объяснение
--- | ---
`#[meta]` | Внешний атрибут
`#![meta]` | Внутренний атрибут
`$ident` | Подстановка в макросе
`$ident:kind` | Захват макроса
`$(…)…` | Повторение макроса
`ident!(...)`, `ident!{...}`, `ident![...]` | Вызов макроса

Таблица Б-7 показывает обозначения, которые создают комментарии.

<span class="caption">Таблица Б-7: Комментарии</span>

Обозначение | Объяснение
--- | ---
`//` | Однострочный комментарий
`//!` | Внутренний однострочный комментарий документации
`///` | Внешний однострочный комментарий документации
`/*...*/` | Многострочный комментарий
`/*!...*/` | Внутренний многострочный комментарий документации
`/**...*/` | Внешний многострочный комментарий документации

Таблица Б-8 показывает обозначения, которые появляются в среде использования кортежей.

<span class="caption">Таблица Б-8: Кортежи</span>

Обозначение | Объяснение
--- | ---
`()` | Пустой кортеж, он же пустой вид. И запись и вид.
`(expr)` | Выражение в скобках
`(expr,)` | Кортеж с одним элементом выражения
`(type,)` | Кортеж с одним элементом вида
`(expr, ...)` | Выражение кортежа
`(type, ...)` | Вид кортежа
`(type, ...)` | Выражение вызова функции; также используется для объявления структур-кортежей и вариантов-кортежей перечисления
`expr.0`, `expr.1`, etc. | Взятие элемента по порядковому указателю в кортеже

Таблица Б-9 показывает среды, в которых используются фигурные скобки.

<span class="caption">Таблица Б-9: Фигурные скобки</span>

Среда | Объяснение
--- | ---
`{...}` | Выражение раздела
`Type {...}` | `struct` запись

Таблица Б-10 показывает среды, в которых используются квадратные скобки.

<span class="caption">Таблица Б-10: Квадратные скобки</span>

Среда | Объяснение
--- | ---
`[...]` | Запись массива
`[expr; len]` | Запись массива, содержащий `len` копий `expr`
`[type; len]` | Массив, содержащий `len` образцов вида `type`
`expr[expr]` | Взятие по порядковому указателю в собрания. Возможна перегрузка (`Index`, `IndexMut`)
`expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Взятие среза собрания по порядковому указателю, используется `Range`, `RangeFrom`, `RangeTo`, или `RangeFull` как "порядковый указатель"
