## Хранение списков значений в векторах

Первым видом собрания, который мы разберём, будет вид данных `Vec<T>`, также известный как <em>вектор</em> (vector). Векторы позволяют хранить более одного значения в единой стопке данных, хранящей значения в памяти одно за другим. Векторы могут хранить данные только одного вида данных. Их удобно использовать, когда нужно хранить список значений, например, список написанных строк из файла, или список цен товаров в корзине покупок.

### Создание нового вектора

Чтобы создать новый пустой вектор, мы вызываем функцию `Vec::new`, как показано в приложении 8-1.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-01/src/main.rs:here}}
```

<span class="caption">Приложение 8-1: Создание нового пустого вектора для хранения значений вида данных <code>i32</code></span>

Обратите внимание, что здесь мы добавили изложение вида данных. Поскольку мы не вставляем никаких значений в этот вектор, Ржавчина не знает, какие значения мы собираемся хранить. Это важная особенность. Векторы выполнены с использованием обобщённых видов данных; мы рассмотрим, как использовать обобщённые виды данных с вашими собственными видами данных в Главе 10. А пока знайте, что вид данных `Vec<T>`, предоставляемый встроенной библиотекой, может хранить любой вид данных. Когда мы создаём новый вектор для хранения определенного вида данных, мы можем указать этот вид данных в угловых скобках. В приложении 8-1 мы сообщили Ржавчине, что вектор `Vec<T>` в переменной `v` будет хранить значения вида данных `i32`.

Чаще всего вы будете создавать `Vec<T>` с начальными значениями. Ржавчина может определить вид данных присваиваемых вами значений, но иногда вам всё же придётся указывать изложение вида данных. Для удобства, Ржавчина предоставляет макрос `vec!`, который создаст новый вектор, содержащий заданные вами значения. В приложении 8-2 создаётся новый вектор `Vec<i32>`, который будет хранить значения `1`, `2` и `3`. Числовым видом данных является `i32`, потому что это вид данных по установлен умолчанию для целочисленных значений, о чём упоминалось в разделе [“Виды данных”] Главы 3.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-02/src/main.rs:here}}
```

<span class="caption">Приложение 8-2: Создание нового вектора, содержащего значения</span>

Поскольку мы указали начальные значения вида данных `i32`, Ржавчина может сделать вывод, что вид данных переменной `v` это `Vec<i32>` и изложение вида данных здесь не нужно. Далее мы посмотрим как изменять вектор.

### Изменение вектора

Чтобы создать вектор и затем добавить к нему элементы, можно использовать способ `push`, показанный в приложении 8-3.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-03/src/main.rs:here}}
```

<span class="caption">Приложение 8-3: Использование способа <code>push</code> для добавления значений в вектор</span>

Как и с любой переменной, если мы хотим изменить её значение, нам нужно сделать её изменяемой с помощью ключевого слова `mut`, что обсуждалось в Главе 3. Все числа, которые мы помещаем в вектор имеют вид данных `i32` по умолчанию, поэтому Ржавчина с лёгкостью сама определяет вид данных `вектора`, по этой причине здесь не требуется изложение вида данных вектора как `Vec<i32>`.

### Чтение данных вектора

Есть два способа сослаться на значение, хранящееся в векторе: с помощью порядкового указателя или способа `get` . В следующих примерах для большей ясности мы указали виды данных значений, возвращаемых этими функциями.

В приложении 8-4 показаны оба способа доступа к значению в векторе: с помощью правил порядка и с помощью способа `get`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-04/src/main.rs:here}}
```

<span class="caption">Приложение 8-4. Использование правил порядка и способа <code>get</code>, для доступа к элементу в векторе</span>

Обратите внимание здесь на пару подробностей. Мы используем значение порядкового указателя `2` для получения третьего элемента: векторы упорядочиваются начиная с нуля. Указывая `&` и `[]` мы получаем ссылку на элемент по указанному порядковому указателю. Когда мы используем способ `get` содержащего порядковый указатель, переданный в качестве переменной, мы получаем вид данных `Option<&T>`, который мы можем проверить с помощью `match`.

Причина, по которой Ржавчина предоставляет два способа ссылки на элемент, заключается в том, что вы можете выбрать, как программа будет себя вести, когда вы попытаетесь использовать значение порядкового указателя за пределами ряда существующих элементов. В качестве примера давайте посмотрим, что происходит, когда у нас есть вектор из пяти элементов, а затем мы пытаемся получить доступ к элементу с порядковым указателем 100 с помощью каждого способа, как показано в приложении 8-5.

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-05/src/main.rs:here}}
```

<span class="caption">Приложение 8-5. Попытка доступа к элементу с порядковым указателем 100 в векторе, содержащем пять элементов</span>

Когда мы запускаем эту рукопись, первая строка с `&v[100]` вызовет сбой программы, потому что происходит попытка получить ссылку на несуществующий элемент. Такой подход лучше всего использовать, когда вы хотите, чтобы ваша программа со сбоем завершила работу при попытке доступа к элементу за пределами вектора.

Когда способу `get` передаётся порядковый указатель, который находится за пределами вектора, он без сбоя возвращает `None`. Вы могли бы использовать такой подход, если доступ к элементу за пределами ряда вектора происходит время от времени при обычных обстоятельствах. Тогда ваша рукопись будет иметь ход мыслей для обработки наличия `Some(&element)` или `None`, как обсуждалось в Главе 6. Например, порядковый указатель может исходить от человека, вводящего число. Если пользователь случайно введёт слишком большое число, то программа получит значение `None` и у вас будет возможность сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему возможность ввести допустимое значение. Такое поведение было бы более дружелюбным для пользователя, чем внезапный сбой программы из-за опечатки!

Когда у программы есть действительная ссылка, borrow checker (средство проверки заимствований), обеспечивает соблюдение правил владения и заимствования (описанные в Главе 4), чтобы обеспечить, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, которое гласит, что у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в приложении 8-6, где мы храним неизменяемую ссылку на первый элемент вектора и затем пытаемся добавить элемент в конец вектора. Данная программа не будет работать, если мы также попробуем сослаться на данный элемент позже в функции:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-06/src/main.rs:here}}
```

<span class="caption">Приложение 8-6. Попытка добавить некоторый элемент в вектор, в то время когда есть ссылка на элемент вектора</span>

Сборка этой рукописи приведёт к ошибке:

```console
{{#include ../listings/ch08-common-collections/listing-08-06/output.txt}}
```

Рукопись в приложении 8-6 может выглядеть так, как будто она должна работать. Почему ссылка на первый элемент должна заботиться об изменениях в конце вектора? Эта ошибка возникает из-за особенности того, как работают векторы: поскольку векторы размещают значения в памяти друг за другом, добавление нового элемента в конец вектора может потребовать выделения новой памяти и повторения старых элементов в новое пространство, если нет достаточного места, чтобы разместить все элементы друг за другом там, где в данное мгновение хранится вектор. В этом случае ссылка на первый элемент будет указывать на освобождённую память. Правила заимствования предотвращают попадание программ в таком случае.

> Примечание: Дополнительные сведения о использовании вида данных `Vec<T>` смотрите в разделе ["The Rustonomicon"](https://doc.rust-lang.org/nomicon/vec/vec.html).

### Перебор значений в векторе

Для доступа к каждому элементу вектора по очереди, мы повторяем все элементы, вместо использования порядковых указателей для доступа к одному за раз. В приложении 8-7 показано, как использовать круговорот `for` для получения неизменяемых ссылок на каждый элемент в векторе значений вида данных `i32` и их вывода.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-07/src/main.rs:here}}
```

<span class="caption">Приложение 8-7. вывод каждого элемента векторе, при помощи повторения по элементам вектора с помощью круговорота <code>for</code></span>

Мы также можем повторять изменяемые ссылки на каждый элемент изменяемого вектора, чтобы вносить изменения во все элементы. Круговорот `for` в приложении 8-8 добавит `50` к каждому элементу.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
```

<span class="caption">Приложение 8-8. Повторение и изменение элементов вектора по изменяемым ссылкам</span>

Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать приказчик разыменования ссылки `*` для получения значения по ссылке в переменной `i` прежде чем использовать приказчик `+=`. Мы поговорим подробнее об приказчике разыменования в разделе [“Следование по указателю к значению с помощью приказчика разыменования”] Главы 15.

Перебор вектора, будь то неизменяемый или изменяемый, безопасен из-за правил проверки заимствования. Если бы мы попытались вставить или удалить элементы в телах круговорота `for` в приложениях 8-7 и 8-8, мы бы получили ошибку сборщика, подобную той, которую мы получили с рукописью в приложении 8-6. Ссылка на вектор, содержащийся в круговороте for, предотвращает одновременную изменение всего вектора.

### Использование перечислений для хранения множества разных видов

Векторы могут хранить значения только одинакового вида данных. Это может быть неудобно; определённо могут быть случаи когда надо хранить список элементов разных видов данных. К счастью, исходы перечисления определены для одного и того же вида перечисления, поэтому, когда нам нужен один вид данных для представления элементов разных видов данных, мы можем определить и использовать перечисление!

Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, некоторые числа с плавающей точкой, а другие - строковые значения. Можно определить перечисление, исходы которого будут содержать разные виды данных значений и тогда все исходы перечисления будут считаться одним и тем же видом: видом самого перечисления. Затем мы можем создать вектор для хранения этого перечисления и, в конечном счёте, для хранения различных видов. Мы покажем это в приложении 8-9.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-09/src/main.rs:here}}
```

<span class="caption">Приложение 8-9: Определение <code>enum</code> для хранения значений разных видов данных в одном векторе</span>

Ржавчина должна знать, какие виды данных будут в векторе во время сборки, чтобы точно знать сколько памяти в куче потребуется для хранения каждого элемента. Мы также должны чётко указать, какие виды данных разрешены в этом векторе. Если бы Ржавчина позволял вектору содержать любой вид данных, то был бы возможность что один или несколько видов данных вызовут ошибки при выполнении действий над элементами вектора. Использование перечисления вместе с выражением `match` означает, что во время сборки Ржавчина  заверяет, что все возможные исходы будут обработаны, как обсуждалось в главе 6.

Если вы не знаете исчерпывающий набор видов данных, которые программа получит во время выполнения для хранения в векторе, то техника использования перечисления не сработает. Вместо этого вы можете использовать сущность-предмет, который мы рассмотрим в главе 17.

Теперь, когда мы обсудили некоторые из наиболее распространённых способов использования векторов, обязательно ознакомьтесь [с пособием по API вектора](https://doc.rust-lang.org/std/vec/struct.Vec.html), чтобы узнать о множестве полезных способов, определённых в `Vec<T>` встроенной библиотеки. Например, в дополнение к способу `push`, существует способ `pop`, который удаляет и возвращает последний элемент.

### Удаление элементов из вектора

Подобно стопкам`struct`, вектор высвобождает свою память когда выходит из области видимости, что показано в приложении 8-10.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-10/src/main.rs:here}}
```

<span class="caption">Приложение 8-10. Показано как удаляется вектор и его элементы</span>

Когда вектор удаляется, всё его содержимое также удаляется: удаление вектора означает и удаление значений, которые он содержит. Средство проверки заимствования заверяет, что любые ссылки на содержимое вектора используются только тогда, когда сам вектор действителен.

Давайте перейдём к следующему виду собрания: `String`!


[“Виды данных”]: ch03-02-data-types.html#data-types
[“Следование по указателю к значению с помощью приказчика разыменования”]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator