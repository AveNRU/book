## Дополнение В: Выводимые особенности

Во многих частях книги мы обсуждали свойство `derive`, которые Вы могли применить к объявлению устройства или перечисления. Свойство `derive` порождает рукопись по умолчанию для выполнения особенности, который вы указали в  `derive`.

В этом дополнении, мы расскажем про все особенности, которые вы можете использовать в свойстве `derive`. Каждая раздел содержит:

- Действия и способы, добавляемые особенностью
- Как представлена выполнение особенности через `derive`
- Что выполнение особенности рассказывает про вид
- Условия, в которых разрешено или запрещено выполнить особенность
- Примеры случаев, которые требуют наличие особенности

Если Вам понадобилось поведение отличное от поведения при выполнения через `derive`, обратитесь к [пособия по встроенной библиотеке](../std/index.html)<!-- ignore --> чтобы узнать как вручную выполнить особенность.

Перечисленные здесь особенности являются единственными, определёнными встроенной библиотекой, которые могут быть выполнены в ваших видах с помощью `derive`. Другие особенности, определённые в встроенной библиотеке, не имеют ощутимого поведения по умолчанию, поэтому вам решать, как выполнить их для достижения ваших целей.

Пример особенности, который нельзя выполнить через derive - `Display`, который обрабатывает изменение
для конечных пользователей. Вы всегда должны сами рассмотреть лучший способ для отображения вида конечному пользователю. Какие части вида должны быть разрешены для просмотра конечному пользователю? Какие части они найдут подходящими? Какой вид вывода для них будет самым подходящим? Сборщик ржавчины не знает ответы на эти вопросы, поэтому он не может подобрать подходящее обычное поведение.

Список видов, выполняемых через derive, в этом дополнении не является исчерпывающим: библиотеки могут выполнить `derive` для их собственных особенностей, составляя свои списки особенностей, которые Вы можете использовать с помощью `derive`. Выполнение `derive` включает в себя использование процедурных макросов, которые были рассмотрены в разделе ["Макросы"]<!--  --> главы 19.

### `Debug` для отладочного вывода

Особенность `Debug` включает отладочное изменение
в изменяемых строках, которые вы можете указать с помощью `:?` внутри `{}` фигурных скобок.

Особенность `Debug` позволяет Вам напечатать предметы вида с целью отладки, поэтому Вы и другие программисты, использующие Ваш вид, смогут проверить предмет в определённой точке выполнения программы.

Особенность `Debug` обязателен в некоторых случаях. Например, при использовании макроса `assert_eq!`. Этот макрос печатает значения входных переменных, если они не совпадают. Это позволяет программистам увидеть, почему эти предметы не равны.

### `PartialEq` и `Eq` для сравнения равенства

Особенность `PartialEq` позволяет Вам сравнить предметы одного вида на эквивалентность, и включает для них использование приказчиков `==` и `!=`.

Использование `PartialEq` выполняет способ `eq`. Когда `PartialEq` используют для устройства, два предмета равны если равны *все* поля предметов, и предметы не равны, если хотя бы одно поле отлично. Когда используется для перечислений, каждый исход равен себе, и не равен другим исходам.

Особенность `PartialEq` обязателен в некоторых случаях. Например для макроса `assert_eq!`, где необходимо сравнивать два предмета одного вида на эквивалентность.

Особенность `Eq` не имеет способов. Он указывает что каждое значение определеного вида равно самому себе. Особенность `Eq` может быть применён только для видов выполняющих особенность `PartialEq`, хотя не все виды, которые выполняют `PartialEq` могут выполнить `Eq`. Примером являются числа с плавающей запятой: выполнение чисел с плавающей запятой говорит, что два образца со значениями не-число (`NaN`) не равны друг другу.

Особенность `Eq`необходим в некоторых случаях. Например, для ключей в `HashMap<K, V>`. Поэтому `HashMap<K, V>` может сказать, что два ключа являются одним и тем же.

### `PartialOrd` и `Ord` для сравнения порядка

Особенность `PartialOrd` позволяет Вам сравнить предметы одного вида с помощью сортировки. Вид, выполняющий `PartialOrd` может использоваться с приказчиками `<`, `>`, `<=`, и `>=`. Вы можете выполнить особенность `PartialOrd` только для видов, выполняющих `PartialEq`.

Использование `PartialOrd` выполняет способ `partial_cmp`, который возвращает `Option<Ordering>` который является `None` когда значения не выстраивают порядок. Примером значения, которое не может быть упорядочено, не являются числом (`NaN`) значение с плавающей запятой. Вызов `partial_cmp` с любым числом с плавающей запятой и значением `NaN` вернёт `None`.

Когда используется для устройств, `PartialOrd` сравнивает два предмета путём сравнения значений каждого поля в порядке, в котором поля объявлены в устройстве. Когда используется для перечислений, то исходы перечисления объявленные ранее будут меньше чем исходы объявленные позже.

Например, особенность `PartialOrd` может потребоваться для способа `gen_range` из `rand` ящика который порождает случайные значения в заданном ряде (который определён выражением ряда).

Особенность `Ord` позволяет знать, для двух значений определеного вида всегда будет существовать валидный порядок. Особенность `Ord` выполняет способ `cmp`, который возвращает `Ordering` а не `Option<Ordering>` потому что валидный порядок всегда будет существовать. Вы можете применить особенность  `Ord` только для видов, выполняющих особенность `PartialOrd` и `Eq` (`Eq` также требует `PartialEq`). При использовании на устройствах или перечислениях, `cmp` имеет такое же поведение, как и `partial_cmp` в`PartialOrd`.

Особенность `Ord` необходим в некоторых случаях. Например, сохранение значений в `BTreeSet<T>`, виде данных, который хранит сведения на основе порядка отсортированных данных.

### `Clone` и `Copy` для повторения значений

Особенность `Clone` позволяет вам явно создать глубокую повтор значения, а также этап повторения может вызывать особый рукопись и воспроизводить данные с кучи. Более подробно про `Clone` смотрите в разделы ["Способы взаимодействия переменных и данных: клонирование"](ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone) в разделе 4.

Использование `Clone` выполняет способ `clone`, который в случае выполнения на всем виде, вызывает `clone`для каждой части данных вида. Это подразумевает, что все поля или значения в виде также должны выполнить `Clone` для использования `Clone`.

Особенность `Clone` необходим в некоторых случаях. Например, для вызова способа `to_vec` для среза. Срез не владеет данными, содержащимися в нем, но вектор значений, возвращённый из `to_vec` должен владеть этими предметами, поэтому `to_vec` вызывает `clone` для всех данных. Таким образом, вид хранящийся в срезе, должен выполнить `Clone`.

Особенность `Copy` позволяет повторять значения повторяя только данные, которые хранятся на обойме, произвольный рукопись не требуется. Смотрите раздел ["Из обоймы данные: Повторение"](ch04-01-what-is-ownership.html#stack-only-data-copy)<!-- ignore --> в разделе 4 для большей сведений о `Copy`.

Особенность `Copy` не содержит способов для предотвращения перегрузки этих способов программистами, иначе бы это нарушило соглашение, что никакой произвольный рукопись не запускается. Таким образом все программисты могут предполагать, что повторение значений будет происходить быстро.

Вы можете вывести `Copy` для любого вида все части которого выполняют `Copy`. Вид который выполняет `Copy` должен также выполнить `Clone`, потому что вид выполняющий `Copy` имеет обыкновенную выполнение `Clone` который выполняет ту же задачу, что и `Copy`.

Особенность `Copy` нужен очень редко; виды, выполняющие `Copy` имеют небольшую переработку, то есть для него не нужно вызывать способ `clone`, который делает рукопись более кратким.

Все, что вы делаете с `Copy` можно также делать и с `Clone`, но рукопись может быть медленнее и требовать вызов способа `clone` в некоторых местах.

### `Hash` для превращения значения в значение конечного размера

Особенность `Hash` позволяет превратить значение произвольного размера в значение конечного размера с использованием хеш-функции. Использование `Hash` выполняет способ `hash`. При выполнения через derive, способ `hash` сочетает итоги вызова `hash` на каждой части данных вида, то есть все поля или значения должны выполнить `Hash` для использования `Hash` с помощью derive.

Особенность `Hash` необходим в некоторых случаях. Например, для хранения ключей в `HashMap<K, V>`, для их более качественного хранения.

### `Default` для значений по умолчанию

Особенность `Default` позволяет создавать значение по умолчанию для вида. Использование `Default` выполняет функцию `default`. Обычная выполнение способа `default` вызовет функцию `default` на каждой части данных вида, то есть для использования `Default` через derive, все поля и значения вида данных должны также выполнить `Default`.

Функция `Default::default`часто используется в сочетания с правилами написания обновления устройства, который мы обсуждали в разделы ["Создание образца устройства из образца другой устройства с помощью правил написания обновления устройства"](ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)<!-- ignore --> главы 5. Вы можете настроить несколько полей для устройства, а для остальных полей установить значения с помощью <code>..Default::default()</code>.

Особенность `Default` необходим в некоторых случаях. Например, для способа `unwrap_or_default` у вида `Option<T>`. Если значение `Option<T>` будет `None`, способ `unwrap_or_default` вернёт итог вызова функции `Default::default` для вида `T`, хранящегося в `Option<T>`.


["Макросы"]: ch19-06-macros.html#macros