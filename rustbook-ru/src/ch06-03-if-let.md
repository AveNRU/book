## Краткое управление потоком выполнения с `if let`

правила написания `if let` позволяет ссоединенять `if` и `let` в менее многословную устройство, и затем обработать значения соответствующе только одному шаблону, одновременно пренебрегая все остальные. Рассмотрим программу в приложении 6-6, которая обрабатывает сопоставление значения `Option<u8>` в переменной `config_max`, но хочет выполнить код только в том случае, если значение является вариантом `Some`.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
```

<span class="caption">Приложение 6-6. Выражение <code>match</code>, которое выполнит код только при значении равном <code>Some</code></span>

Если значение равно `Some`, мы распечатываем значение в варианте `Some`, привязывая значение к переменной `max` в шаблоне. Мы не хотим ничего делать со значением `None`. Чтобы удовлетворить выражение `match`, мы должны добавить `_ => ()` после обработки первой и единственной ветки, и добавление шаблонного кода раздражает.

Вместо этого, мы могли бы написать это более коротким способом, используя `if let`. Следующий код ведёт себя так же, как выражение `match` в приложении 6-6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
```

правила написания `if let` принимает шаблон и выражение, разделённые знаком равенства. Он работает так же, как `match`, когда в него на вход передадут выражение и подходящим шаблоном для этого выражения окажется первая ветка. В данном случае шаблоном является `Some(max)`, где `max` привязывается к значению внутри `Some`. Затем мы можем использовать `max` в теле раздела `if let` так же, как мы использовали `max` в соответствующей ветке `match`. Код в разделе `if let` не запускается, если значение не соответствует шаблону.

Используя `if let` мы меньше печатаем, меньше делаем отступов и меньше получаем шаблонного кода. Тем не менее, мы теряем полную проверку всех вариантов, предоставляемую выражением `match`. Выбор между `match` и `if let` зависит от того, что вы делаете в вашем определенном случае и является ли получение краткости при потере полноты проверки подходящим соглашением.

Другими словами, вы можете думать о устройства `if let` как о <em>синтаксическом сахаре</em> для `match`, который выполнит код если входное значение будет соответствовать единственному шаблону, и пропренебрегает все остальные значения.

Можно добавлять `else` к `if let`. Разделкода, который находится внутри `else` подобен по смыслу блоку кода ветки связанной с шаблоном `_` выражения `match` (которое эквивалентно сборной устройства `if let` и `else`). Вспомним объявление перечисления `Coin` в приложении 6-4, где вариант `Quarter` также содержит внутри значение штата вида `UsState`. Если бы мы хотели посчитать все монеты не являющиеся четвертями, а для четвертей печатать название штата, то мы могли бы сделать это с помощью выражения `match` таким образом:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
```

Или мы могли бы использовать выражение `if let` и `else` так:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
```

Если у вас есть случаей в которой ваша программа имеет логику которая слишком многословна для того чтобы её выражать используя `match`, помните, о том, что также в вашем наборе средств Ржавчина есть `if let`.

## Итоги

Мы рассмотрели как использовать перечисления для создания пользовательских видов, которые могут быть одним из наборов перечисляемых значений. Мы показали, как вид `Option<T>` из встроенной библиотеки помогает использовать систему видов для предотвращения ошибок. А когда значения перечисления имеют данные внутри них, можно использовать `match` или `if let`, чтобы извлечь и пользоваться значением, в зависимости от того, сколько случаев нужно обработать.

Теперь ваши программы на Ржавчина могут выражать подходы вашей предметной области, используя структуры и перечисления. Создание и использование пользовательских видов в API обеспечивает <em>типобезопасность</em>: сборщик позаботится о том, чтобы функции получали значения только того вида, который они ожидают.

Чтобы предоставить вашим пользователям хорошо согласованный API, который прост в использовании и предоставляет только то, что нужно вашим пользователям, надо поговорить о модулях в Rust.
