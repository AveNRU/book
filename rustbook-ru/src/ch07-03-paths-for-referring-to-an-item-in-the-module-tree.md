## Пути для ссылки на элемент в дереве звеньев

Чтобы показать Ржавчина, где найти элемент в дереве звеньев, мы используем путь так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать её путь.

Пути бывают двух видов:

- *абсолютный путь* - это полный путь, начинающийся от корневого звена ящика; для кода из внешнего ящика абсолютный путь начинается с имени ящика, а для кода из текущего ящика он начинается с записи `crate`.
- *относительный путь* начинается с текущего звена и использует ключевые слова `self`, `super` или определитель в текущем звене.

Как абсолютные, так и относительные, пути состоят из одного или нескольких определителей, разделённых двойными двоеточиями (`::`).

Вернёмся к приложению 7-1, скажем, мы хотим вызвать функцию `add_to_waitlist`. Это то же самое, что спросить: какой путь у функции `add_to_waitlist`? В приложении 7-3 мы немного упроисполнения код приложения 7-1, удалив некоторые звенья и функции.

Мы покажем два способа вызова функции `add_to_waitlist` из новой функции `eat_at_restaurant`, определённой в корневом звене ящика. Эти пути правильные, но остаётся ещё одна неполадка, которая не позволит этому примеру собраться как есть. Мы скоро объясним почему.

Функция `eat_at_restaurant` является частью общедоступного API нашего библиотечного ящика, поэтому мы помечаем её ключевым словом `pub`. В разделе <a data-md-type="raw_html" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Раскрываем закрытые пути с помощью ключевого слова `pub`"</a><!-- ignore --> мы рассмотрим более подробно `pub`.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}
```

<span class="caption">Приложение 7-3. Вызов функции <code>add_to_waitlist</code> с использованием абсолютного и относительного пути</span>

При первом вызове функции `add_to_waitlist` из `eat_at_restaurant` мы используем абсолютный путь. Функция `add_to_waitlist` определена в том же ящике, что и `eat_at_restaurant`, и это означает, что мы можем использовать ключевое слово `crate` в начале абсолютного пути. Затем мы добавляем каждый из последующих дочерних звеньев, пока не составим путь до `add_to_waitlist`. Вы можете представить себе файловую систему с такой же устройством: мы указываем путь `/front_of_house/hosting/add_to_waitlist` для запуска программы `add_to_waitlist`; использование имени `crate` в качестве корневого звена ящика подобно использованию `/` для указания корня файловой системы в вашей оболочке.

Второй раз, когда мы вызываем `add_to_waitlist` из `eat_at_restaurant`, мы используем относительный путь. Путь начинается с имени звена `front_of_house`, определённого на том же уровне дерева звеньев, что и `eat_at_restaurant`. Для эквивалентной файловой системы использовался бы путь `front_of_house/hosting/add_to_waitlist`. Начало пути с имени звена означает, что путь является относительным.

Выбор, использовать относительный или абсолютный путь, является решением, которое вы примете на основании вашего дела. Решение должно зависеть от того, с какой вероятностью вы переместите объявление элемента отдельно от или вместе с кодом использующим этот элемент. Например, в случае перемещения звена `front_of_house` и его функции `eat_at_restaurant` в другой звено с именем `customer_experience`, будет необходимо обновить абсолютный путь до `add_to_waitlist`, но относительный путь всё равно будет действителен. Однако, если мы переместим отдельно функцию `eat_at_restaurant` в звено с именем `dining`, то абсолютный путь вызова `add_to_waitlist` останется прежним, а относительный путь нужно будет обновить. Мы предпочитаем указывать абсолютные пути, потому что это позволяет проще перемещать определения кода и вызовы элементов независимо друг от друга.

Давайте попробуем собрать код из приложения 7-3 и выяснить, почему он ещё не собирается. Ошибка, которую мы получаем, показана в приложении 7-4.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
```

<span class="caption">Приложение 7-4. Ошибки сборки при сборке кода из приложения 7-3</span>

Сообщения об ошибках говорят о том, что звено `hosting` является закрытым. Другими словами, у нас есть правильные пути к звену `hosting` и функции `add_to_waitlist`, но Ржавчина не позволяет нам использовать их, потому что у него нет доступа к закрытым разделам. В Ржавчина все элементы (функции, способы, устройства, перечисления, звенья и постоянные значения) по умолчанию являются закрытыми для родительских звеньев. Если вы хотите сделать элемент, например функцию или устройство, закрытым, вы помещаете его в звено.

Элементы в родительском звене не могут использовать закрытые элементы внутри дочерних звеньев, но элементы в дочерних звенах могут использовать элементы у своих звенах-предках. Это связано с тем, что дочерние звенья оборачивают и скрывают подробности своей выполнения, но дочерние звенья могут видеть среда, в котором они определены. Продолжая нашу метафору, подумайте о правилах закрытости как о задней части ресторана: то, что там происходит, скрыто от клиентов ресторана, но офис-управленцы могут видеть и делать всё в ресторане, которым они управляют.

В Ржавчина решили, что система звеньев должна исполняться таким образом, чтобы по умолчанию скрывать подробности выполнения. Таким образом, вы знаете, какие части внутреннего кода вы можете изменять не нарушая работы внешнего кода. Тем не менее, Ржавчина даёт нам возможность открывать внутренние части кода дочерних звеньев для внешних звеньев-предков, используя ключевое слово `pub`, чтобы сделать элемент общедоступным.

### Раскрываем закрытые пути с помощью ключевого слова `pub`<a id="exposing-paths-with-the-pub-keyword"></a>

Давайте вернёмся к ошибке в приложении 7-4, которая говорит, что звено `hosting` является закрытым. Мы хотим, чтобы функция `eat_at_restaurant` из родительского звена имела доступ к функции `add_to_waitlist` в дочернем звене, поэтому мы помечаем звено `hosting` ключевым словом `pub`, как показано в приложении 7-5.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}
```

<span class="caption">Приложение 7-5. Объявление звена <code>hosting</code> как <code>pub</code> для его использования из <code>eat_at_restaurant</code></span>

К сожалению, код в приложении 7-5 всё ещё приводит к ошибке, как показано в приложении 7-6.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
```

<span class="caption">Приложение 7-6: Ошибки сборки при сборке кода в приложении 7-5</span>

Что произошло? Добавление ключевого слова `pub` перед `mod hosting` сделало звено общедоступным. После этого изменения, если мы можем получить доступ к звену `front_of_house`, то мы можем получить доступ к звену `hosting`. Но *содержимое* звена `hosting` всё ещё является закрытым: превращение звена в общедоступный звено не делает его содержимое общедоступным. Ключевое слово `pub` позволяет внешнему коду в звенах-предках обращаться только к звену, без доступа ко внутреннему коду. Поскольку звенья являются дополнениями, мы мало что можем сделать, просто сделав звено общедоступным; нам нужно пойти дальше и сделать один или несколько элементов в звене общедоступными.

Ошибки в приложении 7-6 говорят, что функция `add_to_waitlist` является закрытой. Правила закрытости применяются к устройствам, перечислениям, функциям и способам, также как и к звенам.

Давайте также сделаем функцию `add_to_waitlist` общедоступной, добавив ключевое слово `pub` перед её определением, как показано в приложении 7-7.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}
```

<span class="caption">Приложение 7-7. Добавление ключевого слова <code>pub</code> к <code>mod hosting</code> и к <code>fn add_to_waitlist</code> позволяет нам вызывать функцию из <code>eat_at_restaurant</code></span>

Теперь код собирается! Чтобы понять, почему добавление ключевого слова `pub` позволяет нам использовать эти пути для `add_to_waitlist` в соответствии с правилами закрытости, давайте рассмотрим абсолютный и относительный пути.

В случае абсолютного пути мы начинаем с `crate`, корня дерева звеньев нашего ящика. Звено `front_of_house` определён в корневом звене ящика. Хотя `front_of_house` не является общедоступным, но поскольку функция `eat_at_restaurant` определена в том же звене, что и `front_of_house` (то есть, `eat_at_restaurant` и `front_of_house` являются потомками одного родителя), мы можем ссылаться на `front_of_house` из `eat_at_restaurant`. Далее идёт звено `hosting`, помеченный как `pub`. Мы можем получить доступ к родительскому звену звена `hosting`, поэтому мы можем получить доступ и к `hosting`. Наконец, функция `add_to_waitlist` помечена как `pub`, и так как мы можем получить доступ к её родительскому звену, то вызов этой функции разрешён!

В случае относительного пути логика такая же как для абсолютного пути, за исключением первого шага: вместо того, чтобы начинать с корневого звена ящика, путь начинается с `front_of_house`. Звено `front_of_house` определён в том же звене, что и `eat_at_restaurant`, поэтому относительный путь, начинающийся с звена, в котором определена `eat_at_restaurant` тоже работает. Тогда, по причине того, что `hosting` и `add_to_waitlist` помечены как `pub`, остальная часть пути работает и вызов этой функции разрешён!

Если вы собираетесь предоставить общий доступ к своему библиотечному ящику, чтобы другие дела могли использовать ваш код, ваш общедоступный API — это ваш договор с пользователями вашего ящика, определяющий, как они могут взаимодействовать с вашим кодом. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать необременительным для людей зависимость от вашего ящика. Эти соображения выходят за рамки этой книги; если вам важна эта тема, см. [The Ржавчина API Guidelines].

> #### Лучшие опытов для дополнений с двоичным и библиотечным ящиками
>
> Мы упоминали, что дополнение может содержать как корневой звено двоичного ящика *src/main.rs*, так и корневой звено библиотечного ящика *src/lib.rs*, и оба ящика будут по умолчанию иметь имя дополнения. Как правило, дополнения с таким образцом, содержащим как библиотечный, так и двоичный ящик, будут иметь достаточно кода в двоичном ящике, чтобы запустить исполняемый файл, который вызывает код из библиотечного ящика. Это позволяет другим делам извлечь выгоду из большей части возможности, предоставляемой дополнением, поскольку код библиотечного ящика можно использовать совместно.
>
> Дерево звеньев должно быть определено в *src/lib.rs*. Затем любые общедоступные элементы можно использовать в двоичном ящике, начав пути с имени дополнения. Двоичный ящик становится пользователем библиотечного ящика точно так же, как полностью внешний ящик использует библиотечный ящик: он может использовать только общедоступный API. Это поможет вам разработать хороший API; вы не только автор, но и пользователь!
>
> В [Главе 12]<!-- ignore --> мы эту опыт согласования кода с помощью окно выводаной программы, которая будет содержать как двоичный, так и библиотечный ящики.

### Начинаем относительный путь с помощью `super`

Также можно построить относительные пути, которые начинаются в родительском звене, используя ключевое слово `super` в начале пути. Это похоже на правила написания начала пути файловой системы `..`. Использование `super` позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском звене, что может упростить переупорядочение дерева звеньев, чем когда звено тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве звеньев.

Рассмотрим код в приложении 7-8, где расчитывается случай, в которой повар исправляет неправильный заказ и лично приносит его клиенту. Функция `fix_incorrect_order` вызывает функцию `deliver_order`, определённую в родительском звене, указывая путь к `deliver_order`, начинающийся с `super`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}
```

<span class="caption">Приложение 7-8: Вызов функции с использованием относительного пути, начинающегося с <code>super</code></span>

Функция `fix_incorrect_order` находится в звене `back_of_house`, поэтому мы можем использовать `super` для перехода к родительскому звену звена `back_of_house`, который в этом случае является `crate`, корневым звеном. В этом звене мы ищем `deliver_order` и находим его. Успех! Мы думаем, что звено `back_of_house` и функция `deliver_order`, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут перемещены вместе, если мы решим ресогласовать дерево звеньев ящика. Поэтому мы использовали `super`, чтобы в будущем у нас было меньше мест для обновления кода, если этот код будет перемещён в другой звено.

### Делаем общедоступными устройства и перечисления

Мы также можем использовать `pub` для обозначения устройств и перечислений как общедоступных, но есть несколько дополнительных подробностей использования `pub` со устройствами и перечислениями. Если мы используем `pub` перед определением устройства, мы делаем устройство общедоступной, но поля устройства по-прежнему остаются закрытыми. Мы можем сделать каждое поле общедоступным или нет в каждом определенном случае. В приложении 7-9 мы определили общедоступную устройство `back_of_house::Breakfast` с общедоступным полем `toast` и с закрытым полем `seasonal_fruit`. Это расчитывает случай в ресторане, когда клиент может выбрать вид хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому клиенты не могут выбирать фрукты или даже увидеть, какие фрукты они получат.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}
```

<span class="caption">Приложение 7-9: Устройства с общедоступными и закрытыми полями</span>

Поскольку поле `toast` в устройстве `back_of_house::Breakfast` является открытым, то в функции `eat_at_restaurant` можно писать и читать поле `toast`, используя точечную наставление. Обратите внимание, что мы не можем использовать поле `seasonal_fruit` в `eat_at_restaurant`, потому что `seasonal_fruit` является закрытым. Попробуйте убрать примечания с последней строки для значения поля `seasonal_fruit`, чтобы увидеть какую ошибку вы получите!

Также обратите внимание, что поскольку `back_of_house::Breakfast` имеет закрытое поле, то устройства должна предоставить открытую сопряженную функцию, которая создаёт образец `Breakfast` (мы назвали её `summer`). Если `Breakfast` не имел бы такой функции, мы бы не могли создать образец `Breakfast` внутри `eat_at_restaurant`, потому что мы не смогли бы установить значение закрытого поля `seasonal_fruit` в функции `eat_at_restaurant`.

В отличии от устройства, если мы сделаем общедоступным перечисление, то все его исходы будут общедоступными. Нужно только указать `pub` перед ключевым словом `enum`, как показано в приложении 7-10.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}
```

<span class="caption">Приложение 7-10. Определяя перечисление общедоступным мы делаем все его исходы общедоступными</span>

Поскольку мы сделали общедоступным перечисление `Appetizer`, то можно использовать исходы `Soup` и `Salad` в функции `eat_at_restaurant`.

Перечисления не очень полезны, если их исходы не являются общедоступными: было бы досадно каждый раз определять все исходы перечисления как `pub`. По этой причине по умолчанию исходы перечислений являются общедоступными. Устройства часто полезны, если их поля не являются общедоступными, поэтому поля устройства следуют общему правилу, согласно которому, всё по умолчанию является закрытым, если не указано `pub`.

Есть ещё одна случай с `pub`, которую мы не освещали, и это последняя особенность состоящей из звеньев системы: ключевое слово `use`. Мы сначала опишем `use` само по себе, а затем покажем как сочетать `pub` и `use` вместе.


[The Ржавчина API Guidelines]: https://rust-lang.github.io/api-guidelines/
[Главе 12]: ch12-00-an-io-project.html