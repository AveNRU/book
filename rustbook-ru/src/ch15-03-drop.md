## Запуск кода при очистке с помощью типажа `Drop`

Вторым важным типажом умного указателя является Drop, который позволяет управлять, что происходит, когда значение вот-вот выйдет из области видимости. Вы можете реализовать типаж Drop для любого вида, а также использовать этот код для высвобождения ресурсов, таких как файлы или сетевые соединения.

Мы рассматриваем `Drop` в среде умных указателей, потому что функциональность свойства `Drop` по сути всегда используется при реализации умного указателя. Например, при сбросе `Box<T>` происходит деаллокация пространства на куче, на которое указывает box.

В некоторых языках для некоторых видов программист должен вызывать код для освобождения памяти или ресурсов каждый раз, когда он завершает использование образцов этих видов. Примерами могут служить дескрипторы файлов, сокеты или блокировки. Если забыть об этом, система окажется перегруженной и может упасть. В Ржавчина вы можете указать, что определённый фрагмент кода должен выполняться всякий раз, когда значение выходит из области видимости, и сборщик самостоятельно будет его вставлять. Как следствие, вам не нужно заботиться о размещении кода очистки везде в программе, где завершается работа образца определённого вида - утечки ресурсов все равно не будет!

Вы можете задать определённую логику, которая будет выполняться, когда значение выходит за пределы области видимости, реализовав признак `Drop`. Типаж `Drop` требует от вас реализации одного способа `drop`, который принимает изменяемую ссылку на `self`. Чтобы увидеть, когда Ржавчина вызывает `drop`, давайте реализуем `drop` с помощью указаний `println!`.

В приложении 15-14 показана структура `CustomSmartPointer`, единственной не имеющей себе подобных функциональностью которой является печать `Dropping CustomSmartPointer!`, когда образец выходит из области видимости, чтобы показать, когда Ржавчина выполняет функцию `drop`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-14/src/main.rs}}
```

<span class="caption">Приложение 15-14: Структура <code>CustomSmartPointer</code>, реализующая типаж <code>Drop</code>, куда мы поместим наш код очистки</span>

Типаж `Drop` включён в прелюдию, поэтому нам не нужно вводить его в область видимости. Мы реализуем типаж `Drop` для `CustomSmartPointer` и реализуем способ `drop`, который будет вызывать `println!`. Тело функции `drop` - это место, где должна располагаться вся логика, которую вы захотите выполнять, когда образец вашего вида выйдет из области видимости. Мы печатаем здесь текст, чтобы наглядно отобразить, когда Ржавчина вызовет `drop`.

В `main` мы создаём два образца `CustomSmartPointer` и затем печатаем `CustomSmartPointers created` . В конце `main` наши образцы `CustomSmartPointer` выйдут из области видимости и Ржавчина вызовет код, который мы добавили в способ `drop`, который и напечатает наше окончательное сообщение. Обратите внимание, что нам не нужно вызывать способ `drop` явно.

Когда мы запустим эту программу, мы увидим следующий вывод:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-14/output.txt}}
```

Rust самостоятельно вызывал `drop` в мгновение выхода наших образцов из области видимости, тем самым выполнив заданный нами код. Переменные удаляются в обратном порядке их создания, поэтому `d` была удалена до `c`. Цель этого примера — дать вам наглядное представление о том, как работает способ `drop`; в типичных случаях вы будете задавать код очистки, который должен выполнить ваш вид, а не печатать сообщение.

### Раннее удаление значения с помощью `std::mem::drop`

К сожалению, отключение функции самостоятельного удаления с помощью `drop` является не простым. Отключение `drop` обычно не требуется; весь смысл типажа `Drop` в том, чтобы о функции позаботились самостоятельно . Иногда, однако, вы можете захотеть очистить значение рано. Одним из примеров является использование умных указателей, которые управляют блокировками: вы могли бы потребовать принудительный вызов способа `drop` который снимает блокировку, чтобы другой код в той же области видимости мог получить блокировку. Ржавчина не позволяет вызвать способ типажа `Drop` вручную; вместо этого вы должны вызвать функцию `std::mem::drop` предоставляемую встроенной библиотекой, если хотите принудительно удалить значение до конца области видимости.

Если попытаться вызвать способ `drop` типажа `Drop` вручную, изменяя функцию `main` приложения 15-14 так, как показано в приложении 15-15, мы получим ошибку сборщика:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-15/src/main.rs:here}}
```

<span class="caption">Приложение 15-15: Попытка вызвать способ <code>drop</code> из особенности <code>Drop</code> вручную для досрочной очистки</span>

Когда мы попытаемся собрать этот код, мы получим ошибку:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-15/output.txt}}
```

Это сообщение об ошибке говорит, что мы не можем явно вызывать `drop`. В сообщении об ошибке используется понятие *деструктор (destructor)*, который является общим понятием программирования для функции, которая очищает образец. *Деструктор* подобен *строителю*, который создаёт образец. Функция `drop` в Ржавчина является определённым деструктором.

Rust не позволяет обращаться к `drop` напрямую, потому что он все равно самостоятельно вызовет `drop` в конце `main`. Это вызвало бы ошибку *double free*, потому что в этом случае Ржавчина попытался бы дважды очистить одно и то же значение.

Невозможно отключить самостоятельную подстановку вызова `drop`, когда значение выходит из области видимости, и нельзя вызвать способ `drop` напрямую. Поэтому, если нам нужно принудительно избавиться от значения раньше времени, следует использовать функцию `std::mem::drop`.

Функция `std::mem::drop` отличается от способа `drop` особенности `Drop`. Мы вызываем её, передавая в качестве переменной значение, которое хотим принудительно уничтожить. Функция находится в прелюдии, поэтому мы можем изменить `main` в приложении 15-15 так, чтобы вызвать функцию `drop`, как показано в приложении 15-16:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-16/src/main.rs:here}}
```

<span class="caption">Приложение 15-16: Вызов <code>std::mem::drop</code> для принудительного удаления значения до того, как оно выйдет из области видимости</span>

Выполнение данного кода выведет следующий итог::

```console
{{#include ../listings/ch15-smart-pointers/listing-15-16/output.txt}}
```

Текст `Dropping CustomSmartPointer with data `some data`!`, напечатанный между `CustomSmartPointer created.` и текстом `CustomSmartPointer dropped before the end of main.`, показывает, что код способа `drop` вызывается для удаления `c` в этой точке.

Вы можете использовать код, указанный в реализации типажа `Drop`, чтобы сделать очистку удобной и безопасной: например, вы можете использовать её для создания своего собственного управленца памяти! С помощью типажа `Drop` и системы владения Ржавчина не нужно целенаправленно заботиться о том, чтобы освобождать ресурсы, потому что Ржавчина делает это самостоятельно .

Также не нужно беспокоиться о неполадках, возникающих в итоге случайной очистки значений, которые всё ещё используются: система владения, которая заверяет, что ссылки всегда действительны, также заверяет, что `drop` вызывается только один раз, когда значение больше не используется.

После того, как мы познакомились с `Box<T>` и свойствами умных указателей, познакомимся с другими умными указателями, определёнными в встроенной библиотеке.
