## Привет, Cargo!

Cargo - это система сборки и управленец дополнений Rust. Большая часть разработчиков используют данный средство для управления делами, потому что Cargo выполняет за вас множество задач, таких как сборка кода, загрузка библиотек, от которых зависит ваш код, и создание этих библиотек. (Мы называем библиотеки, которые нужны вашему коду, *зависимостями*.)

Самые простые программы на Rust, подобные той, которую мы написали, не имеют никаких зависимостей. Если бы мы сделали дело «Hello, world!» с Cargo, он бы использовал только ту часть Cargo, которая отвечает за сборку вашего кода. По мере написания более сложных программ на Ржавчина вы будете добавлять зависимости, а если вы начнёте дело с использованием Cargo, добавлять зависимости станет намного проще.

Поскольку значительное число дел Ржавчина используют Cargo, оставшаяся часть книги подразумевает, что вы тоже используете Cargo. Cargo входит в состав поставки Rust, если вы использовали напрямую от разрабочиков программы установки, рассмотренные в разделе ["Установка"]<!-- ignore -->. Если вы установили Ржавчина другим способом, проверьте, установлен ли Cargo, введя в окне вызова следующее:

```console
$ cargo --version
```

Если приказ выдал номер исполнения, то значит Cargo установлен. Если вы видите ошибку, вроде `command not found` ("приказ не найдена"), загляните в документацию для использованного вами способа установки, чтобы выполнить установку Cargo отдельно.

### Создание дела с помощью Cargo

Давайте создадим новый дело с помощью Cargo и посмотрим, как он отличается от нашего начального дела "Hello, world!". Перейдите обратно в папку *projects* (или любую другую, где вы решили сохранять код). Затем, в любой операционной системе, запустите приказ:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

Первая приказ создаёт новый папка и дело с именем *hello_cargo*. Мы назвали наш дело *hello_cargo*, и Cargo создаёт свои файлы в папке с тем же именем.

Перейдём в папка *hello_cargo* и посмотрим файлы. Увидим, что Cargo создал два файла и одну папку: файл  *Cargo.toml* и папка *src* с файлом *main.rs* внутри.

Кроме того, cargo объявлял новый хранилище Git вместе с файлом *.gitignore*. Файлы Git не будут созданы, если вы запустите `cargo new` в существующем хранилища Git; вы можете изменить это поведение, используя `cargo new --vcs=git`.

> Примечание. Git — это распространённая система управления исполнений. Вы можете изменить `cargo new`, чтобы использовать другую систему управления исполнений или не использовать систему управления исполнений, используя флаг `--vcs`. Запустите `cargo new --help`, чтобы увидеть доступные свойства.

Откройте файл *Cargo.toml* в любом текстовом редакторе. Он должен выглядеть как код в приложении 1-2.

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

<span class="caption">Приложение 1-2: Содержимое файла <em>Cargo.toml</em>, созданное приказом <code>cargo new</code></span>

Это файл в виде[*TOML*](https://github.com/toml-lang/toml)<!--  --> (*Tom’s Obvious, Minimal Language*), который является видом настроек Cargo.

Первая строка, `[package]`, является заголовочной разделом, которая указывает что следующие указания настраивают дополнение. По мере добавления больше сведений в данный файл, будет добавляться больше разделов и указаний (строк).

Следующие три строки задают сведения о настройке, необходимую Cargo для сборки вашей программы: имя, исполнение и издание Rust, который будет использоваться. Мы поговорим о ключе `edition` в [Приложении E]<!-- ignore -->.

Последняя строка, `[dependencies]` является началом разделы для списка любых зависимостей вашего дела. В Rust, это внешние дополнения кода, на которые ссылаются ключевым словом *crate*. Нам не нужны никакие зависимости в данном деле, но мы будем использовать их в первом деле главы 2, так что нам пригодится данная раздел зависимостей потом.

Откройте файл *src/main.rs* и загляните в него:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo создал для вас программу "Hello, world!", подобную той, которую мы написали в Приложении 1-1! Пока что различия между нашим предыдущим делом и делом, созданным при помощи Cargo, заключаются в том, что Cargo поместил исходный код в папка *src*, и у нас есть настроечный файл *Cargo.toml* в верхнем папке дела.

Cargo ожидает, что ваши исходные файлы находятся внутри папки *src*. Папка верхнего уровня дела предназначен только для файлов README, сведений о лицензии, файлы настройке и чего то ещё не относящего к вашему коду. Использование Cargo помогает создавать дело. Есть место для всего и все находится на своём месте.

Если вы начали дело без использования Cargo, как мы делали для "Hello, world!" дела, то можно преобразовывать его в дело с использованием Cargo. Переместите код в подпапка *src* и создайте соответствующий файл *Cargo.toml* в папке.

### Сборка и запуск Cargo дела

Посмотрим, в чем разница при сборке и запуске программы "Hello, world!" с помощью Cargo. В папке *hello_cargo* соберите дело следующей приказом:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Этот приказ создаёт исполняемый файл в *target/debug/hello_cargo* (или *target\debug\hello_cargo.exe* в Windows), а не в вашем текущем папке. Поскольку обычная сборка является отладочной, Cargo помещает двоичный файл в папка с именем *debug*. Вы можете запустить исполняемый файл с помощью этой приказы:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

Если все хорошо, то `Hello, world!` печатается в окне вызова. Запуск приказы `cargo build` в первый раз также приводит к созданию нового файла *Cargo.lock* в папке верхнего уровня. Данный файл хранит точные исполнения зависимостей вашего дела. Так как у нас нет зависимостей, то файл пустой. Вы никогда не должны менять этот файл вручную: Cargo сам управляет его содержимым для вас.

Только что мы собрали дело приказом `cargo build` и запустили его из `./target/debug/hello_cargo`. Но мы также можем при помощи приказы `cargo run` сразу и собрать код, и затем запустить полученный исполняемый файл всего лишь одной приказом:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Использование `cargo run` более удобно, чем необходимость помнить и запускать `cargo build`, а затем использовать весь путь к двоичному файлу, поэтому большинство разработчиков используют `cargo run`.

Обратите внимание, что на этот раз мы не видели вывода, указывающего на то, что Cargo собирает `hello_cargo`. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать, а просто запустил двоичный файл. Если бы вы изменили свой исходный код, Cargo пересобрал бы дело перед его запуском, и вы бы увидели этот вывод:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo также предоставляет приказ, называемую `cargo check`. Этот приказ быстро проверяет ваш код, чтобы убедиться, что он собирается, но не создаёт исполняемый файл:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Почему вам не нужен исполняемый файл? Часто `cargo check` выполняется намного быстрее, чем `cargo build`, поскольку пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу во время написания кода, использование `cargo check` ускорит этап уведомления вас о том, что ваш дело всё ещё собирается! Таким образом, многие Rustacean периодически запускают `cargo check`, когда пишут свои программы, чтобы убедиться, что она собирается. Затем они запускают `cargo build`, когда готовы использовать исполняемый файл.

Давайте подытожим, что мы уже узнали о Cargo:

- Мы можем создать дело с помощью `cargo new`.
- можно собирать дело, используя приказ `cargo build`,
- можно одновременно собирать и запускать дело одной приказом `cargo run`,
- можно собрать дело для проверки ошибок с помощью `cargo check`, не тратя время на кодосоздание исполняемого файла,
- cargo сохраняет итоги сборки не в папку с исходным кодом, а в отдельный папка *target/debug*.

Дополнительным преимуществом использования Cargo является то, что его приказы одинаковы для разных операционных систем. С этой точки зрения, мы больше не будем предоставлять отдельные указания для Linux, macOS или Windows.

### Сборка конечной исполнения (Release)

Когда дело, наконец, готов к исполнению, можно использовать приказ `cargo build --release` для его сборки с переработкой. Данная приказ создаёт исполняемый файл в папке *target/release* в отличии от папки *target/debug*. Переработки делают так, что Ржавчина код работает быстрее, но их включение увеличивает время сборки. По этой причине есть два отдельных профиля: один для разработки, когда нужно осуществлять сборку быстро и часто, и другой, для сборки конечной программы, которую будете отдавать пользователям, которая готова к работе и будет выполняться сверх быстро. Если вы замеряете время выполнения вашего кода, убедитесь, что собрали дело с переработкой `cargo build --release` и проверяете исполняемый файл из папки *target/release*.

### Cargo как Условие

В простых делах Cargo не даёт больших преимуществ по сравнению с использованием `rustc`, но он проявит себя, когда ваши программы станут более сложными. Когда программы вырастают до нескольких файлов или нуждаются в зависимостях, гораздо проще позволить Cargo согласовывать сборку.

Не смотря на то, что дело `hello_cargo` простой, теперь он  использует большую часть существующего набора средств, который вы будете повседневно использовать в вашей развитии, связанной с Rust. Когда потребуется работать над делами размещёнными в сети, вы сможете просто использовать следующую последовательность приказов для получения кода с помощью Git, перехода в папка дела, сборку дела:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Для получения дополнительной сведений о Cargo ознакомьтесь с [его документацией] .

## Итоги

Теперь вы готовы начать своё Ржавчина путешествие! В данной главе вы изучили как:

- установить последнюю безотказную исполнение Rust, используя `rustup`,
- обновить Ржавчина до последней исполнения,
- открыть местно установленную документацию,
- написать и запустить программу вида "Hello, world!", используя напрямую сборщик `rustc`,
- создать и запустить новый дело, используя соглашения и приказы Cargo.

Это отличное время для создания более существенной программы, чтобы привыкнуть читать и писать код на языке Rust. Итак, в главе 2 мы построим программу для игры в угадай число. Если вы предпочитаете начать с изучения того, как работают общие подходы программирования в Rust, обратитесь к главе 3, а затем вернитесь к главе 2.


["Установка"]: ch01-01-installation.html#installation
[Приложении E]: appendix-05-editions.html
[его документацией]: https://doc.rust-lang.org/cargo/