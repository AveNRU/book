## Хранение закодированного текста UTF-8 в строках

Мы говорили о строках в главе 4, но сейчас мы рассмотрим их более подробно. Новички в Rust обычно застревают на строках из-за  сочетания трёх причин: склонность Rust сборщика к выявлению возможных ошибок, более сложная структура данных чем считают многие программисты и UTF-8. Эти обстоятельства объединяются таким образом, что направление может показаться сложной, если вы пришли из других языков программирования.

Полезно обсуждать строки в среде собраний, потому что строки реализованы в виде набора байтов, плюс некоторые способы для обеспечения полезной функциональности, когда эти байты преобразуются как текст. В этом разделе мы поговорим об действиех над `String` таких как создание, обновление и чтение, которые есть у каждого вида собраний. Мы также обсудим какими особенностями `String` отличается от других собраний, а именно каким образом упорядочевание в  `String` осложняется различием между тем как люди и компьютеры преобразуют данные заключённые в  `String`.

### Что же такое строка?

Сначала мы определим, что мы подразумеваем под понятием  *строка* (string). В Rust есть только один строковый вид в ядре языка - срез строки `str`, обычно используемый в заимствованном виде как `&str`. В Главе 4 мы говорили о *срезах строк, string slices*, которые являются ссылками на некоторые строковые данные в кодировке UTF-8. Например, строковые записи хранятся в двоичном файле программы и поэтому являются срезами строк.

Вид `String` предоставляемый встроенной библиотекой Rust, не встроен в ядро языка и является расширяемым, изменяемым, владеющим, строковым видом в UTF-8 кодировке.  Когда Rustaceans говорят о "строках" то, они обычно имеют в виду виды `String` или строковые срезы `&str`, а не просто один из них. Хотя этот раздел в основном посвящён `String`, оба вида усиленно используются в встроенной библиотеке Rust, оба, и `String` и строковые срезы, кодируются в UTF-8.

### Создание новых строк

Многие из тех же действий, которые доступны `Vec<T>` , доступны также в `String`, потому что `String` в действительности реализован как обёртка вокруг вектора байтов с некоторыми дополнительными заверениями, ограничениями и возможностями. Примером функции, которая одинаково работает с `Vec<T>` и `String`, является функция  `new`, создающая новый образец вида, и показана в Приложении 8-11.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

<span class="caption">Приложение 8-11. Создание новой пустой <code>String</code> строки</span>

Эта строка создаёт новую пустую строковую переменную с именем `s`, в которую мы можем затем загрузить данные. Часто у нас есть некоторые начальные данные, которые мы хотим назначить строке. Для этого мы используем способ `to_string` доступный для любого вида, который реализует типаж `Display`, как у строковых записей. Приложение 8-12 показывает два примера.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

<span class="caption">Приложение 8-12: Использование способа <code>to_string</code> для создания образца вида <code>String</code>  из строкового записи</span>

Эти выражения создают строку с  `initial contents`.

Мы также можем использовать функцию `String::from` для создания `String`  из строкового записи. Код приложения 8-13 является эквивалентным коду из приложения 8-12, который использует функцию `to_string`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

<span class="caption">Приложение 8-13: Использование функции <code>String::from</code> для создания образца вида <code>String</code> из строкового записи</span>

Поскольку строки используются для очень многих вещей, можно использовать множество API для строк, предоставляющих множество возможностей. Некоторые из них могут показаться избыточными, но все они занимаются своим делом!  В данном случае `String::from` и `to_string` делают одно и тоже, поэтому выбор зависит от исполнения который вам больше импонирует.

Запомните, что строки хранятся в кодировке UTF-8, поэтому можно использовать любые правильно кодированные данные в них, как показано в приложении 8-14:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

<span class="caption">Приложение 8-14: Хранение приветствий в строках на разных языках</span>

Все это допустимые `String` значения.

### Обновление строковых данных

Строка `String` может увеличиваться в размере, а её содержимое может меняться, по подобию как содержимое `Vec<T>` при вставке в него большего количества данных. Кроме того, можно использовать оператор `+` или макрос `format!` для объединения значений `String`.

#### Присоединение к строке с помощью `push_str` и `push`

Мы можем нарастить `String` используя способ `push_str` который добавит в исходное значение новый строковый срез, как показано в приложении 8-15.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

<span class="caption">Приложение 8-15. Добавление среза строки к <code>String</code> с помощью способа <code>push_str</code></span>

После этих двух строк кода `s` будет содержать `foobar`. Способ `push_str` принимает строковый срез, потому что мы не всегда хотим владеть входным свойствоом. Например, код в приложении 8-16 показывает вариант, когда будет не желательно поведение, при котором мы не сможем использовать `s2` после его добавления к содержимому значения переменной `s1`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

<span class="caption">Приложение 8-16: Использование среза строки после добавления её содержимого к другой <code>String</code></span>

Если способ `push_str` стал бы владельцем переменной`s2`, мы не смогли бы напечатать его значение в последней строке. Однако этот код работает так, как мы ожидали!

Способ `push` принимает один символ в качестве свойства и добавляет его к `String`. В приложении 8-17 показан код, добавляющий букву “l” к `String` используя способ `push`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

<span class="caption">Приложение 8-17: Добавление одного символа в <code>String</code> значение используя <code>push</code></span>

В итоге `s` будет содержать `lol`.

#### Объединение строк с помощью оператора `+` или макроса `format!`

Часто хочется объединять две существующие строки. Один из возможных способов — это использование оператора `+` из приложения 8-18:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

<span class="caption">Приложение 8-18: Использование оператора <code>+</code> для объединения двух значений <code>String</code> в новое <code>String</code> значение</span>

Строка `s3` будет содержать `Hello, world!`. Причина того, что `s1` после добавления больше недействительна и причина, по которой мы использовали ссылку на `s2` имеют отношение к сигнатуре вызываемого способа при использовании оператора `+`. Оператор `+` использует способ `add`, чья сигнатура выглядит примерно так:

```rust,ignore
fn add(self, s: &str) -> String {
```

В встроенной библиотеке вы увидите способ `add` определённым с использованием обобщённых и связанных видов. Здесь мы видим сигнатуру  с определенными видами, заменяющими обобщённый, что происходит когда вызывается данный способ со значениями `String`. Мы обсудим обобщённые виды в Главе 10. Эта сигнатура даёт нам ключ для понимания особенностей оператора `+`.

Во-первых, перед `s2` мы видим `&`, что означает что мы складываем *ссылку* на вторую строку с первой строкой. Это происходит из-за  свойства `s` в функции `add`: мы можем добавить только `&str` к `String`; мы не можем сложить два значения `String`. Но подождите — вид `&s2` это `&String`, а не `&str`, как определён второй свойство в `add`. Так почему код в приложении 8-18 собирается?

Причина, по которой мы можем использовать `&s2` в вызове `add` заключается в том, что сборщик может *принудительно привести (coerce)* переменная вида `&String` к виду `&str`. Когда мы вызываем способ `add` в Rust используется *принудительное приведение* (deref coercion), которое превращает `&s2` в `&s2[..]`. Мы подробно обсудим принудительное приведение в Главе 15. Так как `add` не забирает во владение свойство `s`, `s2` по прежнему будет действительной строкой `String` после применения действия.

Во-вторых, как можно видеть в сигнатуре, `add` забирает во владение `self`, потому что  `self` *не имеет* `&`. Это означает, что `s1` в приложении 8-18 будет перемещён в вызов `add` и больше не будет действителен после этого вызова. Не смотря на то, что код `let s3 = s1 + &s2;` выглядит как будто он скопирует обе строки и создаёт новую, эта указание в действительности забирает во владение переменную `s1`, присоединяет к ней копию содержимого `s2`, а затем возвращает владение итогом.  Другими словами, это выглядит как будто код создаёт множество копий, но это не так; данная реализация более эффективна, чем копирование.

Если нужно объединить несколько строк, поведение оператора `+` становится громоздким:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

Здесь переменная `s` будет содержать `tic-tac-toe`. С множеством символов `+` и `"` становится трудно понять, что происходит. Для более сложного комбинирования строк можно использовать макрос `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

Этот код также устанавливает переменную `s` в значение `tic-tac-toe`. Макрос `format!` работает тем же способом что макрос `println!`, но вместо вывода на экран возвращает вид `String` с содержимым. Исполнение кода с использованием `format!` значительно легче читается, а также код, сгенерированный макросом `format!`, использует ссылки, а значит не забирает во владение ни один из его свойств.

### Упорядочевание в строках

Доступ к отдельным символам в строке, при помощи ссылки на них по порядковому указателю, является допустимой и распространённой операцией во многих других языках программирования. Тем не менее, если вы попытаетесь получить доступ к частям `String`, используя правила написания упорядочевания в Rust, то вы получите ошибку. Рассмотрим неверный код в приложении 8-19.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

<span class="caption">Приложение 8-19: Попытка использовать правила написания порядкового указателя со строкой</span>

Этот код приведёт к следующей ошибке:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

Ошибка и примечание говорит, что в Rust строки не поддерживают упорядочевание. Но почему так? Чтобы ответить на этот вопрос, нужно обсудить то, как Rust хранит строки в памяти.

#### Внутреннее представление

Вид `String` является оболочкой над видом  `Vec<u8>`. Давайте посмотрим на несколько закодированных корректным образом в UTF-8 строк из примера приложения 8-14. Начнём с этой:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

В этом случае `len` будет 4, что означает вектор, хранит строку "Hola" длиной 4 байта. Каждая из этих букв занимает 1 байт при кодировании в UTF-8. Но как насчёт следующей строки? (Обратите внимание, что эта строка начинается с заглавной кириллической "З", а не цифры 3.)

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

Отвечая на вопрос, какова длина строки, вы можете ответить 12. Однако ответ Rust - 24, что равно числу байт, необходимых для кодирования «Здравствуйте» в UTF-8, так происходит, потому что каждое одиночное значение Unicode символа в этой строке занимает 2 байта памяти. Следовательно, порядковый указательпо байтам строки не всегда бы соответствовал действительному одиночному Unicode значению. Для отображения рассмотрим этот недопустимый код Rust:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

Каким должно быть значение переменной `answer`? Должно ли оно быть значением первой буквы `З`? При кодировке в UTF-8, первый байт значения `З` равен `208`, а второй - `151`, поэтому значение в `answer` на самом деле должно быть `208`, но само по себе `208` не является действительным символом. Возвращение `208`, скорее всего не то, что хотел бы получить пользователь: ведь он ожидает первую букву этой строки; тем не менее, это единственный байт данных, который в Rust доступен по порядковому указателю 0. Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если `&"hello"[0] `было бы допустимым кодом, который вернул значение байта, то он вернул бы `104`, а не `h`.

Таким образом, чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки которые не могут быть сразу обнаружены, Rust просто не собирает такой код и предотвращает недопонимание на ранних этапах процесса разработки.

#### Байты, одиночные значения и кластеры графем! Боже мой!

Ещё один мгновение, касающийся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Rust: как байты, как одиночные значения и как кластеры графем (самая близкая вещь к тому, что мы назвали бы *буквами*).

Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор значений `u8` который выглядит следующим образом:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

Эти 18 байт являются именно тем, как компьютеры в конечном итоге сохранят в памяти эту строку. Если мы посмотрим на 18 байт как на одиночные Unicode значения, которые являются Rust видом `char`, то байты будут выглядеть так:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

Здесь есть шесть значений вида `char`, но четвёртый и шестой являются не буквами: они диакритики, особые обозначения которые не имеют смысла сами по себе. Наконец, если мы посмотрим на байты как на кластеры графем, то получим то, что человек назвал бы словом на хинди состоящем из четырёх букв:

```text
["न", "म", "स्", "ते"]
```

Rust предоставляет различные способы преобразования необработанных строковых данных, которые компьютеры хранят так, чтобы каждой программе можно было выбрать необходимую преобразование, независимо от того, на каком человеческом языке представлены эти данные.

Последняя причина, по которой Rust не позволяет нам упорядочивать `String` для получения символов является то, что программисты ожидают, что действия упорядочевания всегда имеют постоянное время (O(1)) выполнения. Но невозможно обеспечить такую производительность для `String`, потому что Rust понадобилось бы пройтись по содержимому от начала до порядкового указателя, чтобы определить, сколько было действительных символов.

### Срезы строк

Упорядочевание строк часто является плохой идеей, потому что не ясно каким должен быть возвращаемый вид такой действия: байтовым значением, символом, кластером графем или срезом строки. Поэтому Rust просит вас быть более определенным, если действительно требуется использовать порядковые указатели для создания срезов строк.

Вместо упорядочевания с помощью числового порядкового указателя `[]`, вы можете использовать оператор ряда`[]` при создании среза строки в котором содержится указание на то, срез каких байтов надо делать:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

Здесь переменная `s` будет вида `&str` который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов был по 2 байта, что означает, что `s` будет содержать <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end -->.

Что бы произошло, если бы мы использовали `&hello[0..1]`? Ответ: Rust бы запаниковал во время выполнения точно так же, как если бы обращались к недействительному порядковому указателю в векторе:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

Вы должны использовать ряды для создания срезов строк с осторожностью, потому что это может привести к сбою вашей программы.

### Способы для перебора строк

Лучший способ работать с фрагментами строк — чётко указать, нужны ли вам символы или байты. Для отдельных одиночных значений в Юникоде используйте способ `chars`. Вызов `chars` у <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end --> выделяет и возвращает два значения вида `char`, и вы можете выполнить повторение по итогу для доступа к каждому элементу:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

Код напечатает следующее:

```text
З
д
```

Способ `bytes` возвращает каждый байт, который может быть подходящим в другой предметной области:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

Этот код выведет четыре байта, составляющих эту строку:

```text
208
151
208
180
```

Но делая так, обязательно помните, что валидные одиночные Unicode значения могут состоять более чем из одного байта.

Извлечение кластеров графем из строк, как в случае с языком хинди, является сложным, поэтому эта функциональность не предусмотрена встроенной библиотекой. На [crates.io](https://crates.io/)<!-- ignore --> есть доступные библиотеки, если Вам нужен данный функционал.

### Строки не так просты

Подводя итог, становится ясно, что строки сложны. Различные языки программирования реализуют различные варианты того, как представить эту сложность для программиста. В Rust решили сделать правильную обработку данных `String` поведением по умолчанию для всех программ Rust, что означает, что программисты должны заранее продумать обработку UTF-8 данных. Этот соглашение раскрывает большую сложность строк, чем в других языках программирования, но это предотвращает от необходимости обрабатывать ошибки, связанные с не-ASCII символами которые могут появиться в ходе разработки позже.

Хорошая новость состоит в том что стандартная библиотека предлагает множество функциональных возможностей, построенных на основе видов `String` и `&str`, чтобы помочь правильно обрабатывать эти сложные случаи. Обязательно ознакомьтесь с документацией для полезных способов, таких как `contains` для поиска в строке и `replace` для замены частей строки другой строкой.

Давайте переключимся на что-то немного менее сложное: HashMap!
