## Хранение закодированного писания UTF-8 в строках

Мы говорили о строках в главе 4, но сейчас мы рассмотрим их более подробно. Новички в Ржавчине обычно застревают на строках из-за  сочетания трёх причин: склонность сборщика Ржавчины  к выявлению возможных ошибок, более сложный вид данных чем считают многие программисты и UTF-8. Эти обстоятельства объединяются таким образом, что освоение может показаться сложным, если вы пришли из других языков программирования.

Рассмотрим строки в среде собраний, потому что строки внутренне представлены в виде набора байтов, дополнительно включены ряд способов для обеспечения действий над строками, которые выполняют действия над при переводе их в писание, понятное человеку. В этом разделе мы поговорим о действиях над видом данных `String`. Создание, чтение, изменение, которые есть у каждого вида собраний. Мы также обсудим какими особенностями вид данных `String` отличается от других собраний, а именно каким образом упорядочивание в виде данных  `String` осложняется различием между тем как люди и компьютеры представляют данные, заключённые в виде `String`.

### Что же такое строка?

Сначала мы определим, что мы подразумеваем под понятием  `*строка* (string)`. В Ржавчине есть только один строковый вид данных в ядре языка - срез строки `str`, обычно используемый в заимствованном исполнении как вид данных `&str`. В Главе 4 мы говорили о *срезах строк, string slices*, которые являются ссылками на некоторые строковые данные в представлении UTF-8. Например, строковые записи хранятся в двоичном файле программы и поэтому являются срезами строк.

Вид данных `String` , предоставляемый встроенной библиотекой Ржавчины, не встроен в ядро языка. Поэтому его можно расширять, изменять, изменять владение, он представлен в виле UTF-8.  Когда Rustaceans говорят о "строках" то, они обычно имеют в виду виды данных `String` или строковые срезы `&str`, а не просто один из них. Хотя этот раздел в основном посвящён виду данных `String`, оба вида данных усиленно используются во встроенной библиотеке Ржавчины оба, и сама строка `String` и строковые срезы, кодируются в UTF-8.

### Создание новых строк

Многие из тех же действий, которые доступны  виду данных `Vec<T>` , доступны также в виде данных `String`, потому что `String` в действительности выполнен как обёртка вокруг вектора байтов с некоторыми дополнительными заверениями, ограничениями и возможностями. Примером функции, которая одинаково работает с видами данных `Vec<T>` и `String`, является функция  `new`, создающая новый образец вида данных, и показана в Приложении 8-11.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

<span class="caption">Приложение 8-11. Создание новой пустой строки вида данных <code>String</code></span>

Эта строка создаёт новую пустую строковую переменную с именем `s`, в которую мы можем затем внести данные. Часто у нас есть некоторые начальные данные, которые мы хотим присвоить строке. Для этого мы используем способ `to_string`, доступный для любого вида данных, который использует сущность `Display`, как у строковых записей. Приложение 8-12 показывает два примера.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

<span class="caption">Приложение 8-12: Использование способа <code>to_string</code> для создания образца вида данных <code>String</code>  из строковой записи</span>

Эти выражения создают строку с  `initial contents`.

Мы также можем использовать функцию `String::from` для создания `String`  из строковой записи. Рукопись приложения 8-13 является равнозначной рукописи из приложения 8-12, которая использует функцию `to_string`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

<span class="caption">Приложение 8-13: Использование функции <code>String::from</code> для создания образца вида данных <code>String</code> из строковой записи</span>

Поскольку строки используются для очень многих вещей, можно использовать множество API для строк, предоставляющих множество возможностей. Некоторые из них могут показаться избыточными, но все они занимаются своим делом!  В данном случае `String::from` и `to_string` делают одно и тоже, поэтому выбор зависит от исполнения, которое вам больше импонирует.

Запомните, что строки хранятся в представлении UTF-8, поэтому можно использовать любые правильно преобразованные данные в них, как показано в приложении 8-14:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

<span class="caption">Приложение 8-14: Хранение приветствий в строках на разных языках</span>

Все это допустимые `String` значения.

### Обновление строковых данных

Строка `String` может увеличиваться в размере, а её содержимое может меняться, по подобию как содержимое `Vec<T>` при вставке в него большего количества данных. Кроме того, можно использовать приказчик `+` или макрос `format!` для объединения значений `String`.

#### Присоединение к строке с помощью `push_str` и `push`

Мы можем нарастить `String` используя способ `push_str` который добавит в исходное значение новый строковый срез, как показано в приложении 8-15.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

<span class="caption">Приложение 8-15. Добавление среза строки к <code>String</code> с помощью способа <code>push_str</code></span>

После этих двух строк рукописи `s` будет содержать `foobar`. Способ `push_str` принимает строковый срез, потому что мы не всегда хотим владеть входным свойством. Например, рукопись в приложении 8-16 показывает исход, когда будет не желательно поведение, при котором мы не сможем использовать `s2` после его добавления к содержимому значения переменной `s1`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

<span class="caption">Приложение 8-16: Использование среза строки после добавления её содержимого к другой <code>String</code></span>

Если способ `push_str` стал бы владельцем переменной`s2`, мы не смогли бы вывести его значение в последней строке. Однако эта рукопись работает так, как мы ожидали!

Способ `push` принимает один знак в качестве свойства и добавляет его к `String`. В приложении 8-17 показана рукопись, добавляющая букву “l” к `String` используя способ `push`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

<span class="caption">Приложение 8-17: Добавление одного знака в <code>String</code> значение используя <code>push</code></span>

В итоге `s` будет содержать `lol`.

#### Объединение строк с помощью приказчика `+` или макроса `format!`

Часто хочется объединять две существующие строки. Один из возможных способов — это использование приказчика `+` из приложения 8-18:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

<span class="caption">Приложение 8-18: Использование приказчика <code>+</code> для объединения двух значений <code>String</code> в новое <code>String</code> значение</span>

Строка `s3` будет содержать `Hello, world!`. Причина того, что `s1` после добавления больше недействительна и причина, по которой мы использовали ссылку на `s2` имеют отношение к ярлыке вызываемого способа при использовании приказчика `+`. Приказчик `+` использует способ `add`, чья ярлык выглядит примерно так:

```rust,ignore
fn add(self, s: &str) -> String {
```

В встроенной библиотеке вы увидите способ `add` определённым с использованием обобщённых и связанных видов данных. Здесь мы видим ярлык  с определенными видами данных, заменяющими обобщённый, что происходит когда вызывается данный способ со значениями `String`. Мы обсудим обобщённые виды данных в Главе 10. Эта ярлык даёт нам ключ для понимания особенностей приказчика `+`.

Во-первых, перед `s2` мы видим `&`, что означает что мы складываем *ссылку* на вторую строку с первой строкой. Это происходит из-за  свойства `s` в функции `add`: мы можем добавить только `&str` к `String`; мы не можем сложить два значения `String`. Но подождите — вид данных `&s2` это `&String`, а не `&str`, как определён второй свойство в `add`. Так почему рукопись в приложении 8-18 собирается?

Причина, по которой мы можем использовать `&s2` в вызове `add` заключается в том, что сборщик может *принудительно привести (coerce)* переменная вида данных `&String` к виду данных `&str`. Когда мы вызываем способ `add` в Ржавчине используется *принудительное приведение* (deref coercion), которое превращает `&s2` в `&s2[..]`. Мы подробно обсудим принудительное приведение в Главе 15. Так как `add` не забирает во владение свойство `s`, `s2` по прежнему будет действительной строкой `String` после применения действия.

Во-вторых, как можно видеть в ярлыке, `add` забирает во владение `self`, потому что  `self` *не имеет* `&`. Это означает, что `s1` в приложении 8-18 будет перемещён в вызов `add` и больше не будет действителен после этого вызова. Не смотря на то, что рукопись `let s3 = s1 + &s2;` выглядит как будто он воспроизведет обе строки и создаёт новую, это указание в действительности забирает во владение переменную `s1`, присоединяет к ней повтор содержимого `s2`, а затем возвращает владение итогом.  Другими словами, это выглядит как будто рукопись создаёт множество повторов, но это не так; данная выполнение более производительна, чем повторение.

Если нужно объединить несколько строк, поведение приказчика `+` становится громоздким:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

Здесь переменная `s` будет содержать `tic-tac-toe`. С множеством знаков `+` и `"` становится трудно понять, что происходит. Для более сложного соединения строк можно использовать макрос `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

Эта рукопись также устанавливает переменную `s` в значение `tic-tac-toe`. Макрос `format!` работает тем же способом что макрос `println!`, но вместо вывода на экран возвращает вид данных `String` с содержимым. Исполнение рукописи с использованием `format!` значительно легче читается, а также рукопись, созданная макросом `format!`, использует ссылки, а значит не забирает во владение ни один из его свойств.

### Упорядочивание в строках

Доступ к отдельным знакам в строке, при помощи ссылки на них по порядковому указателю, является допустимой и распространённой действием во многих других языках программирования. Тем не менее, если вы попытаетесь получить доступ к частям `String`, используя правила написания упорядочивания в Ржавчине, то вы получите ошибку. Рассмотрим неверный рукопись в приложении 8-19.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

<span class="caption">Приложение 8-19: Попытка использовать правила написания порядкового указателя со строкой</span>

Эта рукопись приведёт к следующей ошибке:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

Ошибка и примечание говорит, что в Ржавчине строки не поддерживают упорядочивание. Но почему так? Чтобы ответить на этот вопрос, нужно обсудить то, как Ржавчина хранит строки в памяти.

#### Внутреннее представление

Вид данных `String` является оболочкой над видом данных  `Vec<u8>`. Давайте посмотрим на несколько закодированных правильным образом в UTF-8 строк из примера приложения 8-14. Начнём с этой:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

В этом случае `len` будет 4, что означает вектор, хранит строку "Hola" длиной 4 байта. Каждая из этих букв занимает 1 байт при преобразовании в UTF-8. Но как насчёт следующей строки? (Обратите внимание, что эта строка начинается с заглавной кириллической "З", а не цифры 3.)

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

Отвечая на вопрос, какова длина строки, вы можете ответить 12. Однако ответ Ржавчины - 24, что равно числу байт, необходимых для преобразования «Здравствуйте» в UTF-8, так происходит, потому что каждое одиночное значение Unicode знака в этой строке занимает 2 байта памяти. Следовательно, порядковый указатель по байтам строки не всегда бы соответствовал действительному одиночному Unicode значению. Для отображения рассмотрим эту недопустимую рукопись Ржавчины:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

Каким должно быть значение переменной `answer`? Должно ли оно быть значением первой буквы `З`? При представлении в UTF-8, первый байт значения `З` равен `208`, а второй - `151`, поэтому значение в `answer` на самом деле должно быть `208`, но само по себе `208` не является действительным знаком. Возвращение `208`, скорее всего не то, что хотел бы получить пользователь: ведь он ожидает первую букву этой строки; тем не менее, это единственный байт данных, который в Ржавчине доступен по порядковому указателю 0. Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если `&"hello"[0] `было бы допустимым рукописью, который вернул значение байта, то он вернул бы `104`, а не `h`.

Таким образом, чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки которые не могут быть сразу обнаружены, Ржавчина просто не собирает такую рукопись и предотвращает недопонимание на ранних этапах этапа разработки.

#### Байты, одиночные значения и кластеры графем! Боже мой!

Ещё одна особенность, касающаяся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Ржавчины: как байты, как одиночные значения и как кластеры графем (самая близкая вещь к тому, что мы назвали бы *буквами*).

Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор значений `u8` который выглядит следующим образом:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

Эти 18 байт являются именно тем, как компьютеры в конечном итоге сохранят в памяти эту строку. Если мы посмотрим на 18 байт как на одиночные Unicode значения, которые являются Ржавчина видом данных `char`, то байты будут выглядеть так:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

Здесь есть шесть значений вида данных `char`, но четвёртый и шестой являются не буквами: они диакритики, особые обозначения которые не имеют смысла сами по себе. Наконец, если мы посмотрим на байты как на кластеры графем, то получим то, что человек назвал бы словом на хинди состоящем из четырёх букв:

```text
["न", "म", "स्", "ते"]
```

Ржавчина предоставляет различные способы преобразования необработанных строковых данных, которые компьютеры хранят так, чтобы каждой программе можно было выбрать необходимую преобразование, независимо от того, на каком человеческом языке представлены эти данные.

Последняя причина, по которой Ржавчина не позволяет нам упорядочивать `String` для получения знаков является то, что программисты ожидают, что действия упорядочивания всегда имеют постоянное время (O(1)) выполнения. Но невозможно обеспечить такую производительность для `String`, потому что Ржавчина понадобилось бы пройтись по содержимому от начала до порядкового указателя, чтобы определить, сколько было действительных знаков.

### Срезы строк

Упорядочивание строк часто является плохой мыслью, потому что не ясно каким должен быть возвращаемый вид данных такого действия: байтовым значением, знаком, кластером графем или срезом строки. Поэтому Ржавчина просит вас быть более определенным, если действительно требуется использовать порядковые указатели для создания срезов строк.

Вместо упорядочивания с помощью числового порядкового указателя `[]`, вы можете использовать приказчик ряда`[]` при создании среза строки в котором содержится указание на то, срез каких байтов надо делать:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

Здесь переменная `s` будет вида данных `&str` который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих знаков был по 2 байта, что означает, что `s` будет содержать <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end -->.

Что бы произошло, если бы мы использовали `&hello[0..1]`? Ответ: Ржавчина бы вызвала сбой во время выполнения точно так же, как если бы обращались к недействительному порядковому указателю в векторе:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

Вы должны использовать ряды для создания срезов строк с осторожностью, потому что это может привести к сбою вашей программы.

### Способы для перебора строк

Лучший способ работать с отрывками строк — чётко указать, нужны ли вам знаки или байты. Для отдельных одиночных значений в Unicode используйте способ `chars`. Вызов `chars` у <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end --> выделяет и возвращает два значения вида данных `char`, и вы можете выполнить повторение по итогу для доступа к каждой переменной:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

Рукопись выведет следующее:

```text
З
д
```

Способ `bytes` возвращает каждый байт, который может быть подходящим в другой предметной области:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

Эта рукопись выведет четыре байта, составляющих эту строку:

```text
208
151
208
180
```

Но делая так, обязательно помните, что действительные одиночные Unicode значения могут состоять более чем из одного байта.

Извлечение кластеров графем из строк, как в случае с языком хинди, является сложным, поэтому эта возможность не предусмотрена встроенной библиотекой. На [crates.io](https://crates.io/)<!-- ignore --> есть доступные библиотеки, если Вам нужны данные возможности.

### Строки не так просты

Подводя итог, становится ясно, что строки сложны. Различные языки программирования выполняют различные исходы того, как представить эту сложность для программиста. В Ржавчине решили сделать правильную обработку данных `String` поведением по умолчанию для всех программ Ржавчина, что означает, что программисты должны заранее продумать обработку UTF-8 данных. Это соглашение раскрывает большую сложность строк, чем в других языках программирования, но это предотвращает от необходимости обрабатывать ошибки, связанные с не-ASCII знаками которые могут появиться в ходе разработки позже.

Хорошая новость состоит в том что обычная библиотека предлагает множество полезных возможностей, построенных на основе видов данных `String` и `&str`, чтобы помочь правильно обрабатывать эти сложные случаи. Обязательно ознакомьтесь с пособием для полезных способов, таких как `contains` для поиска в строке и `replace` для замены частей строки другой строкой.

Давайте переключимся на что-то немного менее сложное: HashMap!
