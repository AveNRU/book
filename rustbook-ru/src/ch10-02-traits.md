## Сущности: определение общего поведения

*Сущность* сообщает сборщику Ржавчина о возможности, которой обладает определённый вид и которой он может поделиться с другими видами данных. Можно использовать сущности, чтобы определять общее поведение абстрактным способом. Мы можем использовать *ограничение сущности* (trait bounds) чтобы указать, что общим видом может быть любой вид, который имеет определённое поведение.

> Примечание: Сущности похожи на возможность часто называемую *внешней оболочкими* в других языках программирования, хотя и с некоторыми отличиями.

### Определение сущности

Поведение вида определяется теми способами, которые мы можем вызвать у данного вида. Различные виды данных разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов. Определение сущностей - это способ объединять ярлыки способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.

Например, пусть есть несколько стопок, которые имеют различный вид и различный размер писания: стопки `NewsArticle`, которая содержит новость, выведенную в каком-то месте мира; стопки `Tweet`, которая содержит 280 знаковую строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.

Мы хотим создать ящик библиотеки медиа-агрегатора `aggregator`, которая может отображать сводку данных сохранённых в образцах стопок `NewsArticle` или `Tweet`. Чтобы этого достичь, нам необходимо иметь возможность для каждой стопки получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ `summarize`. Приложение 10-12 показывает определение сущности `Summary`, который выражает это поведение.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

<span class="caption">Приложение 10-12: Определение сущности <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span>

Здесь мы объявляем сущность с использованием ключевого слова `trait`, а затем его название, которым в нашем случае является `Summary`. Также мы объявляем ящик как `pub` что позволяет ящикам, зависящим от нашего ящика, тоже использовать наш ящик, что мы увидим в последующих примерах. Внутри узорчатых скобок объявляются ярлыки способов, которые описывают поведения видов, выполняющих данную сущность, в данном случае поведение определяется только одной ярлыком способа `fn summarize(&self) -> String`.

После ярлыков способа, вместо предоставления выполнения в узорчатых в скобках, мы используем точку с запятой. Каждый вид, выполняющий данную сущность, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид содержащий сущность `Summary`, будет также иметь и способ `summarize` объявленный с точно такой же ярлыком.

Сущность может иметь несколько способов в описании его тела: ярлыки способов перечисляются по одной на каждой строке и должны закачиваться знаком <code>;</code>.

### Использование сущности у вида

Теперь, после того как мы определили желаемое поведение используя сущность `Summary`, можно использовать его у видов в нашем медиа-агрегаторе. Приложение 10-13 показывает использование сущности `Summary` у стопки `NewsArticle`, которая использует для создания сводки в способе `summarize` заголовок, составителя и место обнародования статьи. Для стопки `Tweet` мы определяем использование `summarize` используя имя пользователя и следующий за ним полный писание твита, полагая что содержание твита уже ограничено 280 знаками.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

<span class="caption">Приложение 10-13: Использование сущности <code>Summary</code> для стопок <code>NewsArticle</code> и <code>Tweet</code></span>

Использование сущности у вида подобно выполнению обычных способов. Разница в том что после `impl` мы ставим имя сущности, который мы хотим использовать, затем используем ключевое слово `for`, а затем указываем имя вида, для которого мы хотим сделать использование сущности. Внутри раздела `impl` мы помещаем ярлык способа объявленную в сущности. Вместо добавления точки с запятой в конце, после каждой ярлыки используются узорчатые скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов сущности для определенного вида.

Теперь когда библиотека выполнила сущность `Summary` для `NewsArticle` и `Tweet`, программисты использующие ящик могут вызывать способы сущности у образцов видов `NewsArticle` и `Tweet` точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести сущность в область видимости точно так же как и виды данных. Здесь пример того как двоичный ящик может использовать наш `aggregator`:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

Данная рукопись выведет: `1 new tweet: horse_ebooks: of course, as you probably already know, people`.

Другие ящики, которые зависят от `aggregator`, тоже могу включить сущность `Summary` в область видимости для использования `Summary` в их собственных видах. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем использовать сущность для вида только в том случае, если хотя бы один из сущностей вида является местным для нашего ящика. Например, мы можем использовать обычную библиотечную сущность `Display` на собственном виде `Tweet` как часть возможности нашего ящика `aggregator` потому что вид `Tweet` является местным для ящика `aggregator`. Также мы можем использовать `Summary` для `Vec<T>` в нашем ящике `aggregator`, потому что сущность `Summary` является местным для нашего ящика `aggregator`.

Но мы не можем использовать внешние сущности для внешних видов. Например, мы не можем использовать сущность `Display` для `Vec<T>` внутри нашего ящика `aggregator`, потому что `Display` и `Vec<T>` оба определены в встроенной библиотеке а не местно в нашем ящике `aggregator`. Это ограничение является частью свойства называемого *согласованность* (coherence), а ещё точнее *сиротское правило* (orphan rule), которое называется так потому что не представлен родительский вид. Это правило заверяет, что рукопись других людей не может сломать вашу рукопись и наоборот. Без этого правила два ящика могли бы использовать одну сущность для одинакового вида и Ржавчина не сможет понять, каким исполнением нужно пользоваться.

### Выполнение поведения по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в сущности вместо того, чтобы требовать выполнения всех способов в каждом виде, выполняющим данную сущность. Затем, когда мы выполняем сущность для определённого вида, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов.

В примере 10-14 показано, как указать строку по умолчанию для способа `summarize` из сущности `Summary` вместо определения только ярлыки способа, как мы сделали в примере 10-12.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

<span class="caption">Приложение 10-14: Определение сущности <code>Summary</code> с использованием способа <code>summarize</code> по умолчанию</span>

Для использования выполнения по умолчанию при создании сводки у образцов `NewsArticle` вместо определения пользовательского выполнения, мы указываем пустой раздел`impl` с `impl Summary for NewsArticle {}`.

Хотя мы больше не определяем способ `summarize` непосредственно в `NewsArticle`, мы предоставили выполнение по умолчанию и указали, что `NewsArticle` использует сущность `Summary`. В итоге мы всё ещё можем вызвать способ `summarize` у образца `NewsArticle`, например так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

Эта рукопись выводит `New article available! (Read more...)` .

Создание выполнения по умолчанию не требует от нас изменений чего-либо в выполнения `Summary` для `Tweet` в приложении 10-13. Причина заключается в том, что правила написания для переопределения выполнения по умолчанию является таким же, как правила написания для выполнения способа сущности, который не имеет выполнения по умолчанию.

Выполнения по умолчанию могут вызывать другие способы в том же сущности, даже если эти другие способы не имеют выполнения по умолчанию. Таким образом, сущность может предоставить много полезной возможности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить сущность `Summary` имеющий способ `summarize_author`, выполнение которого требуется, а затем определить способ `summarize` который имеет выполнение по умолчанию, которая внутри вызывает способ `summarize_author`:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

Чтобы использовать такую исполнение сущности `Summary`, нужно только определить способ `summarize_author`, при выполнения сущности для вида:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

После того, как мы определим `summarize_author`, можно вызвать `summarize` для образцов стопки `Tweet` и выполнение по умолчанию способа `summarize` будет вызывать определение `summarize_author` которое мы уже предоставили. Так как мы выполнили способ `summarize_author` сущности `Summary`, то сущность даёт нам поведение способа `summarize` без необходимости писать рукопись.

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

Эта рукопись выводит `1 new tweet: (Read more from @horse_ebooks...)` .

Обратите внимание, что невозможно вызвать выполнение по умолчанию из переопределённой выполнения того же способа.

### Сущности как свойства

Теперь, когда вы знаете, как определять и использовать сущности, можно изучить, как использовать сущности, чтобы определить функции, которые принимают много различных видов. Мы будем использовать сущность `Summary`,  выполненный для видов `NewsArticle` и `Tweet` в приложении 10-13, чтобы определить функцию `notify`, которая вызывает способ `summarize` для его свойства `item`, который имеет некоторый вид, выполняющий сущность `Summary`. Для этого мы используем правила написания `impl Trait` примерно так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

Вместо определенного вида у свойства `item` указывается ключевое слово `impl` и имя сущности. Это свойство принимает любой вид, который использует указанную сущность. В теле `notify` мы можем вызывать любые способы у образца `item` , которые приходят с сущностью `Summary`, такие как способ `summarize`. Мы можем вызвать `notify` и передать в него любой образец `NewsArticle` или `Tweet`. Рукопись, которая вызывает данную функцию с любым другим видом, таким как `String` или `i32`, не будет собираться, потому что эти виды данных не используют сущность `Summary`.

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### Правила написания ограничения сущности

Правила написания `impl Trait` работает для простых случаев, но на самом деле является связанным сахаром для более длинной вида, которая называется *ограничением сущности* (trait bound); это выглядит так:

```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Эта более длинная разновидность равнозначна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида с ограничением сущности после двоеточия внутри угловых скобок.

Правила написания `impl Trait` удобен и делает рукопись более сжатым в простых случаях, в то время как более полные правила написания с ограничением сущности в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые используют сущность  `Summary`. Использование правил написания  `impl Trait` выглядит так:

```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

Использовать `impl Trait` удобнее если мы хотим разрешить функции иметь разные виды данных для `item1` и `item2` (но оба вида должны использовать `Summary`). Если же мы хотим заставить оба свойства иметь один и тот же вид, то мы должны использовать ограничение сущности так:

```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

Обобщённый вид `T` указан для видов свойств `item1` и `item2` и ограничивает функцию так, что определенные значения видов переданные переменнойми для `item1` и `item2` должны быть одинаковыми.

#### Задание нескольких границ сущностей с помощью правил написания `+`

Также можно указать более одного ограничения сущности. Допустим, мы хотели бы чтобы `notify` использовал как изменение вывода так и  `summarize` для свойства `item`: <br>тогда мы указываем что в `notify` свойство `item` должно использовать обе сущности `Display` и `Summary`. Мы можем сделать это используя правила написания `+`:

```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```

Правила написания `+` также допустим с ограничениями сущности для обобщённых видов:

```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```

При наличии двух ограничений сущности, тело способа `notify` может вызывать `summarize` и использовать `{}` для изменения `item` при его выводе.

#### Более ясные границы сущности с помощью `where`

Использование слишком большого количества ограничений сущности имеет свои недостатки. Каждый обобщённый вид имеет свои границы сущности, поэтому функции с несколькими свойствами обобщённого вида могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение ярлыки. По этой причине в Ржавчине есть иной правила написания для определения ограничений сущности внутри предложения `where` после ярлыков функции. Поэтому вместо того, чтобы писать так:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

можно использовать `where` таким образом:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

Ярлык этой функции менее загромождена: название функции, список свойств, и возвращаемый вид находятся рядом, а ярлык не содержит в себе множество ограничений сущности.

### Возврат значений вида выполняющего определённый сущность

Также можно использовать правила написания `impl Trait` в возвращаемое положение, чтобы вернуть значение некоторого вида выполняющего сущность, как показано здесь:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

Используя `impl Summary` для возвращаемого вида, мы указываем, что функция `returns_summarizable` возвращает некоторый вид, который использует сущность `Summary` без обозначения определенного вида. В этом случае `returns_summarizable` возвращает `Tweet`, но рукопись, вызывающая эту функцию, этого не знает.

Возможность возвращать вид, который определяется только выполняемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды, которые знает только сборщик или виды, которые очень долго указывать. правила написания `impl Trait` позволяет кратко указать, что функция возвращает некоторый вид, который использует сущность `Iterator` без необходимости писать очень длинный вид.

Однако, `impl Trait` возможно использовать, если возвращаете только один вид. Например, данная рукопись, которая возвращает значения или вида `NewsArticle` или вида `Tweet`, но в качестве возвращаемого вида объявляет `impl Summary` , не будет работать:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

Возврат либо `NewsArticle` либо `Tweet` не допускается из-за ограничений того, как выполнен правила написания `impl Trait` в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе ["Использование предметов сущностей, которые разрешены для значений или разных видов"]<!--  --> Главы 17.

### Использование ограничений сущности для условной выполнения способов

Используя ограничение сущности с разделом `impl`, который использует свойства обобщённого вида, можно использовать способы условно, для тех видов, которые используют указанную сущность. Например, вид `Pair<T>`  в приложении 10-15 всегда использует функцию  `new` для возврата нового образца `Pair<T>` (вспомните раздел [“Определение способов”]<!-- ignore --> Главы 5 где `Self` является псевдонимом вида для вида раздела `impl`, который в данном случае является `Pair<T>`). Но в следующем разделе `impl` вид `Pair<T>` использует способ  `cmp_display` только если его внутренний вид `T` использует сущность `PartialOrd` (позволяющий сравнивать) *и* сущность `Display` (позволяющий выводить на вывод).

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

<span class="caption">Приложение 10-15: Условная использование способов у обобщённых видов в зависимости от ограничений сущности</span>

Мы также можем условно использовать сущность для любого вида, который использует другой сущность. Выполнения сущности для любого вида, который удовлетворяет ограничениям сущности, называются *общими исполнениями* и широко используются в встроенной библиотеке Ржавчина. Например, обычная библиотека использует сущность `ToString` для любого вида, который использует сущность `Display`. Раздел`impl` в встроенной библиотеке выглядит примерно так:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

Поскольку обычная библиотека имеет эту общую выполнение, то можно вызвать способ `to_string` определённый сущностью `ToString` для любого вида, который использует сущность `Display`. Например, мы можем превратить целые числа в их соответствующие `String` значения, потому что целые числа используют сущность `Display`:

```rust
let s = 3.to_string();
```

Общие выполнения приведены в пособии к сущности в разделе "Implementors".

Сущности и ограничения сущностей позволяют писать рукопись, которая использует свойства обобщённого вида для уменьшения повторения рукописи, а также указывая сборщику, что мы хотим обобщённый вид, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения сущности, чтобы проверить, что все определенные виды данных, используемые с нашей рукописью, обеспечивают правильное поведение.  В изменяемых строго определенных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида, который не использует вид определяемый способом. Но Ржавчина перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить сбои, прежде чем наша рукопись начнёт работать. Кроме того, мы не должны писать рукопись, которая проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов.


["Использование предметов сущностей, которые разрешены для значений или разных видов"]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[“Определение способов”]: ch05-03-method-syntax.html#defining-methods