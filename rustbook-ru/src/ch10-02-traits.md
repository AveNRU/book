## Особенности: определение общего поведения

*Особенность* сообщает сборщику Ржавчина о возможности, которой обладает определённый вид и которой он может поделиться с другими видами. Можно использовать особенности, чтобы определять общее поведение абстрактным способом. Мы можем использовать *ограничение особенности* (trait bounds) чтобы указать, что общим видом может быть любой вид, который имеет определённое поведение.

> Примечание: Особенности похожи на возможность часто называемую *внешней оболочкими* в других языках программирования, хотя и с некоторыми отличиями.

### Определение особенности

Поведение вида определяется теми способами, которые мы можем вызвать у данного вида. Различные виды разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов. Определение особенностей - это способ объединять ярлыки способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.

Например, пусть есть несколько устройств, которые имеют различный вид и различный размер писания: устройства `NewsArticle`, которая содержит новость, выведенную в каком-то месте мира; устройства `Tweet`, которая содержит 280 знаковую строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.

Мы хотим создать ящик библиотеки медиа-агрегатора `aggregator`, которая может отображать сводку данных сохранённых в образцах устройств `NewsArticle` или `Tweet`. Чтобы этого достичь, нам необходимо иметь возможность для каждой устройства получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ `summarize`. Приложение 10-12 показывает определение особенности `Summary`, который выражает это поведение.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

<span class="caption">Приложение 10-12: Определение особенности <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span>

Здесь мы объявляем особенность с использованием ключевого слова `trait`, а затем его название, которым в нашем случае является `Summary`. Также мы объявляем ящик как `pub` что позволяет ящикам, зависящим от нашего ящика, тоже использовать наш ящик, что мы увидим в последующих примерах. Внутри узорчатых скобок объявляются ярлыки способов, которые описывают поведения видов, выполняющих данный особенность, в данном случае поведение определяется только одной ярлыком способа `fn summarize(&self) -> String`.

После ярлыки способа, вместо предоставления выполнения в узорчатых в скобках, мы используем точку с запятой. Каждый вид, выполняющий данный особенность, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид содержащий сущность `Summary`, будет также иметь и способ `summarize` объявленный с точно такой же ярлыком.

Особенность может иметь несколько способов в описании его тела: ярлыки способов перечисляются по одной на каждой строке и должны закачиваться знаком <code>;</code>.

### Выполнение особенности у вида

Теперь, после того как мы определили желаемое поведение используя сущность `Summary`, можно выполнить его у видов в нашем медиа-агрегаторе. Приложение 10-13 показывает выполнение особенности `Summary` у устройства `NewsArticle`, которая использует для создания сводки в способе `summarize` заголовок, составителя и место обнародования статьи. Для устройства `Tweet` мы определяем выполнение `summarize` используя имя пользователя и следующий за ним полный писание твита, полагая что содержание твита уже ограничено 280 знаками.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

<span class="caption">Приложение 10-13: Выполнение особенности <code>Summary</code> для устройств <code>NewsArticle</code> и <code>Tweet</code></span>

Выполнение особенности у вида подобна выполнения обычных способов. Разница в том что после `impl` мы ставим имя особенности, который мы хотим выполнить, затем используем ключевое слово `for`, а затем указываем имя вида, для которого мы хотим сделать выполнение особенности. Внутри раздела `impl` мы помещаем ярлык способа объявленную в особенности. Вместо добавления точки с запятой в конце, после каждой ярлыки используются узорчатые скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов особенности для определенного вида.

Теперь когда библиотека выполнила сущность `Summary` для `NewsArticle` и `Tweet`, программисты использующие ящик могут вызывать способы особенности у образцов видов `NewsArticle` и `Tweet` точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести особенность в область видимости точно так же как и виды. Здесь пример того как двоичный ящик может использовать наш `aggregator`:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

Данная рукопись выведет: `1 new tweet: horse_ebooks: of course, as you probably already know, people`.

Другие ящики, которые зависят от `aggregator`, тоже могу включить сущность `Summary` в область видимости для выполнения `Summary` в их собственных видах. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем выполнить особенность для вида только в том случае, если хотя бы один из особенностей вида является местным для нашего ящика. Например, мы можем выполнить обычный библиотечный сущность `Display` на собственном виде `Tweet` как часть возможности нашего ящика `aggregator` потому что вид `Tweet` является местным для ящика `aggregator`. Также мы можем выполнить `Summary` для `Vec<T>` в нашем ящике `aggregator`, потому что сущность `Summary` является местным для нашего ящика `aggregator`.

Но мы не можем выполнить внешние особенности для внешних видов. Например, мы не можем выполнить сущность `Display` для `Vec<T>` внутри нашего ящика `aggregator`, потому что `Display` и `Vec<T>` оба определены в встроенной библиотеке а не местно в нашем ящике `aggregator`. Это ограничение является частью свойства называемого *согласованность* (coherence), а ещё точнее *сиротское правило* (orphan rule), которое называется так потому что не представлен родительский вид. Это правило заверяет, что рукопись других людей не может сломать вашу рукопись и наоборот. Без этого правила два ящика могли бы выполнить одна особенность для одинакового вида и Ржавчина не сможет понять, каким исполнением нужно пользоваться.

### Выполнение поведения по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в особенности вместо того, чтобы требовать выполнения всех способов в каждом виде, выполняющим данный особенность. Затем, когда мы выполняем особенность для определённого вида, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов.

В примере 10-14 показано, как указать строку по умолчанию для способа `summarize` из особенности `Summary` вместо определения только ярлыки способа, как мы сделали в примере 10-12.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

<span class="caption">Приложение 10-14: Определение особенности <code>Summary</code> с выполнением способа <code>summarize</code> по умолчанию</span>

Для использования выполнения по умолчанию при создании сводки у образцов `NewsArticle` вместо определения пользовательской выполнения, мы указываем пустой раздел`impl` с `impl Summary for NewsArticle {}`.

Хотя мы больше не определяем способ `summarize` непосредственно в `NewsArticle`, мы предоставили выполнение по умолчанию и указали, что `NewsArticle` выполняет сущность `Summary`. В итоге мы всё ещё можем вызвать способ `summarize` у образца `NewsArticle`, например так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

Эта рукопись выводит `New article available! (Read more...)` .

Создание выполнения по умолчанию не требует от нас изменений чего-либо в выполнения `Summary` для `Tweet` в приложении 10-13. Причина заключается в том, что правила написания для переопределения выполнения по умолчанию является таким же, как правила написания для выполнения способа особенности, который не имеет выполнения по умолчанию.

Выполнения по умолчанию могут вызывать другие способы в том же особенности, даже если эти другие способы не имеют выполнения по умолчанию. Таким образом, особенность может предоставить много полезной возможности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить сущность `Summary` имеющий способ `summarize_author`, выполнение которого требуется, а затем определить способ `summarize` который имеет выполнение по умолчанию, которая внутри вызывает способ `summarize_author`:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

Чтобы использовать такую исполнение особенности `Summary`, нужно только определить способ `summarize_author`, при выполнения особенности для вида:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

После того, как мы определим `summarize_author`, можно вызвать `summarize` для образцов устройства `Tweet` и выполнение по умолчанию способа `summarize` будет вызывать определение `summarize_author` которое мы уже предоставили. Так как мы выполнили способ `summarize_author` особенности `Summary`, то особенность даёт нам поведение способа `summarize` без необходимости писать рукопись.

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

Эта рукопись выводит `1 new tweet: (Read more from @horse_ebooks...)` .

Обратите внимание, что невозможно вызвать выполнение по умолчанию из переопределённой выполнения того же способа.

### Особенности как свойства

Теперь, когда вы знаете, как определять и выполнить особенности, можно изучить, как использовать особенности, чтобы определить функции, которые принимают много различных видов. Мы будем использовать сущность `Summary`,  выполненный для видов `NewsArticle` и `Tweet` в приложении 10-13, чтобы определить функцию `notify`, которая вызывает способ `summarize` для его свойства `item`, который имеет некоторый вид, выполняющий сущность `Summary`. Для этого мы используем правила написания `impl Trait` примерно так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

Вместо определенного вида у свойства `item` указывается ключевое слово `impl` и имя особенности. Этот свойство принимает любой вид, который выполняет указанный особенность. В теле `notify` мы можем вызывать любые способы у образца `item` , которые приходят с особенностью `Summary`, такие как способ `summarize`. Мы можем вызвать `notify` и передать в него любой образец `NewsArticle` или `Tweet`. Рукопись, который вызывает данную функцию с любым другим видом, таким как `String` или `i32`, не будет собираться, потому что эти виды не выполняют сущность `Summary`.

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### Правила написания ограничения особенности

Правила написания `impl Trait` работает для простых случаев, но на самом деле является связанным сахаром для более длинной вида, которая называется *ограничением особенности* (trait bound); это выглядит так:

```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Эта более длинная разновидность равнозначна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида с ограничением особенности после двоеточия внутри угловых скобок.

Правила написания `impl Trait` удобен и делает рукопись более сжатым в простых случаях, в то время как более полный правила написания с ограничением особенности в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые выполняют особенность  `Summary`. Использование правил написания  `impl Trait` выглядит так:

```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

Использовать `impl Trait` удобнее если мы хотим разрешить функции иметь разные виды для `item1` и `item2` (но оба вида должны выполнить `Summary`). Если же мы хотим заставить оба свойства иметь один и тот же вид, то мы должны использовать ограничение особенности так:

```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

Обобщённый вид `T` указан для видов свойств `item1` и `item2` и ограничивает функцию так, что определенные значения видов переданные переменнойми для `item1` и `item2` должны быть одинаковыми.

#### Задание нескольких границ особенностей с помощью правил написания `+`

Также можно указать более одного ограничения особенности. Допустим, мы хотели бы чтобы `notify` использовал как изменение
вывода так и  `summarize` для свойства `item`: <br>тогда мы указываем что в `notify` свойство `item` должен выполнить оба особенности `Display` и `Summary`. Мы можем сделать это используя правила написания `+`:

```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```

Правила написания `+` также допустим с ограничениями особенности для обобщённых видов:

```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```

При наличии двух ограничений особенности, тело способа `notify` может вызывать `summarize` и использовать `{}` для изменения `item` при его выводе.

#### Более ясные границы особенности с помощью `where`

Использование слишком большого количества ограничений особенности имеет свои недостатки. Каждый обобщённый вид имеет свои границы особенности, поэтому функции с несколькими свойствами обобщённого вида могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение ярлыки. По этой причине в Ржавчине есть иной правила написания для определения ограничений особенности внутри предложения `where` после ярлыков функции. Поэтому вместо того, чтобы писать так:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

можно использовать `where` таким образом:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

Ярлык этой функции менее загромождена: название функции, список свойств, и возвращаемый вид находятся рядом, а ярлык не содержит в себе множество ограничений особенности.

### Возврат значений вида выполняющего определённый особенность

Также можно использовать правила написания `impl Trait` в возвращаемой позиции, чтобы вернуть значение некоторого вида выполняющего особенность, как показано здесь:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

Используя `impl Summary` для возвращаемого вида, мы указываем, что функция `returns_summarizable` возвращает некоторый вид, который выполняет сущность `Summary` без обозначения определенного вида. В этом случае `returns_summarizable` возвращает `Tweet`, но рукопись, вызывающий эту функцию, этого не знает.

Возможность возвращать вид, который определяется только выполняемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды, которые знает только сборщик или виды, которые очень долго указывать. правила написания `impl Trait` позволяет кратко указать, что функция возвращает некоторый вид, который выполняет сущность `Iterator` без необходимости писать очень длинный вид.

Однако, `impl Trait` возможно использовать, если возвращаете только один вид. Например, данная рукопись, который возвращает значения или вида `NewsArticle` или вида `Tweet`, но в качестве возвращаемого вида объявляет `impl Summary` , не будет работать:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

Возврат либо `NewsArticle` либо `Tweet` не допускается из-за ограничений того, как выполнен правила написания `impl Trait` в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе ["Использование предметов особенностей, которые разрешены для значений или разных видов"]<!--  --> Главы 17.

### Использование ограничений особенности для условной выполнения способов

Используя ограничение особенности с разделом `impl`, который использует свойства обобщённого вида, можно выполнить способы условно, для тех видов, которые выполняют указанный особенность. Например, вид `Pair<T>`  в приложении 10-15 всегда выполняет функцию  `new` для возврата нового образца `Pair<T>` (вспомните раздел [“Определение способов”]<!-- ignore --> Главы 5 где `Self` является псевдонимом вида для вида раздела `impl`, который в данном случае является `Pair<T>`). Но в следующем разделе `impl` вид `Pair<T>` выполняет способ  `cmp_display` только если его внутренний вид `T` выполняет сущность `PartialOrd` (позволяющий сравнивать) *и* сущность `Display` (позволяющий выводить на вывод).

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

<span class="caption">Приложение 10-15: Условная выполнение способов у обобщённых видов в зависимости от ограничений особенности</span>

Мы также можем условно выполнить особенность для любого вида, который выполняет другой особенность. Выполнения особенности для любого вида, который удовлетворяет ограничениям особенности, называются *общими выполнениеми* и широко используются в встроенной библиотеке Ржавчина. Например, обычная библиотека выполняет сущность `ToString` для любого вида, который выполняет сущность `Display`. Раздел`impl` в встроенной библиотеке выглядит примерно так:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

Поскольку обычная библиотека имеет эту общую выполнение, то можно вызвать способ `to_string` определённый особенностью `ToString` для любого вида, который выполняет сущность `Display`. Например, мы можем превратить целые числа в их соответствующие `String` значения, потому что целые числа выполняют сущность `Display`:

```rust
let s = 3.to_string();
```

Общие выполнения приведены в пособия к особенности в разделе "Implementors".

Особенности и ограничения особенностей позволяют писать рукопись, которая использует свойства обобщённого вида для уменьшения повторения рукописи, а также указывая сборщику, что мы хотим обобщённый вид, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения особенности, чтобы проверить, что все определенные виды, используемые с нашей рукописью, обеспечивают правильное поведение.  В изменяемых строго определенных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида, который не выполняет вид определяемый способом. Но Ржавчина перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить сбои, прежде чем наша рукопись начнёт работать. Кроме того, мы не должны писать рукопись, который проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов.


["Использование предметов особенностей, которые разрешены для значений или разных видов"]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[“Определение способов”]: ch05-03-method-syntax.html#defining-methods