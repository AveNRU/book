## Типажи: определение общего поведения

*Типаж* сообщает сборщику Ржавчина о функциональности, которой обладает определённый вид и которой он может поделиться с другими видами. Можно использовать типажи, чтобы определять общее поведение абстрактным способом. Мы можем использовать *ограничение типажа* (trait bounds) чтобы указать, что общим видом может быть любой вид, который имеет определённое поведение.

> Примечание: Типажи похожи на функциональность часто называемую *внешней оболочкими* в других языках программирования, хотя и с некоторыми отличиями.

### Определение типажа

Поведение вида определяется теми способами, которые мы можем вызвать у данного вида. Различные виды разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов. Определение типажей - это способ сгруппировать ярлыки способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.

Например, пусть есть несколько структур, которые имеют различный вид и различный размер текста: структура `NewsArticle`, которая содержит новость, напечатанную в каком-то месте мира; структура `Tweet`, которая содержит 280 символьную строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.

Мы хотим создать ящик библиотеки медиа-агрегатора `aggregator`, которая может отображать сводку данных сохранённых в образцах структур `NewsArticle` или `Tweet`. Чтобы этого достичь, нам необходимо иметь возможность для каждой структуры получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ `summarize`. Приложение 10-12 показывает определение типажа `Summary`, который выражает это поведение.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

<span class="caption">Приложение 10-12: Определение типажа <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span>

Здесь мы объявляем типаж с использованием ключевого слова `trait`, а затем его название, которым в нашем случае является `Summary`. Также мы объявляем ящик как `pub` что позволяет ящикам, зависящим от нашего ящика, тоже использовать наш ящик, что мы увидим в последующих примерах. Внутри фигурных скобок объявляются ярлыки способов, которые описывают поведения видов, реализующих данный типаж, в данном случае поведение определяется только одной ярлыком способа `fn summarize(&self) -> String`.

После ярлыки способа, вместо предоставления реализации в фигурных в скобках, мы используем точку с запятой. Каждый вид, реализующий данный типаж, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид содержащий типаж `Summary`, будет также иметь и способ `summarize` объявленный с точно такой же ярлыком.

Типаж может иметь несколько способов в описании его тела: ярлыки способов перечисляются по одной на каждой строке и должны закачиваться символом <code>;</code>.

### Реализация типажа у вида

Теперь, после того как мы определили желаемое поведение используя типаж `Summary`, можно реализовать его у видов в нашем медиа-агрегаторе. Приложение 10-13 показывает реализацию типажа `Summary` у структуры `NewsArticle`, которая использует для создания сводки в способе `summarize` заголовок, автора и место публикации статьи. Для структуры `Tweet` мы определяем реализацию `summarize` используя имя пользователя и следующий за ним полный текст твита, полагая что содержание твита уже ограничено 280 символами.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

<span class="caption">Приложение 10-13: Реализация типажа <code>Summary</code> для структур <code>NewsArticle</code> и <code>Tweet</code></span>

Реализация типажа у вида подобна реализации обычных способов. Разница в том что после `impl` мы ставим имя типажа, который мы хотим реализовать, затем используем ключевое слово `for`, а затем указываем имя вида, для которого мы хотим сделать реализацию типажа. Внутри раздела `impl` мы помещаем ярлык способа объявленную в типаже. Вместо добавления точки с запятой в конце, после каждой ярлыки используются фигурные скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов типажа для определенного вида.

Теперь когда библиотека реализовала типаж `Summary` для `NewsArticle` и `Tweet`, программисты использующие ящик могут вызывать способы типажа у образцов видов `NewsArticle` и `Tweet` точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести типаж в область видимости точно так же как и виды. Здесь пример того как двоичный ящик может использовать наш `aggregator`:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

Данный код напечатает: `1 new tweet: horse_ebooks: of course, as you probably already know, people`.

Другие ящики, которые зависят от `aggregator`, тоже могу включить типаж `Summary` в область видимости для реализации `Summary` в их собственных видах. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем реализовать типаж для вида только в том случае, если хотя бы один из типажей вида является местным для нашего ящика. Например, мы можем реализовать обычный библиотечный типаж `Display` на собственном виде `Tweet` как часть функциональности нашего ящика `aggregator` потому что вид `Tweet` является местным для ящика `aggregator`. Также мы можем реализовать `Summary` для `Vec<T>` в нашем ящике `aggregator`, потому что типаж `Summary` является местным для нашего ящика `aggregator`.

Но мы не можем реализовать внешние типажи для внешних видов. Например, мы не можем реализовать типаж `Display` для `Vec<T>` внутри нашего ящика `aggregator`, потому что `Display` и `Vec<T>` оба определены в встроенной библиотеке а не местно в нашем ящике `aggregator`. Это ограничение является частью свойства называемого *согласованность* (coherence), а ещё точнее *сиротское правило* (orphan rule), которое называется так потому что не представлен родительский вид. Это правило заверяет, что код других людей не может сломать ваш код и наоборот. Без этого правила два ящика могли бы реализовать один типаж для одинакового вида и Ржавчина не сможет понять, какой реализацией нужно пользоваться.

### Реализация поведения по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в типаже вместо того, чтобы требовать реализации всех способов в каждом виде, реализующим данный типаж. Затем, когда мы реализуем типаж для определённого вида, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов.

В примере 10-14 показано, как указать строку по умолчанию для способа `summarize` из типажа `Summary` вместо определения только ярлыки способа, как мы сделали в примере 10-12.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

<span class="caption">Приложение 10-14: Определение типажа <code>Summary</code> с реализацией способа <code>summarize</code> по умолчанию</span>

Для использования реализации по умолчанию при создании сводки у образцов `NewsArticle` вместо определения пользовательской реализации, мы указываем пустой раздел`impl` с `impl Summary for NewsArticle {}`.

Хотя мы больше не определяем способ `summarize` непосредственно в `NewsArticle`, мы предоставили реализацию по умолчанию и указали, что `NewsArticle` реализует типаж `Summary`. В итоге мы всё ещё можем вызвать способ `summarize` у образца `NewsArticle`, например так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

Этот код печатает `New article available! (Read more...)` .

Создание реализации по умолчанию не требует от нас изменений чего-либо в реализации `Summary` для `Tweet` в приложении 10-13. Причина заключается в том, что правила написания для переопределения реализации по умолчанию является таким же, как правила написания для реализации способа типажа, который не имеет реализации по умолчанию.

Реализации по умолчанию могут вызывать другие способы в том же типаже, даже если эти другие способы не имеют реализации по умолчанию. Таким образом, типаж может предоставить много полезной функциональности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить типаж `Summary` имеющий способ `summarize_author`, реализация которого требуется, а затем определить способ `summarize` который имеет реализацию по умолчанию, которая внутри вызывает способ `summarize_author`:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

Чтобы использовать такую исполнение типажа `Summary`, нужно только определить способ `summarize_author`, при реализации типажа для вида:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

После того, как мы определим `summarize_author`, можно вызвать `summarize` для образцов структуры `Tweet` и реализация по умолчанию способа `summarize` будет вызывать определение `summarize_author` которое мы уже предоставили. Так как мы реализовали способ `summarize_author` типажа `Summary`, то типаж даёт нам поведение способа `summarize` без необходимости писать код.

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

Этот код печатает `1 new tweet: (Read more from @horse_ebooks...)` .

Обратите внимание, что невозможно вызвать реализацию по умолчанию из переопределённой реализации того же способа.

### Типажи как свойства

Теперь, когда вы знаете, как определять и реализовывать типажи, можно изучить, как использовать типажи, чтобы определить функции, которые принимают много различных видов. Мы будем использовать типаж `Summary`,  реализованный для видов `NewsArticle` и `Tweet` в приложении 10-13, чтобы определить функцию `notify`, которая вызывает способ `summarize` для его свойства `item`, который имеет некоторый вид, реализующий типаж `Summary`. Для этого мы используем правила написания `impl Trait` примерно так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

Вместо определенного вида у свойства `item` указывается ключевое слово `impl` и имя типажа. Этот свойство принимает любой вид, который реализует указанный типаж. В теле `notify` мы можем вызывать любые способы у образца `item` , которые приходят с типажом `Summary`, такие как способ `summarize`. Мы можем вызвать `notify` и передать в него любой образец `NewsArticle` или `Tweet`. Код, который вызывает данную функцию с любым другим видом, таким как `String` или `i32`, не будет собираться, потому что эти виды не реализуют типаж `Summary`.

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### правила написания ограничения типажа

правила написания `impl Trait` работает для простых случаев, но на самом деле является синтаксическим сахаром для более длинной видовы, которая называется *ограничением типажа* (trait bound); это выглядит так:

```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Эта более длинная разновидность эквивалентна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида с ограничением типажа после двоеточия внутри угловых скобок.

правила написания `impl Trait` удобен и делает код более сжатым в простых случаях, в то время как более полный правила написания с ограничением типажа в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые реализуют типаж  `Summary`. Использование правил написания  `impl Trait` выглядит так:

```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

Использовать `impl Trait` удобнее если мы хотим разрешить функции иметь разные виды для `item1` и `item2` (но оба вида должны реализовывать `Summary`). Если же мы хотим заставить оба свойства иметь один и тот же вид, то мы должны использовать ограничение типажа так:

```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

Обобщённый вид `T` указан для видов свойств `item1` и `item2` и ограничивает функцию так, что определенные значения видов переданные переменнойми для `item1` и `item2` должны быть одинаковыми.

#### Задание нескольких границ типажей с помощью правил написания `+`

Также можно указать более одного ограничения типажа. Допустим, мы хотели бы чтобы `notify` использовал как изменение
вывода так и  `summarize` для свойства `item`: <br>тогда мы указываем что в `notify` свойство `item` должен реализовывать оба типажа `Display` и `Summary`. Мы можем сделать это используя правила написания `+`:

```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```

правила написания `+` также допустим с ограничениями типажа для обобщённых видов:

```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```

При наличии двух ограничений типажа, тело способа `notify` может вызывать `summarize` и использовать `{}` для изменения `item` при его печати.

#### Более ясные границы типажа с помощью `where`

Использование слишком большого количества ограничений типажа имеет свои недостатки. Каждый обобщённый вид имеет свои границы типажа, поэтому функции с несколькими свойствами обобщённого вида могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение ярлыки. По этой причине в Ржавчина есть иной правила написания для определения ограничений типажа внутри предложения `where` после ярлыки функции. Поэтому вместо того, чтобы писать так:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

можно использовать `where` таким образом:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

Ярлык этой функции менее загромождена: название функции, список свойств, и возвращаемый вид находятся рядом, а ярлык не содержит в себе множество ограничений типажа.

### Возврат значений вида реализующего определённый типаж

Также можно использовать правила написания `impl Trait` в возвращаемой позиции, чтобы вернуть значение некоторого вида реализующего типаж, как показано здесь:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

Используя `impl Summary` для возвращаемого вида, мы указываем, что функция `returns_summarizable` возвращает некоторый вид, который реализует типаж `Summary` без обозначения определенного вида. В этом случае `returns_summarizable` возвращает `Tweet`, но код, вызывающий эту функцию, этого не знает.

Возможность возвращать вид, который определяется только реализуемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды, которые знает только сборщик или виды, которые очень долго указывать. правила написания `impl Trait` позволяет кратко указать, что функция возвращает некоторый вид, который реализует типаж `Iterator` без необходимости писать очень длинный вид.

Однако, `impl Trait` возможно использовать, если возвращаете только один вид. Например, данный код, который возвращает значения или вида `NewsArticle` или вида `Tweet`, но в качестве возвращаемого вида объявляет `impl Summary` , не будет работать:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

Возврат либо `NewsArticle` либо `Tweet` не допускается из-за ограничений того, как реализован правила написания `impl Trait` в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе ["Использование предметов типажей, которые разрешены для значений или разных видов"]<!--  --> Главы 17.

### Использование ограничений типажа для условной реализации способов

Используя ограничение типажа с разделом `impl`, который использует свойства обобщённого вида, можно реализовать способы условно, для тех видов, которые реализуют указанный типаж. Например, вид `Pair<T>`  в приложении 10-15 всегда реализует функцию  `new` для возврата нового образца `Pair<T>` (вспомните раздел [“Определение способов”]<!-- ignore --> Главы 5 где `Self` является псевдонимом вида для вида раздела `impl`, который в данном случае является `Pair<T>`). Но в следующем разделе `impl` вид `Pair<T>` реализует способ  `cmp_display` только если его внутренний вид `T` реализует типаж `PartialOrd` (позволяющий сравнивать) *и* типаж `Display` (позволяющий выводить на печать).

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

<span class="caption">Приложение 10-15: Условная реализация способов у обобщённых видов в зависимости от ограничений типажа</span>

Мы также можем условно реализовать типаж для любого вида, который реализует другой типаж. Реализации типажа для любого вида, который удовлетворяет ограничениям типажа, называются *общими реализациями* и широко используются в встроенной библиотеке Rust. Например, обычная библиотека реализует типаж `ToString` для любого вида, который реализует типаж `Display`. Раздел`impl` в встроенной библиотеке выглядит примерно так:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

Поскольку обычная библиотека имеет эту общую реализацию, то можно вызвать способ `to_string` определённый типажом `ToString` для любого вида, который реализует типаж `Display`. Например, мы можем превратить целые числа в их соответствующие `String` значения, потому что целые числа реализуют типаж `Display`:

```rust
let s = 3.to_string();
```

Общие реализации приведены в документации к типажу в разделе "Implementors".

Типажи и ограничения типажей позволяют писать код, который использует свойства обобщённого вида для уменьшения повторения кода, а также указывая сборщику, что мы хотим обобщённый вид, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения типажа, чтобы проверить, что все определенные виды, используемые с нашим кодом, обеспечивают правильное поведение.  В изменяемых строго определенных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида, который не реализует вид определяемый способом. Но Ржавчина перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить сбоев, прежде чем наш код начнёт работать. Кроме того, мы не должны писать код, который проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов.


["Использование предметов типажей, которые разрешены для значений или разных видов"]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[“Определение способов”]: ch05-03-method-syntax.html#defining-methods