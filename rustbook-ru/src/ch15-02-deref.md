## Обращение с умными указателями как с обычными ссылками с помощью `Deref` особенности

Используя особенность `Deref`, вы можете изменить поведение *оператора разыменования* `*` (не путать с операторами умножения или вездесущего подключения). Выполнив `Deref` таким образом, что умный указатель может рассматриваться как обычная ссылка, вы можете писать код, оперирующий ссылками, а также использовать этот код с умными указателями.

Давайте сначала посмотрим, как работает оператор разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский вид, который ведёт себя как `Box<T>` и посмотрим, почему оператор разыменования не работает как ссылка для нового объявленного вида. Мы рассмотрим, как выполнение особенности `Deref` делает возможным работу умных указателей подобно ссылкам. Затем посмотрим на *разыменованное приведение* (deref coercion) в Ржавчина и как оно позволяет работать с любыми ссылками или умными указателями.

> Примечание: есть одна большая разница между видом `MyBox<T>`, который мы собираемся создать и существующим `Box<T>`: наша исполнение не будет хранить свои данные в куче. В примере мы сосредоточимся на особенности `Deref`, поэтому менее важно то, где данные хранятся, чем поведение подобное указателю.

<!-- Old link, do not remove -->

<a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a>

### Следуя за указателем на значение

Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте. В приложении 15-6 мы создаём ссылку на значение `i32`, а затем используем оператор разыменования для перехода от ссылки к значению:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}
```

<span class="caption">Приложение 15-6: Использование оператора разыменования для следования по ссылке к значению <code>i32</code></span>

Переменной `x` присвоено значение`5` вида `i32`. Мы установили в качестве значения `y` ссылку на `x`. Мы можем утверждать, что значение `x` равно `5`. Однако, если мы хотим сделать утверждение о значении в `y`, мы должны использовать `*y`, чтобы перейти по ссылке к значению, на которое она указывает (таким образом, происходит *разыменование*), для того чтобы сборщик при сравнении мог использовать действительное значение. Как только мы разыменуем `y`, мы получим доступ к целочисленному значению, на которое указывает `y`, которое и будем сравнивать с `5`.

Если бы мы попытались написать `assert_eq!(5, y);`, то получили ошибку сборки:

```console
{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}
```

Сравнение числа и ссылки на число не допускается, потому что они различных видов. Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.

### Использование `Box<T>` как ссылку

Мы можем переписать код в приложении 15-6, чтобы использовать `Box<T>` вместо ссылки; оператор разыменования, используемый для `Box<T>` в приложении 15-7, работает так же, как оператор разыменования, используемый для ссылки в приложении 15-6:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}
```

<span class="caption">Приложение 15-7: Использование оператора разыменования с видом <code>Box&lt;i32&gt;</code></span>

Основное различие между приложением 15-7 и приложением 15-6 заключается в том, что здесь мы устанавливаем `y` как образец `Box<T>`, указывающий на воспроизведенное значение `x`, а не как ссылку, указывающую на значение `x`. В последнем утверждении мы можем использовать оператор разыменования, чтобы проследовать за указателем `Box<T>` так же, как мы это делали, когда `y` был ссылкой. Далее мы рассмотрим, что особенного в `Box<T>`, что позволяет нам использовать оператор разыменования, определяя наш собственный вид.

### Определение собственного умного указателя

Давайте создадим умный указатель, похожий на вид `Box<T>` предоставляемый встроенной библиотекой, чтобы понять как поведение умных указателей отличается от поведения обычной ссылки. Затем мы рассмотрим вопрос, как добавить возможность использовать оператор разыменования.

Вид `Box<T>` в конечном итоге определяется как устройства упорядоченного ряда с одним элементом, поэтому в приложении 15-8 подобным образом определяется `MyBox<T>`. Мы также определим функцию `new`, чтобы она соответствовала функции `new`, определённой в `Box<T>`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}
```

<span class="caption">Приложение 15-8: Определение вида <code>MyBox&lt;T&gt;</code></span>

Мы определяем устройство с именем `MyBox` и объявляем обобщённый свойство `T`, потому что мы хотим, чтобы наш вид хранил значения любого вида. Вид `MyBox` является устройством упорядоченного ряда с одним элементом вида `T`. Функция `MyBox::new` принимает один свойство вида `T` и возвращает образец `MyBox`, который содержит переданное значение.

Давайте попробуем добавить функцию `main` из приложения 15-7 в приложение 15-8 и изменим её на использование вида `MyBox<T>`, который мы определили вместо `Box<T>`. Код в приложении 15-9 не будет собираться, потому что Ржавчина не знает, как разыменовывать `MyBox`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}
```

<span class="caption">Приложение 15-9. Попытка использовать <code>MyBox&lt;T&gt;</code> таким же образом, как мы использовали ссылки и <code>Box&lt;T&gt;</code></span>

Вот итог ошибки сборки:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}
```

Наш вид `MyBox<T>` не может быть разыменован, потому что мы не выполнили эту возможность. Чтобы включить разыменование с помощью оператора `*`, мы выполняем особенность `Deref`.

### Трактование вида как ссылки выполняя особенность `Deref`

Как обсуждалось в разделе [“Выполнение особенности для вида”]<!--  --> Главы 10, для выполнения особенности нужно предоставить выполнения требуемых способов особенности. Особенность `Deref`, предоставляемый встроенной библиотекой требует от нас выполнения одного способа с именем `deref`, который заимствует `self` и возвращает ссылку на внутренние данные. Приложение 15-10 содержит выполнение `Deref` добавленную к определению `MyBox`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
```

<span class="caption">Приложение 15-10: Выполнение <code>Deref</code> для вида <code>MyBox&lt;T&gt;</code></span>

правила написания `type Target = T;` определяет связанный вид для использования у особенности `Deref`. Связанные виды - это немного другой способ объявления обобщённого свойства, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.

Мы заполним тело способа `deref` оператором `&self.0 `, чтобы `deref` вернул ссылку на значение, к которому мы хотим получить доступ с помощью оператора `*`; вспомним из раздела ["Using Tuple Structs without Named Fields to Create Different Types"]<!-- ignore --> главы 5, что `.0` получает доступ к первому значению в упорядоченной в ряд устройстве. Функция `main` в приложении 15-9, которая вызывает `*` для значения `MyBox<T>`, теперь собирается, и проверки проходят!

Без особенности `Deref` сборщик может только разыменовывать `&` ссылки. Способ `deref` даёт сборщику возможность принимать значение любого вида, выполняющего `Deref` и вызывать способ `deref` чтобы получить ссылку `&`, которую он знает, как разыменовывать.

Когда мы ввели `*y` в приложении 15-9, Ржавчина в действительности выполнил за кулисами такой код:

```rust,ignore
*(y.deref())
```

Ржавчина заменяет оператор `*` вызовом способа `deref` и затем простое разыменование, поэтому нам не нужно думать о том, нужно ли нам вызывать способ `deref`. Эта функция Ржавчина позволяет писать код, который исполняется одинаково, независимо от того, есть ли у нас обычная ссылка или вид, выполняющий особенность `Deref`.

Причина, по которой способ `deref` возвращает ссылку на значение, и что простое разыменование вне круглых скобок в `*(y.deref())` все ещё необходимо, связана с системой владения. Если бы способ `deref` возвращал значение напрямую, а не ссылку на него, значение переместилось бы из `self`. Мы не хотим передавать владение внутренним значением внутри `MyBox<T>` в этом случае и в большинстве случаев, когда мы используем оператор разыменования.

Обратите внимание, что оператор `*` заменён вызовом способа `deref`, а затем вызовом оператора `*` только один раз, каждый раз, когда мы используем `*` в коде. Поскольку замена оператора `*` не повторяется бесконечно, мы получаем данные вида `i32`, которые соответствуют `5` в `assert_eq!` приложения 15-9.

### Неявные разыменованные приведения с функциями и способами<a id="implicit-deref-coercions-with-functions-and-methods"></a>

*Разыменованное приведение* преобразует ссылку на вид, который выполняет признак `Deref`, в ссылку на другой вид. Например, deref coercion может преобразовать `&String` в `&str`, потому что `String` выполняет признак `Deref`, который возвращает `&str`. Deref coercion - это удобный рычаг, который Ржавчина использует для переменных функций и способов, и работает только для видов, выполняющих признак `Deref`. Это происходит самостоятельно , когда мы передаём в качестве переменной функции или способа ссылку на значение определённого вида, которое не соответствует виду свойства в определении функции или способа. В итоге серии вызовов способа `deref` вид, который мы передали, преобразуется в вид, необходимый для свойства.

Разыменованное приведение было добавлено в Ржавчина так, что программистам, пишущим вызовы функций и способов, не нужно добавлять множество явных ссылок и разыменований с помощью использования `&` и `*`. Возможность разыменованного приведения также позволяет писать больше кода, который может работать как с ссылками, так и с умными указателями.

Чтобы увидеть разыменованное приведение в действии, давайте воспользуемся видом `MyBox<T>` определённым в приложении 15-8, а также выполнение `Deref` добавленную в приложении 15-10. Приложение 15-11 показывает определение функции, у которой есть свойство вида срез строки:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}
```

<span class="caption">Приложение 15-11: Функция <code>hello</code> имеющая свойство  <code>name</code> вида <code>&amp;str</code></span>

Можно вызвать функцию `hello` со срезом строки в качестве переменной, например `hello("Rust");`. Разыменованное приведение делает возможным вызов `hello` со ссылкой на значение вида `MyBox<String>`, как показано в приложении 15-12.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}
```

<span class="caption">Приложение 15-12: Вызов <code>hello</code> со ссылкой на значение <code>MyBox&lt;String&gt;</code>, которое работает из-за разыменованного приведения</span>

Здесь мы вызываем функцию `hello` с переменнаяом `&m`, который является ссылкой на значение `MyBox<String>`. Поскольку мы выполнили особенность `Deref` для `MyBox<T>` в приложении 15-10, то Ржавчина может преобразовать `&MyBox<String>` в `&String` вызывая `deref`. Обычная библиотека предоставляет выполнение особенности `Deref` для вида `String`, которая возвращает срез строки, это описано в документации API особенности `Deref`. Ржавчина снова вызывает `deref`, чтобы превратить `&String` в `&str`, что соответствует определению функции `hello`.

Если бы Ржавчина не выполнил разыменованное приведение, мы должны были бы написать код в приложении 15-13 вместо кода в приложении 15-12 для вызова способа `hello` со значением вида `&MyBox<String>`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}
```

<span class="caption">Приложение 15-13: Код, который нам пришлось бы написать, если бы в Ржавчина не было разыменованного приведения ссылок</span>

Код `(*m)` разыменовывает `MyBox<String>` в `String`. Затем `&` и `[..]` принимают строковый срез `String`, равный всей строке, чтобы соответствовать ярлыке `hello`. Код без разыменованного приведения сложнее читать, писать и понимать со всеми этими символами. Разыменованное приведение позволяет Ржавчина обрабатывать эти преобразования для нас самостоятельно .

Когда особенность `Deref` определён для задействованных видов, Ржавчина проанализирует виды и будет использовать `Deref::deref` столько раз, сколько необходимо, чтобы получить ссылку, соответствующую виду свойства. Количество раз, которое нужно вставить `Deref::deref` определяется во время сборки, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!

### Как разыменованное приведение взаимодействует с изменяемостью

Подобно тому, как вы используете особенность `Deref` для переопределения оператора `*` у неизменяемых ссылок, вы можете использовать особенность `DerefMut` для переопределения оператора `*` у изменяемых ссылок.

Ржавчина выполняет разыменованное приведение, когда находит виды и выполнения особенностей в трёх случаях:

- Из вида `&T` в вид `&U` когда верно `T: Deref<Target=U>`
- Из вида `&mut T` в вид `&mut U` когда верно `T: DerefMut<Target=U>`
- Из вида `&mut T` в вид `&U` когда верно `T: Deref<Target=U>`

Первые два случая равноценны друг другу, за исключением того, что второй выполняет изменяемость. В первом случае говорится, что если у вас есть `&T`, а `T` выполняет `Deref` для некоторого вида `U`, вы сможете прозрачно получить `&U`. Во втором случае говорится, что такое же разыменованное приведение происходит и для изменяемых ссылок.

Третий случай хитрее: Ржавчина также приводит изменяемую ссылку к неизменяемой. Но обратное *не* представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на данные (в противном случае программа не будет собираться). Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, и правила заимствования не заверяют этого. Следовательно, Ржавчина не может сделать предположение, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.


[“Выполнение особенности для вида”]: ch10-02-traits.html#implementing-a-trait-on-a-type
["Using Tuple Structs without Named Fields to Create Different Types"]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types