## Продвинутые виды

Перечень видов Ржавчине имеет некоторые сущности, о которых мы уже упоминали, но ещё не обсуждали. Мы начнём с общего обзора newtypes, а затем разберёмся, чем они могут пригодиться в качестве видов. Далее мы перейдём к псевдонимам видов - возможности, похожей на newtypes, но с несколько иной смыслом. Мы также обсудим вид `!` и виды с изменяемым размером.

### Использование образца Newtype для обеспечения безопасности видов и создания абстракций

> Примечание: В этом разделе предполагается, что вы прочитали предыдущий раздел ["Использование образца Newtype для выполнения внешних сущностей для внешних видов."]<!-- ignore -->

Образец newtype полезен и для других задач, помимо тех, которые мы обсуждали до сих пор, в частности, для постоянного обеспечения того, чтобы значения никогда не путались, а также для указания единиц измерения значения. Пример использования newtypes для указания единиц измерения вы видели в приложении 19-15: вспомните, как устройства `Millimeters` и `Meters` обернули значения `u32` в newtype. Если бы мы написали функцию со свойством вида `Millimeters`, мы не смогли бы собрать программу, которая случайно попыталась бы вызвать эту функцию со значением вида `Meters` или обычным `u32`.

Мы также можем использовать образец newtype для абстрагирования от некоторых подробностей выполнения вида: новый вид может предоставлять открытый API, который отличается от API скрытого внутри вида.

Newtypes также позволяют скрыть внутреннее выполнение. Например, мы можем создать вид `People`, который обернёт `HashMap<i32, String>`, хранящий ID человека, связанный с его именем. Рукопись, использующая `People`, будет взаимодействовать только с открытым API, который мы предоставляем, например, способ добавления имени в собрание `People`; этой рукописи не нужно будет знать, что внутри мы присваиваем `i32` ID именам. Образец newtype - это лёгкий способ достижения инкапсуляции для скрытия подробностей выполнения, который мы обсуждали в разделе ["Инкапсуляция, скрывающая подробности выполнения"](ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details)<!-- ignore --> главы 17.

### Создание родственных вида с помощью псевдонимов вида

Ржавчина предоставляет возможность объявить *псевдоним вида* чтобы дать существующему виду другое имя. Для этого мы используем ключевое слово `type`. Например, мы можем создать псевдоним вида `Kilometers` для `i32` следующим образом:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}
```

Теперь псевдоним `Kilometers` является *родственным* для `i32`; в отличие от видов `Millimeters` и `Meters`, которые мы создали в приложении 19-15, `Kilometers` не является отдельным, новым видом. Значения, имеющие вид `Kilometers`, будут обрабатываться так же, как и значения вида `i32`:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}
```

Поскольку `Kilometers` и `i32` являются одним и тем же видом, мы можем добавлять значения обоих видов и передавать значения `Kilometers` функциям, принимающим свойства `i32`. Однако, используя этот способ, мы не получаем тех преимуществ проверки видов, которые мы получаем от образца newtype, рассмотренного ранее. Другими словами, если мы где-то перепутаем значения `Kilometers` и `i32`, сборщик не выдаст нам ошибку.

Родственные в основном используются для сокращения повторений. Например, у нас может быть такой многословный вид:

```rust,ignore
Box<dyn Fn() + Send + 'static>
```

Написание таких длинных видов в описании самих функций и в виде наставлений видов по всему рукописи может быть утомительным и чреватым ошибками. Представьте себе дело, наполненный таким рукописью, как в приложении 19-24.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-24/src/main.rs:here}}
```

<span class="caption">Приложение 19-24: Использование длинного вида во многих местах</span>

Псевдоним вида делает эту рукопись более удобной для работы, сокращая количество повторений. В приложении 19-25 мы ввели псевдоним `Thunk` для вида verbose и можем заменить все использования этого вида более коротким псевдонимом `Thunk`.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-25/src/main.rs:here}}
```

<span class="caption">Приложение 19-25: Представление псевдонима <code>Thunk</code> для уменьшения количества повторений</span>

Такую рукопись гораздо легче читать и писать! Выбор осмысленного имени для псевдонима вида также может помочь прояснить ваши намерения (*thunk* - название для рукописи, которая будет вычисляться позднее, поэтому это подходящее имя для сохраняемого замыкания).

Псевдонимы видов также часто используются с видом `Result<T, E>` для сокращения повторений. Рассмотрим звено `std::io` в встроенной библиотеке. Действия ввода-вывода часто возвращают `Result<T, E>` для обработки случаев, когда эти действия не удаются. В данной библиотеке есть устройства `std::io::Error`, которая отражает все возможные ошибки ввода/вывода. Многие функции в `std::io` будут возвращать `Result<T, E>`, где `E` - это `std::io::Error`, например, эти функции в сущности `Write`:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-05-write-trait/src/lib.rs}}
```

`Result<..., Error>` часто повторяется. Поэтому `std::io` содержит такое объявление псевдонима вида:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}
```

Поскольку это объявление находится в звене `std::io`, мы можем использовать полный псевдоним `std::io::Result<T>`; это и есть `Result<T, E>`, где в качестве `E` выступает `std::io::Error`. Ярлыки функций сущности `Write` в итоге выглядят следующим образом:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}
```

Псевдоним вида помогает двумя способами: он облегчает написание рукописи *и* даёт нам согласованный внешняя оболочка для всего из `std::io`. Поскольку это псевдоним, то это просто ещё один вид `Result<T, E>`, что означает, что с ним мы можем использовать любые способы, которые работают с `Result<T, E>`, а также особый правила написания вроде `?` приказчика.

### Вид Never, который никогда не возвращается

В Ржавчине есть особый вид `!`, который на жаргоне теории видов известен как *empty type* (пустой вид), потому что он не содержит никаких значений. Мы предпочитаем называть его *never type* (никакой вид), потому что он используется в качестве возвращаемого вида, когда функция ничего не возвращает. Вот пример:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-07-never-type/src/lib.rs:here}}
```

Эта рукопись читается как "функция `bar` ничего не возвращает". Функции, которые ничего не возвращают, называются *рассеивающими функциями* (diverging functions). Мы не можем производить значения вида `!`, поэтому `bar` никогда ничего не вернёт.

Но для чего нужен вид, для которого вы никогда не сможете создать значения? Напомним рукопись из приложения 2-5, отрывка "игры в загадки"; мы воспроизвели его часть здесь в приложении 19-26.

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}
```

<span class="caption">Приложение 19-26: Сопоставление <code>match</code> с веткой, которая заканчивается <code>continue</code></span>

В то время мы опустили некоторые подробности в этой рукописи. В главе 6 раздела ["Приказчик управления потоком `match`"](ch06-02-match.html#the-match-control-flow-operator)<!--  --> мы обсуждали, что все ветви `match` должны возвращать одинаковый вид. Например, следующая рукопись не работает:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}
```

Вид `guess` в этой рукописи должен быть целым *и* строкой, а Ржавчина требует, чтобы `guess` имел только один вид. Так что же возвращает `continue`? Как нам позволили вернуть `u32` из одной ветви и при этом иметь другую ветвь, которая оканчивается `continue` в приложении 19-26?

Как вы уже возможно догадались, `continue` имеет  значение `!`. То есть, когда Ржавчина вычисляет вид `guess`, он смотрит на обе сопоставляемые ветки, первая со значением `u32` и последняя со значением `!`. Так как `!` никогда не может иметь значение, то Ржавчина решает что видом `guess` является вид `u32`.

Условный подход к описанию такого поведения заключается в том, что выражения вида `!` могут быть преобразованы в любой другой вид. Нам позволяется завершить этот `match` с помощью `continue`, потому что `continue` не возвращает никакого значения; вместо этого он передаёт управление обратно в начало круговорота, поэтому в случае `Err` мы никогда не присваиваем значение `guess`.

Вид never полезен также для макроса `panic!`. Вспомните функцию `unwrap`, которую мы вызываем для значений `Option<T>`, чтобы создать значение или вызвать сбой с этим определением:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}
```

В этой рукописи происходит то же самое, что и в `match` в приложении 19-26: Ржавчина видит, что `val` имеет вид `T`, а `panic!` имеет вид `!`, поэтому итогом общего выражения `match` является `T`. Эта рукопись работает, потому что `panic!` не производит никакого значения; он завершает программу. В случае `None` мы не будем возвращать значение из `unwrap`, поэтому эта рукопись работает.

Последнее выражение, которое имеет вид `!` это `loop`:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}
```

В данном случае круговорот никогда не завершится, поэтому `!` является значением выражения. Но это не будет так, если мы добавим `break`, так как круговорот завершит свою работу, когда дойдёт до `break`.

### Виды с изменяемым размером и сущность `Sized`

Ржавчине необходимо знать некоторые подробности о видах, например, сколько места нужно выделить для значения определённого вида. Из-за этого один из сущностей системы видов поначалу вызывает некоторое недоумение: подход *видов с изменяемым размером*. Иногда называемые *DST* или *безразмерные виды*, эти виды позволяют нам писать рукопись, используя значения, размер которых мы можем узнать только во время выполнения.

Давайте углубимся в подробности изменяемого вида `str`, который мы использовали на протяжении всей книги. Все верно, не вида `&str`, а вида `str` самого по себе, который является DST. Мы не можем знать, какой длины строка до мгновения времени выполнения, то есть мы не можем создать переменную вида `str` и не можем принять переменную вида `str`. Рассмотрим следующую рукопись, которая не работает:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}
```

Ржавчина должна знать, сколько памяти выделить для любого значения определенного вида и все значения вида должны использовать одинаковый размер памяти. Если Ржавчина позволила бы нам написать такую рукопись, то эти два значения `str` должны были бы занимать одинаковое количество памяти. Но они имеют разную длину: `s1` нужно 12 байтов памяти, а для `s2` нужно 15. Вот почему невозможно создать переменную имеющую вид изменяемого размера.

Так что же нам делать? В этом случае вы уже знаете ответ: мы преобразуем виды `s1` и `s2` в `&str`, а не в `str`. Вспомните из раздела ["Строковые срезы"] главы 4, что устройства данных среза просто хранит начальное положение и длину среза. Так, в отличие от `&T`, который содержит только одно значение - адрес памяти, где находится `T`, в `&str` хранятся *два* значения - адрес `str` и его длина. Таким образом, мы можем узнать размер значения `&str` во время сборки: он вдвое больше длины `usize`. То есть, мы всегда знаем размер `&str`, независимо от длины строки, на которую оно ссылается. В целом, именно так в Ржавчине используются виды изменяемого размера: они содержат дополнительный бит метаданных, который хранит размер изменяемой сведений. Золотое правило изменяемых размерных видов заключается в том, что мы всегда должны помещать значения таких видов за каким-либо указателем.

Мы можем соединенять `str` со всеми видами указателей: например, `Box<str>` или `Rc<str>`. На самом деле, вы уже видели это раньше, но с другим изменяемым размерным видом: сущностями. Каждый сущность - это изменяемый размерный вид, на который мы можем ссылаться, используя имя сущности. В главе 17 в разделе ["Использование сущность-предметов, допускающих значения разных видов"](ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types) мы упоминали, что для использования сущностей в качестве сущность-предметов мы должны поместить их за указателем, например `&dyn Trait` или `Box<dyn Trait>` (`Rc<dyn Trait>` тоже подойдёт).

Для работы с DST Ржавчина использует сущность `Sized` чтобы решить, будет ли размер вида известен на этапе сборки. Эту сущность самостоятельно используется для всего, чей размер известен к времени сборки. Кроме того, Ржавчина неявно добавляет ограничение на `Sized` к каждой гибкой функции. То есть, определение гибкой функции, такое как:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}
```

на самом деле рассматривается как если бы мы написали её в виде:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}
```

По умолчанию обобщённые функции будут работать только с видами данных чей размер известен во время сборки. Тем не менее, можно использовать следующий особый правила написания, чтобы ослабить это ограничение:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}
```

Ограничение сущности `?Sized` означает «`T` может или не может быть `Sized`», эта наставление отменяет обычное правило, согласно которому гибкие виды должны иметь известный размер во время сборки. Использовать правила написания `?Trait` в таком качестве можно только для `Sized`, и ни для каких других особенностей.

Также обратите внимание, что мы поменяли вид свойства `t` с `T` на `&T`. Поскольку вид мог бы не быть `Sized`, мы должны использовать его за каким-либо указателем. В данном случае мы выбрали ссылку.

Далее мы поговорим о функциях и замыканиях!


["Строковые срезы"]: ch04-03-slices.html#string-slices
["Использование образца Newtype для выполнения внешних сущностей для внешних видов."]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types