## `panic!` или не `panic!`

Итак, как принимается решение о том, когда следует вызывать `panic!`, а когда вернуть `Result`? При панике код не имеет возможности восстановить своё выполнение. Можно было бы вызывать `panic!` для любой ошибочной случаи, независимо от того, имеется ли способ восстановления или нет, но с другой стороны, вы принимаете решение от имени вызывающего вас кода, что случаей необратима. Когда вы возвращаете значение `Result`, вы делегируете принятие решения вызывающему коду. Вызывающий код может попытаться выполнить восстановление способом, который подходит в данной случаи, или же он может решить, что из ошибки в  `Err` нельзя восстановиться и вызовет `panic!`, превратив вашу исправимую ошибку в неисправимую. Поэтому возвращение `Result` является хорошим выбором по умолчанию для функции, которая может дать сбой.

В таких случаей как примеры, протовиды и проверки, более уместно писать код, который паникует вместо возвращения `Result`. Давайте рассмотрим почему, а затем мы обсудим случаи, в которых сборщик не может доказать, что ошибка невозможна, но вы, как человек, можете это сделать. Глава будет заканчиваться некоторыми общими руководящими принципами о том, как решить, стоит ли паниковать в коде библиотеки.

### Примеры, прототипирование и проверки

Когда вы пишете пример, отображающий некоторую подход, наличие хорошего кода обработки ошибок может сделать пример менее понятным. Понятно, что в примерах вызов способа `unwrap`, который может привести к панике, является лишь обозначением способа обработки ошибок в приложении, который может отличаться в зависимости от того, что делает остальная часть кода.

Точно так же способы `unwrap` и `expect` являются очень удобными при создании протовида, прежде чем вы будете готовы решить, как обрабатывать ошибки. Они оставляют чёткие отступыв коде до особенности, когда вы будете готовы сделать программу более надёжной.

Если в проверке происходит сбой при вызове способа, то вы бы хотели, чтобы весь проверка не прошёл, даже если этот способ не является проверяемой возможностью. Поскольку вызов `panic!` это способ, которым проверка помечается как провалившийся, использование `unwrap` или `expect` - именно то, что нужно.

### Случаи, в которых у вас больше сведений, чем у сборщика

Также было бы целесообразно вызывать `unwrap` или `expect` когда у вас есть какая-то другая логика, которая заверяет, что `Result` будет иметь значение `Ok`, но вашу логику не понимает сборщик. У вас по-прежнему будет значение `Result` которое нужно обработать: любая действие, которую вы вызываете, все ещё имеет возможность неудачи в целом, хотя это логически невозможно в вашей именно случаи. Если, проверяя код вручную, вы можете убедиться, что никогда не будет исход с `Err`, то вполне допустимо вызывать `unwrap`, а ещё лучше задокументировать причину, по которой, по вашему мнению, у вас никогда не будет исхода `Err` в тексте `expect`. Вот пример:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

Мы создаём образец `IpAddr`, анализируя жёстко закодированную строку. Можно увидеть, что `127.0.0.1` является действительным IP-адресом, поэтому здесь допустимо использование `expect`. Однако наличие жёстко закодированной допустимой строки не меняет вид возвращаемого значения способа `parse`: мы все ещё получаем значение `Result` и сборщик все также заставляет нас обращаться с `Result`так, будто возможен исход `Err`, потому что сборщик недостаточно умён, чтобы увидеть, что эта строка всегда действительный IP-адрес. Если строка IP-адреса пришла от пользователя, то она не является жёстко запрограммированной в программе и, следовательно, *может* привести к ошибке, мы определённо хотели бы обработать `Result` более надёжным способом. Упоминание предположения о том, что этот IP-адрес жёстко закодирован, побудит нас изменить `expect` для лучшей обработки ошибок, если в будущем нам потребуется вместо этого получить IP-адрес из какого-либо другого источника.

### Руководство по обработке ошибок

Желательно, чтобы код паниковал, если он может оказаться в неправильном состоянии. В этом среде *неправильное состояние* это когда некоторое допущение, заверение, договор или неизменная величина были нарушены. Например, когда недопустимые, противоречивые или пропущенные значения передаются в ваш код - плюс один или несколько пунктов из следующего перечисленного в списке:

- Неправильное состояние — это что-то неожиданное, отличается от того, что может происходить время от времени, например, когда пользователь вводит данные в неправильном виде.
- Ваш код после этой точки должен полагаться на то, что он не находится в неправильном состоянии, вместо проверок наличия сбоев на каждом этапе.
- Нет хорошего способа закодировать данную сведения в видах, которые вы используете. Мы рассмотрим пример того, что мы имеем в виду в разделе [“Кодирование состояний и поведения на основе видов”]<!-- ignore --> главы 17.

Если кто-то вызывает ваш код и передаёт значения, которые не имеют смысла, лучше всего вернуть ошибку, если вы это можете, чтобы пользователь библиотеки мог решить, что он хочет делать в этом случае. Однако в тех случаях, когда продолжение выполнения программы может быть небезопасным или вредным, лучшим выбором будет вызов `panic!` и оповещение пользователя, использующего вашу библиотеку, об ошибке в его коде, чтобы он мог исправить её во время разработки. Подобно `panic!` подходит, если вы вызываете внешний, неподуправлениеный вам код, и он возвращает недопустимое состояние, которое вы не можете исправить.

Однако, когда ожидается сбой, лучше вернуть `Result`, чем выполнить вызов `panic!`.  В качестве примера можно привести синтаксический анализатор, которому передали неправильно созданные данные, или HTTP-запрос, возвращающий значение указывающий на то, что вы достигли ограничения на частоту запросов. В этих случаях возврат `Result` означает, что ошибка является ожидаемой и вызывающий код должен решить, как её обрабатывать.

Когда ваш код выполняет действие, которая может подвергнуть пользователя риску, если она вызывается с использованием недопустимых значений, ваш код должен сначала проверить допустимость значений и паниковать, если значения недопустимы. Так советуется делать в основном из соображений безопасности: попытка оперировать неправильными данными может привести к уязвимостям. Это основная причина, по которой обычная библиотека будет вызывать `panic!`, если попытаться получить доступ к памяти вне границ массива: доступ к памяти, не относящейся к текущей устройстве данных, является известной неполадкой безопасности. Функции часто имеют договоры: их поведение обеспечивается, только если входные данные отвечают определённым требованиям. Паника при нарушении договора имеет смысл, потому что это всегда указывает на изъян со стороны вызывающего кода, и это не ошибка, которую вы хотели бы, чтобы вызывающий код явно обрабатывал. На самом деле, нет разумного способа для восстановления вызывающего кода; программисты, вызывающие ваш код, должны исправить свой. Договоры для функции, особенно когда нарушение вызывает панику, следует описать в документации по API функции.

Тем не менее, наличие множества проверок ошибок во всех ваших функциях было бы многословным и раздражительным. К счастью, можно использовать систему видов Ржавчина (следовательно и проверку видов сборщиком), чтобы она сделала множество проверок вместо вас. Если ваша функция имеет определённый вид в качестве свойства, вы можете продолжить работу с логикой кода зная, что сборщик уже обеспечил правильное значение. Например, если используется обычный вид, а не вид `Option`, то ваша программа ожидает наличие *чего-то* вместо *ничего*. Ваш код не должен будет обрабатывать оба исхода `Some` и `None`: он будет иметь только один исход для определённого значения. Код, пытающийся ничего не передавать в функцию, не будет даже собираться, поэтому ваша функция не должна проверять такой случай во время выполнения. Другой пример - это использование целого вида без знака, такого как `u32`, который заверяет, что свойство никогда не будет отрицательным.

### Создание пользовательских видов для проверки

Давайте разовьём мысль использования системы видов Ржавчина чтобы убедиться, что у нас есть правильное значение, и рассмотрим создание пользовательского вида для валидации. Вспомним игру угадывания числа из Главы 2, в которой наш код просил пользователя угадать число между 1 и 100. Мы никогда не проверяли, что предположение пользователя лежит между этими числами, перед сравнением предположения с загаданным нами числом; мы только проверяли, что оно положительно. В этом случае последствия были не очень страшными: наши сообщения «Слишком много» или «Слишком мало», выводимые в окно вывода, все равно были правильными. Но было бы лучше подталкивать пользователя к правильным догадкам и иметь различное поведение для случаев, когда пользователь предлагает число за пределами ряда, и когда пользователь вводит, например, буквы вместо цифр.

Один из способов добиться этого - пытаться разобрать введённое значение как `i32`, а не как `u32`, чтобы разрешить возможно отрицательные числа, а затем добавить проверку для нахождение числа в ряде, например, так:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

Выражение `if` проверяет, находится ли наше значение вне ряда, сообщает пользователю о неполадке и вызывает `continue`, чтобы начать следующую повторение цикла и попросить ввести другое число. После выражения `if` мы можем продолжить сравнение значения `guess` с загаданным числом, зная, что `guess` лежит в ряде от 1 до 100.

Однако это не наилучшее решение: если бы было чрезвычайно важно, чтобы программа работала только со значениями от 1 до 100, существовало бы много функций, требующих этого, то такая проверка в каждой функции была бы утомительной (и могла бы отрицательно повлиять на производительность).

Вместо этого можно создать новый вид и поместить проверки в функцию создания образца этого вида, не повторяя их везде. Таким образом, функции могут использовать новый вид в своих ярлыках и быть уверены в значениях, которые им передают. Приложение 9-13 показывает один из способов, как определить вид `Guess`, чтобы образец `Guess` создавался только при условии, что функция `new` получает значение от 1 до 100.

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-13/src/main.rs:here}}
```

<span class="caption">Приложение 9-13. Вид <code>Guess</code>, который будет создавать образцы только для значений от 1 до 100</span>

Сначала мы определяем устройство с именем `Guess`, которая имеет поле с именем `value` вида `i32`, в котором будет храниться число.

Затем мы выполняем сопряженную функцию `new`, создающую образцы значений вида `Guess`. Функция `new`  имеет один свойство `value` вида `i32`, и возвращает `Guess`. Код в теле функции `new` проверяет, что значение `value` находится между 1 и 100. Если `value` не проходит эту проверку, мы вызываем `panic!`, которая оповестит программиста, написавшего вызывающий код, что в его коде есть ошибка, которую необходимо исправить, поскольку попытка создания `Guess` со значением `value` вне заданного ряда нарушает договор, на который полагается `Guess::new`. Условия, в которых `Guess::new` паникует, должны быть описаны в документации к API; мы рассмотрим соглашения о документации, указывающие на возможность появления `panic!` в документации API, которую вы создадите в Главе 14. Если `value` проходит проверку, мы создаём новый образец `Guess`, у которого значение поля  `value` равно значению свойства `value`, и возвращаем `Guess`.

Затем мы выполняем способ с названием `value`, который заимствует `self`, не имеет других свойств, и возвращает значение вида `i32`. Этот способ иногда называют *извлекатель* (getter), потому что его цель состоит в том, чтобы извлечь данные из полей устройства и вернуть их. Этот открытый способ является необходимым, поскольку поле `value` устройства `Guess`  является закрытым. Важно, чтобы поле `value` было закрытым, чтобы код, использующий устройство `Guess`, не мог устанавливать `value` напрямую: код снаружи звена *должен* использовать функцию `Guess::new` для создания образца `Guess`, таким образом обеспечивая, что у `Guess` нет возможности получить `value`, не проверенное условиями в функции `Guess::new`.

Функция, которая принимает или возвращает только числа от 1 до 100, может объявить в своей ярлыке, что она принимает или возвращает `Guess`, вместо `i32`, таким образом не будет необходимости делать дополнительные проверки в теле такой функции.

## Итоги

Функции обработки ошибок в Ржавчина призваны помочь написанию более надёжного кода. Макрос `panic!` указывает , что ваша программа находится в состоянии, которое она не может обработать, и позволяет сказать этапу чтобы он прекратил своё выполнение, вместо попытки продолжить выполнение с неправильными или неверными значениями. Перечисление `Result` использует систему видов Rust, чтобы сообщить, что действия могут завершиться неудачей, и ваш код мог восстановиться. Можно использовать `Result`, чтобы сообщить вызывающему коду, что он должен обрабатывать вероятный успех или вероятную неудачу. Использование `panic!` и `Result` правильным образом сделает ваш код более надёжным перед лицом неизбежных неполадок.

Теперь, когда вы увидели полезные способы использования  обобщённых видов `Option` и `Result` в встроенной библиотеке, мы поговорим о том, как работают обобщённые виды и как вы можете использовать их в своём коде.


[“Кодирование состояний и поведения на основе видов”]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types